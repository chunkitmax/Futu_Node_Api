/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.Common = (function() {

    /**
     * Namespace Common.
     * @exports Common
     * @namespace
     */
    var Common = {};

    /**
     * RetType enum.
     * @name Common.RetType
     * @enum {string}
     * @property {number} RetType_Succeed=0 RetType_Succeed value
     * @property {number} RetType_Failed=-1 RetType_Failed value
     * @property {number} RetType_TimeOut=-100 RetType_TimeOut value
     * @property {number} RetType_DisConnect=-200 RetType_DisConnect value
     * @property {number} RetType_Unknown=-400 RetType_Unknown value
     * @property {number} RetType_Invalid=-500 RetType_Invalid value
     */
    Common.RetType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RetType_Succeed"] = 0;
        values[valuesById[-1] = "RetType_Failed"] = -1;
        values[valuesById[-100] = "RetType_TimeOut"] = -100;
        values[valuesById[-200] = "RetType_DisConnect"] = -200;
        values[valuesById[-400] = "RetType_Unknown"] = -400;
        values[valuesById[-500] = "RetType_Invalid"] = -500;
        return values;
    })();

    /**
     * PacketEncAlgo enum.
     * @name Common.PacketEncAlgo
     * @enum {string}
     * @property {number} PacketEncAlgo_FTAES_ECB=0 PacketEncAlgo_FTAES_ECB value
     * @property {number} PacketEncAlgo_None=-1 PacketEncAlgo_None value
     * @property {number} PacketEncAlgo_AES_ECB=1 PacketEncAlgo_AES_ECB value
     * @property {number} PacketEncAlgo_AES_CBC=2 PacketEncAlgo_AES_CBC value
     */
    Common.PacketEncAlgo = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PacketEncAlgo_FTAES_ECB"] = 0;
        values[valuesById[-1] = "PacketEncAlgo_None"] = -1;
        values[valuesById[1] = "PacketEncAlgo_AES_ECB"] = 1;
        values[valuesById[2] = "PacketEncAlgo_AES_CBC"] = 2;
        return values;
    })();

    Common.PacketID = (function() {

        /**
         * Properties of a PacketID.
         * @memberof Common
         * @interface IPacketID
         * @property {number|Long} connID PacketID connID
         * @property {number} serialNo PacketID serialNo
         */

        /**
         * Constructs a new PacketID.
         * @memberof Common
         * @classdesc Represents a PacketID.
         * @implements IPacketID
         * @constructor
         * @param {Common.IPacketID=} [properties] Properties to set
         */
        function PacketID(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PacketID connID.
         * @member {number|Long} connID
         * @memberof Common.PacketID
         * @instance
         */
        PacketID.prototype.connID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PacketID serialNo.
         * @member {number} serialNo
         * @memberof Common.PacketID
         * @instance
         */
        PacketID.prototype.serialNo = 0;

        /**
         * Creates a new PacketID instance using the specified properties.
         * @function create
         * @memberof Common.PacketID
         * @static
         * @param {Common.IPacketID=} [properties] Properties to set
         * @returns {Common.PacketID} PacketID instance
         */
        PacketID.create = function create(properties) {
            return new PacketID(properties);
        };

        /**
         * Encodes the specified PacketID message. Does not implicitly {@link Common.PacketID.verify|verify} messages.
         * @function encode
         * @memberof Common.PacketID
         * @static
         * @param {Common.IPacketID} message PacketID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PacketID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.connID);
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.serialNo);
            return writer;
        };

        /**
         * Encodes the specified PacketID message, length delimited. Does not implicitly {@link Common.PacketID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Common.PacketID
         * @static
         * @param {Common.IPacketID} message PacketID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PacketID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PacketID message from the specified reader or buffer.
         * @function decode
         * @memberof Common.PacketID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Common.PacketID} PacketID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PacketID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Common.PacketID();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.connID = reader.uint64();
                    break;
                case 2:
                    message.serialNo = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("connID"))
                throw $util.ProtocolError("missing required 'connID'", { instance: message });
            if (!message.hasOwnProperty("serialNo"))
                throw $util.ProtocolError("missing required 'serialNo'", { instance: message });
            return message;
        };

        /**
         * Decodes a PacketID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Common.PacketID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Common.PacketID} PacketID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PacketID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PacketID message.
         * @function verify
         * @memberof Common.PacketID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PacketID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.connID) && !(message.connID && $util.isInteger(message.connID.low) && $util.isInteger(message.connID.high)))
                return "connID: integer|Long expected";
            if (!$util.isInteger(message.serialNo))
                return "serialNo: integer expected";
            return null;
        };

        /**
         * Creates a PacketID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Common.PacketID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Common.PacketID} PacketID
         */
        PacketID.fromObject = function fromObject(object) {
            if (object instanceof $root.Common.PacketID)
                return object;
            var message = new $root.Common.PacketID();
            if (object.connID != null)
                if ($util.Long)
                    (message.connID = $util.Long.fromValue(object.connID)).unsigned = true;
                else if (typeof object.connID === "string")
                    message.connID = parseInt(object.connID, 10);
                else if (typeof object.connID === "number")
                    message.connID = object.connID;
                else if (typeof object.connID === "object")
                    message.connID = new $util.LongBits(object.connID.low >>> 0, object.connID.high >>> 0).toNumber(true);
            if (object.serialNo != null)
                message.serialNo = object.serialNo >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PacketID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Common.PacketID
         * @static
         * @param {Common.PacketID} message PacketID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PacketID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.connID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.connID = options.longs === String ? "0" : 0;
                object.serialNo = 0;
            }
            if (message.connID != null && message.hasOwnProperty("connID"))
                if (typeof message.connID === "number")
                    object.connID = options.longs === String ? String(message.connID) : message.connID;
                else
                    object.connID = options.longs === String ? $util.Long.prototype.toString.call(message.connID) : options.longs === Number ? new $util.LongBits(message.connID.low >>> 0, message.connID.high >>> 0).toNumber(true) : message.connID;
            if (message.serialNo != null && message.hasOwnProperty("serialNo"))
                object.serialNo = message.serialNo;
            return object;
        };

        /**
         * Converts this PacketID to JSON.
         * @function toJSON
         * @memberof Common.PacketID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PacketID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PacketID;
    })();

    /**
     * ProtoFmt enum.
     * @name Common.ProtoFmt
     * @enum {string}
     * @property {number} ProtoFmt_Protobuf=0 ProtoFmt_Protobuf value
     * @property {number} ProtoFmt_Json=1 ProtoFmt_Json value
     */
    Common.ProtoFmt = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ProtoFmt_Protobuf"] = 0;
        values[valuesById[1] = "ProtoFmt_Json"] = 1;
        return values;
    })();

    /**
     * ProgramStatusType enum.
     * @name Common.ProgramStatusType
     * @enum {string}
     * @property {number} ProgramStatusType_None=0 ProgramStatusType_None value
     * @property {number} ProgramStatusType_Loaded=1 ProgramStatusType_Loaded value
     * @property {number} ProgramStatusType_Loging=2 ProgramStatusType_Loging value
     * @property {number} ProgramStatusType_NeedPicVerifyCode=3 ProgramStatusType_NeedPicVerifyCode value
     * @property {number} ProgramStatusType_NeedPhoneVerifyCode=4 ProgramStatusType_NeedPhoneVerifyCode value
     * @property {number} ProgramStatusType_LoginFailed=5 ProgramStatusType_LoginFailed value
     * @property {number} ProgramStatusType_ForceUpdate=6 ProgramStatusType_ForceUpdate value
     * @property {number} ProgramStatusType_NessaryDataPreparing=7 ProgramStatusType_NessaryDataPreparing value
     * @property {number} ProgramStatusType_NessaryDataMissing=8 ProgramStatusType_NessaryDataMissing value
     * @property {number} ProgramStatusType_UnAgreeDisclaimer=9 ProgramStatusType_UnAgreeDisclaimer value
     * @property {number} ProgramStatusType_Ready=10 ProgramStatusType_Ready value
     * @property {number} ProgramStatusType_ForceLogout=11 ProgramStatusType_ForceLogout value
     */
    Common.ProgramStatusType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ProgramStatusType_None"] = 0;
        values[valuesById[1] = "ProgramStatusType_Loaded"] = 1;
        values[valuesById[2] = "ProgramStatusType_Loging"] = 2;
        values[valuesById[3] = "ProgramStatusType_NeedPicVerifyCode"] = 3;
        values[valuesById[4] = "ProgramStatusType_NeedPhoneVerifyCode"] = 4;
        values[valuesById[5] = "ProgramStatusType_LoginFailed"] = 5;
        values[valuesById[6] = "ProgramStatusType_ForceUpdate"] = 6;
        values[valuesById[7] = "ProgramStatusType_NessaryDataPreparing"] = 7;
        values[valuesById[8] = "ProgramStatusType_NessaryDataMissing"] = 8;
        values[valuesById[9] = "ProgramStatusType_UnAgreeDisclaimer"] = 9;
        values[valuesById[10] = "ProgramStatusType_Ready"] = 10;
        values[valuesById[11] = "ProgramStatusType_ForceLogout"] = 11;
        return values;
    })();

    Common.ProgramStatus = (function() {

        /**
         * Properties of a ProgramStatus.
         * @memberof Common
         * @interface IProgramStatus
         * @property {Common.ProgramStatusType} type ProgramStatus type
         * @property {string|null} [strExtDesc] ProgramStatus strExtDesc
         */

        /**
         * Constructs a new ProgramStatus.
         * @memberof Common
         * @classdesc Represents a ProgramStatus.
         * @implements IProgramStatus
         * @constructor
         * @param {Common.IProgramStatus=} [properties] Properties to set
         */
        function ProgramStatus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProgramStatus type.
         * @member {Common.ProgramStatusType} type
         * @memberof Common.ProgramStatus
         * @instance
         */
        ProgramStatus.prototype.type = 0;

        /**
         * ProgramStatus strExtDesc.
         * @member {string} strExtDesc
         * @memberof Common.ProgramStatus
         * @instance
         */
        ProgramStatus.prototype.strExtDesc = "";

        /**
         * Creates a new ProgramStatus instance using the specified properties.
         * @function create
         * @memberof Common.ProgramStatus
         * @static
         * @param {Common.IProgramStatus=} [properties] Properties to set
         * @returns {Common.ProgramStatus} ProgramStatus instance
         */
        ProgramStatus.create = function create(properties) {
            return new ProgramStatus(properties);
        };

        /**
         * Encodes the specified ProgramStatus message. Does not implicitly {@link Common.ProgramStatus.verify|verify} messages.
         * @function encode
         * @memberof Common.ProgramStatus
         * @static
         * @param {Common.IProgramStatus} message ProgramStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProgramStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.strExtDesc != null && message.hasOwnProperty("strExtDesc"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.strExtDesc);
            return writer;
        };

        /**
         * Encodes the specified ProgramStatus message, length delimited. Does not implicitly {@link Common.ProgramStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Common.ProgramStatus
         * @static
         * @param {Common.IProgramStatus} message ProgramStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProgramStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProgramStatus message from the specified reader or buffer.
         * @function decode
         * @memberof Common.ProgramStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Common.ProgramStatus} ProgramStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProgramStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Common.ProgramStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.strExtDesc = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };

        /**
         * Decodes a ProgramStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Common.ProgramStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Common.ProgramStatus} ProgramStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProgramStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProgramStatus message.
         * @function verify
         * @memberof Common.ProgramStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProgramStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
                break;
            }
            if (message.strExtDesc != null && message.hasOwnProperty("strExtDesc"))
                if (!$util.isString(message.strExtDesc))
                    return "strExtDesc: string expected";
            return null;
        };

        /**
         * Creates a ProgramStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Common.ProgramStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Common.ProgramStatus} ProgramStatus
         */
        ProgramStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.Common.ProgramStatus)
                return object;
            var message = new $root.Common.ProgramStatus();
            switch (object.type) {
            case "ProgramStatusType_None":
            case 0:
                message.type = 0;
                break;
            case "ProgramStatusType_Loaded":
            case 1:
                message.type = 1;
                break;
            case "ProgramStatusType_Loging":
            case 2:
                message.type = 2;
                break;
            case "ProgramStatusType_NeedPicVerifyCode":
            case 3:
                message.type = 3;
                break;
            case "ProgramStatusType_NeedPhoneVerifyCode":
            case 4:
                message.type = 4;
                break;
            case "ProgramStatusType_LoginFailed":
            case 5:
                message.type = 5;
                break;
            case "ProgramStatusType_ForceUpdate":
            case 6:
                message.type = 6;
                break;
            case "ProgramStatusType_NessaryDataPreparing":
            case 7:
                message.type = 7;
                break;
            case "ProgramStatusType_NessaryDataMissing":
            case 8:
                message.type = 8;
                break;
            case "ProgramStatusType_UnAgreeDisclaimer":
            case 9:
                message.type = 9;
                break;
            case "ProgramStatusType_Ready":
            case 10:
                message.type = 10;
                break;
            case "ProgramStatusType_ForceLogout":
            case 11:
                message.type = 11;
                break;
            }
            if (object.strExtDesc != null)
                message.strExtDesc = String(object.strExtDesc);
            return message;
        };

        /**
         * Creates a plain object from a ProgramStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Common.ProgramStatus
         * @static
         * @param {Common.ProgramStatus} message ProgramStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProgramStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "ProgramStatusType_None" : 0;
                object.strExtDesc = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.Common.ProgramStatusType[message.type] : message.type;
            if (message.strExtDesc != null && message.hasOwnProperty("strExtDesc"))
                object.strExtDesc = message.strExtDesc;
            return object;
        };

        /**
         * Converts this ProgramStatus to JSON.
         * @function toJSON
         * @memberof Common.ProgramStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProgramStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProgramStatus;
    })();

    return Common;
})();

$root.GetDelayStatistics = (function() {

    /**
     * Namespace GetDelayStatistics.
     * @exports GetDelayStatistics
     * @namespace
     */
    var GetDelayStatistics = {};

    /**
     * DelayStatisticsType enum.
     * @name GetDelayStatistics.DelayStatisticsType
     * @enum {string}
     * @property {number} DelayStatisticsType_Unkonw=0 DelayStatisticsType_Unkonw value
     * @property {number} DelayStatisticsType_QotPush=1 DelayStatisticsType_QotPush value
     * @property {number} DelayStatisticsType_ReqReply=2 DelayStatisticsType_ReqReply value
     * @property {number} DelayStatisticsType_PlaceOrder=3 DelayStatisticsType_PlaceOrder value
     */
    GetDelayStatistics.DelayStatisticsType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DelayStatisticsType_Unkonw"] = 0;
        values[valuesById[1] = "DelayStatisticsType_QotPush"] = 1;
        values[valuesById[2] = "DelayStatisticsType_ReqReply"] = 2;
        values[valuesById[3] = "DelayStatisticsType_PlaceOrder"] = 3;
        return values;
    })();

    /**
     * QotPushStage enum.
     * @name GetDelayStatistics.QotPushStage
     * @enum {string}
     * @property {number} QotPushStage_Unkonw=0 QotPushStage_Unkonw value
     * @property {number} QotPushStage_SR2SS=1 QotPushStage_SR2SS value
     * @property {number} QotPushStage_SS2CR=2 QotPushStage_SS2CR value
     * @property {number} QotPushStage_CR2CS=3 QotPushStage_CR2CS value
     * @property {number} QotPushStage_SS2CS=4 QotPushStage_SS2CS value
     * @property {number} QotPushStage_SR2CS=5 QotPushStage_SR2CS value
     */
    GetDelayStatistics.QotPushStage = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "QotPushStage_Unkonw"] = 0;
        values[valuesById[1] = "QotPushStage_SR2SS"] = 1;
        values[valuesById[2] = "QotPushStage_SS2CR"] = 2;
        values[valuesById[3] = "QotPushStage_CR2CS"] = 3;
        values[valuesById[4] = "QotPushStage_SS2CS"] = 4;
        values[valuesById[5] = "QotPushStage_SR2CS"] = 5;
        return values;
    })();

    /**
     * QotPushType enum.
     * @name GetDelayStatistics.QotPushType
     * @enum {string}
     * @property {number} QotPushType_Unkonw=0 QotPushType_Unkonw value
     * @property {number} QotPushType_Price=1 QotPushType_Price value
     * @property {number} QotPushType_Ticker=2 QotPushType_Ticker value
     * @property {number} QotPushType_OrderBook=3 QotPushType_OrderBook value
     * @property {number} QotPushType_Broker=4 QotPushType_Broker value
     */
    GetDelayStatistics.QotPushType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "QotPushType_Unkonw"] = 0;
        values[valuesById[1] = "QotPushType_Price"] = 1;
        values[valuesById[2] = "QotPushType_Ticker"] = 2;
        values[valuesById[3] = "QotPushType_OrderBook"] = 3;
        values[valuesById[4] = "QotPushType_Broker"] = 4;
        return values;
    })();

    GetDelayStatistics.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof GetDelayStatistics
         * @interface IC2S
         * @property {Array.<number>|null} [typeList] C2S typeList
         * @property {number|null} [qotPushStage] C2S qotPushStage
         * @property {Array.<number>|null} [segmentList] C2S segmentList
         */

        /**
         * Constructs a new C2S.
         * @memberof GetDelayStatistics
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {GetDelayStatistics.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.typeList = [];
            this.segmentList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S typeList.
         * @member {Array.<number>} typeList
         * @memberof GetDelayStatistics.C2S
         * @instance
         */
        C2S.prototype.typeList = $util.emptyArray;

        /**
         * C2S qotPushStage.
         * @member {number} qotPushStage
         * @memberof GetDelayStatistics.C2S
         * @instance
         */
        C2S.prototype.qotPushStage = 0;

        /**
         * C2S segmentList.
         * @member {Array.<number>} segmentList
         * @memberof GetDelayStatistics.C2S
         * @instance
         */
        C2S.prototype.segmentList = $util.emptyArray;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof GetDelayStatistics.C2S
         * @static
         * @param {GetDelayStatistics.IC2S=} [properties] Properties to set
         * @returns {GetDelayStatistics.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link GetDelayStatistics.C2S.verify|verify} messages.
         * @function encode
         * @memberof GetDelayStatistics.C2S
         * @static
         * @param {GetDelayStatistics.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.typeList != null && message.typeList.length)
                for (var i = 0; i < message.typeList.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.typeList[i]);
            if (message.qotPushStage != null && message.hasOwnProperty("qotPushStage"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.qotPushStage);
            if (message.segmentList != null && message.segmentList.length)
                for (var i = 0; i < message.segmentList.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.segmentList[i]);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link GetDelayStatistics.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetDelayStatistics.C2S
         * @static
         * @param {GetDelayStatistics.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof GetDelayStatistics.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetDelayStatistics.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetDelayStatistics.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.typeList && message.typeList.length))
                        message.typeList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.typeList.push(reader.int32());
                    } else
                        message.typeList.push(reader.int32());
                    break;
                case 2:
                    message.qotPushStage = reader.int32();
                    break;
                case 3:
                    if (!(message.segmentList && message.segmentList.length))
                        message.segmentList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.segmentList.push(reader.int32());
                    } else
                        message.segmentList.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetDelayStatistics.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetDelayStatistics.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof GetDelayStatistics.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.typeList != null && message.hasOwnProperty("typeList")) {
                if (!Array.isArray(message.typeList))
                    return "typeList: array expected";
                for (var i = 0; i < message.typeList.length; ++i)
                    if (!$util.isInteger(message.typeList[i]))
                        return "typeList: integer[] expected";
            }
            if (message.qotPushStage != null && message.hasOwnProperty("qotPushStage"))
                if (!$util.isInteger(message.qotPushStage))
                    return "qotPushStage: integer expected";
            if (message.segmentList != null && message.hasOwnProperty("segmentList")) {
                if (!Array.isArray(message.segmentList))
                    return "segmentList: array expected";
                for (var i = 0; i < message.segmentList.length; ++i)
                    if (!$util.isInteger(message.segmentList[i]))
                        return "segmentList: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetDelayStatistics.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetDelayStatistics.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.GetDelayStatistics.C2S)
                return object;
            var message = new $root.GetDelayStatistics.C2S();
            if (object.typeList) {
                if (!Array.isArray(object.typeList))
                    throw TypeError(".GetDelayStatistics.C2S.typeList: array expected");
                message.typeList = [];
                for (var i = 0; i < object.typeList.length; ++i)
                    message.typeList[i] = object.typeList[i] | 0;
            }
            if (object.qotPushStage != null)
                message.qotPushStage = object.qotPushStage | 0;
            if (object.segmentList) {
                if (!Array.isArray(object.segmentList))
                    throw TypeError(".GetDelayStatistics.C2S.segmentList: array expected");
                message.segmentList = [];
                for (var i = 0; i < object.segmentList.length; ++i)
                    message.segmentList[i] = object.segmentList[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetDelayStatistics.C2S
         * @static
         * @param {GetDelayStatistics.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.typeList = [];
                object.segmentList = [];
            }
            if (options.defaults)
                object.qotPushStage = 0;
            if (message.typeList && message.typeList.length) {
                object.typeList = [];
                for (var j = 0; j < message.typeList.length; ++j)
                    object.typeList[j] = message.typeList[j];
            }
            if (message.qotPushStage != null && message.hasOwnProperty("qotPushStage"))
                object.qotPushStage = message.qotPushStage;
            if (message.segmentList && message.segmentList.length) {
                object.segmentList = [];
                for (var j = 0; j < message.segmentList.length; ++j)
                    object.segmentList[j] = message.segmentList[j];
            }
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof GetDelayStatistics.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    GetDelayStatistics.DelayStatisticsItem = (function() {

        /**
         * Properties of a DelayStatisticsItem.
         * @memberof GetDelayStatistics
         * @interface IDelayStatisticsItem
         * @property {number} begin DelayStatisticsItem begin
         * @property {number} end DelayStatisticsItem end
         * @property {number} count DelayStatisticsItem count
         * @property {number} proportion DelayStatisticsItem proportion
         * @property {number} cumulativeRatio DelayStatisticsItem cumulativeRatio
         */

        /**
         * Constructs a new DelayStatisticsItem.
         * @memberof GetDelayStatistics
         * @classdesc Represents a DelayStatisticsItem.
         * @implements IDelayStatisticsItem
         * @constructor
         * @param {GetDelayStatistics.IDelayStatisticsItem=} [properties] Properties to set
         */
        function DelayStatisticsItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelayStatisticsItem begin.
         * @member {number} begin
         * @memberof GetDelayStatistics.DelayStatisticsItem
         * @instance
         */
        DelayStatisticsItem.prototype.begin = 0;

        /**
         * DelayStatisticsItem end.
         * @member {number} end
         * @memberof GetDelayStatistics.DelayStatisticsItem
         * @instance
         */
        DelayStatisticsItem.prototype.end = 0;

        /**
         * DelayStatisticsItem count.
         * @member {number} count
         * @memberof GetDelayStatistics.DelayStatisticsItem
         * @instance
         */
        DelayStatisticsItem.prototype.count = 0;

        /**
         * DelayStatisticsItem proportion.
         * @member {number} proportion
         * @memberof GetDelayStatistics.DelayStatisticsItem
         * @instance
         */
        DelayStatisticsItem.prototype.proportion = 0;

        /**
         * DelayStatisticsItem cumulativeRatio.
         * @member {number} cumulativeRatio
         * @memberof GetDelayStatistics.DelayStatisticsItem
         * @instance
         */
        DelayStatisticsItem.prototype.cumulativeRatio = 0;

        /**
         * Creates a new DelayStatisticsItem instance using the specified properties.
         * @function create
         * @memberof GetDelayStatistics.DelayStatisticsItem
         * @static
         * @param {GetDelayStatistics.IDelayStatisticsItem=} [properties] Properties to set
         * @returns {GetDelayStatistics.DelayStatisticsItem} DelayStatisticsItem instance
         */
        DelayStatisticsItem.create = function create(properties) {
            return new DelayStatisticsItem(properties);
        };

        /**
         * Encodes the specified DelayStatisticsItem message. Does not implicitly {@link GetDelayStatistics.DelayStatisticsItem.verify|verify} messages.
         * @function encode
         * @memberof GetDelayStatistics.DelayStatisticsItem
         * @static
         * @param {GetDelayStatistics.IDelayStatisticsItem} message DelayStatisticsItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelayStatisticsItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.begin);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.count);
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.proportion);
            writer.uint32(/* id 5, wireType 5 =*/45).float(message.cumulativeRatio);
            return writer;
        };

        /**
         * Encodes the specified DelayStatisticsItem message, length delimited. Does not implicitly {@link GetDelayStatistics.DelayStatisticsItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetDelayStatistics.DelayStatisticsItem
         * @static
         * @param {GetDelayStatistics.IDelayStatisticsItem} message DelayStatisticsItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelayStatisticsItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelayStatisticsItem message from the specified reader or buffer.
         * @function decode
         * @memberof GetDelayStatistics.DelayStatisticsItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetDelayStatistics.DelayStatisticsItem} DelayStatisticsItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelayStatisticsItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetDelayStatistics.DelayStatisticsItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.begin = reader.int32();
                    break;
                case 2:
                    message.end = reader.int32();
                    break;
                case 3:
                    message.count = reader.int32();
                    break;
                case 4:
                    message.proportion = reader.float();
                    break;
                case 5:
                    message.cumulativeRatio = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("begin"))
                throw $util.ProtocolError("missing required 'begin'", { instance: message });
            if (!message.hasOwnProperty("end"))
                throw $util.ProtocolError("missing required 'end'", { instance: message });
            if (!message.hasOwnProperty("count"))
                throw $util.ProtocolError("missing required 'count'", { instance: message });
            if (!message.hasOwnProperty("proportion"))
                throw $util.ProtocolError("missing required 'proportion'", { instance: message });
            if (!message.hasOwnProperty("cumulativeRatio"))
                throw $util.ProtocolError("missing required 'cumulativeRatio'", { instance: message });
            return message;
        };

        /**
         * Decodes a DelayStatisticsItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetDelayStatistics.DelayStatisticsItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetDelayStatistics.DelayStatisticsItem} DelayStatisticsItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelayStatisticsItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelayStatisticsItem message.
         * @function verify
         * @memberof GetDelayStatistics.DelayStatisticsItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelayStatisticsItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.begin))
                return "begin: integer expected";
            if (!$util.isInteger(message.end))
                return "end: integer expected";
            if (!$util.isInteger(message.count))
                return "count: integer expected";
            if (typeof message.proportion !== "number")
                return "proportion: number expected";
            if (typeof message.cumulativeRatio !== "number")
                return "cumulativeRatio: number expected";
            return null;
        };

        /**
         * Creates a DelayStatisticsItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetDelayStatistics.DelayStatisticsItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetDelayStatistics.DelayStatisticsItem} DelayStatisticsItem
         */
        DelayStatisticsItem.fromObject = function fromObject(object) {
            if (object instanceof $root.GetDelayStatistics.DelayStatisticsItem)
                return object;
            var message = new $root.GetDelayStatistics.DelayStatisticsItem();
            if (object.begin != null)
                message.begin = object.begin | 0;
            if (object.end != null)
                message.end = object.end | 0;
            if (object.count != null)
                message.count = object.count | 0;
            if (object.proportion != null)
                message.proportion = Number(object.proportion);
            if (object.cumulativeRatio != null)
                message.cumulativeRatio = Number(object.cumulativeRatio);
            return message;
        };

        /**
         * Creates a plain object from a DelayStatisticsItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetDelayStatistics.DelayStatisticsItem
         * @static
         * @param {GetDelayStatistics.DelayStatisticsItem} message DelayStatisticsItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelayStatisticsItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.begin = 0;
                object.end = 0;
                object.count = 0;
                object.proportion = 0;
                object.cumulativeRatio = 0;
            }
            if (message.begin != null && message.hasOwnProperty("begin"))
                object.begin = message.begin;
            if (message.end != null && message.hasOwnProperty("end"))
                object.end = message.end;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            if (message.proportion != null && message.hasOwnProperty("proportion"))
                object.proportion = options.json && !isFinite(message.proportion) ? String(message.proportion) : message.proportion;
            if (message.cumulativeRatio != null && message.hasOwnProperty("cumulativeRatio"))
                object.cumulativeRatio = options.json && !isFinite(message.cumulativeRatio) ? String(message.cumulativeRatio) : message.cumulativeRatio;
            return object;
        };

        /**
         * Converts this DelayStatisticsItem to JSON.
         * @function toJSON
         * @memberof GetDelayStatistics.DelayStatisticsItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelayStatisticsItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelayStatisticsItem;
    })();

    GetDelayStatistics.DelayStatistics = (function() {

        /**
         * Properties of a DelayStatistics.
         * @memberof GetDelayStatistics
         * @interface IDelayStatistics
         * @property {number} qotPushType DelayStatistics qotPushType
         * @property {Array.<GetDelayStatistics.IDelayStatisticsItem>|null} [itemList] DelayStatistics itemList
         * @property {number} delayAvg DelayStatistics delayAvg
         * @property {number} count DelayStatistics count
         */

        /**
         * Constructs a new DelayStatistics.
         * @memberof GetDelayStatistics
         * @classdesc Represents a DelayStatistics.
         * @implements IDelayStatistics
         * @constructor
         * @param {GetDelayStatistics.IDelayStatistics=} [properties] Properties to set
         */
        function DelayStatistics(properties) {
            this.itemList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelayStatistics qotPushType.
         * @member {number} qotPushType
         * @memberof GetDelayStatistics.DelayStatistics
         * @instance
         */
        DelayStatistics.prototype.qotPushType = 0;

        /**
         * DelayStatistics itemList.
         * @member {Array.<GetDelayStatistics.IDelayStatisticsItem>} itemList
         * @memberof GetDelayStatistics.DelayStatistics
         * @instance
         */
        DelayStatistics.prototype.itemList = $util.emptyArray;

        /**
         * DelayStatistics delayAvg.
         * @member {number} delayAvg
         * @memberof GetDelayStatistics.DelayStatistics
         * @instance
         */
        DelayStatistics.prototype.delayAvg = 0;

        /**
         * DelayStatistics count.
         * @member {number} count
         * @memberof GetDelayStatistics.DelayStatistics
         * @instance
         */
        DelayStatistics.prototype.count = 0;

        /**
         * Creates a new DelayStatistics instance using the specified properties.
         * @function create
         * @memberof GetDelayStatistics.DelayStatistics
         * @static
         * @param {GetDelayStatistics.IDelayStatistics=} [properties] Properties to set
         * @returns {GetDelayStatistics.DelayStatistics} DelayStatistics instance
         */
        DelayStatistics.create = function create(properties) {
            return new DelayStatistics(properties);
        };

        /**
         * Encodes the specified DelayStatistics message. Does not implicitly {@link GetDelayStatistics.DelayStatistics.verify|verify} messages.
         * @function encode
         * @memberof GetDelayStatistics.DelayStatistics
         * @static
         * @param {GetDelayStatistics.IDelayStatistics} message DelayStatistics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelayStatistics.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.qotPushType);
            if (message.itemList != null && message.itemList.length)
                for (var i = 0; i < message.itemList.length; ++i)
                    $root.GetDelayStatistics.DelayStatisticsItem.encode(message.itemList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.delayAvg);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.count);
            return writer;
        };

        /**
         * Encodes the specified DelayStatistics message, length delimited. Does not implicitly {@link GetDelayStatistics.DelayStatistics.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetDelayStatistics.DelayStatistics
         * @static
         * @param {GetDelayStatistics.IDelayStatistics} message DelayStatistics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelayStatistics.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelayStatistics message from the specified reader or buffer.
         * @function decode
         * @memberof GetDelayStatistics.DelayStatistics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetDelayStatistics.DelayStatistics} DelayStatistics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelayStatistics.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetDelayStatistics.DelayStatistics();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.qotPushType = reader.int32();
                    break;
                case 2:
                    if (!(message.itemList && message.itemList.length))
                        message.itemList = [];
                    message.itemList.push($root.GetDelayStatistics.DelayStatisticsItem.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.delayAvg = reader.float();
                    break;
                case 4:
                    message.count = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("qotPushType"))
                throw $util.ProtocolError("missing required 'qotPushType'", { instance: message });
            if (!message.hasOwnProperty("delayAvg"))
                throw $util.ProtocolError("missing required 'delayAvg'", { instance: message });
            if (!message.hasOwnProperty("count"))
                throw $util.ProtocolError("missing required 'count'", { instance: message });
            return message;
        };

        /**
         * Decodes a DelayStatistics message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetDelayStatistics.DelayStatistics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetDelayStatistics.DelayStatistics} DelayStatistics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelayStatistics.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelayStatistics message.
         * @function verify
         * @memberof GetDelayStatistics.DelayStatistics
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelayStatistics.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.qotPushType))
                return "qotPushType: integer expected";
            if (message.itemList != null && message.hasOwnProperty("itemList")) {
                if (!Array.isArray(message.itemList))
                    return "itemList: array expected";
                for (var i = 0; i < message.itemList.length; ++i) {
                    var error = $root.GetDelayStatistics.DelayStatisticsItem.verify(message.itemList[i]);
                    if (error)
                        return "itemList." + error;
                }
            }
            if (typeof message.delayAvg !== "number")
                return "delayAvg: number expected";
            if (!$util.isInteger(message.count))
                return "count: integer expected";
            return null;
        };

        /**
         * Creates a DelayStatistics message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetDelayStatistics.DelayStatistics
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetDelayStatistics.DelayStatistics} DelayStatistics
         */
        DelayStatistics.fromObject = function fromObject(object) {
            if (object instanceof $root.GetDelayStatistics.DelayStatistics)
                return object;
            var message = new $root.GetDelayStatistics.DelayStatistics();
            if (object.qotPushType != null)
                message.qotPushType = object.qotPushType | 0;
            if (object.itemList) {
                if (!Array.isArray(object.itemList))
                    throw TypeError(".GetDelayStatistics.DelayStatistics.itemList: array expected");
                message.itemList = [];
                for (var i = 0; i < object.itemList.length; ++i) {
                    if (typeof object.itemList[i] !== "object")
                        throw TypeError(".GetDelayStatistics.DelayStatistics.itemList: object expected");
                    message.itemList[i] = $root.GetDelayStatistics.DelayStatisticsItem.fromObject(object.itemList[i]);
                }
            }
            if (object.delayAvg != null)
                message.delayAvg = Number(object.delayAvg);
            if (object.count != null)
                message.count = object.count | 0;
            return message;
        };

        /**
         * Creates a plain object from a DelayStatistics message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetDelayStatistics.DelayStatistics
         * @static
         * @param {GetDelayStatistics.DelayStatistics} message DelayStatistics
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelayStatistics.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.itemList = [];
            if (options.defaults) {
                object.qotPushType = 0;
                object.delayAvg = 0;
                object.count = 0;
            }
            if (message.qotPushType != null && message.hasOwnProperty("qotPushType"))
                object.qotPushType = message.qotPushType;
            if (message.itemList && message.itemList.length) {
                object.itemList = [];
                for (var j = 0; j < message.itemList.length; ++j)
                    object.itemList[j] = $root.GetDelayStatistics.DelayStatisticsItem.toObject(message.itemList[j], options);
            }
            if (message.delayAvg != null && message.hasOwnProperty("delayAvg"))
                object.delayAvg = options.json && !isFinite(message.delayAvg) ? String(message.delayAvg) : message.delayAvg;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            return object;
        };

        /**
         * Converts this DelayStatistics to JSON.
         * @function toJSON
         * @memberof GetDelayStatistics.DelayStatistics
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelayStatistics.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelayStatistics;
    })();

    GetDelayStatistics.ReqReplyStatisticsItem = (function() {

        /**
         * Properties of a ReqReplyStatisticsItem.
         * @memberof GetDelayStatistics
         * @interface IReqReplyStatisticsItem
         * @property {number} protoID ReqReplyStatisticsItem protoID
         * @property {number} count ReqReplyStatisticsItem count
         * @property {number} totalCostAvg ReqReplyStatisticsItem totalCostAvg
         * @property {number} openDCostAvg ReqReplyStatisticsItem openDCostAvg
         * @property {number} netDelayAvg ReqReplyStatisticsItem netDelayAvg
         * @property {boolean} isLocalReply ReqReplyStatisticsItem isLocalReply
         */

        /**
         * Constructs a new ReqReplyStatisticsItem.
         * @memberof GetDelayStatistics
         * @classdesc Represents a ReqReplyStatisticsItem.
         * @implements IReqReplyStatisticsItem
         * @constructor
         * @param {GetDelayStatistics.IReqReplyStatisticsItem=} [properties] Properties to set
         */
        function ReqReplyStatisticsItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReqReplyStatisticsItem protoID.
         * @member {number} protoID
         * @memberof GetDelayStatistics.ReqReplyStatisticsItem
         * @instance
         */
        ReqReplyStatisticsItem.prototype.protoID = 0;

        /**
         * ReqReplyStatisticsItem count.
         * @member {number} count
         * @memberof GetDelayStatistics.ReqReplyStatisticsItem
         * @instance
         */
        ReqReplyStatisticsItem.prototype.count = 0;

        /**
         * ReqReplyStatisticsItem totalCostAvg.
         * @member {number} totalCostAvg
         * @memberof GetDelayStatistics.ReqReplyStatisticsItem
         * @instance
         */
        ReqReplyStatisticsItem.prototype.totalCostAvg = 0;

        /**
         * ReqReplyStatisticsItem openDCostAvg.
         * @member {number} openDCostAvg
         * @memberof GetDelayStatistics.ReqReplyStatisticsItem
         * @instance
         */
        ReqReplyStatisticsItem.prototype.openDCostAvg = 0;

        /**
         * ReqReplyStatisticsItem netDelayAvg.
         * @member {number} netDelayAvg
         * @memberof GetDelayStatistics.ReqReplyStatisticsItem
         * @instance
         */
        ReqReplyStatisticsItem.prototype.netDelayAvg = 0;

        /**
         * ReqReplyStatisticsItem isLocalReply.
         * @member {boolean} isLocalReply
         * @memberof GetDelayStatistics.ReqReplyStatisticsItem
         * @instance
         */
        ReqReplyStatisticsItem.prototype.isLocalReply = false;

        /**
         * Creates a new ReqReplyStatisticsItem instance using the specified properties.
         * @function create
         * @memberof GetDelayStatistics.ReqReplyStatisticsItem
         * @static
         * @param {GetDelayStatistics.IReqReplyStatisticsItem=} [properties] Properties to set
         * @returns {GetDelayStatistics.ReqReplyStatisticsItem} ReqReplyStatisticsItem instance
         */
        ReqReplyStatisticsItem.create = function create(properties) {
            return new ReqReplyStatisticsItem(properties);
        };

        /**
         * Encodes the specified ReqReplyStatisticsItem message. Does not implicitly {@link GetDelayStatistics.ReqReplyStatisticsItem.verify|verify} messages.
         * @function encode
         * @memberof GetDelayStatistics.ReqReplyStatisticsItem
         * @static
         * @param {GetDelayStatistics.IReqReplyStatisticsItem} message ReqReplyStatisticsItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReqReplyStatisticsItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.protoID);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.count);
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.totalCostAvg);
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.openDCostAvg);
            writer.uint32(/* id 5, wireType 5 =*/45).float(message.netDelayAvg);
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isLocalReply);
            return writer;
        };

        /**
         * Encodes the specified ReqReplyStatisticsItem message, length delimited. Does not implicitly {@link GetDelayStatistics.ReqReplyStatisticsItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetDelayStatistics.ReqReplyStatisticsItem
         * @static
         * @param {GetDelayStatistics.IReqReplyStatisticsItem} message ReqReplyStatisticsItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReqReplyStatisticsItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReqReplyStatisticsItem message from the specified reader or buffer.
         * @function decode
         * @memberof GetDelayStatistics.ReqReplyStatisticsItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetDelayStatistics.ReqReplyStatisticsItem} ReqReplyStatisticsItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReqReplyStatisticsItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetDelayStatistics.ReqReplyStatisticsItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.protoID = reader.int32();
                    break;
                case 2:
                    message.count = reader.int32();
                    break;
                case 3:
                    message.totalCostAvg = reader.float();
                    break;
                case 4:
                    message.openDCostAvg = reader.float();
                    break;
                case 5:
                    message.netDelayAvg = reader.float();
                    break;
                case 6:
                    message.isLocalReply = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("protoID"))
                throw $util.ProtocolError("missing required 'protoID'", { instance: message });
            if (!message.hasOwnProperty("count"))
                throw $util.ProtocolError("missing required 'count'", { instance: message });
            if (!message.hasOwnProperty("totalCostAvg"))
                throw $util.ProtocolError("missing required 'totalCostAvg'", { instance: message });
            if (!message.hasOwnProperty("openDCostAvg"))
                throw $util.ProtocolError("missing required 'openDCostAvg'", { instance: message });
            if (!message.hasOwnProperty("netDelayAvg"))
                throw $util.ProtocolError("missing required 'netDelayAvg'", { instance: message });
            if (!message.hasOwnProperty("isLocalReply"))
                throw $util.ProtocolError("missing required 'isLocalReply'", { instance: message });
            return message;
        };

        /**
         * Decodes a ReqReplyStatisticsItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetDelayStatistics.ReqReplyStatisticsItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetDelayStatistics.ReqReplyStatisticsItem} ReqReplyStatisticsItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReqReplyStatisticsItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReqReplyStatisticsItem message.
         * @function verify
         * @memberof GetDelayStatistics.ReqReplyStatisticsItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReqReplyStatisticsItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.protoID))
                return "protoID: integer expected";
            if (!$util.isInteger(message.count))
                return "count: integer expected";
            if (typeof message.totalCostAvg !== "number")
                return "totalCostAvg: number expected";
            if (typeof message.openDCostAvg !== "number")
                return "openDCostAvg: number expected";
            if (typeof message.netDelayAvg !== "number")
                return "netDelayAvg: number expected";
            if (typeof message.isLocalReply !== "boolean")
                return "isLocalReply: boolean expected";
            return null;
        };

        /**
         * Creates a ReqReplyStatisticsItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetDelayStatistics.ReqReplyStatisticsItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetDelayStatistics.ReqReplyStatisticsItem} ReqReplyStatisticsItem
         */
        ReqReplyStatisticsItem.fromObject = function fromObject(object) {
            if (object instanceof $root.GetDelayStatistics.ReqReplyStatisticsItem)
                return object;
            var message = new $root.GetDelayStatistics.ReqReplyStatisticsItem();
            if (object.protoID != null)
                message.protoID = object.protoID | 0;
            if (object.count != null)
                message.count = object.count | 0;
            if (object.totalCostAvg != null)
                message.totalCostAvg = Number(object.totalCostAvg);
            if (object.openDCostAvg != null)
                message.openDCostAvg = Number(object.openDCostAvg);
            if (object.netDelayAvg != null)
                message.netDelayAvg = Number(object.netDelayAvg);
            if (object.isLocalReply != null)
                message.isLocalReply = Boolean(object.isLocalReply);
            return message;
        };

        /**
         * Creates a plain object from a ReqReplyStatisticsItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetDelayStatistics.ReqReplyStatisticsItem
         * @static
         * @param {GetDelayStatistics.ReqReplyStatisticsItem} message ReqReplyStatisticsItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReqReplyStatisticsItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.protoID = 0;
                object.count = 0;
                object.totalCostAvg = 0;
                object.openDCostAvg = 0;
                object.netDelayAvg = 0;
                object.isLocalReply = false;
            }
            if (message.protoID != null && message.hasOwnProperty("protoID"))
                object.protoID = message.protoID;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            if (message.totalCostAvg != null && message.hasOwnProperty("totalCostAvg"))
                object.totalCostAvg = options.json && !isFinite(message.totalCostAvg) ? String(message.totalCostAvg) : message.totalCostAvg;
            if (message.openDCostAvg != null && message.hasOwnProperty("openDCostAvg"))
                object.openDCostAvg = options.json && !isFinite(message.openDCostAvg) ? String(message.openDCostAvg) : message.openDCostAvg;
            if (message.netDelayAvg != null && message.hasOwnProperty("netDelayAvg"))
                object.netDelayAvg = options.json && !isFinite(message.netDelayAvg) ? String(message.netDelayAvg) : message.netDelayAvg;
            if (message.isLocalReply != null && message.hasOwnProperty("isLocalReply"))
                object.isLocalReply = message.isLocalReply;
            return object;
        };

        /**
         * Converts this ReqReplyStatisticsItem to JSON.
         * @function toJSON
         * @memberof GetDelayStatistics.ReqReplyStatisticsItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReqReplyStatisticsItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReqReplyStatisticsItem;
    })();

    GetDelayStatistics.PlaceOrderStatisticsItem = (function() {

        /**
         * Properties of a PlaceOrderStatisticsItem.
         * @memberof GetDelayStatistics
         * @interface IPlaceOrderStatisticsItem
         * @property {string} orderID PlaceOrderStatisticsItem orderID
         * @property {number} totalCost PlaceOrderStatisticsItem totalCost
         * @property {number} openDCost PlaceOrderStatisticsItem openDCost
         * @property {number} netDelay PlaceOrderStatisticsItem netDelay
         * @property {number} updateCost PlaceOrderStatisticsItem updateCost
         */

        /**
         * Constructs a new PlaceOrderStatisticsItem.
         * @memberof GetDelayStatistics
         * @classdesc Represents a PlaceOrderStatisticsItem.
         * @implements IPlaceOrderStatisticsItem
         * @constructor
         * @param {GetDelayStatistics.IPlaceOrderStatisticsItem=} [properties] Properties to set
         */
        function PlaceOrderStatisticsItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlaceOrderStatisticsItem orderID.
         * @member {string} orderID
         * @memberof GetDelayStatistics.PlaceOrderStatisticsItem
         * @instance
         */
        PlaceOrderStatisticsItem.prototype.orderID = "";

        /**
         * PlaceOrderStatisticsItem totalCost.
         * @member {number} totalCost
         * @memberof GetDelayStatistics.PlaceOrderStatisticsItem
         * @instance
         */
        PlaceOrderStatisticsItem.prototype.totalCost = 0;

        /**
         * PlaceOrderStatisticsItem openDCost.
         * @member {number} openDCost
         * @memberof GetDelayStatistics.PlaceOrderStatisticsItem
         * @instance
         */
        PlaceOrderStatisticsItem.prototype.openDCost = 0;

        /**
         * PlaceOrderStatisticsItem netDelay.
         * @member {number} netDelay
         * @memberof GetDelayStatistics.PlaceOrderStatisticsItem
         * @instance
         */
        PlaceOrderStatisticsItem.prototype.netDelay = 0;

        /**
         * PlaceOrderStatisticsItem updateCost.
         * @member {number} updateCost
         * @memberof GetDelayStatistics.PlaceOrderStatisticsItem
         * @instance
         */
        PlaceOrderStatisticsItem.prototype.updateCost = 0;

        /**
         * Creates a new PlaceOrderStatisticsItem instance using the specified properties.
         * @function create
         * @memberof GetDelayStatistics.PlaceOrderStatisticsItem
         * @static
         * @param {GetDelayStatistics.IPlaceOrderStatisticsItem=} [properties] Properties to set
         * @returns {GetDelayStatistics.PlaceOrderStatisticsItem} PlaceOrderStatisticsItem instance
         */
        PlaceOrderStatisticsItem.create = function create(properties) {
            return new PlaceOrderStatisticsItem(properties);
        };

        /**
         * Encodes the specified PlaceOrderStatisticsItem message. Does not implicitly {@link GetDelayStatistics.PlaceOrderStatisticsItem.verify|verify} messages.
         * @function encode
         * @memberof GetDelayStatistics.PlaceOrderStatisticsItem
         * @static
         * @param {GetDelayStatistics.IPlaceOrderStatisticsItem} message PlaceOrderStatisticsItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlaceOrderStatisticsItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.orderID);
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.totalCost);
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.openDCost);
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.netDelay);
            writer.uint32(/* id 5, wireType 5 =*/45).float(message.updateCost);
            return writer;
        };

        /**
         * Encodes the specified PlaceOrderStatisticsItem message, length delimited. Does not implicitly {@link GetDelayStatistics.PlaceOrderStatisticsItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetDelayStatistics.PlaceOrderStatisticsItem
         * @static
         * @param {GetDelayStatistics.IPlaceOrderStatisticsItem} message PlaceOrderStatisticsItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlaceOrderStatisticsItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlaceOrderStatisticsItem message from the specified reader or buffer.
         * @function decode
         * @memberof GetDelayStatistics.PlaceOrderStatisticsItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetDelayStatistics.PlaceOrderStatisticsItem} PlaceOrderStatisticsItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlaceOrderStatisticsItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetDelayStatistics.PlaceOrderStatisticsItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.orderID = reader.string();
                    break;
                case 2:
                    message.totalCost = reader.float();
                    break;
                case 3:
                    message.openDCost = reader.float();
                    break;
                case 4:
                    message.netDelay = reader.float();
                    break;
                case 5:
                    message.updateCost = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("orderID"))
                throw $util.ProtocolError("missing required 'orderID'", { instance: message });
            if (!message.hasOwnProperty("totalCost"))
                throw $util.ProtocolError("missing required 'totalCost'", { instance: message });
            if (!message.hasOwnProperty("openDCost"))
                throw $util.ProtocolError("missing required 'openDCost'", { instance: message });
            if (!message.hasOwnProperty("netDelay"))
                throw $util.ProtocolError("missing required 'netDelay'", { instance: message });
            if (!message.hasOwnProperty("updateCost"))
                throw $util.ProtocolError("missing required 'updateCost'", { instance: message });
            return message;
        };

        /**
         * Decodes a PlaceOrderStatisticsItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetDelayStatistics.PlaceOrderStatisticsItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetDelayStatistics.PlaceOrderStatisticsItem} PlaceOrderStatisticsItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlaceOrderStatisticsItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlaceOrderStatisticsItem message.
         * @function verify
         * @memberof GetDelayStatistics.PlaceOrderStatisticsItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlaceOrderStatisticsItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.orderID))
                return "orderID: string expected";
            if (typeof message.totalCost !== "number")
                return "totalCost: number expected";
            if (typeof message.openDCost !== "number")
                return "openDCost: number expected";
            if (typeof message.netDelay !== "number")
                return "netDelay: number expected";
            if (typeof message.updateCost !== "number")
                return "updateCost: number expected";
            return null;
        };

        /**
         * Creates a PlaceOrderStatisticsItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetDelayStatistics.PlaceOrderStatisticsItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetDelayStatistics.PlaceOrderStatisticsItem} PlaceOrderStatisticsItem
         */
        PlaceOrderStatisticsItem.fromObject = function fromObject(object) {
            if (object instanceof $root.GetDelayStatistics.PlaceOrderStatisticsItem)
                return object;
            var message = new $root.GetDelayStatistics.PlaceOrderStatisticsItem();
            if (object.orderID != null)
                message.orderID = String(object.orderID);
            if (object.totalCost != null)
                message.totalCost = Number(object.totalCost);
            if (object.openDCost != null)
                message.openDCost = Number(object.openDCost);
            if (object.netDelay != null)
                message.netDelay = Number(object.netDelay);
            if (object.updateCost != null)
                message.updateCost = Number(object.updateCost);
            return message;
        };

        /**
         * Creates a plain object from a PlaceOrderStatisticsItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetDelayStatistics.PlaceOrderStatisticsItem
         * @static
         * @param {GetDelayStatistics.PlaceOrderStatisticsItem} message PlaceOrderStatisticsItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlaceOrderStatisticsItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.orderID = "";
                object.totalCost = 0;
                object.openDCost = 0;
                object.netDelay = 0;
                object.updateCost = 0;
            }
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                object.orderID = message.orderID;
            if (message.totalCost != null && message.hasOwnProperty("totalCost"))
                object.totalCost = options.json && !isFinite(message.totalCost) ? String(message.totalCost) : message.totalCost;
            if (message.openDCost != null && message.hasOwnProperty("openDCost"))
                object.openDCost = options.json && !isFinite(message.openDCost) ? String(message.openDCost) : message.openDCost;
            if (message.netDelay != null && message.hasOwnProperty("netDelay"))
                object.netDelay = options.json && !isFinite(message.netDelay) ? String(message.netDelay) : message.netDelay;
            if (message.updateCost != null && message.hasOwnProperty("updateCost"))
                object.updateCost = options.json && !isFinite(message.updateCost) ? String(message.updateCost) : message.updateCost;
            return object;
        };

        /**
         * Converts this PlaceOrderStatisticsItem to JSON.
         * @function toJSON
         * @memberof GetDelayStatistics.PlaceOrderStatisticsItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlaceOrderStatisticsItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlaceOrderStatisticsItem;
    })();

    GetDelayStatistics.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof GetDelayStatistics
         * @interface IS2C
         * @property {Array.<GetDelayStatistics.IDelayStatistics>|null} [qotPushStatisticsList] S2C qotPushStatisticsList
         * @property {Array.<GetDelayStatistics.IReqReplyStatisticsItem>|null} [reqReplyStatisticsList] S2C reqReplyStatisticsList
         * @property {Array.<GetDelayStatistics.IPlaceOrderStatisticsItem>|null} [placeOrderStatisticsList] S2C placeOrderStatisticsList
         */

        /**
         * Constructs a new S2C.
         * @memberof GetDelayStatistics
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {GetDelayStatistics.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.qotPushStatisticsList = [];
            this.reqReplyStatisticsList = [];
            this.placeOrderStatisticsList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C qotPushStatisticsList.
         * @member {Array.<GetDelayStatistics.IDelayStatistics>} qotPushStatisticsList
         * @memberof GetDelayStatistics.S2C
         * @instance
         */
        S2C.prototype.qotPushStatisticsList = $util.emptyArray;

        /**
         * S2C reqReplyStatisticsList.
         * @member {Array.<GetDelayStatistics.IReqReplyStatisticsItem>} reqReplyStatisticsList
         * @memberof GetDelayStatistics.S2C
         * @instance
         */
        S2C.prototype.reqReplyStatisticsList = $util.emptyArray;

        /**
         * S2C placeOrderStatisticsList.
         * @member {Array.<GetDelayStatistics.IPlaceOrderStatisticsItem>} placeOrderStatisticsList
         * @memberof GetDelayStatistics.S2C
         * @instance
         */
        S2C.prototype.placeOrderStatisticsList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof GetDelayStatistics.S2C
         * @static
         * @param {GetDelayStatistics.IS2C=} [properties] Properties to set
         * @returns {GetDelayStatistics.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link GetDelayStatistics.S2C.verify|verify} messages.
         * @function encode
         * @memberof GetDelayStatistics.S2C
         * @static
         * @param {GetDelayStatistics.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.qotPushStatisticsList != null && message.qotPushStatisticsList.length)
                for (var i = 0; i < message.qotPushStatisticsList.length; ++i)
                    $root.GetDelayStatistics.DelayStatistics.encode(message.qotPushStatisticsList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.reqReplyStatisticsList != null && message.reqReplyStatisticsList.length)
                for (var i = 0; i < message.reqReplyStatisticsList.length; ++i)
                    $root.GetDelayStatistics.ReqReplyStatisticsItem.encode(message.reqReplyStatisticsList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.placeOrderStatisticsList != null && message.placeOrderStatisticsList.length)
                for (var i = 0; i < message.placeOrderStatisticsList.length; ++i)
                    $root.GetDelayStatistics.PlaceOrderStatisticsItem.encode(message.placeOrderStatisticsList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link GetDelayStatistics.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetDelayStatistics.S2C
         * @static
         * @param {GetDelayStatistics.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof GetDelayStatistics.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetDelayStatistics.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetDelayStatistics.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.qotPushStatisticsList && message.qotPushStatisticsList.length))
                        message.qotPushStatisticsList = [];
                    message.qotPushStatisticsList.push($root.GetDelayStatistics.DelayStatistics.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.reqReplyStatisticsList && message.reqReplyStatisticsList.length))
                        message.reqReplyStatisticsList = [];
                    message.reqReplyStatisticsList.push($root.GetDelayStatistics.ReqReplyStatisticsItem.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.placeOrderStatisticsList && message.placeOrderStatisticsList.length))
                        message.placeOrderStatisticsList = [];
                    message.placeOrderStatisticsList.push($root.GetDelayStatistics.PlaceOrderStatisticsItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetDelayStatistics.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetDelayStatistics.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof GetDelayStatistics.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.qotPushStatisticsList != null && message.hasOwnProperty("qotPushStatisticsList")) {
                if (!Array.isArray(message.qotPushStatisticsList))
                    return "qotPushStatisticsList: array expected";
                for (var i = 0; i < message.qotPushStatisticsList.length; ++i) {
                    var error = $root.GetDelayStatistics.DelayStatistics.verify(message.qotPushStatisticsList[i]);
                    if (error)
                        return "qotPushStatisticsList." + error;
                }
            }
            if (message.reqReplyStatisticsList != null && message.hasOwnProperty("reqReplyStatisticsList")) {
                if (!Array.isArray(message.reqReplyStatisticsList))
                    return "reqReplyStatisticsList: array expected";
                for (var i = 0; i < message.reqReplyStatisticsList.length; ++i) {
                    var error = $root.GetDelayStatistics.ReqReplyStatisticsItem.verify(message.reqReplyStatisticsList[i]);
                    if (error)
                        return "reqReplyStatisticsList." + error;
                }
            }
            if (message.placeOrderStatisticsList != null && message.hasOwnProperty("placeOrderStatisticsList")) {
                if (!Array.isArray(message.placeOrderStatisticsList))
                    return "placeOrderStatisticsList: array expected";
                for (var i = 0; i < message.placeOrderStatisticsList.length; ++i) {
                    var error = $root.GetDelayStatistics.PlaceOrderStatisticsItem.verify(message.placeOrderStatisticsList[i]);
                    if (error)
                        return "placeOrderStatisticsList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetDelayStatistics.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetDelayStatistics.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.GetDelayStatistics.S2C)
                return object;
            var message = new $root.GetDelayStatistics.S2C();
            if (object.qotPushStatisticsList) {
                if (!Array.isArray(object.qotPushStatisticsList))
                    throw TypeError(".GetDelayStatistics.S2C.qotPushStatisticsList: array expected");
                message.qotPushStatisticsList = [];
                for (var i = 0; i < object.qotPushStatisticsList.length; ++i) {
                    if (typeof object.qotPushStatisticsList[i] !== "object")
                        throw TypeError(".GetDelayStatistics.S2C.qotPushStatisticsList: object expected");
                    message.qotPushStatisticsList[i] = $root.GetDelayStatistics.DelayStatistics.fromObject(object.qotPushStatisticsList[i]);
                }
            }
            if (object.reqReplyStatisticsList) {
                if (!Array.isArray(object.reqReplyStatisticsList))
                    throw TypeError(".GetDelayStatistics.S2C.reqReplyStatisticsList: array expected");
                message.reqReplyStatisticsList = [];
                for (var i = 0; i < object.reqReplyStatisticsList.length; ++i) {
                    if (typeof object.reqReplyStatisticsList[i] !== "object")
                        throw TypeError(".GetDelayStatistics.S2C.reqReplyStatisticsList: object expected");
                    message.reqReplyStatisticsList[i] = $root.GetDelayStatistics.ReqReplyStatisticsItem.fromObject(object.reqReplyStatisticsList[i]);
                }
            }
            if (object.placeOrderStatisticsList) {
                if (!Array.isArray(object.placeOrderStatisticsList))
                    throw TypeError(".GetDelayStatistics.S2C.placeOrderStatisticsList: array expected");
                message.placeOrderStatisticsList = [];
                for (var i = 0; i < object.placeOrderStatisticsList.length; ++i) {
                    if (typeof object.placeOrderStatisticsList[i] !== "object")
                        throw TypeError(".GetDelayStatistics.S2C.placeOrderStatisticsList: object expected");
                    message.placeOrderStatisticsList[i] = $root.GetDelayStatistics.PlaceOrderStatisticsItem.fromObject(object.placeOrderStatisticsList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetDelayStatistics.S2C
         * @static
         * @param {GetDelayStatistics.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.qotPushStatisticsList = [];
                object.reqReplyStatisticsList = [];
                object.placeOrderStatisticsList = [];
            }
            if (message.qotPushStatisticsList && message.qotPushStatisticsList.length) {
                object.qotPushStatisticsList = [];
                for (var j = 0; j < message.qotPushStatisticsList.length; ++j)
                    object.qotPushStatisticsList[j] = $root.GetDelayStatistics.DelayStatistics.toObject(message.qotPushStatisticsList[j], options);
            }
            if (message.reqReplyStatisticsList && message.reqReplyStatisticsList.length) {
                object.reqReplyStatisticsList = [];
                for (var j = 0; j < message.reqReplyStatisticsList.length; ++j)
                    object.reqReplyStatisticsList[j] = $root.GetDelayStatistics.ReqReplyStatisticsItem.toObject(message.reqReplyStatisticsList[j], options);
            }
            if (message.placeOrderStatisticsList && message.placeOrderStatisticsList.length) {
                object.placeOrderStatisticsList = [];
                for (var j = 0; j < message.placeOrderStatisticsList.length; ++j)
                    object.placeOrderStatisticsList[j] = $root.GetDelayStatistics.PlaceOrderStatisticsItem.toObject(message.placeOrderStatisticsList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof GetDelayStatistics.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    GetDelayStatistics.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof GetDelayStatistics
         * @interface IRequest
         * @property {GetDelayStatistics.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof GetDelayStatistics
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {GetDelayStatistics.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {GetDelayStatistics.IC2S} c2s
         * @memberof GetDelayStatistics.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof GetDelayStatistics.Request
         * @static
         * @param {GetDelayStatistics.IRequest=} [properties] Properties to set
         * @returns {GetDelayStatistics.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link GetDelayStatistics.Request.verify|verify} messages.
         * @function encode
         * @memberof GetDelayStatistics.Request
         * @static
         * @param {GetDelayStatistics.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.GetDelayStatistics.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link GetDelayStatistics.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetDelayStatistics.Request
         * @static
         * @param {GetDelayStatistics.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof GetDelayStatistics.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetDelayStatistics.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetDelayStatistics.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.GetDelayStatistics.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetDelayStatistics.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetDelayStatistics.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof GetDelayStatistics.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.GetDelayStatistics.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetDelayStatistics.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetDelayStatistics.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.GetDelayStatistics.Request)
                return object;
            var message = new $root.GetDelayStatistics.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".GetDelayStatistics.Request.c2s: object expected");
                message.c2s = $root.GetDelayStatistics.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetDelayStatistics.Request
         * @static
         * @param {GetDelayStatistics.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.GetDelayStatistics.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof GetDelayStatistics.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    GetDelayStatistics.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof GetDelayStatistics
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {GetDelayStatistics.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof GetDelayStatistics
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {GetDelayStatistics.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof GetDelayStatistics.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof GetDelayStatistics.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof GetDelayStatistics.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {GetDelayStatistics.IS2C|null|undefined} s2c
         * @memberof GetDelayStatistics.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof GetDelayStatistics.Response
         * @static
         * @param {GetDelayStatistics.IResponse=} [properties] Properties to set
         * @returns {GetDelayStatistics.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link GetDelayStatistics.Response.verify|verify} messages.
         * @function encode
         * @memberof GetDelayStatistics.Response
         * @static
         * @param {GetDelayStatistics.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.GetDelayStatistics.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link GetDelayStatistics.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetDelayStatistics.Response
         * @static
         * @param {GetDelayStatistics.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof GetDelayStatistics.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetDelayStatistics.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetDelayStatistics.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.GetDelayStatistics.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetDelayStatistics.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetDelayStatistics.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof GetDelayStatistics.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.GetDelayStatistics.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetDelayStatistics.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetDelayStatistics.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.GetDelayStatistics.Response)
                return object;
            var message = new $root.GetDelayStatistics.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".GetDelayStatistics.Response.s2c: object expected");
                message.s2c = $root.GetDelayStatistics.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetDelayStatistics.Response
         * @static
         * @param {GetDelayStatistics.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.GetDelayStatistics.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof GetDelayStatistics.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return GetDelayStatistics;
})();

$root.GetGlobalState = (function() {

    /**
     * Namespace GetGlobalState.
     * @exports GetGlobalState
     * @namespace
     */
    var GetGlobalState = {};

    GetGlobalState.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof GetGlobalState
         * @interface IC2S
         * @property {number|Long} userID C2S userID
         */

        /**
         * Constructs a new C2S.
         * @memberof GetGlobalState
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {GetGlobalState.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S userID.
         * @member {number|Long} userID
         * @memberof GetGlobalState.C2S
         * @instance
         */
        C2S.prototype.userID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof GetGlobalState.C2S
         * @static
         * @param {GetGlobalState.IC2S=} [properties] Properties to set
         * @returns {GetGlobalState.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link GetGlobalState.C2S.verify|verify} messages.
         * @function encode
         * @memberof GetGlobalState.C2S
         * @static
         * @param {GetGlobalState.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.userID);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link GetGlobalState.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetGlobalState.C2S
         * @static
         * @param {GetGlobalState.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof GetGlobalState.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetGlobalState.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetGlobalState.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userID = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userID"))
                throw $util.ProtocolError("missing required 'userID'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetGlobalState.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetGlobalState.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof GetGlobalState.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.userID) && !(message.userID && $util.isInteger(message.userID.low) && $util.isInteger(message.userID.high)))
                return "userID: integer|Long expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetGlobalState.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetGlobalState.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.GetGlobalState.C2S)
                return object;
            var message = new $root.GetGlobalState.C2S();
            if (object.userID != null)
                if ($util.Long)
                    (message.userID = $util.Long.fromValue(object.userID)).unsigned = true;
                else if (typeof object.userID === "string")
                    message.userID = parseInt(object.userID, 10);
                else if (typeof object.userID === "number")
                    message.userID = object.userID;
                else if (typeof object.userID === "object")
                    message.userID = new $util.LongBits(object.userID.low >>> 0, object.userID.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetGlobalState.C2S
         * @static
         * @param {GetGlobalState.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.userID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.userID = options.longs === String ? "0" : 0;
            if (message.userID != null && message.hasOwnProperty("userID"))
                if (typeof message.userID === "number")
                    object.userID = options.longs === String ? String(message.userID) : message.userID;
                else
                    object.userID = options.longs === String ? $util.Long.prototype.toString.call(message.userID) : options.longs === Number ? new $util.LongBits(message.userID.low >>> 0, message.userID.high >>> 0).toNumber(true) : message.userID;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof GetGlobalState.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    GetGlobalState.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof GetGlobalState
         * @interface IS2C
         * @property {number} marketHK S2C marketHK
         * @property {number} marketUS S2C marketUS
         * @property {number} marketSH S2C marketSH
         * @property {number} marketSZ S2C marketSZ
         * @property {number} marketHKFuture S2C marketHKFuture
         * @property {number|null} [marketUSFuture] S2C marketUSFuture
         * @property {boolean} qotLogined S2C qotLogined
         * @property {boolean} trdLogined S2C trdLogined
         * @property {number} serverVer S2C serverVer
         * @property {number} serverBuildNo S2C serverBuildNo
         * @property {number|Long} time S2C time
         * @property {number|null} [localTime] S2C localTime
         * @property {Common.IProgramStatus|null} [programStatus] S2C programStatus
         * @property {string|null} [qotSvrIpAddr] S2C qotSvrIpAddr
         * @property {string|null} [trdSvrIpAddr] S2C trdSvrIpAddr
         * @property {number|Long|null} [connID] S2C connID
         */

        /**
         * Constructs a new S2C.
         * @memberof GetGlobalState
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {GetGlobalState.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C marketHK.
         * @member {number} marketHK
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.marketHK = 0;

        /**
         * S2C marketUS.
         * @member {number} marketUS
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.marketUS = 0;

        /**
         * S2C marketSH.
         * @member {number} marketSH
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.marketSH = 0;

        /**
         * S2C marketSZ.
         * @member {number} marketSZ
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.marketSZ = 0;

        /**
         * S2C marketHKFuture.
         * @member {number} marketHKFuture
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.marketHKFuture = 0;

        /**
         * S2C marketUSFuture.
         * @member {number} marketUSFuture
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.marketUSFuture = 0;

        /**
         * S2C qotLogined.
         * @member {boolean} qotLogined
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.qotLogined = false;

        /**
         * S2C trdLogined.
         * @member {boolean} trdLogined
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.trdLogined = false;

        /**
         * S2C serverVer.
         * @member {number} serverVer
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.serverVer = 0;

        /**
         * S2C serverBuildNo.
         * @member {number} serverBuildNo
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.serverBuildNo = 0;

        /**
         * S2C time.
         * @member {number|Long} time
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * S2C localTime.
         * @member {number} localTime
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.localTime = 0;

        /**
         * S2C programStatus.
         * @member {Common.IProgramStatus|null|undefined} programStatus
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.programStatus = null;

        /**
         * S2C qotSvrIpAddr.
         * @member {string} qotSvrIpAddr
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.qotSvrIpAddr = "";

        /**
         * S2C trdSvrIpAddr.
         * @member {string} trdSvrIpAddr
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.trdSvrIpAddr = "";

        /**
         * S2C connID.
         * @member {number|Long} connID
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.connID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof GetGlobalState.S2C
         * @static
         * @param {GetGlobalState.IS2C=} [properties] Properties to set
         * @returns {GetGlobalState.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link GetGlobalState.S2C.verify|verify} messages.
         * @function encode
         * @memberof GetGlobalState.S2C
         * @static
         * @param {GetGlobalState.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.marketHK);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.marketUS);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.marketSH);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.marketSZ);
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.marketHKFuture);
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.qotLogined);
            writer.uint32(/* id 7, wireType 0 =*/56).bool(message.trdLogined);
            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.serverVer);
            writer.uint32(/* id 9, wireType 0 =*/72).int32(message.serverBuildNo);
            writer.uint32(/* id 10, wireType 0 =*/80).int64(message.time);
            if (message.localTime != null && message.hasOwnProperty("localTime"))
                writer.uint32(/* id 11, wireType 1 =*/89).double(message.localTime);
            if (message.programStatus != null && message.hasOwnProperty("programStatus"))
                $root.Common.ProgramStatus.encode(message.programStatus, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.qotSvrIpAddr != null && message.hasOwnProperty("qotSvrIpAddr"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.qotSvrIpAddr);
            if (message.trdSvrIpAddr != null && message.hasOwnProperty("trdSvrIpAddr"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.trdSvrIpAddr);
            if (message.marketUSFuture != null && message.hasOwnProperty("marketUSFuture"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.marketUSFuture);
            if (message.connID != null && message.hasOwnProperty("connID"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint64(message.connID);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link GetGlobalState.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetGlobalState.S2C
         * @static
         * @param {GetGlobalState.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof GetGlobalState.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetGlobalState.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetGlobalState.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.marketHK = reader.int32();
                    break;
                case 2:
                    message.marketUS = reader.int32();
                    break;
                case 3:
                    message.marketSH = reader.int32();
                    break;
                case 4:
                    message.marketSZ = reader.int32();
                    break;
                case 5:
                    message.marketHKFuture = reader.int32();
                    break;
                case 15:
                    message.marketUSFuture = reader.int32();
                    break;
                case 6:
                    message.qotLogined = reader.bool();
                    break;
                case 7:
                    message.trdLogined = reader.bool();
                    break;
                case 8:
                    message.serverVer = reader.int32();
                    break;
                case 9:
                    message.serverBuildNo = reader.int32();
                    break;
                case 10:
                    message.time = reader.int64();
                    break;
                case 11:
                    message.localTime = reader.double();
                    break;
                case 12:
                    message.programStatus = $root.Common.ProgramStatus.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.qotSvrIpAddr = reader.string();
                    break;
                case 14:
                    message.trdSvrIpAddr = reader.string();
                    break;
                case 16:
                    message.connID = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("marketHK"))
                throw $util.ProtocolError("missing required 'marketHK'", { instance: message });
            if (!message.hasOwnProperty("marketUS"))
                throw $util.ProtocolError("missing required 'marketUS'", { instance: message });
            if (!message.hasOwnProperty("marketSH"))
                throw $util.ProtocolError("missing required 'marketSH'", { instance: message });
            if (!message.hasOwnProperty("marketSZ"))
                throw $util.ProtocolError("missing required 'marketSZ'", { instance: message });
            if (!message.hasOwnProperty("marketHKFuture"))
                throw $util.ProtocolError("missing required 'marketHKFuture'", { instance: message });
            if (!message.hasOwnProperty("qotLogined"))
                throw $util.ProtocolError("missing required 'qotLogined'", { instance: message });
            if (!message.hasOwnProperty("trdLogined"))
                throw $util.ProtocolError("missing required 'trdLogined'", { instance: message });
            if (!message.hasOwnProperty("serverVer"))
                throw $util.ProtocolError("missing required 'serverVer'", { instance: message });
            if (!message.hasOwnProperty("serverBuildNo"))
                throw $util.ProtocolError("missing required 'serverBuildNo'", { instance: message });
            if (!message.hasOwnProperty("time"))
                throw $util.ProtocolError("missing required 'time'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetGlobalState.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetGlobalState.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof GetGlobalState.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.marketHK))
                return "marketHK: integer expected";
            if (!$util.isInteger(message.marketUS))
                return "marketUS: integer expected";
            if (!$util.isInteger(message.marketSH))
                return "marketSH: integer expected";
            if (!$util.isInteger(message.marketSZ))
                return "marketSZ: integer expected";
            if (!$util.isInteger(message.marketHKFuture))
                return "marketHKFuture: integer expected";
            if (message.marketUSFuture != null && message.hasOwnProperty("marketUSFuture"))
                if (!$util.isInteger(message.marketUSFuture))
                    return "marketUSFuture: integer expected";
            if (typeof message.qotLogined !== "boolean")
                return "qotLogined: boolean expected";
            if (typeof message.trdLogined !== "boolean")
                return "trdLogined: boolean expected";
            if (!$util.isInteger(message.serverVer))
                return "serverVer: integer expected";
            if (!$util.isInteger(message.serverBuildNo))
                return "serverBuildNo: integer expected";
            if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                return "time: integer|Long expected";
            if (message.localTime != null && message.hasOwnProperty("localTime"))
                if (typeof message.localTime !== "number")
                    return "localTime: number expected";
            if (message.programStatus != null && message.hasOwnProperty("programStatus")) {
                var error = $root.Common.ProgramStatus.verify(message.programStatus);
                if (error)
                    return "programStatus." + error;
            }
            if (message.qotSvrIpAddr != null && message.hasOwnProperty("qotSvrIpAddr"))
                if (!$util.isString(message.qotSvrIpAddr))
                    return "qotSvrIpAddr: string expected";
            if (message.trdSvrIpAddr != null && message.hasOwnProperty("trdSvrIpAddr"))
                if (!$util.isString(message.trdSvrIpAddr))
                    return "trdSvrIpAddr: string expected";
            if (message.connID != null && message.hasOwnProperty("connID"))
                if (!$util.isInteger(message.connID) && !(message.connID && $util.isInteger(message.connID.low) && $util.isInteger(message.connID.high)))
                    return "connID: integer|Long expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetGlobalState.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetGlobalState.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.GetGlobalState.S2C)
                return object;
            var message = new $root.GetGlobalState.S2C();
            if (object.marketHK != null)
                message.marketHK = object.marketHK | 0;
            if (object.marketUS != null)
                message.marketUS = object.marketUS | 0;
            if (object.marketSH != null)
                message.marketSH = object.marketSH | 0;
            if (object.marketSZ != null)
                message.marketSZ = object.marketSZ | 0;
            if (object.marketHKFuture != null)
                message.marketHKFuture = object.marketHKFuture | 0;
            if (object.marketUSFuture != null)
                message.marketUSFuture = object.marketUSFuture | 0;
            if (object.qotLogined != null)
                message.qotLogined = Boolean(object.qotLogined);
            if (object.trdLogined != null)
                message.trdLogined = Boolean(object.trdLogined);
            if (object.serverVer != null)
                message.serverVer = object.serverVer | 0;
            if (object.serverBuildNo != null)
                message.serverBuildNo = object.serverBuildNo | 0;
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
            if (object.localTime != null)
                message.localTime = Number(object.localTime);
            if (object.programStatus != null) {
                if (typeof object.programStatus !== "object")
                    throw TypeError(".GetGlobalState.S2C.programStatus: object expected");
                message.programStatus = $root.Common.ProgramStatus.fromObject(object.programStatus);
            }
            if (object.qotSvrIpAddr != null)
                message.qotSvrIpAddr = String(object.qotSvrIpAddr);
            if (object.trdSvrIpAddr != null)
                message.trdSvrIpAddr = String(object.trdSvrIpAddr);
            if (object.connID != null)
                if ($util.Long)
                    (message.connID = $util.Long.fromValue(object.connID)).unsigned = true;
                else if (typeof object.connID === "string")
                    message.connID = parseInt(object.connID, 10);
                else if (typeof object.connID === "number")
                    message.connID = object.connID;
                else if (typeof object.connID === "object")
                    message.connID = new $util.LongBits(object.connID.low >>> 0, object.connID.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetGlobalState.S2C
         * @static
         * @param {GetGlobalState.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.marketHK = 0;
                object.marketUS = 0;
                object.marketSH = 0;
                object.marketSZ = 0;
                object.marketHKFuture = 0;
                object.qotLogined = false;
                object.trdLogined = false;
                object.serverVer = 0;
                object.serverBuildNo = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time = options.longs === String ? "0" : 0;
                object.localTime = 0;
                object.programStatus = null;
                object.qotSvrIpAddr = "";
                object.trdSvrIpAddr = "";
                object.marketUSFuture = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.connID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.connID = options.longs === String ? "0" : 0;
            }
            if (message.marketHK != null && message.hasOwnProperty("marketHK"))
                object.marketHK = message.marketHK;
            if (message.marketUS != null && message.hasOwnProperty("marketUS"))
                object.marketUS = message.marketUS;
            if (message.marketSH != null && message.hasOwnProperty("marketSH"))
                object.marketSH = message.marketSH;
            if (message.marketSZ != null && message.hasOwnProperty("marketSZ"))
                object.marketSZ = message.marketSZ;
            if (message.marketHKFuture != null && message.hasOwnProperty("marketHKFuture"))
                object.marketHKFuture = message.marketHKFuture;
            if (message.qotLogined != null && message.hasOwnProperty("qotLogined"))
                object.qotLogined = message.qotLogined;
            if (message.trdLogined != null && message.hasOwnProperty("trdLogined"))
                object.trdLogined = message.trdLogined;
            if (message.serverVer != null && message.hasOwnProperty("serverVer"))
                object.serverVer = message.serverVer;
            if (message.serverBuildNo != null && message.hasOwnProperty("serverBuildNo"))
                object.serverBuildNo = message.serverBuildNo;
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
            if (message.localTime != null && message.hasOwnProperty("localTime"))
                object.localTime = options.json && !isFinite(message.localTime) ? String(message.localTime) : message.localTime;
            if (message.programStatus != null && message.hasOwnProperty("programStatus"))
                object.programStatus = $root.Common.ProgramStatus.toObject(message.programStatus, options);
            if (message.qotSvrIpAddr != null && message.hasOwnProperty("qotSvrIpAddr"))
                object.qotSvrIpAddr = message.qotSvrIpAddr;
            if (message.trdSvrIpAddr != null && message.hasOwnProperty("trdSvrIpAddr"))
                object.trdSvrIpAddr = message.trdSvrIpAddr;
            if (message.marketUSFuture != null && message.hasOwnProperty("marketUSFuture"))
                object.marketUSFuture = message.marketUSFuture;
            if (message.connID != null && message.hasOwnProperty("connID"))
                if (typeof message.connID === "number")
                    object.connID = options.longs === String ? String(message.connID) : message.connID;
                else
                    object.connID = options.longs === String ? $util.Long.prototype.toString.call(message.connID) : options.longs === Number ? new $util.LongBits(message.connID.low >>> 0, message.connID.high >>> 0).toNumber(true) : message.connID;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof GetGlobalState.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    GetGlobalState.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof GetGlobalState
         * @interface IRequest
         * @property {GetGlobalState.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof GetGlobalState
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {GetGlobalState.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {GetGlobalState.IC2S} c2s
         * @memberof GetGlobalState.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof GetGlobalState.Request
         * @static
         * @param {GetGlobalState.IRequest=} [properties] Properties to set
         * @returns {GetGlobalState.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link GetGlobalState.Request.verify|verify} messages.
         * @function encode
         * @memberof GetGlobalState.Request
         * @static
         * @param {GetGlobalState.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.GetGlobalState.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link GetGlobalState.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetGlobalState.Request
         * @static
         * @param {GetGlobalState.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof GetGlobalState.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetGlobalState.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetGlobalState.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.GetGlobalState.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetGlobalState.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetGlobalState.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof GetGlobalState.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.GetGlobalState.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetGlobalState.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetGlobalState.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.GetGlobalState.Request)
                return object;
            var message = new $root.GetGlobalState.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".GetGlobalState.Request.c2s: object expected");
                message.c2s = $root.GetGlobalState.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetGlobalState.Request
         * @static
         * @param {GetGlobalState.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.GetGlobalState.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof GetGlobalState.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    GetGlobalState.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof GetGlobalState
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {GetGlobalState.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof GetGlobalState
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {GetGlobalState.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof GetGlobalState.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof GetGlobalState.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof GetGlobalState.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {GetGlobalState.IS2C|null|undefined} s2c
         * @memberof GetGlobalState.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof GetGlobalState.Response
         * @static
         * @param {GetGlobalState.IResponse=} [properties] Properties to set
         * @returns {GetGlobalState.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link GetGlobalState.Response.verify|verify} messages.
         * @function encode
         * @memberof GetGlobalState.Response
         * @static
         * @param {GetGlobalState.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.GetGlobalState.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link GetGlobalState.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetGlobalState.Response
         * @static
         * @param {GetGlobalState.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof GetGlobalState.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetGlobalState.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetGlobalState.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.GetGlobalState.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetGlobalState.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetGlobalState.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof GetGlobalState.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.GetGlobalState.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetGlobalState.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetGlobalState.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.GetGlobalState.Response)
                return object;
            var message = new $root.GetGlobalState.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".GetGlobalState.Response.s2c: object expected");
                message.s2c = $root.GetGlobalState.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetGlobalState.Response
         * @static
         * @param {GetGlobalState.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.GetGlobalState.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof GetGlobalState.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return GetGlobalState;
})();

$root.Qot_Common = (function() {

    /**
     * Namespace Qot_Common.
     * @exports Qot_Common
     * @namespace
     */
    var Qot_Common = {};

    /**
     * QotMarket enum.
     * @name Qot_Common.QotMarket
     * @enum {string}
     * @property {number} QotMarket_Unknown=0 QotMarket_Unknown value
     * @property {number} QotMarket_HK_Security=1 QotMarket_HK_Security value
     * @property {number} QotMarket_HK_Future=2 QotMarket_HK_Future value
     * @property {number} QotMarket_US_Security=11 QotMarket_US_Security value
     * @property {number} QotMarket_CNSH_Security=21 QotMarket_CNSH_Security value
     * @property {number} QotMarket_CNSZ_Security=22 QotMarket_CNSZ_Security value
     */
    Qot_Common.QotMarket = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "QotMarket_Unknown"] = 0;
        values[valuesById[1] = "QotMarket_HK_Security"] = 1;
        values[valuesById[2] = "QotMarket_HK_Future"] = 2;
        values[valuesById[11] = "QotMarket_US_Security"] = 11;
        values[valuesById[21] = "QotMarket_CNSH_Security"] = 21;
        values[valuesById[22] = "QotMarket_CNSZ_Security"] = 22;
        return values;
    })();

    /**
     * SecurityType enum.
     * @name Qot_Common.SecurityType
     * @enum {string}
     * @property {number} SecurityType_Unknown=0 SecurityType_Unknown value
     * @property {number} SecurityType_Bond=1 SecurityType_Bond value
     * @property {number} SecurityType_Bwrt=2 SecurityType_Bwrt value
     * @property {number} SecurityType_Eqty=3 SecurityType_Eqty value
     * @property {number} SecurityType_Trust=4 SecurityType_Trust value
     * @property {number} SecurityType_Warrant=5 SecurityType_Warrant value
     * @property {number} SecurityType_Index=6 SecurityType_Index value
     * @property {number} SecurityType_Plate=7 SecurityType_Plate value
     * @property {number} SecurityType_Drvt=8 SecurityType_Drvt value
     * @property {number} SecurityType_PlateSet=9 SecurityType_PlateSet value
     * @property {number} SecurityType_Future=10 SecurityType_Future value
     */
    Qot_Common.SecurityType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SecurityType_Unknown"] = 0;
        values[valuesById[1] = "SecurityType_Bond"] = 1;
        values[valuesById[2] = "SecurityType_Bwrt"] = 2;
        values[valuesById[3] = "SecurityType_Eqty"] = 3;
        values[valuesById[4] = "SecurityType_Trust"] = 4;
        values[valuesById[5] = "SecurityType_Warrant"] = 5;
        values[valuesById[6] = "SecurityType_Index"] = 6;
        values[valuesById[7] = "SecurityType_Plate"] = 7;
        values[valuesById[8] = "SecurityType_Drvt"] = 8;
        values[valuesById[9] = "SecurityType_PlateSet"] = 9;
        values[valuesById[10] = "SecurityType_Future"] = 10;
        return values;
    })();

    /**
     * PlateSetType enum.
     * @name Qot_Common.PlateSetType
     * @enum {string}
     * @property {number} PlateSetType_All=0 PlateSetType_All value
     * @property {number} PlateSetType_Industry=1 PlateSetType_Industry value
     * @property {number} PlateSetType_Region=2 PlateSetType_Region value
     * @property {number} PlateSetType_Concept=3 PlateSetType_Concept value
     * @property {number} PlateSetType_Other=4 PlateSetType_Other value
     */
    Qot_Common.PlateSetType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PlateSetType_All"] = 0;
        values[valuesById[1] = "PlateSetType_Industry"] = 1;
        values[valuesById[2] = "PlateSetType_Region"] = 2;
        values[valuesById[3] = "PlateSetType_Concept"] = 3;
        values[valuesById[4] = "PlateSetType_Other"] = 4;
        return values;
    })();

    /**
     * WarrantType enum.
     * @name Qot_Common.WarrantType
     * @enum {string}
     * @property {number} WarrantType_Unknown=0 WarrantType_Unknown value
     * @property {number} WarrantType_Buy=1 WarrantType_Buy value
     * @property {number} WarrantType_Sell=2 WarrantType_Sell value
     * @property {number} WarrantType_Bull=3 WarrantType_Bull value
     * @property {number} WarrantType_Bear=4 WarrantType_Bear value
     * @property {number} WarrantType_InLine=5 WarrantType_InLine value
     */
    Qot_Common.WarrantType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "WarrantType_Unknown"] = 0;
        values[valuesById[1] = "WarrantType_Buy"] = 1;
        values[valuesById[2] = "WarrantType_Sell"] = 2;
        values[valuesById[3] = "WarrantType_Bull"] = 3;
        values[valuesById[4] = "WarrantType_Bear"] = 4;
        values[valuesById[5] = "WarrantType_InLine"] = 5;
        return values;
    })();

    /**
     * OptionType enum.
     * @name Qot_Common.OptionType
     * @enum {string}
     * @property {number} OptionType_Unknown=0 OptionType_Unknown value
     * @property {number} OptionType_Call=1 OptionType_Call value
     * @property {number} OptionType_Put=2 OptionType_Put value
     */
    Qot_Common.OptionType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OptionType_Unknown"] = 0;
        values[valuesById[1] = "OptionType_Call"] = 1;
        values[valuesById[2] = "OptionType_Put"] = 2;
        return values;
    })();

    /**
     * IndexOptionType enum.
     * @name Qot_Common.IndexOptionType
     * @enum {string}
     * @property {number} IndexOptionType_Unknown=0 IndexOptionType_Unknown value
     * @property {number} IndexOptionType_Normal=1 IndexOptionType_Normal value
     * @property {number} IndexOptionType_Small=2 IndexOptionType_Small value
     */
    Qot_Common.IndexOptionType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "IndexOptionType_Unknown"] = 0;
        values[valuesById[1] = "IndexOptionType_Normal"] = 1;
        values[valuesById[2] = "IndexOptionType_Small"] = 2;
        return values;
    })();

    /**
     * OptionAreaType enum.
     * @name Qot_Common.OptionAreaType
     * @enum {string}
     * @property {number} OptionAreaType_Unknown=0 OptionAreaType_Unknown value
     * @property {number} OptionAreaType_American=1 OptionAreaType_American value
     * @property {number} OptionAreaType_European=2 OptionAreaType_European value
     * @property {number} OptionAreaType_Bermuda=3 OptionAreaType_Bermuda value
     */
    Qot_Common.OptionAreaType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OptionAreaType_Unknown"] = 0;
        values[valuesById[1] = "OptionAreaType_American"] = 1;
        values[valuesById[2] = "OptionAreaType_European"] = 2;
        values[valuesById[3] = "OptionAreaType_Bermuda"] = 3;
        return values;
    })();

    /**
     * QotMarketState enum.
     * @name Qot_Common.QotMarketState
     * @enum {string}
     * @property {number} QotMarketState_None=0 QotMarketState_None value
     * @property {number} QotMarketState_Auction=1 QotMarketState_Auction value
     * @property {number} QotMarketState_WaitingOpen=2 QotMarketState_WaitingOpen value
     * @property {number} QotMarketState_Morning=3 QotMarketState_Morning value
     * @property {number} QotMarketState_Rest=4 QotMarketState_Rest value
     * @property {number} QotMarketState_Afternoon=5 QotMarketState_Afternoon value
     * @property {number} QotMarketState_Closed=6 QotMarketState_Closed value
     * @property {number} QotMarketState_PreMarketBegin=8 QotMarketState_PreMarketBegin value
     * @property {number} QotMarketState_PreMarketEnd=9 QotMarketState_PreMarketEnd value
     * @property {number} QotMarketState_AfterHoursBegin=10 QotMarketState_AfterHoursBegin value
     * @property {number} QotMarketState_AfterHoursEnd=11 QotMarketState_AfterHoursEnd value
     * @property {number} QotMarketState_NightOpen=13 QotMarketState_NightOpen value
     * @property {number} QotMarketState_NightEnd=14 QotMarketState_NightEnd value
     * @property {number} QotMarketState_FutureDayOpen=15 QotMarketState_FutureDayOpen value
     * @property {number} QotMarketState_FutureDayBreak=16 QotMarketState_FutureDayBreak value
     * @property {number} QotMarketState_FutureDayClose=17 QotMarketState_FutureDayClose value
     * @property {number} QotMarketState_FutureDayWaitForOpen=18 QotMarketState_FutureDayWaitForOpen value
     * @property {number} QotMarketState_HkCas=19 QotMarketState_HkCas value
     * @property {number} QotMarketState_FutureNightWait=20 QotMarketState_FutureNightWait value
     * @property {number} QotMarketState_FutureAfternoon=21 QotMarketState_FutureAfternoon value
     * @property {number} QotMarketState_FutureSwitchDate=22 QotMarketState_FutureSwitchDate value
     * @property {number} QotMarketState_FutureOpen=23 QotMarketState_FutureOpen value
     * @property {number} QotMarketState_FutureBreak=24 QotMarketState_FutureBreak value
     * @property {number} QotMarketState_FutureBreakOver=25 QotMarketState_FutureBreakOver value
     * @property {number} QotMarketState_FutureClose=26 QotMarketState_FutureClose value
     */
    Qot_Common.QotMarketState = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "QotMarketState_None"] = 0;
        values[valuesById[1] = "QotMarketState_Auction"] = 1;
        values[valuesById[2] = "QotMarketState_WaitingOpen"] = 2;
        values[valuesById[3] = "QotMarketState_Morning"] = 3;
        values[valuesById[4] = "QotMarketState_Rest"] = 4;
        values[valuesById[5] = "QotMarketState_Afternoon"] = 5;
        values[valuesById[6] = "QotMarketState_Closed"] = 6;
        values[valuesById[8] = "QotMarketState_PreMarketBegin"] = 8;
        values[valuesById[9] = "QotMarketState_PreMarketEnd"] = 9;
        values[valuesById[10] = "QotMarketState_AfterHoursBegin"] = 10;
        values[valuesById[11] = "QotMarketState_AfterHoursEnd"] = 11;
        values[valuesById[13] = "QotMarketState_NightOpen"] = 13;
        values[valuesById[14] = "QotMarketState_NightEnd"] = 14;
        values[valuesById[15] = "QotMarketState_FutureDayOpen"] = 15;
        values[valuesById[16] = "QotMarketState_FutureDayBreak"] = 16;
        values[valuesById[17] = "QotMarketState_FutureDayClose"] = 17;
        values[valuesById[18] = "QotMarketState_FutureDayWaitForOpen"] = 18;
        values[valuesById[19] = "QotMarketState_HkCas"] = 19;
        values[valuesById[20] = "QotMarketState_FutureNightWait"] = 20;
        values[valuesById[21] = "QotMarketState_FutureAfternoon"] = 21;
        values[valuesById[22] = "QotMarketState_FutureSwitchDate"] = 22;
        values[valuesById[23] = "QotMarketState_FutureOpen"] = 23;
        values[valuesById[24] = "QotMarketState_FutureBreak"] = 24;
        values[valuesById[25] = "QotMarketState_FutureBreakOver"] = 25;
        values[valuesById[26] = "QotMarketState_FutureClose"] = 26;
        return values;
    })();

    /**
     * TradeDateMarket enum.
     * @name Qot_Common.TradeDateMarket
     * @enum {string}
     * @property {number} TradeDateMarket_Unknown=0 TradeDateMarket_Unknown value
     * @property {number} TradeDateMarket_HK=1 TradeDateMarket_HK value
     * @property {number} TradeDateMarket_US=2 TradeDateMarket_US value
     * @property {number} TradeDateMarket_CN=3 TradeDateMarket_CN value
     * @property {number} TradeDateMarket_NT=4 TradeDateMarket_NT value
     * @property {number} TradeDateMarket_ST=5 TradeDateMarket_ST value
     */
    Qot_Common.TradeDateMarket = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TradeDateMarket_Unknown"] = 0;
        values[valuesById[1] = "TradeDateMarket_HK"] = 1;
        values[valuesById[2] = "TradeDateMarket_US"] = 2;
        values[valuesById[3] = "TradeDateMarket_CN"] = 3;
        values[valuesById[4] = "TradeDateMarket_NT"] = 4;
        values[valuesById[5] = "TradeDateMarket_ST"] = 5;
        return values;
    })();

    /**
     * TradeDateType enum.
     * @name Qot_Common.TradeDateType
     * @enum {string}
     * @property {number} TradeDateType_Whole=0 TradeDateType_Whole value
     * @property {number} TradeDateType_Morning=1 TradeDateType_Morning value
     * @property {number} TradeDateType_Afternoon=2 TradeDateType_Afternoon value
     */
    Qot_Common.TradeDateType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TradeDateType_Whole"] = 0;
        values[valuesById[1] = "TradeDateType_Morning"] = 1;
        values[valuesById[2] = "TradeDateType_Afternoon"] = 2;
        return values;
    })();

    /**
     * RehabType enum.
     * @name Qot_Common.RehabType
     * @enum {string}
     * @property {number} RehabType_None=0 RehabType_None value
     * @property {number} RehabType_Forward=1 RehabType_Forward value
     * @property {number} RehabType_Backward=2 RehabType_Backward value
     */
    Qot_Common.RehabType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RehabType_None"] = 0;
        values[valuesById[1] = "RehabType_Forward"] = 1;
        values[valuesById[2] = "RehabType_Backward"] = 2;
        return values;
    })();

    /**
     * KLType enum.
     * @name Qot_Common.KLType
     * @enum {string}
     * @property {number} KLType_Unknown=0 KLType_Unknown value
     * @property {number} KLType_1Min=1 KLType_1Min value
     * @property {number} KLType_Day=2 KLType_Day value
     * @property {number} KLType_Week=3 KLType_Week value
     * @property {number} KLType_Month=4 KLType_Month value
     * @property {number} KLType_Year=5 KLType_Year value
     * @property {number} KLType_5Min=6 KLType_5Min value
     * @property {number} KLType_15Min=7 KLType_15Min value
     * @property {number} KLType_30Min=8 KLType_30Min value
     * @property {number} KLType_60Min=9 KLType_60Min value
     * @property {number} KLType_3Min=10 KLType_3Min value
     * @property {number} KLType_Quarter=11 KLType_Quarter value
     */
    Qot_Common.KLType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "KLType_Unknown"] = 0;
        values[valuesById[1] = "KLType_1Min"] = 1;
        values[valuesById[2] = "KLType_Day"] = 2;
        values[valuesById[3] = "KLType_Week"] = 3;
        values[valuesById[4] = "KLType_Month"] = 4;
        values[valuesById[5] = "KLType_Year"] = 5;
        values[valuesById[6] = "KLType_5Min"] = 6;
        values[valuesById[7] = "KLType_15Min"] = 7;
        values[valuesById[8] = "KLType_30Min"] = 8;
        values[valuesById[9] = "KLType_60Min"] = 9;
        values[valuesById[10] = "KLType_3Min"] = 10;
        values[valuesById[11] = "KLType_Quarter"] = 11;
        return values;
    })();

    /**
     * KLFields enum.
     * @name Qot_Common.KLFields
     * @enum {string}
     * @property {number} KLFields_None=0 KLFields_None value
     * @property {number} KLFields_High=1 KLFields_High value
     * @property {number} KLFields_Open=2 KLFields_Open value
     * @property {number} KLFields_Low=4 KLFields_Low value
     * @property {number} KLFields_Close=8 KLFields_Close value
     * @property {number} KLFields_LastClose=16 KLFields_LastClose value
     * @property {number} KLFields_Volume=32 KLFields_Volume value
     * @property {number} KLFields_Turnover=64 KLFields_Turnover value
     * @property {number} KLFields_TurnoverRate=128 KLFields_TurnoverRate value
     * @property {number} KLFields_PE=256 KLFields_PE value
     * @property {number} KLFields_ChangeRate=512 KLFields_ChangeRate value
     */
    Qot_Common.KLFields = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "KLFields_None"] = 0;
        values[valuesById[1] = "KLFields_High"] = 1;
        values[valuesById[2] = "KLFields_Open"] = 2;
        values[valuesById[4] = "KLFields_Low"] = 4;
        values[valuesById[8] = "KLFields_Close"] = 8;
        values[valuesById[16] = "KLFields_LastClose"] = 16;
        values[valuesById[32] = "KLFields_Volume"] = 32;
        values[valuesById[64] = "KLFields_Turnover"] = 64;
        values[valuesById[128] = "KLFields_TurnoverRate"] = 128;
        values[valuesById[256] = "KLFields_PE"] = 256;
        values[valuesById[512] = "KLFields_ChangeRate"] = 512;
        return values;
    })();

    /**
     * SubType enum.
     * @name Qot_Common.SubType
     * @enum {string}
     * @property {number} SubType_None=0 SubType_None value
     * @property {number} SubType_Basic=1 SubType_Basic value
     * @property {number} SubType_OrderBook=2 SubType_OrderBook value
     * @property {number} SubType_Ticker=4 SubType_Ticker value
     * @property {number} SubType_RT=5 SubType_RT value
     * @property {number} SubType_KL_Day=6 SubType_KL_Day value
     * @property {number} SubType_KL_5Min=7 SubType_KL_5Min value
     * @property {number} SubType_KL_15Min=8 SubType_KL_15Min value
     * @property {number} SubType_KL_30Min=9 SubType_KL_30Min value
     * @property {number} SubType_KL_60Min=10 SubType_KL_60Min value
     * @property {number} SubType_KL_1Min=11 SubType_KL_1Min value
     * @property {number} SubType_KL_Week=12 SubType_KL_Week value
     * @property {number} SubType_KL_Month=13 SubType_KL_Month value
     * @property {number} SubType_Broker=14 SubType_Broker value
     * @property {number} SubType_KL_Qurater=15 SubType_KL_Qurater value
     * @property {number} SubType_KL_Year=16 SubType_KL_Year value
     * @property {number} SubType_KL_3Min=17 SubType_KL_3Min value
     * @property {number} SubType_OrderDetail=18 SubType_OrderDetail value
     */
    Qot_Common.SubType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SubType_None"] = 0;
        values[valuesById[1] = "SubType_Basic"] = 1;
        values[valuesById[2] = "SubType_OrderBook"] = 2;
        values[valuesById[4] = "SubType_Ticker"] = 4;
        values[valuesById[5] = "SubType_RT"] = 5;
        values[valuesById[6] = "SubType_KL_Day"] = 6;
        values[valuesById[7] = "SubType_KL_5Min"] = 7;
        values[valuesById[8] = "SubType_KL_15Min"] = 8;
        values[valuesById[9] = "SubType_KL_30Min"] = 9;
        values[valuesById[10] = "SubType_KL_60Min"] = 10;
        values[valuesById[11] = "SubType_KL_1Min"] = 11;
        values[valuesById[12] = "SubType_KL_Week"] = 12;
        values[valuesById[13] = "SubType_KL_Month"] = 13;
        values[valuesById[14] = "SubType_Broker"] = 14;
        values[valuesById[15] = "SubType_KL_Qurater"] = 15;
        values[valuesById[16] = "SubType_KL_Year"] = 16;
        values[valuesById[17] = "SubType_KL_3Min"] = 17;
        values[valuesById[18] = "SubType_OrderDetail"] = 18;
        return values;
    })();

    /**
     * TickerDirection enum.
     * @name Qot_Common.TickerDirection
     * @enum {string}
     * @property {number} TickerDirection_Unknown=0 TickerDirection_Unknown value
     * @property {number} TickerDirection_Bid=1 TickerDirection_Bid value
     * @property {number} TickerDirection_Ask=2 TickerDirection_Ask value
     * @property {number} TickerDirection_Neutral=3 TickerDirection_Neutral value
     */
    Qot_Common.TickerDirection = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TickerDirection_Unknown"] = 0;
        values[valuesById[1] = "TickerDirection_Bid"] = 1;
        values[valuesById[2] = "TickerDirection_Ask"] = 2;
        values[valuesById[3] = "TickerDirection_Neutral"] = 3;
        return values;
    })();

    /**
     * TickerType enum.
     * @name Qot_Common.TickerType
     * @enum {string}
     * @property {number} TickerType_Unknown=0 TickerType_Unknown value
     * @property {number} TickerType_Automatch=1 TickerType_Automatch value
     * @property {number} TickerType_Late=2 TickerType_Late value
     * @property {number} TickerType_NoneAutomatch=3 TickerType_NoneAutomatch value
     * @property {number} TickerType_InterAutomatch=4 TickerType_InterAutomatch value
     * @property {number} TickerType_InterNoneAutomatch=5 TickerType_InterNoneAutomatch value
     * @property {number} TickerType_OddLot=6 TickerType_OddLot value
     * @property {number} TickerType_Auction=7 TickerType_Auction value
     * @property {number} TickerType_Bulk=8 TickerType_Bulk value
     * @property {number} TickerType_Crash=9 TickerType_Crash value
     * @property {number} TickerType_CrossMarket=10 TickerType_CrossMarket value
     * @property {number} TickerType_BulkSold=11 TickerType_BulkSold value
     * @property {number} TickerType_FreeOnBoard=12 TickerType_FreeOnBoard value
     * @property {number} TickerType_Rule127Or155=13 TickerType_Rule127Or155 value
     * @property {number} TickerType_Delay=14 TickerType_Delay value
     * @property {number} TickerType_MarketCenterClosePrice=15 TickerType_MarketCenterClosePrice value
     * @property {number} TickerType_NextDay=16 TickerType_NextDay value
     * @property {number} TickerType_MarketCenterOpening=17 TickerType_MarketCenterOpening value
     * @property {number} TickerType_PriorReferencePrice=18 TickerType_PriorReferencePrice value
     * @property {number} TickerType_MarketCenterOpenPrice=19 TickerType_MarketCenterOpenPrice value
     * @property {number} TickerType_Seller=20 TickerType_Seller value
     * @property {number} TickerType_T=21 TickerType_T value
     * @property {number} TickerType_ExtendedTradingHours=22 TickerType_ExtendedTradingHours value
     * @property {number} TickerType_Contingent=23 TickerType_Contingent value
     * @property {number} TickerType_AvgPrice=24 TickerType_AvgPrice value
     * @property {number} TickerType_OTCSold=25 TickerType_OTCSold value
     * @property {number} TickerType_OddLotCrossMarket=26 TickerType_OddLotCrossMarket value
     * @property {number} TickerType_DerivativelyPriced=27 TickerType_DerivativelyPriced value
     * @property {number} TickerType_ReOpeningPriced=28 TickerType_ReOpeningPriced value
     * @property {number} TickerType_ClosingPriced=29 TickerType_ClosingPriced value
     * @property {number} TickerType_ComprehensiveDelayPrice=30 TickerType_ComprehensiveDelayPrice value
     * @property {number} TickerType_Overseas=31 TickerType_Overseas value
     */
    Qot_Common.TickerType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TickerType_Unknown"] = 0;
        values[valuesById[1] = "TickerType_Automatch"] = 1;
        values[valuesById[2] = "TickerType_Late"] = 2;
        values[valuesById[3] = "TickerType_NoneAutomatch"] = 3;
        values[valuesById[4] = "TickerType_InterAutomatch"] = 4;
        values[valuesById[5] = "TickerType_InterNoneAutomatch"] = 5;
        values[valuesById[6] = "TickerType_OddLot"] = 6;
        values[valuesById[7] = "TickerType_Auction"] = 7;
        values[valuesById[8] = "TickerType_Bulk"] = 8;
        values[valuesById[9] = "TickerType_Crash"] = 9;
        values[valuesById[10] = "TickerType_CrossMarket"] = 10;
        values[valuesById[11] = "TickerType_BulkSold"] = 11;
        values[valuesById[12] = "TickerType_FreeOnBoard"] = 12;
        values[valuesById[13] = "TickerType_Rule127Or155"] = 13;
        values[valuesById[14] = "TickerType_Delay"] = 14;
        values[valuesById[15] = "TickerType_MarketCenterClosePrice"] = 15;
        values[valuesById[16] = "TickerType_NextDay"] = 16;
        values[valuesById[17] = "TickerType_MarketCenterOpening"] = 17;
        values[valuesById[18] = "TickerType_PriorReferencePrice"] = 18;
        values[valuesById[19] = "TickerType_MarketCenterOpenPrice"] = 19;
        values[valuesById[20] = "TickerType_Seller"] = 20;
        values[valuesById[21] = "TickerType_T"] = 21;
        values[valuesById[22] = "TickerType_ExtendedTradingHours"] = 22;
        values[valuesById[23] = "TickerType_Contingent"] = 23;
        values[valuesById[24] = "TickerType_AvgPrice"] = 24;
        values[valuesById[25] = "TickerType_OTCSold"] = 25;
        values[valuesById[26] = "TickerType_OddLotCrossMarket"] = 26;
        values[valuesById[27] = "TickerType_DerivativelyPriced"] = 27;
        values[valuesById[28] = "TickerType_ReOpeningPriced"] = 28;
        values[valuesById[29] = "TickerType_ClosingPriced"] = 29;
        values[valuesById[30] = "TickerType_ComprehensiveDelayPrice"] = 30;
        values[valuesById[31] = "TickerType_Overseas"] = 31;
        return values;
    })();

    /**
     * DarkStatus enum.
     * @name Qot_Common.DarkStatus
     * @enum {string}
     * @property {number} DarkStatus_None=0 DarkStatus_None value
     * @property {number} DarkStatus_Trading=1 DarkStatus_Trading value
     * @property {number} DarkStatus_End=2 DarkStatus_End value
     */
    Qot_Common.DarkStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DarkStatus_None"] = 0;
        values[valuesById[1] = "DarkStatus_Trading"] = 1;
        values[valuesById[2] = "DarkStatus_End"] = 2;
        return values;
    })();

    /**
     * SecurityStatus enum.
     * @name Qot_Common.SecurityStatus
     * @enum {string}
     * @property {number} SecurityStatus_Unknown=0 SecurityStatus_Unknown value
     * @property {number} SecurityStatus_Normal=1 SecurityStatus_Normal value
     * @property {number} SecurityStatus_Listing=2 SecurityStatus_Listing value
     * @property {number} SecurityStatus_Purchasing=3 SecurityStatus_Purchasing value
     * @property {number} SecurityStatus_Subscribing=4 SecurityStatus_Subscribing value
     * @property {number} SecurityStatus_BeforeDrakTradeOpening=5 SecurityStatus_BeforeDrakTradeOpening value
     * @property {number} SecurityStatus_DrakTrading=6 SecurityStatus_DrakTrading value
     * @property {number} SecurityStatus_DrakTradeEnd=7 SecurityStatus_DrakTradeEnd value
     * @property {number} SecurityStatus_ToBeOpen=8 SecurityStatus_ToBeOpen value
     * @property {number} SecurityStatus_Suspended=9 SecurityStatus_Suspended value
     * @property {number} SecurityStatus_Called=10 SecurityStatus_Called value
     * @property {number} SecurityStatus_ExpiredLastTradingDate=11 SecurityStatus_ExpiredLastTradingDate value
     * @property {number} SecurityStatus_Expired=12 SecurityStatus_Expired value
     * @property {number} SecurityStatus_Delisted=13 SecurityStatus_Delisted value
     * @property {number} SecurityStatus_ChangeToTemporaryCode=14 SecurityStatus_ChangeToTemporaryCode value
     * @property {number} SecurityStatus_TemporaryCodeTradeEnd=15 SecurityStatus_TemporaryCodeTradeEnd value
     * @property {number} SecurityStatus_ChangedPlateTradeEnd=16 SecurityStatus_ChangedPlateTradeEnd value
     * @property {number} SecurityStatus_ChangedCodeTradeEnd=17 SecurityStatus_ChangedCodeTradeEnd value
     * @property {number} SecurityStatus_RecoverableCircuitBreaker=18 SecurityStatus_RecoverableCircuitBreaker value
     * @property {number} SecurityStatus_UnRecoverableCircuitBreaker=19 SecurityStatus_UnRecoverableCircuitBreaker value
     * @property {number} SecurityStatus_AfterCombination=20 SecurityStatus_AfterCombination value
     * @property {number} SecurityStatus_AfterTransation=21 SecurityStatus_AfterTransation value
     */
    Qot_Common.SecurityStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SecurityStatus_Unknown"] = 0;
        values[valuesById[1] = "SecurityStatus_Normal"] = 1;
        values[valuesById[2] = "SecurityStatus_Listing"] = 2;
        values[valuesById[3] = "SecurityStatus_Purchasing"] = 3;
        values[valuesById[4] = "SecurityStatus_Subscribing"] = 4;
        values[valuesById[5] = "SecurityStatus_BeforeDrakTradeOpening"] = 5;
        values[valuesById[6] = "SecurityStatus_DrakTrading"] = 6;
        values[valuesById[7] = "SecurityStatus_DrakTradeEnd"] = 7;
        values[valuesById[8] = "SecurityStatus_ToBeOpen"] = 8;
        values[valuesById[9] = "SecurityStatus_Suspended"] = 9;
        values[valuesById[10] = "SecurityStatus_Called"] = 10;
        values[valuesById[11] = "SecurityStatus_ExpiredLastTradingDate"] = 11;
        values[valuesById[12] = "SecurityStatus_Expired"] = 12;
        values[valuesById[13] = "SecurityStatus_Delisted"] = 13;
        values[valuesById[14] = "SecurityStatus_ChangeToTemporaryCode"] = 14;
        values[valuesById[15] = "SecurityStatus_TemporaryCodeTradeEnd"] = 15;
        values[valuesById[16] = "SecurityStatus_ChangedPlateTradeEnd"] = 16;
        values[valuesById[17] = "SecurityStatus_ChangedCodeTradeEnd"] = 17;
        values[valuesById[18] = "SecurityStatus_RecoverableCircuitBreaker"] = 18;
        values[valuesById[19] = "SecurityStatus_UnRecoverableCircuitBreaker"] = 19;
        values[valuesById[20] = "SecurityStatus_AfterCombination"] = 20;
        values[valuesById[21] = "SecurityStatus_AfterTransation"] = 21;
        return values;
    })();

    /**
     * HolderCategory enum.
     * @name Qot_Common.HolderCategory
     * @enum {string}
     * @property {number} HolderCategory_Unknow=0 HolderCategory_Unknow value
     * @property {number} HolderCategory_Agency=1 HolderCategory_Agency value
     * @property {number} HolderCategory_Fund=2 HolderCategory_Fund value
     * @property {number} HolderCategory_SeniorManager=3 HolderCategory_SeniorManager value
     */
    Qot_Common.HolderCategory = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "HolderCategory_Unknow"] = 0;
        values[valuesById[1] = "HolderCategory_Agency"] = 1;
        values[valuesById[2] = "HolderCategory_Fund"] = 2;
        values[valuesById[3] = "HolderCategory_SeniorManager"] = 3;
        return values;
    })();

    /**
     * PushDataType enum.
     * @name Qot_Common.PushDataType
     * @enum {string}
     * @property {number} PushDataType_Unknow=0 PushDataType_Unknow value
     * @property {number} PushDataType_Realtime=1 PushDataType_Realtime value
     * @property {number} PushDataType_ByDisConn=2 PushDataType_ByDisConn value
     * @property {number} PushDataType_Cache=3 PushDataType_Cache value
     */
    Qot_Common.PushDataType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PushDataType_Unknow"] = 0;
        values[valuesById[1] = "PushDataType_Realtime"] = 1;
        values[valuesById[2] = "PushDataType_ByDisConn"] = 2;
        values[valuesById[3] = "PushDataType_Cache"] = 3;
        return values;
    })();

    /**
     * SortField enum.
     * @name Qot_Common.SortField
     * @enum {string}
     * @property {number} SortField_Unknow=0 SortField_Unknow value
     * @property {number} SortField_Code=1 SortField_Code value
     * @property {number} SortField_CurPrice=2 SortField_CurPrice value
     * @property {number} SortField_PriceChangeVal=3 SortField_PriceChangeVal value
     * @property {number} SortField_ChangeRate=4 SortField_ChangeRate value
     * @property {number} SortField_Status=5 SortField_Status value
     * @property {number} SortField_BidPrice=6 SortField_BidPrice value
     * @property {number} SortField_AskPrice=7 SortField_AskPrice value
     * @property {number} SortField_BidVol=8 SortField_BidVol value
     * @property {number} SortField_AskVol=9 SortField_AskVol value
     * @property {number} SortField_Volume=10 SortField_Volume value
     * @property {number} SortField_Turnover=11 SortField_Turnover value
     * @property {number} SortField_Amplitude=30 SortField_Amplitude value
     * @property {number} SortField_Score=12 SortField_Score value
     * @property {number} SortField_Premium=13 SortField_Premium value
     * @property {number} SortField_EffectiveLeverage=14 SortField_EffectiveLeverage value
     * @property {number} SortField_Delta=15 SortField_Delta value
     * @property {number} SortField_ImpliedVolatility=16 SortField_ImpliedVolatility value
     * @property {number} SortField_Type=17 SortField_Type value
     * @property {number} SortField_StrikePrice=18 SortField_StrikePrice value
     * @property {number} SortField_BreakEvenPoint=19 SortField_BreakEvenPoint value
     * @property {number} SortField_MaturityTime=20 SortField_MaturityTime value
     * @property {number} SortField_ListTime=21 SortField_ListTime value
     * @property {number} SortField_LastTradeTime=22 SortField_LastTradeTime value
     * @property {number} SortField_Leverage=23 SortField_Leverage value
     * @property {number} SortField_InOutMoney=24 SortField_InOutMoney value
     * @property {number} SortField_RecoveryPrice=25 SortField_RecoveryPrice value
     * @property {number} SortField_ChangePrice=26 SortField_ChangePrice value
     * @property {number} SortField_Change=27 SortField_Change value
     * @property {number} SortField_StreetRate=28 SortField_StreetRate value
     * @property {number} SortField_StreetVol=29 SortField_StreetVol value
     * @property {number} SortField_WarrantName=31 SortField_WarrantName value
     * @property {number} SortField_Issuer=32 SortField_Issuer value
     * @property {number} SortField_LotSize=33 SortField_LotSize value
     * @property {number} SortField_IssueSize=34 SortField_IssueSize value
     * @property {number} SortField_UpperStrikePrice=45 SortField_UpperStrikePrice value
     * @property {number} SortField_LowerStrikePrice=46 SortField_LowerStrikePrice value
     * @property {number} SortField_InLinePriceStatus=47 SortField_InLinePriceStatus value
     * @property {number} SortField_PreCurPrice=35 SortField_PreCurPrice value
     * @property {number} SortField_AfterCurPrice=36 SortField_AfterCurPrice value
     * @property {number} SortField_PrePriceChangeVal=37 SortField_PrePriceChangeVal value
     * @property {number} SortField_AfterPriceChangeVal=38 SortField_AfterPriceChangeVal value
     * @property {number} SortField_PreChangeRate=39 SortField_PreChangeRate value
     * @property {number} SortField_AfterChangeRate=40 SortField_AfterChangeRate value
     * @property {number} SortField_PreAmplitude=41 SortField_PreAmplitude value
     * @property {number} SortField_AfterAmplitude=42 SortField_AfterAmplitude value
     * @property {number} SortField_PreTurnover=43 SortField_PreTurnover value
     * @property {number} SortField_AfterTurnover=44 SortField_AfterTurnover value
     * @property {number} SortField_LastSettlePrice=48 SortField_LastSettlePrice value
     * @property {number} SortField_Position=49 SortField_Position value
     * @property {number} SortField_PositionChange=50 SortField_PositionChange value
     */
    Qot_Common.SortField = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SortField_Unknow"] = 0;
        values[valuesById[1] = "SortField_Code"] = 1;
        values[valuesById[2] = "SortField_CurPrice"] = 2;
        values[valuesById[3] = "SortField_PriceChangeVal"] = 3;
        values[valuesById[4] = "SortField_ChangeRate"] = 4;
        values[valuesById[5] = "SortField_Status"] = 5;
        values[valuesById[6] = "SortField_BidPrice"] = 6;
        values[valuesById[7] = "SortField_AskPrice"] = 7;
        values[valuesById[8] = "SortField_BidVol"] = 8;
        values[valuesById[9] = "SortField_AskVol"] = 9;
        values[valuesById[10] = "SortField_Volume"] = 10;
        values[valuesById[11] = "SortField_Turnover"] = 11;
        values[valuesById[30] = "SortField_Amplitude"] = 30;
        values[valuesById[12] = "SortField_Score"] = 12;
        values[valuesById[13] = "SortField_Premium"] = 13;
        values[valuesById[14] = "SortField_EffectiveLeverage"] = 14;
        values[valuesById[15] = "SortField_Delta"] = 15;
        values[valuesById[16] = "SortField_ImpliedVolatility"] = 16;
        values[valuesById[17] = "SortField_Type"] = 17;
        values[valuesById[18] = "SortField_StrikePrice"] = 18;
        values[valuesById[19] = "SortField_BreakEvenPoint"] = 19;
        values[valuesById[20] = "SortField_MaturityTime"] = 20;
        values[valuesById[21] = "SortField_ListTime"] = 21;
        values[valuesById[22] = "SortField_LastTradeTime"] = 22;
        values[valuesById[23] = "SortField_Leverage"] = 23;
        values[valuesById[24] = "SortField_InOutMoney"] = 24;
        values[valuesById[25] = "SortField_RecoveryPrice"] = 25;
        values[valuesById[26] = "SortField_ChangePrice"] = 26;
        values[valuesById[27] = "SortField_Change"] = 27;
        values[valuesById[28] = "SortField_StreetRate"] = 28;
        values[valuesById[29] = "SortField_StreetVol"] = 29;
        values[valuesById[31] = "SortField_WarrantName"] = 31;
        values[valuesById[32] = "SortField_Issuer"] = 32;
        values[valuesById[33] = "SortField_LotSize"] = 33;
        values[valuesById[34] = "SortField_IssueSize"] = 34;
        values[valuesById[45] = "SortField_UpperStrikePrice"] = 45;
        values[valuesById[46] = "SortField_LowerStrikePrice"] = 46;
        values[valuesById[47] = "SortField_InLinePriceStatus"] = 47;
        values[valuesById[35] = "SortField_PreCurPrice"] = 35;
        values[valuesById[36] = "SortField_AfterCurPrice"] = 36;
        values[valuesById[37] = "SortField_PrePriceChangeVal"] = 37;
        values[valuesById[38] = "SortField_AfterPriceChangeVal"] = 38;
        values[valuesById[39] = "SortField_PreChangeRate"] = 39;
        values[valuesById[40] = "SortField_AfterChangeRate"] = 40;
        values[valuesById[41] = "SortField_PreAmplitude"] = 41;
        values[valuesById[42] = "SortField_AfterAmplitude"] = 42;
        values[valuesById[43] = "SortField_PreTurnover"] = 43;
        values[valuesById[44] = "SortField_AfterTurnover"] = 44;
        values[valuesById[48] = "SortField_LastSettlePrice"] = 48;
        values[valuesById[49] = "SortField_Position"] = 49;
        values[valuesById[50] = "SortField_PositionChange"] = 50;
        return values;
    })();

    /**
     * Issuer enum.
     * @name Qot_Common.Issuer
     * @enum {string}
     * @property {number} Issuer_Unknow=0 Issuer_Unknow value
     * @property {number} Issuer_SG=1 Issuer_SG value
     * @property {number} Issuer_BP=2 Issuer_BP value
     * @property {number} Issuer_CS=3 Issuer_CS value
     * @property {number} Issuer_CT=4 Issuer_CT value
     * @property {number} Issuer_EA=5 Issuer_EA value
     * @property {number} Issuer_GS=6 Issuer_GS value
     * @property {number} Issuer_HS=7 Issuer_HS value
     * @property {number} Issuer_JP=8 Issuer_JP value
     * @property {number} Issuer_MB=9 Issuer_MB value
     * @property {number} Issuer_SC=10 Issuer_SC value
     * @property {number} Issuer_UB=11 Issuer_UB value
     * @property {number} Issuer_BI=12 Issuer_BI value
     * @property {number} Issuer_DB=13 Issuer_DB value
     * @property {number} Issuer_DC=14 Issuer_DC value
     * @property {number} Issuer_ML=15 Issuer_ML value
     * @property {number} Issuer_NM=16 Issuer_NM value
     * @property {number} Issuer_RB=17 Issuer_RB value
     * @property {number} Issuer_RS=18 Issuer_RS value
     * @property {number} Issuer_BC=19 Issuer_BC value
     * @property {number} Issuer_HT=20 Issuer_HT value
     * @property {number} Issuer_VT=21 Issuer_VT value
     * @property {number} Issuer_KC=22 Issuer_KC value
     * @property {number} Issuer_MS=23 Issuer_MS value
     */
    Qot_Common.Issuer = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Issuer_Unknow"] = 0;
        values[valuesById[1] = "Issuer_SG"] = 1;
        values[valuesById[2] = "Issuer_BP"] = 2;
        values[valuesById[3] = "Issuer_CS"] = 3;
        values[valuesById[4] = "Issuer_CT"] = 4;
        values[valuesById[5] = "Issuer_EA"] = 5;
        values[valuesById[6] = "Issuer_GS"] = 6;
        values[valuesById[7] = "Issuer_HS"] = 7;
        values[valuesById[8] = "Issuer_JP"] = 8;
        values[valuesById[9] = "Issuer_MB"] = 9;
        values[valuesById[10] = "Issuer_SC"] = 10;
        values[valuesById[11] = "Issuer_UB"] = 11;
        values[valuesById[12] = "Issuer_BI"] = 12;
        values[valuesById[13] = "Issuer_DB"] = 13;
        values[valuesById[14] = "Issuer_DC"] = 14;
        values[valuesById[15] = "Issuer_ML"] = 15;
        values[valuesById[16] = "Issuer_NM"] = 16;
        values[valuesById[17] = "Issuer_RB"] = 17;
        values[valuesById[18] = "Issuer_RS"] = 18;
        values[valuesById[19] = "Issuer_BC"] = 19;
        values[valuesById[20] = "Issuer_HT"] = 20;
        values[valuesById[21] = "Issuer_VT"] = 21;
        values[valuesById[22] = "Issuer_KC"] = 22;
        values[valuesById[23] = "Issuer_MS"] = 23;
        return values;
    })();

    /**
     * IpoPeriod enum.
     * @name Qot_Common.IpoPeriod
     * @enum {string}
     * @property {number} IpoPeriod_Unknow=0 IpoPeriod_Unknow value
     * @property {number} IpoPeriod_Today=1 IpoPeriod_Today value
     * @property {number} IpoPeriod_Tomorrow=2 IpoPeriod_Tomorrow value
     * @property {number} IpoPeriod_Nextweek=3 IpoPeriod_Nextweek value
     * @property {number} IpoPeriod_Lastweek=4 IpoPeriod_Lastweek value
     * @property {number} IpoPeriod_Lastmonth=5 IpoPeriod_Lastmonth value
     */
    Qot_Common.IpoPeriod = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "IpoPeriod_Unknow"] = 0;
        values[valuesById[1] = "IpoPeriod_Today"] = 1;
        values[valuesById[2] = "IpoPeriod_Tomorrow"] = 2;
        values[valuesById[3] = "IpoPeriod_Nextweek"] = 3;
        values[valuesById[4] = "IpoPeriod_Lastweek"] = 4;
        values[valuesById[5] = "IpoPeriod_Lastmonth"] = 5;
        return values;
    })();

    /**
     * PriceType enum.
     * @name Qot_Common.PriceType
     * @enum {string}
     * @property {number} PriceType_Unknow=0 PriceType_Unknow value
     * @property {number} PriceType_Outside=1 PriceType_Outside value
     * @property {number} PriceType_WithIn=2 PriceType_WithIn value
     */
    Qot_Common.PriceType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PriceType_Unknow"] = 0;
        values[valuesById[1] = "PriceType_Outside"] = 1;
        values[valuesById[2] = "PriceType_WithIn"] = 2;
        return values;
    })();

    /**
     * WarrantStatus enum.
     * @name Qot_Common.WarrantStatus
     * @enum {string}
     * @property {number} WarrantStatus_Unknow=0 WarrantStatus_Unknow value
     * @property {number} WarrantStatus_Normal=1 WarrantStatus_Normal value
     * @property {number} WarrantStatus_Suspend=2 WarrantStatus_Suspend value
     * @property {number} WarrantStatus_StopTrade=3 WarrantStatus_StopTrade value
     * @property {number} WarrantStatus_PendingListing=4 WarrantStatus_PendingListing value
     */
    Qot_Common.WarrantStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "WarrantStatus_Unknow"] = 0;
        values[valuesById[1] = "WarrantStatus_Normal"] = 1;
        values[valuesById[2] = "WarrantStatus_Suspend"] = 2;
        values[valuesById[3] = "WarrantStatus_StopTrade"] = 3;
        values[valuesById[4] = "WarrantStatus_PendingListing"] = 4;
        return values;
    })();

    /**
     * CompanyAct enum.
     * @name Qot_Common.CompanyAct
     * @enum {string}
     * @property {number} CompanyAct_None=0 CompanyAct_None value
     * @property {number} CompanyAct_Split=1 CompanyAct_Split value
     * @property {number} CompanyAct_Join=2 CompanyAct_Join value
     * @property {number} CompanyAct_Bonus=4 CompanyAct_Bonus value
     * @property {number} CompanyAct_Transfer=8 CompanyAct_Transfer value
     * @property {number} CompanyAct_Allot=16 CompanyAct_Allot value
     * @property {number} CompanyAct_Add=32 CompanyAct_Add value
     * @property {number} CompanyAct_Dividend=64 CompanyAct_Dividend value
     * @property {number} CompanyAct_SPDividend=128 CompanyAct_SPDividend value
     */
    Qot_Common.CompanyAct = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "CompanyAct_None"] = 0;
        values[valuesById[1] = "CompanyAct_Split"] = 1;
        values[valuesById[2] = "CompanyAct_Join"] = 2;
        values[valuesById[4] = "CompanyAct_Bonus"] = 4;
        values[valuesById[8] = "CompanyAct_Transfer"] = 8;
        values[valuesById[16] = "CompanyAct_Allot"] = 16;
        values[valuesById[32] = "CompanyAct_Add"] = 32;
        values[valuesById[64] = "CompanyAct_Dividend"] = 64;
        values[valuesById[128] = "CompanyAct_SPDividend"] = 128;
        return values;
    })();

    /**
     * QotRight enum.
     * @name Qot_Common.QotRight
     * @enum {string}
     * @property {number} QotRight_Unknow=0 QotRight_Unknow value
     * @property {number} QotRight_Bmp=1 QotRight_Bmp value
     * @property {number} QotRight_Level1=2 QotRight_Level1 value
     * @property {number} QotRight_Level2=3 QotRight_Level2 value
     * @property {number} QotRight_SF=4 QotRight_SF value
     * @property {number} QotRight_No=5 QotRight_No value
     */
    Qot_Common.QotRight = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "QotRight_Unknow"] = 0;
        values[valuesById[1] = "QotRight_Bmp"] = 1;
        values[valuesById[2] = "QotRight_Level1"] = 2;
        values[valuesById[3] = "QotRight_Level2"] = 3;
        values[valuesById[4] = "QotRight_SF"] = 4;
        values[valuesById[5] = "QotRight_No"] = 5;
        return values;
    })();

    /**
     * PriceReminderType enum.
     * @name Qot_Common.PriceReminderType
     * @enum {string}
     * @property {number} PriceReminderType_Unknown=0 PriceReminderType_Unknown value
     * @property {number} PriceReminderType_PriceUp=1 PriceReminderType_PriceUp value
     * @property {number} PriceReminderType_PriceDown=2 PriceReminderType_PriceDown value
     * @property {number} PriceReminderType_ChangeRateUp=3 PriceReminderType_ChangeRateUp value
     * @property {number} PriceReminderType_ChangeRateDown=4 PriceReminderType_ChangeRateDown value
     * @property {number} PriceReminderType_5MinChangeRateUp=5 PriceReminderType_5MinChangeRateUp value
     * @property {number} PriceReminderType_5MinChangeRateDown=6 PriceReminderType_5MinChangeRateDown value
     * @property {number} PriceReminderType_VolumeUp=7 PriceReminderType_VolumeUp value
     * @property {number} PriceReminderType_TurnoverUp=8 PriceReminderType_TurnoverUp value
     * @property {number} PriceReminderType_TurnoverRateUp=9 PriceReminderType_TurnoverRateUp value
     * @property {number} PriceReminderType_BidPriceUp=10 PriceReminderType_BidPriceUp value
     * @property {number} PriceReminderType_AskPriceDown=11 PriceReminderType_AskPriceDown value
     * @property {number} PriceReminderType_BidVolUp=12 PriceReminderType_BidVolUp value
     * @property {number} PriceReminderType_AskVolUp=13 PriceReminderType_AskVolUp value
     */
    Qot_Common.PriceReminderType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PriceReminderType_Unknown"] = 0;
        values[valuesById[1] = "PriceReminderType_PriceUp"] = 1;
        values[valuesById[2] = "PriceReminderType_PriceDown"] = 2;
        values[valuesById[3] = "PriceReminderType_ChangeRateUp"] = 3;
        values[valuesById[4] = "PriceReminderType_ChangeRateDown"] = 4;
        values[valuesById[5] = "PriceReminderType_5MinChangeRateUp"] = 5;
        values[valuesById[6] = "PriceReminderType_5MinChangeRateDown"] = 6;
        values[valuesById[7] = "PriceReminderType_VolumeUp"] = 7;
        values[valuesById[8] = "PriceReminderType_TurnoverUp"] = 8;
        values[valuesById[9] = "PriceReminderType_TurnoverRateUp"] = 9;
        values[valuesById[10] = "PriceReminderType_BidPriceUp"] = 10;
        values[valuesById[11] = "PriceReminderType_AskPriceDown"] = 11;
        values[valuesById[12] = "PriceReminderType_BidVolUp"] = 12;
        values[valuesById[13] = "PriceReminderType_AskVolUp"] = 13;
        return values;
    })();

    /**
     * PriceReminderFreq enum.
     * @name Qot_Common.PriceReminderFreq
     * @enum {string}
     * @property {number} PriceReminderFreq_Unknown=0 PriceReminderFreq_Unknown value
     * @property {number} PriceReminderFreq_Always=1 PriceReminderFreq_Always value
     * @property {number} PriceReminderFreq_OnceADay=2 PriceReminderFreq_OnceADay value
     * @property {number} PriceReminderFreq_OnlyOnce=3 PriceReminderFreq_OnlyOnce value
     */
    Qot_Common.PriceReminderFreq = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PriceReminderFreq_Unknown"] = 0;
        values[valuesById[1] = "PriceReminderFreq_Always"] = 1;
        values[valuesById[2] = "PriceReminderFreq_OnceADay"] = 2;
        values[valuesById[3] = "PriceReminderFreq_OnlyOnce"] = 3;
        return values;
    })();

    Qot_Common.Security = (function() {

        /**
         * Properties of a Security.
         * @memberof Qot_Common
         * @interface ISecurity
         * @property {number} market Security market
         * @property {string} code Security code
         */

        /**
         * Constructs a new Security.
         * @memberof Qot_Common
         * @classdesc Represents a Security.
         * @implements ISecurity
         * @constructor
         * @param {Qot_Common.ISecurity=} [properties] Properties to set
         */
        function Security(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Security market.
         * @member {number} market
         * @memberof Qot_Common.Security
         * @instance
         */
        Security.prototype.market = 0;

        /**
         * Security code.
         * @member {string} code
         * @memberof Qot_Common.Security
         * @instance
         */
        Security.prototype.code = "";

        /**
         * Creates a new Security instance using the specified properties.
         * @function create
         * @memberof Qot_Common.Security
         * @static
         * @param {Qot_Common.ISecurity=} [properties] Properties to set
         * @returns {Qot_Common.Security} Security instance
         */
        Security.create = function create(properties) {
            return new Security(properties);
        };

        /**
         * Encodes the specified Security message. Does not implicitly {@link Qot_Common.Security.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.Security
         * @static
         * @param {Qot_Common.ISecurity} message Security message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Security.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.market);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.code);
            return writer;
        };

        /**
         * Encodes the specified Security message, length delimited. Does not implicitly {@link Qot_Common.Security.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.Security
         * @static
         * @param {Qot_Common.ISecurity} message Security message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Security.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Security message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.Security
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.Security} Security
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Security.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.Security();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.market = reader.int32();
                    break;
                case 2:
                    message.code = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("market"))
                throw $util.ProtocolError("missing required 'market'", { instance: message });
            if (!message.hasOwnProperty("code"))
                throw $util.ProtocolError("missing required 'code'", { instance: message });
            return message;
        };

        /**
         * Decodes a Security message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.Security
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.Security} Security
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Security.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Security message.
         * @function verify
         * @memberof Qot_Common.Security
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Security.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.market))
                return "market: integer expected";
            if (!$util.isString(message.code))
                return "code: string expected";
            return null;
        };

        /**
         * Creates a Security message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.Security
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.Security} Security
         */
        Security.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.Security)
                return object;
            var message = new $root.Qot_Common.Security();
            if (object.market != null)
                message.market = object.market | 0;
            if (object.code != null)
                message.code = String(object.code);
            return message;
        };

        /**
         * Creates a plain object from a Security message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.Security
         * @static
         * @param {Qot_Common.Security} message Security
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Security.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.market = 0;
                object.code = "";
            }
            if (message.market != null && message.hasOwnProperty("market"))
                object.market = message.market;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            return object;
        };

        /**
         * Converts this Security to JSON.
         * @function toJSON
         * @memberof Qot_Common.Security
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Security.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Security;
    })();

    Qot_Common.KLine = (function() {

        /**
         * Properties of a KLine.
         * @memberof Qot_Common
         * @interface IKLine
         * @property {string} time KLine time
         * @property {boolean} isBlank KLine isBlank
         * @property {number|null} [highPrice] KLine highPrice
         * @property {number|null} [openPrice] KLine openPrice
         * @property {number|null} [lowPrice] KLine lowPrice
         * @property {number|null} [closePrice] KLine closePrice
         * @property {number|null} [lastClosePrice] KLine lastClosePrice
         * @property {number|Long|null} [volume] KLine volume
         * @property {number|null} [turnover] KLine turnover
         * @property {number|null} [turnoverRate] KLine turnoverRate
         * @property {number|null} [pe] KLine pe
         * @property {number|null} [changeRate] KLine changeRate
         * @property {number|null} [timestamp] KLine timestamp
         */

        /**
         * Constructs a new KLine.
         * @memberof Qot_Common
         * @classdesc Represents a KLine.
         * @implements IKLine
         * @constructor
         * @param {Qot_Common.IKLine=} [properties] Properties to set
         */
        function KLine(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KLine time.
         * @member {string} time
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.time = "";

        /**
         * KLine isBlank.
         * @member {boolean} isBlank
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.isBlank = false;

        /**
         * KLine highPrice.
         * @member {number} highPrice
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.highPrice = 0;

        /**
         * KLine openPrice.
         * @member {number} openPrice
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.openPrice = 0;

        /**
         * KLine lowPrice.
         * @member {number} lowPrice
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.lowPrice = 0;

        /**
         * KLine closePrice.
         * @member {number} closePrice
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.closePrice = 0;

        /**
         * KLine lastClosePrice.
         * @member {number} lastClosePrice
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.lastClosePrice = 0;

        /**
         * KLine volume.
         * @member {number|Long} volume
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.volume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * KLine turnover.
         * @member {number} turnover
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.turnover = 0;

        /**
         * KLine turnoverRate.
         * @member {number} turnoverRate
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.turnoverRate = 0;

        /**
         * KLine pe.
         * @member {number} pe
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.pe = 0;

        /**
         * KLine changeRate.
         * @member {number} changeRate
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.changeRate = 0;

        /**
         * KLine timestamp.
         * @member {number} timestamp
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.timestamp = 0;

        /**
         * Creates a new KLine instance using the specified properties.
         * @function create
         * @memberof Qot_Common.KLine
         * @static
         * @param {Qot_Common.IKLine=} [properties] Properties to set
         * @returns {Qot_Common.KLine} KLine instance
         */
        KLine.create = function create(properties) {
            return new KLine(properties);
        };

        /**
         * Encodes the specified KLine message. Does not implicitly {@link Qot_Common.KLine.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.KLine
         * @static
         * @param {Qot_Common.IKLine} message KLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KLine.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.time);
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isBlank);
            if (message.highPrice != null && message.hasOwnProperty("highPrice"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.highPrice);
            if (message.openPrice != null && message.hasOwnProperty("openPrice"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.openPrice);
            if (message.lowPrice != null && message.hasOwnProperty("lowPrice"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.lowPrice);
            if (message.closePrice != null && message.hasOwnProperty("closePrice"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.closePrice);
            if (message.lastClosePrice != null && message.hasOwnProperty("lastClosePrice"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.lastClosePrice);
            if (message.volume != null && message.hasOwnProperty("volume"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.volume);
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.turnover);
            if (message.turnoverRate != null && message.hasOwnProperty("turnoverRate"))
                writer.uint32(/* id 10, wireType 1 =*/81).double(message.turnoverRate);
            if (message.pe != null && message.hasOwnProperty("pe"))
                writer.uint32(/* id 11, wireType 1 =*/89).double(message.pe);
            if (message.changeRate != null && message.hasOwnProperty("changeRate"))
                writer.uint32(/* id 12, wireType 1 =*/97).double(message.changeRate);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 13, wireType 1 =*/105).double(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified KLine message, length delimited. Does not implicitly {@link Qot_Common.KLine.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.KLine
         * @static
         * @param {Qot_Common.IKLine} message KLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KLine.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KLine message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.KLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.KLine} KLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KLine.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.KLine();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.string();
                    break;
                case 2:
                    message.isBlank = reader.bool();
                    break;
                case 3:
                    message.highPrice = reader.double();
                    break;
                case 4:
                    message.openPrice = reader.double();
                    break;
                case 5:
                    message.lowPrice = reader.double();
                    break;
                case 6:
                    message.closePrice = reader.double();
                    break;
                case 7:
                    message.lastClosePrice = reader.double();
                    break;
                case 8:
                    message.volume = reader.int64();
                    break;
                case 9:
                    message.turnover = reader.double();
                    break;
                case 10:
                    message.turnoverRate = reader.double();
                    break;
                case 11:
                    message.pe = reader.double();
                    break;
                case 12:
                    message.changeRate = reader.double();
                    break;
                case 13:
                    message.timestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("time"))
                throw $util.ProtocolError("missing required 'time'", { instance: message });
            if (!message.hasOwnProperty("isBlank"))
                throw $util.ProtocolError("missing required 'isBlank'", { instance: message });
            return message;
        };

        /**
         * Decodes a KLine message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.KLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.KLine} KLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KLine.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KLine message.
         * @function verify
         * @memberof Qot_Common.KLine
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KLine.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.time))
                return "time: string expected";
            if (typeof message.isBlank !== "boolean")
                return "isBlank: boolean expected";
            if (message.highPrice != null && message.hasOwnProperty("highPrice"))
                if (typeof message.highPrice !== "number")
                    return "highPrice: number expected";
            if (message.openPrice != null && message.hasOwnProperty("openPrice"))
                if (typeof message.openPrice !== "number")
                    return "openPrice: number expected";
            if (message.lowPrice != null && message.hasOwnProperty("lowPrice"))
                if (typeof message.lowPrice !== "number")
                    return "lowPrice: number expected";
            if (message.closePrice != null && message.hasOwnProperty("closePrice"))
                if (typeof message.closePrice !== "number")
                    return "closePrice: number expected";
            if (message.lastClosePrice != null && message.hasOwnProperty("lastClosePrice"))
                if (typeof message.lastClosePrice !== "number")
                    return "lastClosePrice: number expected";
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (!$util.isInteger(message.volume) && !(message.volume && $util.isInteger(message.volume.low) && $util.isInteger(message.volume.high)))
                    return "volume: integer|Long expected";
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                if (typeof message.turnover !== "number")
                    return "turnover: number expected";
            if (message.turnoverRate != null && message.hasOwnProperty("turnoverRate"))
                if (typeof message.turnoverRate !== "number")
                    return "turnoverRate: number expected";
            if (message.pe != null && message.hasOwnProperty("pe"))
                if (typeof message.pe !== "number")
                    return "pe: number expected";
            if (message.changeRate != null && message.hasOwnProperty("changeRate"))
                if (typeof message.changeRate !== "number")
                    return "changeRate: number expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp !== "number")
                    return "timestamp: number expected";
            return null;
        };

        /**
         * Creates a KLine message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.KLine
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.KLine} KLine
         */
        KLine.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.KLine)
                return object;
            var message = new $root.Qot_Common.KLine();
            if (object.time != null)
                message.time = String(object.time);
            if (object.isBlank != null)
                message.isBlank = Boolean(object.isBlank);
            if (object.highPrice != null)
                message.highPrice = Number(object.highPrice);
            if (object.openPrice != null)
                message.openPrice = Number(object.openPrice);
            if (object.lowPrice != null)
                message.lowPrice = Number(object.lowPrice);
            if (object.closePrice != null)
                message.closePrice = Number(object.closePrice);
            if (object.lastClosePrice != null)
                message.lastClosePrice = Number(object.lastClosePrice);
            if (object.volume != null)
                if ($util.Long)
                    (message.volume = $util.Long.fromValue(object.volume)).unsigned = false;
                else if (typeof object.volume === "string")
                    message.volume = parseInt(object.volume, 10);
                else if (typeof object.volume === "number")
                    message.volume = object.volume;
                else if (typeof object.volume === "object")
                    message.volume = new $util.LongBits(object.volume.low >>> 0, object.volume.high >>> 0).toNumber();
            if (object.turnover != null)
                message.turnover = Number(object.turnover);
            if (object.turnoverRate != null)
                message.turnoverRate = Number(object.turnoverRate);
            if (object.pe != null)
                message.pe = Number(object.pe);
            if (object.changeRate != null)
                message.changeRate = Number(object.changeRate);
            if (object.timestamp != null)
                message.timestamp = Number(object.timestamp);
            return message;
        };

        /**
         * Creates a plain object from a KLine message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.KLine
         * @static
         * @param {Qot_Common.KLine} message KLine
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KLine.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.time = "";
                object.isBlank = false;
                object.highPrice = 0;
                object.openPrice = 0;
                object.lowPrice = 0;
                object.closePrice = 0;
                object.lastClosePrice = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.volume = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.volume = options.longs === String ? "0" : 0;
                object.turnover = 0;
                object.turnoverRate = 0;
                object.pe = 0;
                object.changeRate = 0;
                object.timestamp = 0;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.isBlank != null && message.hasOwnProperty("isBlank"))
                object.isBlank = message.isBlank;
            if (message.highPrice != null && message.hasOwnProperty("highPrice"))
                object.highPrice = options.json && !isFinite(message.highPrice) ? String(message.highPrice) : message.highPrice;
            if (message.openPrice != null && message.hasOwnProperty("openPrice"))
                object.openPrice = options.json && !isFinite(message.openPrice) ? String(message.openPrice) : message.openPrice;
            if (message.lowPrice != null && message.hasOwnProperty("lowPrice"))
                object.lowPrice = options.json && !isFinite(message.lowPrice) ? String(message.lowPrice) : message.lowPrice;
            if (message.closePrice != null && message.hasOwnProperty("closePrice"))
                object.closePrice = options.json && !isFinite(message.closePrice) ? String(message.closePrice) : message.closePrice;
            if (message.lastClosePrice != null && message.hasOwnProperty("lastClosePrice"))
                object.lastClosePrice = options.json && !isFinite(message.lastClosePrice) ? String(message.lastClosePrice) : message.lastClosePrice;
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (typeof message.volume === "number")
                    object.volume = options.longs === String ? String(message.volume) : message.volume;
                else
                    object.volume = options.longs === String ? $util.Long.prototype.toString.call(message.volume) : options.longs === Number ? new $util.LongBits(message.volume.low >>> 0, message.volume.high >>> 0).toNumber() : message.volume;
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                object.turnover = options.json && !isFinite(message.turnover) ? String(message.turnover) : message.turnover;
            if (message.turnoverRate != null && message.hasOwnProperty("turnoverRate"))
                object.turnoverRate = options.json && !isFinite(message.turnoverRate) ? String(message.turnoverRate) : message.turnoverRate;
            if (message.pe != null && message.hasOwnProperty("pe"))
                object.pe = options.json && !isFinite(message.pe) ? String(message.pe) : message.pe;
            if (message.changeRate != null && message.hasOwnProperty("changeRate"))
                object.changeRate = options.json && !isFinite(message.changeRate) ? String(message.changeRate) : message.changeRate;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            return object;
        };

        /**
         * Converts this KLine to JSON.
         * @function toJSON
         * @memberof Qot_Common.KLine
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KLine.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KLine;
    })();

    Qot_Common.OptionBasicQotExData = (function() {

        /**
         * Properties of an OptionBasicQotExData.
         * @memberof Qot_Common
         * @interface IOptionBasicQotExData
         * @property {number} strikePrice OptionBasicQotExData strikePrice
         * @property {number} contractSize OptionBasicQotExData contractSize
         * @property {number} openInterest OptionBasicQotExData openInterest
         * @property {number} impliedVolatility OptionBasicQotExData impliedVolatility
         * @property {number} premium OptionBasicQotExData premium
         * @property {number} delta OptionBasicQotExData delta
         * @property {number} gamma OptionBasicQotExData gamma
         * @property {number} vega OptionBasicQotExData vega
         * @property {number} theta OptionBasicQotExData theta
         * @property {number} rho OptionBasicQotExData rho
         * @property {number|null} [netOpenInterest] OptionBasicQotExData netOpenInterest
         * @property {number|null} [expiryDateDistance] OptionBasicQotExData expiryDateDistance
         * @property {number|null} [contractNominalValue] OptionBasicQotExData contractNominalValue
         * @property {number|null} [ownerLotMultiplier] OptionBasicQotExData ownerLotMultiplier
         * @property {number|null} [optionAreaType] OptionBasicQotExData optionAreaType
         * @property {number|null} [contractMultiplier] OptionBasicQotExData contractMultiplier
         */

        /**
         * Constructs a new OptionBasicQotExData.
         * @memberof Qot_Common
         * @classdesc Represents an OptionBasicQotExData.
         * @implements IOptionBasicQotExData
         * @constructor
         * @param {Qot_Common.IOptionBasicQotExData=} [properties] Properties to set
         */
        function OptionBasicQotExData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OptionBasicQotExData strikePrice.
         * @member {number} strikePrice
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.strikePrice = 0;

        /**
         * OptionBasicQotExData contractSize.
         * @member {number} contractSize
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.contractSize = 0;

        /**
         * OptionBasicQotExData openInterest.
         * @member {number} openInterest
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.openInterest = 0;

        /**
         * OptionBasicQotExData impliedVolatility.
         * @member {number} impliedVolatility
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.impliedVolatility = 0;

        /**
         * OptionBasicQotExData premium.
         * @member {number} premium
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.premium = 0;

        /**
         * OptionBasicQotExData delta.
         * @member {number} delta
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.delta = 0;

        /**
         * OptionBasicQotExData gamma.
         * @member {number} gamma
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.gamma = 0;

        /**
         * OptionBasicQotExData vega.
         * @member {number} vega
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.vega = 0;

        /**
         * OptionBasicQotExData theta.
         * @member {number} theta
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.theta = 0;

        /**
         * OptionBasicQotExData rho.
         * @member {number} rho
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.rho = 0;

        /**
         * OptionBasicQotExData netOpenInterest.
         * @member {number} netOpenInterest
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.netOpenInterest = 0;

        /**
         * OptionBasicQotExData expiryDateDistance.
         * @member {number} expiryDateDistance
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.expiryDateDistance = 0;

        /**
         * OptionBasicQotExData contractNominalValue.
         * @member {number} contractNominalValue
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.contractNominalValue = 0;

        /**
         * OptionBasicQotExData ownerLotMultiplier.
         * @member {number} ownerLotMultiplier
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.ownerLotMultiplier = 0;

        /**
         * OptionBasicQotExData optionAreaType.
         * @member {number} optionAreaType
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.optionAreaType = 0;

        /**
         * OptionBasicQotExData contractMultiplier.
         * @member {number} contractMultiplier
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.contractMultiplier = 0;

        /**
         * Creates a new OptionBasicQotExData instance using the specified properties.
         * @function create
         * @memberof Qot_Common.OptionBasicQotExData
         * @static
         * @param {Qot_Common.IOptionBasicQotExData=} [properties] Properties to set
         * @returns {Qot_Common.OptionBasicQotExData} OptionBasicQotExData instance
         */
        OptionBasicQotExData.create = function create(properties) {
            return new OptionBasicQotExData(properties);
        };

        /**
         * Encodes the specified OptionBasicQotExData message. Does not implicitly {@link Qot_Common.OptionBasicQotExData.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.OptionBasicQotExData
         * @static
         * @param {Qot_Common.IOptionBasicQotExData} message OptionBasicQotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionBasicQotExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.strikePrice);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.contractSize);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.openInterest);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.impliedVolatility);
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.premium);
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.delta);
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.gamma);
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.vega);
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.theta);
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.rho);
            if (message.netOpenInterest != null && message.hasOwnProperty("netOpenInterest"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.netOpenInterest);
            if (message.expiryDateDistance != null && message.hasOwnProperty("expiryDateDistance"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.expiryDateDistance);
            if (message.contractNominalValue != null && message.hasOwnProperty("contractNominalValue"))
                writer.uint32(/* id 13, wireType 1 =*/105).double(message.contractNominalValue);
            if (message.ownerLotMultiplier != null && message.hasOwnProperty("ownerLotMultiplier"))
                writer.uint32(/* id 14, wireType 1 =*/113).double(message.ownerLotMultiplier);
            if (message.optionAreaType != null && message.hasOwnProperty("optionAreaType"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.optionAreaType);
            if (message.contractMultiplier != null && message.hasOwnProperty("contractMultiplier"))
                writer.uint32(/* id 16, wireType 1 =*/129).double(message.contractMultiplier);
            return writer;
        };

        /**
         * Encodes the specified OptionBasicQotExData message, length delimited. Does not implicitly {@link Qot_Common.OptionBasicQotExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.OptionBasicQotExData
         * @static
         * @param {Qot_Common.IOptionBasicQotExData} message OptionBasicQotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionBasicQotExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OptionBasicQotExData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.OptionBasicQotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.OptionBasicQotExData} OptionBasicQotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionBasicQotExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.OptionBasicQotExData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.strikePrice = reader.double();
                    break;
                case 2:
                    message.contractSize = reader.int32();
                    break;
                case 3:
                    message.openInterest = reader.int32();
                    break;
                case 4:
                    message.impliedVolatility = reader.double();
                    break;
                case 5:
                    message.premium = reader.double();
                    break;
                case 6:
                    message.delta = reader.double();
                    break;
                case 7:
                    message.gamma = reader.double();
                    break;
                case 8:
                    message.vega = reader.double();
                    break;
                case 9:
                    message.theta = reader.double();
                    break;
                case 10:
                    message.rho = reader.double();
                    break;
                case 11:
                    message.netOpenInterest = reader.int32();
                    break;
                case 12:
                    message.expiryDateDistance = reader.int32();
                    break;
                case 13:
                    message.contractNominalValue = reader.double();
                    break;
                case 14:
                    message.ownerLotMultiplier = reader.double();
                    break;
                case 15:
                    message.optionAreaType = reader.int32();
                    break;
                case 16:
                    message.contractMultiplier = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("strikePrice"))
                throw $util.ProtocolError("missing required 'strikePrice'", { instance: message });
            if (!message.hasOwnProperty("contractSize"))
                throw $util.ProtocolError("missing required 'contractSize'", { instance: message });
            if (!message.hasOwnProperty("openInterest"))
                throw $util.ProtocolError("missing required 'openInterest'", { instance: message });
            if (!message.hasOwnProperty("impliedVolatility"))
                throw $util.ProtocolError("missing required 'impliedVolatility'", { instance: message });
            if (!message.hasOwnProperty("premium"))
                throw $util.ProtocolError("missing required 'premium'", { instance: message });
            if (!message.hasOwnProperty("delta"))
                throw $util.ProtocolError("missing required 'delta'", { instance: message });
            if (!message.hasOwnProperty("gamma"))
                throw $util.ProtocolError("missing required 'gamma'", { instance: message });
            if (!message.hasOwnProperty("vega"))
                throw $util.ProtocolError("missing required 'vega'", { instance: message });
            if (!message.hasOwnProperty("theta"))
                throw $util.ProtocolError("missing required 'theta'", { instance: message });
            if (!message.hasOwnProperty("rho"))
                throw $util.ProtocolError("missing required 'rho'", { instance: message });
            return message;
        };

        /**
         * Decodes an OptionBasicQotExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.OptionBasicQotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.OptionBasicQotExData} OptionBasicQotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionBasicQotExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OptionBasicQotExData message.
         * @function verify
         * @memberof Qot_Common.OptionBasicQotExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OptionBasicQotExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.strikePrice !== "number")
                return "strikePrice: number expected";
            if (!$util.isInteger(message.contractSize))
                return "contractSize: integer expected";
            if (!$util.isInteger(message.openInterest))
                return "openInterest: integer expected";
            if (typeof message.impliedVolatility !== "number")
                return "impliedVolatility: number expected";
            if (typeof message.premium !== "number")
                return "premium: number expected";
            if (typeof message.delta !== "number")
                return "delta: number expected";
            if (typeof message.gamma !== "number")
                return "gamma: number expected";
            if (typeof message.vega !== "number")
                return "vega: number expected";
            if (typeof message.theta !== "number")
                return "theta: number expected";
            if (typeof message.rho !== "number")
                return "rho: number expected";
            if (message.netOpenInterest != null && message.hasOwnProperty("netOpenInterest"))
                if (!$util.isInteger(message.netOpenInterest))
                    return "netOpenInterest: integer expected";
            if (message.expiryDateDistance != null && message.hasOwnProperty("expiryDateDistance"))
                if (!$util.isInteger(message.expiryDateDistance))
                    return "expiryDateDistance: integer expected";
            if (message.contractNominalValue != null && message.hasOwnProperty("contractNominalValue"))
                if (typeof message.contractNominalValue !== "number")
                    return "contractNominalValue: number expected";
            if (message.ownerLotMultiplier != null && message.hasOwnProperty("ownerLotMultiplier"))
                if (typeof message.ownerLotMultiplier !== "number")
                    return "ownerLotMultiplier: number expected";
            if (message.optionAreaType != null && message.hasOwnProperty("optionAreaType"))
                if (!$util.isInteger(message.optionAreaType))
                    return "optionAreaType: integer expected";
            if (message.contractMultiplier != null && message.hasOwnProperty("contractMultiplier"))
                if (typeof message.contractMultiplier !== "number")
                    return "contractMultiplier: number expected";
            return null;
        };

        /**
         * Creates an OptionBasicQotExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.OptionBasicQotExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.OptionBasicQotExData} OptionBasicQotExData
         */
        OptionBasicQotExData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.OptionBasicQotExData)
                return object;
            var message = new $root.Qot_Common.OptionBasicQotExData();
            if (object.strikePrice != null)
                message.strikePrice = Number(object.strikePrice);
            if (object.contractSize != null)
                message.contractSize = object.contractSize | 0;
            if (object.openInterest != null)
                message.openInterest = object.openInterest | 0;
            if (object.impliedVolatility != null)
                message.impliedVolatility = Number(object.impliedVolatility);
            if (object.premium != null)
                message.premium = Number(object.premium);
            if (object.delta != null)
                message.delta = Number(object.delta);
            if (object.gamma != null)
                message.gamma = Number(object.gamma);
            if (object.vega != null)
                message.vega = Number(object.vega);
            if (object.theta != null)
                message.theta = Number(object.theta);
            if (object.rho != null)
                message.rho = Number(object.rho);
            if (object.netOpenInterest != null)
                message.netOpenInterest = object.netOpenInterest | 0;
            if (object.expiryDateDistance != null)
                message.expiryDateDistance = object.expiryDateDistance | 0;
            if (object.contractNominalValue != null)
                message.contractNominalValue = Number(object.contractNominalValue);
            if (object.ownerLotMultiplier != null)
                message.ownerLotMultiplier = Number(object.ownerLotMultiplier);
            if (object.optionAreaType != null)
                message.optionAreaType = object.optionAreaType | 0;
            if (object.contractMultiplier != null)
                message.contractMultiplier = Number(object.contractMultiplier);
            return message;
        };

        /**
         * Creates a plain object from an OptionBasicQotExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.OptionBasicQotExData
         * @static
         * @param {Qot_Common.OptionBasicQotExData} message OptionBasicQotExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OptionBasicQotExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.strikePrice = 0;
                object.contractSize = 0;
                object.openInterest = 0;
                object.impliedVolatility = 0;
                object.premium = 0;
                object.delta = 0;
                object.gamma = 0;
                object.vega = 0;
                object.theta = 0;
                object.rho = 0;
                object.netOpenInterest = 0;
                object.expiryDateDistance = 0;
                object.contractNominalValue = 0;
                object.ownerLotMultiplier = 0;
                object.optionAreaType = 0;
                object.contractMultiplier = 0;
            }
            if (message.strikePrice != null && message.hasOwnProperty("strikePrice"))
                object.strikePrice = options.json && !isFinite(message.strikePrice) ? String(message.strikePrice) : message.strikePrice;
            if (message.contractSize != null && message.hasOwnProperty("contractSize"))
                object.contractSize = message.contractSize;
            if (message.openInterest != null && message.hasOwnProperty("openInterest"))
                object.openInterest = message.openInterest;
            if (message.impliedVolatility != null && message.hasOwnProperty("impliedVolatility"))
                object.impliedVolatility = options.json && !isFinite(message.impliedVolatility) ? String(message.impliedVolatility) : message.impliedVolatility;
            if (message.premium != null && message.hasOwnProperty("premium"))
                object.premium = options.json && !isFinite(message.premium) ? String(message.premium) : message.premium;
            if (message.delta != null && message.hasOwnProperty("delta"))
                object.delta = options.json && !isFinite(message.delta) ? String(message.delta) : message.delta;
            if (message.gamma != null && message.hasOwnProperty("gamma"))
                object.gamma = options.json && !isFinite(message.gamma) ? String(message.gamma) : message.gamma;
            if (message.vega != null && message.hasOwnProperty("vega"))
                object.vega = options.json && !isFinite(message.vega) ? String(message.vega) : message.vega;
            if (message.theta != null && message.hasOwnProperty("theta"))
                object.theta = options.json && !isFinite(message.theta) ? String(message.theta) : message.theta;
            if (message.rho != null && message.hasOwnProperty("rho"))
                object.rho = options.json && !isFinite(message.rho) ? String(message.rho) : message.rho;
            if (message.netOpenInterest != null && message.hasOwnProperty("netOpenInterest"))
                object.netOpenInterest = message.netOpenInterest;
            if (message.expiryDateDistance != null && message.hasOwnProperty("expiryDateDistance"))
                object.expiryDateDistance = message.expiryDateDistance;
            if (message.contractNominalValue != null && message.hasOwnProperty("contractNominalValue"))
                object.contractNominalValue = options.json && !isFinite(message.contractNominalValue) ? String(message.contractNominalValue) : message.contractNominalValue;
            if (message.ownerLotMultiplier != null && message.hasOwnProperty("ownerLotMultiplier"))
                object.ownerLotMultiplier = options.json && !isFinite(message.ownerLotMultiplier) ? String(message.ownerLotMultiplier) : message.ownerLotMultiplier;
            if (message.optionAreaType != null && message.hasOwnProperty("optionAreaType"))
                object.optionAreaType = message.optionAreaType;
            if (message.contractMultiplier != null && message.hasOwnProperty("contractMultiplier"))
                object.contractMultiplier = options.json && !isFinite(message.contractMultiplier) ? String(message.contractMultiplier) : message.contractMultiplier;
            return object;
        };

        /**
         * Converts this OptionBasicQotExData to JSON.
         * @function toJSON
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OptionBasicQotExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OptionBasicQotExData;
    })();

    Qot_Common.PreAfterMarketData = (function() {

        /**
         * Properties of a PreAfterMarketData.
         * @memberof Qot_Common
         * @interface IPreAfterMarketData
         * @property {number|null} [price] PreAfterMarketData price
         * @property {number|null} [highPrice] PreAfterMarketData highPrice
         * @property {number|null} [lowPrice] PreAfterMarketData lowPrice
         * @property {number|Long|null} [volume] PreAfterMarketData volume
         * @property {number|null} [turnover] PreAfterMarketData turnover
         * @property {number|null} [changeVal] PreAfterMarketData changeVal
         * @property {number|null} [changeRate] PreAfterMarketData changeRate
         * @property {number|null} [amplitude] PreAfterMarketData amplitude
         */

        /**
         * Constructs a new PreAfterMarketData.
         * @memberof Qot_Common
         * @classdesc Represents a PreAfterMarketData.
         * @implements IPreAfterMarketData
         * @constructor
         * @param {Qot_Common.IPreAfterMarketData=} [properties] Properties to set
         */
        function PreAfterMarketData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PreAfterMarketData price.
         * @member {number} price
         * @memberof Qot_Common.PreAfterMarketData
         * @instance
         */
        PreAfterMarketData.prototype.price = 0;

        /**
         * PreAfterMarketData highPrice.
         * @member {number} highPrice
         * @memberof Qot_Common.PreAfterMarketData
         * @instance
         */
        PreAfterMarketData.prototype.highPrice = 0;

        /**
         * PreAfterMarketData lowPrice.
         * @member {number} lowPrice
         * @memberof Qot_Common.PreAfterMarketData
         * @instance
         */
        PreAfterMarketData.prototype.lowPrice = 0;

        /**
         * PreAfterMarketData volume.
         * @member {number|Long} volume
         * @memberof Qot_Common.PreAfterMarketData
         * @instance
         */
        PreAfterMarketData.prototype.volume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PreAfterMarketData turnover.
         * @member {number} turnover
         * @memberof Qot_Common.PreAfterMarketData
         * @instance
         */
        PreAfterMarketData.prototype.turnover = 0;

        /**
         * PreAfterMarketData changeVal.
         * @member {number} changeVal
         * @memberof Qot_Common.PreAfterMarketData
         * @instance
         */
        PreAfterMarketData.prototype.changeVal = 0;

        /**
         * PreAfterMarketData changeRate.
         * @member {number} changeRate
         * @memberof Qot_Common.PreAfterMarketData
         * @instance
         */
        PreAfterMarketData.prototype.changeRate = 0;

        /**
         * PreAfterMarketData amplitude.
         * @member {number} amplitude
         * @memberof Qot_Common.PreAfterMarketData
         * @instance
         */
        PreAfterMarketData.prototype.amplitude = 0;

        /**
         * Creates a new PreAfterMarketData instance using the specified properties.
         * @function create
         * @memberof Qot_Common.PreAfterMarketData
         * @static
         * @param {Qot_Common.IPreAfterMarketData=} [properties] Properties to set
         * @returns {Qot_Common.PreAfterMarketData} PreAfterMarketData instance
         */
        PreAfterMarketData.create = function create(properties) {
            return new PreAfterMarketData(properties);
        };

        /**
         * Encodes the specified PreAfterMarketData message. Does not implicitly {@link Qot_Common.PreAfterMarketData.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.PreAfterMarketData
         * @static
         * @param {Qot_Common.IPreAfterMarketData} message PreAfterMarketData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreAfterMarketData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.price != null && message.hasOwnProperty("price"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.price);
            if (message.highPrice != null && message.hasOwnProperty("highPrice"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.highPrice);
            if (message.lowPrice != null && message.hasOwnProperty("lowPrice"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.lowPrice);
            if (message.volume != null && message.hasOwnProperty("volume"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.volume);
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.turnover);
            if (message.changeVal != null && message.hasOwnProperty("changeVal"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.changeVal);
            if (message.changeRate != null && message.hasOwnProperty("changeRate"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.changeRate);
            if (message.amplitude != null && message.hasOwnProperty("amplitude"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.amplitude);
            return writer;
        };

        /**
         * Encodes the specified PreAfterMarketData message, length delimited. Does not implicitly {@link Qot_Common.PreAfterMarketData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.PreAfterMarketData
         * @static
         * @param {Qot_Common.IPreAfterMarketData} message PreAfterMarketData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreAfterMarketData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PreAfterMarketData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.PreAfterMarketData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.PreAfterMarketData} PreAfterMarketData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreAfterMarketData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.PreAfterMarketData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.price = reader.double();
                    break;
                case 2:
                    message.highPrice = reader.double();
                    break;
                case 3:
                    message.lowPrice = reader.double();
                    break;
                case 4:
                    message.volume = reader.int64();
                    break;
                case 5:
                    message.turnover = reader.double();
                    break;
                case 6:
                    message.changeVal = reader.double();
                    break;
                case 7:
                    message.changeRate = reader.double();
                    break;
                case 8:
                    message.amplitude = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PreAfterMarketData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.PreAfterMarketData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.PreAfterMarketData} PreAfterMarketData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreAfterMarketData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PreAfterMarketData message.
         * @function verify
         * @memberof Qot_Common.PreAfterMarketData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PreAfterMarketData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.price != null && message.hasOwnProperty("price"))
                if (typeof message.price !== "number")
                    return "price: number expected";
            if (message.highPrice != null && message.hasOwnProperty("highPrice"))
                if (typeof message.highPrice !== "number")
                    return "highPrice: number expected";
            if (message.lowPrice != null && message.hasOwnProperty("lowPrice"))
                if (typeof message.lowPrice !== "number")
                    return "lowPrice: number expected";
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (!$util.isInteger(message.volume) && !(message.volume && $util.isInteger(message.volume.low) && $util.isInteger(message.volume.high)))
                    return "volume: integer|Long expected";
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                if (typeof message.turnover !== "number")
                    return "turnover: number expected";
            if (message.changeVal != null && message.hasOwnProperty("changeVal"))
                if (typeof message.changeVal !== "number")
                    return "changeVal: number expected";
            if (message.changeRate != null && message.hasOwnProperty("changeRate"))
                if (typeof message.changeRate !== "number")
                    return "changeRate: number expected";
            if (message.amplitude != null && message.hasOwnProperty("amplitude"))
                if (typeof message.amplitude !== "number")
                    return "amplitude: number expected";
            return null;
        };

        /**
         * Creates a PreAfterMarketData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.PreAfterMarketData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.PreAfterMarketData} PreAfterMarketData
         */
        PreAfterMarketData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.PreAfterMarketData)
                return object;
            var message = new $root.Qot_Common.PreAfterMarketData();
            if (object.price != null)
                message.price = Number(object.price);
            if (object.highPrice != null)
                message.highPrice = Number(object.highPrice);
            if (object.lowPrice != null)
                message.lowPrice = Number(object.lowPrice);
            if (object.volume != null)
                if ($util.Long)
                    (message.volume = $util.Long.fromValue(object.volume)).unsigned = false;
                else if (typeof object.volume === "string")
                    message.volume = parseInt(object.volume, 10);
                else if (typeof object.volume === "number")
                    message.volume = object.volume;
                else if (typeof object.volume === "object")
                    message.volume = new $util.LongBits(object.volume.low >>> 0, object.volume.high >>> 0).toNumber();
            if (object.turnover != null)
                message.turnover = Number(object.turnover);
            if (object.changeVal != null)
                message.changeVal = Number(object.changeVal);
            if (object.changeRate != null)
                message.changeRate = Number(object.changeRate);
            if (object.amplitude != null)
                message.amplitude = Number(object.amplitude);
            return message;
        };

        /**
         * Creates a plain object from a PreAfterMarketData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.PreAfterMarketData
         * @static
         * @param {Qot_Common.PreAfterMarketData} message PreAfterMarketData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PreAfterMarketData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.price = 0;
                object.highPrice = 0;
                object.lowPrice = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.volume = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.volume = options.longs === String ? "0" : 0;
                object.turnover = 0;
                object.changeVal = 0;
                object.changeRate = 0;
                object.amplitude = 0;
            }
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
            if (message.highPrice != null && message.hasOwnProperty("highPrice"))
                object.highPrice = options.json && !isFinite(message.highPrice) ? String(message.highPrice) : message.highPrice;
            if (message.lowPrice != null && message.hasOwnProperty("lowPrice"))
                object.lowPrice = options.json && !isFinite(message.lowPrice) ? String(message.lowPrice) : message.lowPrice;
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (typeof message.volume === "number")
                    object.volume = options.longs === String ? String(message.volume) : message.volume;
                else
                    object.volume = options.longs === String ? $util.Long.prototype.toString.call(message.volume) : options.longs === Number ? new $util.LongBits(message.volume.low >>> 0, message.volume.high >>> 0).toNumber() : message.volume;
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                object.turnover = options.json && !isFinite(message.turnover) ? String(message.turnover) : message.turnover;
            if (message.changeVal != null && message.hasOwnProperty("changeVal"))
                object.changeVal = options.json && !isFinite(message.changeVal) ? String(message.changeVal) : message.changeVal;
            if (message.changeRate != null && message.hasOwnProperty("changeRate"))
                object.changeRate = options.json && !isFinite(message.changeRate) ? String(message.changeRate) : message.changeRate;
            if (message.amplitude != null && message.hasOwnProperty("amplitude"))
                object.amplitude = options.json && !isFinite(message.amplitude) ? String(message.amplitude) : message.amplitude;
            return object;
        };

        /**
         * Converts this PreAfterMarketData to JSON.
         * @function toJSON
         * @memberof Qot_Common.PreAfterMarketData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PreAfterMarketData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PreAfterMarketData;
    })();

    Qot_Common.FutureBasicQotExData = (function() {

        /**
         * Properties of a FutureBasicQotExData.
         * @memberof Qot_Common
         * @interface IFutureBasicQotExData
         * @property {number} lastSettlePrice FutureBasicQotExData lastSettlePrice
         * @property {number} position FutureBasicQotExData position
         * @property {number} positionChange FutureBasicQotExData positionChange
         * @property {number|null} [expiryDateDistance] FutureBasicQotExData expiryDateDistance
         */

        /**
         * Constructs a new FutureBasicQotExData.
         * @memberof Qot_Common
         * @classdesc Represents a FutureBasicQotExData.
         * @implements IFutureBasicQotExData
         * @constructor
         * @param {Qot_Common.IFutureBasicQotExData=} [properties] Properties to set
         */
        function FutureBasicQotExData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FutureBasicQotExData lastSettlePrice.
         * @member {number} lastSettlePrice
         * @memberof Qot_Common.FutureBasicQotExData
         * @instance
         */
        FutureBasicQotExData.prototype.lastSettlePrice = 0;

        /**
         * FutureBasicQotExData position.
         * @member {number} position
         * @memberof Qot_Common.FutureBasicQotExData
         * @instance
         */
        FutureBasicQotExData.prototype.position = 0;

        /**
         * FutureBasicQotExData positionChange.
         * @member {number} positionChange
         * @memberof Qot_Common.FutureBasicQotExData
         * @instance
         */
        FutureBasicQotExData.prototype.positionChange = 0;

        /**
         * FutureBasicQotExData expiryDateDistance.
         * @member {number} expiryDateDistance
         * @memberof Qot_Common.FutureBasicQotExData
         * @instance
         */
        FutureBasicQotExData.prototype.expiryDateDistance = 0;

        /**
         * Creates a new FutureBasicQotExData instance using the specified properties.
         * @function create
         * @memberof Qot_Common.FutureBasicQotExData
         * @static
         * @param {Qot_Common.IFutureBasicQotExData=} [properties] Properties to set
         * @returns {Qot_Common.FutureBasicQotExData} FutureBasicQotExData instance
         */
        FutureBasicQotExData.create = function create(properties) {
            return new FutureBasicQotExData(properties);
        };

        /**
         * Encodes the specified FutureBasicQotExData message. Does not implicitly {@link Qot_Common.FutureBasicQotExData.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.FutureBasicQotExData
         * @static
         * @param {Qot_Common.IFutureBasicQotExData} message FutureBasicQotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FutureBasicQotExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.lastSettlePrice);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.position);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.positionChange);
            if (message.expiryDateDistance != null && message.hasOwnProperty("expiryDateDistance"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.expiryDateDistance);
            return writer;
        };

        /**
         * Encodes the specified FutureBasicQotExData message, length delimited. Does not implicitly {@link Qot_Common.FutureBasicQotExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.FutureBasicQotExData
         * @static
         * @param {Qot_Common.IFutureBasicQotExData} message FutureBasicQotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FutureBasicQotExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FutureBasicQotExData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.FutureBasicQotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.FutureBasicQotExData} FutureBasicQotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FutureBasicQotExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.FutureBasicQotExData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lastSettlePrice = reader.double();
                    break;
                case 2:
                    message.position = reader.int32();
                    break;
                case 3:
                    message.positionChange = reader.int32();
                    break;
                case 4:
                    message.expiryDateDistance = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("lastSettlePrice"))
                throw $util.ProtocolError("missing required 'lastSettlePrice'", { instance: message });
            if (!message.hasOwnProperty("position"))
                throw $util.ProtocolError("missing required 'position'", { instance: message });
            if (!message.hasOwnProperty("positionChange"))
                throw $util.ProtocolError("missing required 'positionChange'", { instance: message });
            return message;
        };

        /**
         * Decodes a FutureBasicQotExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.FutureBasicQotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.FutureBasicQotExData} FutureBasicQotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FutureBasicQotExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FutureBasicQotExData message.
         * @function verify
         * @memberof Qot_Common.FutureBasicQotExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FutureBasicQotExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.lastSettlePrice !== "number")
                return "lastSettlePrice: number expected";
            if (!$util.isInteger(message.position))
                return "position: integer expected";
            if (!$util.isInteger(message.positionChange))
                return "positionChange: integer expected";
            if (message.expiryDateDistance != null && message.hasOwnProperty("expiryDateDistance"))
                if (!$util.isInteger(message.expiryDateDistance))
                    return "expiryDateDistance: integer expected";
            return null;
        };

        /**
         * Creates a FutureBasicQotExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.FutureBasicQotExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.FutureBasicQotExData} FutureBasicQotExData
         */
        FutureBasicQotExData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.FutureBasicQotExData)
                return object;
            var message = new $root.Qot_Common.FutureBasicQotExData();
            if (object.lastSettlePrice != null)
                message.lastSettlePrice = Number(object.lastSettlePrice);
            if (object.position != null)
                message.position = object.position | 0;
            if (object.positionChange != null)
                message.positionChange = object.positionChange | 0;
            if (object.expiryDateDistance != null)
                message.expiryDateDistance = object.expiryDateDistance | 0;
            return message;
        };

        /**
         * Creates a plain object from a FutureBasicQotExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.FutureBasicQotExData
         * @static
         * @param {Qot_Common.FutureBasicQotExData} message FutureBasicQotExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FutureBasicQotExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.lastSettlePrice = 0;
                object.position = 0;
                object.positionChange = 0;
                object.expiryDateDistance = 0;
            }
            if (message.lastSettlePrice != null && message.hasOwnProperty("lastSettlePrice"))
                object.lastSettlePrice = options.json && !isFinite(message.lastSettlePrice) ? String(message.lastSettlePrice) : message.lastSettlePrice;
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = message.position;
            if (message.positionChange != null && message.hasOwnProperty("positionChange"))
                object.positionChange = message.positionChange;
            if (message.expiryDateDistance != null && message.hasOwnProperty("expiryDateDistance"))
                object.expiryDateDistance = message.expiryDateDistance;
            return object;
        };

        /**
         * Converts this FutureBasicQotExData to JSON.
         * @function toJSON
         * @memberof Qot_Common.FutureBasicQotExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FutureBasicQotExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FutureBasicQotExData;
    })();

    Qot_Common.WarrantBasicQotExData = (function() {

        /**
         * Properties of a WarrantBasicQotExData.
         * @memberof Qot_Common
         * @interface IWarrantBasicQotExData
         * @property {number|null} [delta] WarrantBasicQotExData delta
         * @property {number|null} [impliedVolatility] WarrantBasicQotExData impliedVolatility
         * @property {number} premium WarrantBasicQotExData premium
         */

        /**
         * Constructs a new WarrantBasicQotExData.
         * @memberof Qot_Common
         * @classdesc Represents a WarrantBasicQotExData.
         * @implements IWarrantBasicQotExData
         * @constructor
         * @param {Qot_Common.IWarrantBasicQotExData=} [properties] Properties to set
         */
        function WarrantBasicQotExData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WarrantBasicQotExData delta.
         * @member {number} delta
         * @memberof Qot_Common.WarrantBasicQotExData
         * @instance
         */
        WarrantBasicQotExData.prototype.delta = 0;

        /**
         * WarrantBasicQotExData impliedVolatility.
         * @member {number} impliedVolatility
         * @memberof Qot_Common.WarrantBasicQotExData
         * @instance
         */
        WarrantBasicQotExData.prototype.impliedVolatility = 0;

        /**
         * WarrantBasicQotExData premium.
         * @member {number} premium
         * @memberof Qot_Common.WarrantBasicQotExData
         * @instance
         */
        WarrantBasicQotExData.prototype.premium = 0;

        /**
         * Creates a new WarrantBasicQotExData instance using the specified properties.
         * @function create
         * @memberof Qot_Common.WarrantBasicQotExData
         * @static
         * @param {Qot_Common.IWarrantBasicQotExData=} [properties] Properties to set
         * @returns {Qot_Common.WarrantBasicQotExData} WarrantBasicQotExData instance
         */
        WarrantBasicQotExData.create = function create(properties) {
            return new WarrantBasicQotExData(properties);
        };

        /**
         * Encodes the specified WarrantBasicQotExData message. Does not implicitly {@link Qot_Common.WarrantBasicQotExData.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.WarrantBasicQotExData
         * @static
         * @param {Qot_Common.IWarrantBasicQotExData} message WarrantBasicQotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarrantBasicQotExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.delta != null && message.hasOwnProperty("delta"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.delta);
            if (message.impliedVolatility != null && message.hasOwnProperty("impliedVolatility"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.impliedVolatility);
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.premium);
            return writer;
        };

        /**
         * Encodes the specified WarrantBasicQotExData message, length delimited. Does not implicitly {@link Qot_Common.WarrantBasicQotExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.WarrantBasicQotExData
         * @static
         * @param {Qot_Common.IWarrantBasicQotExData} message WarrantBasicQotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarrantBasicQotExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WarrantBasicQotExData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.WarrantBasicQotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.WarrantBasicQotExData} WarrantBasicQotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarrantBasicQotExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.WarrantBasicQotExData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.delta = reader.double();
                    break;
                case 2:
                    message.impliedVolatility = reader.double();
                    break;
                case 3:
                    message.premium = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("premium"))
                throw $util.ProtocolError("missing required 'premium'", { instance: message });
            return message;
        };

        /**
         * Decodes a WarrantBasicQotExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.WarrantBasicQotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.WarrantBasicQotExData} WarrantBasicQotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarrantBasicQotExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WarrantBasicQotExData message.
         * @function verify
         * @memberof Qot_Common.WarrantBasicQotExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WarrantBasicQotExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.delta != null && message.hasOwnProperty("delta"))
                if (typeof message.delta !== "number")
                    return "delta: number expected";
            if (message.impliedVolatility != null && message.hasOwnProperty("impliedVolatility"))
                if (typeof message.impliedVolatility !== "number")
                    return "impliedVolatility: number expected";
            if (typeof message.premium !== "number")
                return "premium: number expected";
            return null;
        };

        /**
         * Creates a WarrantBasicQotExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.WarrantBasicQotExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.WarrantBasicQotExData} WarrantBasicQotExData
         */
        WarrantBasicQotExData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.WarrantBasicQotExData)
                return object;
            var message = new $root.Qot_Common.WarrantBasicQotExData();
            if (object.delta != null)
                message.delta = Number(object.delta);
            if (object.impliedVolatility != null)
                message.impliedVolatility = Number(object.impliedVolatility);
            if (object.premium != null)
                message.premium = Number(object.premium);
            return message;
        };

        /**
         * Creates a plain object from a WarrantBasicQotExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.WarrantBasicQotExData
         * @static
         * @param {Qot_Common.WarrantBasicQotExData} message WarrantBasicQotExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WarrantBasicQotExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.delta = 0;
                object.impliedVolatility = 0;
                object.premium = 0;
            }
            if (message.delta != null && message.hasOwnProperty("delta"))
                object.delta = options.json && !isFinite(message.delta) ? String(message.delta) : message.delta;
            if (message.impliedVolatility != null && message.hasOwnProperty("impliedVolatility"))
                object.impliedVolatility = options.json && !isFinite(message.impliedVolatility) ? String(message.impliedVolatility) : message.impliedVolatility;
            if (message.premium != null && message.hasOwnProperty("premium"))
                object.premium = options.json && !isFinite(message.premium) ? String(message.premium) : message.premium;
            return object;
        };

        /**
         * Converts this WarrantBasicQotExData to JSON.
         * @function toJSON
         * @memberof Qot_Common.WarrantBasicQotExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WarrantBasicQotExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WarrantBasicQotExData;
    })();

    Qot_Common.BasicQot = (function() {

        /**
         * Properties of a BasicQot.
         * @memberof Qot_Common
         * @interface IBasicQot
         * @property {Qot_Common.ISecurity} security BasicQot security
         * @property {boolean} isSuspended BasicQot isSuspended
         * @property {string} listTime BasicQot listTime
         * @property {number} priceSpread BasicQot priceSpread
         * @property {string} updateTime BasicQot updateTime
         * @property {number} highPrice BasicQot highPrice
         * @property {number} openPrice BasicQot openPrice
         * @property {number} lowPrice BasicQot lowPrice
         * @property {number} curPrice BasicQot curPrice
         * @property {number} lastClosePrice BasicQot lastClosePrice
         * @property {number|Long} volume BasicQot volume
         * @property {number} turnover BasicQot turnover
         * @property {number} turnoverRate BasicQot turnoverRate
         * @property {number} amplitude BasicQot amplitude
         * @property {number|null} [darkStatus] BasicQot darkStatus
         * @property {Qot_Common.IOptionBasicQotExData|null} [optionExData] BasicQot optionExData
         * @property {number|null} [listTimestamp] BasicQot listTimestamp
         * @property {number|null} [updateTimestamp] BasicQot updateTimestamp
         * @property {Qot_Common.IPreAfterMarketData|null} [preMarket] BasicQot preMarket
         * @property {Qot_Common.IPreAfterMarketData|null} [afterMarket] BasicQot afterMarket
         * @property {number|null} [secStatus] BasicQot secStatus
         * @property {Qot_Common.IFutureBasicQotExData|null} [futureExData] BasicQot futureExData
         * @property {Qot_Common.IWarrantBasicQotExData|null} [warrantExData] BasicQot warrantExData
         */

        /**
         * Constructs a new BasicQot.
         * @memberof Qot_Common
         * @classdesc Represents a BasicQot.
         * @implements IBasicQot
         * @constructor
         * @param {Qot_Common.IBasicQot=} [properties] Properties to set
         */
        function BasicQot(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BasicQot security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.security = null;

        /**
         * BasicQot isSuspended.
         * @member {boolean} isSuspended
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.isSuspended = false;

        /**
         * BasicQot listTime.
         * @member {string} listTime
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.listTime = "";

        /**
         * BasicQot priceSpread.
         * @member {number} priceSpread
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.priceSpread = 0;

        /**
         * BasicQot updateTime.
         * @member {string} updateTime
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.updateTime = "";

        /**
         * BasicQot highPrice.
         * @member {number} highPrice
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.highPrice = 0;

        /**
         * BasicQot openPrice.
         * @member {number} openPrice
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.openPrice = 0;

        /**
         * BasicQot lowPrice.
         * @member {number} lowPrice
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.lowPrice = 0;

        /**
         * BasicQot curPrice.
         * @member {number} curPrice
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.curPrice = 0;

        /**
         * BasicQot lastClosePrice.
         * @member {number} lastClosePrice
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.lastClosePrice = 0;

        /**
         * BasicQot volume.
         * @member {number|Long} volume
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.volume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BasicQot turnover.
         * @member {number} turnover
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.turnover = 0;

        /**
         * BasicQot turnoverRate.
         * @member {number} turnoverRate
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.turnoverRate = 0;

        /**
         * BasicQot amplitude.
         * @member {number} amplitude
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.amplitude = 0;

        /**
         * BasicQot darkStatus.
         * @member {number} darkStatus
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.darkStatus = 0;

        /**
         * BasicQot optionExData.
         * @member {Qot_Common.IOptionBasicQotExData|null|undefined} optionExData
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.optionExData = null;

        /**
         * BasicQot listTimestamp.
         * @member {number} listTimestamp
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.listTimestamp = 0;

        /**
         * BasicQot updateTimestamp.
         * @member {number} updateTimestamp
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.updateTimestamp = 0;

        /**
         * BasicQot preMarket.
         * @member {Qot_Common.IPreAfterMarketData|null|undefined} preMarket
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.preMarket = null;

        /**
         * BasicQot afterMarket.
         * @member {Qot_Common.IPreAfterMarketData|null|undefined} afterMarket
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.afterMarket = null;

        /**
         * BasicQot secStatus.
         * @member {number} secStatus
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.secStatus = 0;

        /**
         * BasicQot futureExData.
         * @member {Qot_Common.IFutureBasicQotExData|null|undefined} futureExData
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.futureExData = null;

        /**
         * BasicQot warrantExData.
         * @member {Qot_Common.IWarrantBasicQotExData|null|undefined} warrantExData
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.warrantExData = null;

        /**
         * Creates a new BasicQot instance using the specified properties.
         * @function create
         * @memberof Qot_Common.BasicQot
         * @static
         * @param {Qot_Common.IBasicQot=} [properties] Properties to set
         * @returns {Qot_Common.BasicQot} BasicQot instance
         */
        BasicQot.create = function create(properties) {
            return new BasicQot(properties);
        };

        /**
         * Encodes the specified BasicQot message. Does not implicitly {@link Qot_Common.BasicQot.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.BasicQot
         * @static
         * @param {Qot_Common.IBasicQot} message BasicQot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicQot.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isSuspended);
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.listTime);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.priceSpread);
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.updateTime);
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.highPrice);
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.openPrice);
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.lowPrice);
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.curPrice);
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.lastClosePrice);
            writer.uint32(/* id 11, wireType 0 =*/88).int64(message.volume);
            writer.uint32(/* id 12, wireType 1 =*/97).double(message.turnover);
            writer.uint32(/* id 13, wireType 1 =*/105).double(message.turnoverRate);
            writer.uint32(/* id 14, wireType 1 =*/113).double(message.amplitude);
            if (message.darkStatus != null && message.hasOwnProperty("darkStatus"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.darkStatus);
            if (message.optionExData != null && message.hasOwnProperty("optionExData"))
                $root.Qot_Common.OptionBasicQotExData.encode(message.optionExData, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                writer.uint32(/* id 17, wireType 1 =*/137).double(message.listTimestamp);
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                writer.uint32(/* id 18, wireType 1 =*/145).double(message.updateTimestamp);
            if (message.preMarket != null && message.hasOwnProperty("preMarket"))
                $root.Qot_Common.PreAfterMarketData.encode(message.preMarket, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.afterMarket != null && message.hasOwnProperty("afterMarket"))
                $root.Qot_Common.PreAfterMarketData.encode(message.afterMarket, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            if (message.secStatus != null && message.hasOwnProperty("secStatus"))
                writer.uint32(/* id 21, wireType 0 =*/168).int32(message.secStatus);
            if (message.futureExData != null && message.hasOwnProperty("futureExData"))
                $root.Qot_Common.FutureBasicQotExData.encode(message.futureExData, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.warrantExData != null && message.hasOwnProperty("warrantExData"))
                $root.Qot_Common.WarrantBasicQotExData.encode(message.warrantExData, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BasicQot message, length delimited. Does not implicitly {@link Qot_Common.BasicQot.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.BasicQot
         * @static
         * @param {Qot_Common.IBasicQot} message BasicQot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicQot.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BasicQot message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.BasicQot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.BasicQot} BasicQot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicQot.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.BasicQot();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.isSuspended = reader.bool();
                    break;
                case 3:
                    message.listTime = reader.string();
                    break;
                case 4:
                    message.priceSpread = reader.double();
                    break;
                case 5:
                    message.updateTime = reader.string();
                    break;
                case 6:
                    message.highPrice = reader.double();
                    break;
                case 7:
                    message.openPrice = reader.double();
                    break;
                case 8:
                    message.lowPrice = reader.double();
                    break;
                case 9:
                    message.curPrice = reader.double();
                    break;
                case 10:
                    message.lastClosePrice = reader.double();
                    break;
                case 11:
                    message.volume = reader.int64();
                    break;
                case 12:
                    message.turnover = reader.double();
                    break;
                case 13:
                    message.turnoverRate = reader.double();
                    break;
                case 14:
                    message.amplitude = reader.double();
                    break;
                case 15:
                    message.darkStatus = reader.int32();
                    break;
                case 16:
                    message.optionExData = $root.Qot_Common.OptionBasicQotExData.decode(reader, reader.uint32());
                    break;
                case 17:
                    message.listTimestamp = reader.double();
                    break;
                case 18:
                    message.updateTimestamp = reader.double();
                    break;
                case 19:
                    message.preMarket = $root.Qot_Common.PreAfterMarketData.decode(reader, reader.uint32());
                    break;
                case 20:
                    message.afterMarket = $root.Qot_Common.PreAfterMarketData.decode(reader, reader.uint32());
                    break;
                case 21:
                    message.secStatus = reader.int32();
                    break;
                case 22:
                    message.futureExData = $root.Qot_Common.FutureBasicQotExData.decode(reader, reader.uint32());
                    break;
                case 23:
                    message.warrantExData = $root.Qot_Common.WarrantBasicQotExData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("isSuspended"))
                throw $util.ProtocolError("missing required 'isSuspended'", { instance: message });
            if (!message.hasOwnProperty("listTime"))
                throw $util.ProtocolError("missing required 'listTime'", { instance: message });
            if (!message.hasOwnProperty("priceSpread"))
                throw $util.ProtocolError("missing required 'priceSpread'", { instance: message });
            if (!message.hasOwnProperty("updateTime"))
                throw $util.ProtocolError("missing required 'updateTime'", { instance: message });
            if (!message.hasOwnProperty("highPrice"))
                throw $util.ProtocolError("missing required 'highPrice'", { instance: message });
            if (!message.hasOwnProperty("openPrice"))
                throw $util.ProtocolError("missing required 'openPrice'", { instance: message });
            if (!message.hasOwnProperty("lowPrice"))
                throw $util.ProtocolError("missing required 'lowPrice'", { instance: message });
            if (!message.hasOwnProperty("curPrice"))
                throw $util.ProtocolError("missing required 'curPrice'", { instance: message });
            if (!message.hasOwnProperty("lastClosePrice"))
                throw $util.ProtocolError("missing required 'lastClosePrice'", { instance: message });
            if (!message.hasOwnProperty("volume"))
                throw $util.ProtocolError("missing required 'volume'", { instance: message });
            if (!message.hasOwnProperty("turnover"))
                throw $util.ProtocolError("missing required 'turnover'", { instance: message });
            if (!message.hasOwnProperty("turnoverRate"))
                throw $util.ProtocolError("missing required 'turnoverRate'", { instance: message });
            if (!message.hasOwnProperty("amplitude"))
                throw $util.ProtocolError("missing required 'amplitude'", { instance: message });
            return message;
        };

        /**
         * Decodes a BasicQot message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.BasicQot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.BasicQot} BasicQot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicQot.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BasicQot message.
         * @function verify
         * @memberof Qot_Common.BasicQot
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BasicQot.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (typeof message.isSuspended !== "boolean")
                return "isSuspended: boolean expected";
            if (!$util.isString(message.listTime))
                return "listTime: string expected";
            if (typeof message.priceSpread !== "number")
                return "priceSpread: number expected";
            if (!$util.isString(message.updateTime))
                return "updateTime: string expected";
            if (typeof message.highPrice !== "number")
                return "highPrice: number expected";
            if (typeof message.openPrice !== "number")
                return "openPrice: number expected";
            if (typeof message.lowPrice !== "number")
                return "lowPrice: number expected";
            if (typeof message.curPrice !== "number")
                return "curPrice: number expected";
            if (typeof message.lastClosePrice !== "number")
                return "lastClosePrice: number expected";
            if (!$util.isInteger(message.volume) && !(message.volume && $util.isInteger(message.volume.low) && $util.isInteger(message.volume.high)))
                return "volume: integer|Long expected";
            if (typeof message.turnover !== "number")
                return "turnover: number expected";
            if (typeof message.turnoverRate !== "number")
                return "turnoverRate: number expected";
            if (typeof message.amplitude !== "number")
                return "amplitude: number expected";
            if (message.darkStatus != null && message.hasOwnProperty("darkStatus"))
                if (!$util.isInteger(message.darkStatus))
                    return "darkStatus: integer expected";
            if (message.optionExData != null && message.hasOwnProperty("optionExData")) {
                var error = $root.Qot_Common.OptionBasicQotExData.verify(message.optionExData);
                if (error)
                    return "optionExData." + error;
            }
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                if (typeof message.listTimestamp !== "number")
                    return "listTimestamp: number expected";
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                if (typeof message.updateTimestamp !== "number")
                    return "updateTimestamp: number expected";
            if (message.preMarket != null && message.hasOwnProperty("preMarket")) {
                var error = $root.Qot_Common.PreAfterMarketData.verify(message.preMarket);
                if (error)
                    return "preMarket." + error;
            }
            if (message.afterMarket != null && message.hasOwnProperty("afterMarket")) {
                var error = $root.Qot_Common.PreAfterMarketData.verify(message.afterMarket);
                if (error)
                    return "afterMarket." + error;
            }
            if (message.secStatus != null && message.hasOwnProperty("secStatus"))
                if (!$util.isInteger(message.secStatus))
                    return "secStatus: integer expected";
            if (message.futureExData != null && message.hasOwnProperty("futureExData")) {
                var error = $root.Qot_Common.FutureBasicQotExData.verify(message.futureExData);
                if (error)
                    return "futureExData." + error;
            }
            if (message.warrantExData != null && message.hasOwnProperty("warrantExData")) {
                var error = $root.Qot_Common.WarrantBasicQotExData.verify(message.warrantExData);
                if (error)
                    return "warrantExData." + error;
            }
            return null;
        };

        /**
         * Creates a BasicQot message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.BasicQot
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.BasicQot} BasicQot
         */
        BasicQot.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.BasicQot)
                return object;
            var message = new $root.Qot_Common.BasicQot();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_Common.BasicQot.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.isSuspended != null)
                message.isSuspended = Boolean(object.isSuspended);
            if (object.listTime != null)
                message.listTime = String(object.listTime);
            if (object.priceSpread != null)
                message.priceSpread = Number(object.priceSpread);
            if (object.updateTime != null)
                message.updateTime = String(object.updateTime);
            if (object.highPrice != null)
                message.highPrice = Number(object.highPrice);
            if (object.openPrice != null)
                message.openPrice = Number(object.openPrice);
            if (object.lowPrice != null)
                message.lowPrice = Number(object.lowPrice);
            if (object.curPrice != null)
                message.curPrice = Number(object.curPrice);
            if (object.lastClosePrice != null)
                message.lastClosePrice = Number(object.lastClosePrice);
            if (object.volume != null)
                if ($util.Long)
                    (message.volume = $util.Long.fromValue(object.volume)).unsigned = false;
                else if (typeof object.volume === "string")
                    message.volume = parseInt(object.volume, 10);
                else if (typeof object.volume === "number")
                    message.volume = object.volume;
                else if (typeof object.volume === "object")
                    message.volume = new $util.LongBits(object.volume.low >>> 0, object.volume.high >>> 0).toNumber();
            if (object.turnover != null)
                message.turnover = Number(object.turnover);
            if (object.turnoverRate != null)
                message.turnoverRate = Number(object.turnoverRate);
            if (object.amplitude != null)
                message.amplitude = Number(object.amplitude);
            if (object.darkStatus != null)
                message.darkStatus = object.darkStatus | 0;
            if (object.optionExData != null) {
                if (typeof object.optionExData !== "object")
                    throw TypeError(".Qot_Common.BasicQot.optionExData: object expected");
                message.optionExData = $root.Qot_Common.OptionBasicQotExData.fromObject(object.optionExData);
            }
            if (object.listTimestamp != null)
                message.listTimestamp = Number(object.listTimestamp);
            if (object.updateTimestamp != null)
                message.updateTimestamp = Number(object.updateTimestamp);
            if (object.preMarket != null) {
                if (typeof object.preMarket !== "object")
                    throw TypeError(".Qot_Common.BasicQot.preMarket: object expected");
                message.preMarket = $root.Qot_Common.PreAfterMarketData.fromObject(object.preMarket);
            }
            if (object.afterMarket != null) {
                if (typeof object.afterMarket !== "object")
                    throw TypeError(".Qot_Common.BasicQot.afterMarket: object expected");
                message.afterMarket = $root.Qot_Common.PreAfterMarketData.fromObject(object.afterMarket);
            }
            if (object.secStatus != null)
                message.secStatus = object.secStatus | 0;
            if (object.futureExData != null) {
                if (typeof object.futureExData !== "object")
                    throw TypeError(".Qot_Common.BasicQot.futureExData: object expected");
                message.futureExData = $root.Qot_Common.FutureBasicQotExData.fromObject(object.futureExData);
            }
            if (object.warrantExData != null) {
                if (typeof object.warrantExData !== "object")
                    throw TypeError(".Qot_Common.BasicQot.warrantExData: object expected");
                message.warrantExData = $root.Qot_Common.WarrantBasicQotExData.fromObject(object.warrantExData);
            }
            return message;
        };

        /**
         * Creates a plain object from a BasicQot message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.BasicQot
         * @static
         * @param {Qot_Common.BasicQot} message BasicQot
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BasicQot.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.security = null;
                object.isSuspended = false;
                object.listTime = "";
                object.priceSpread = 0;
                object.updateTime = "";
                object.highPrice = 0;
                object.openPrice = 0;
                object.lowPrice = 0;
                object.curPrice = 0;
                object.lastClosePrice = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.volume = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.volume = options.longs === String ? "0" : 0;
                object.turnover = 0;
                object.turnoverRate = 0;
                object.amplitude = 0;
                object.darkStatus = 0;
                object.optionExData = null;
                object.listTimestamp = 0;
                object.updateTimestamp = 0;
                object.preMarket = null;
                object.afterMarket = null;
                object.secStatus = 0;
                object.futureExData = null;
                object.warrantExData = null;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.isSuspended != null && message.hasOwnProperty("isSuspended"))
                object.isSuspended = message.isSuspended;
            if (message.listTime != null && message.hasOwnProperty("listTime"))
                object.listTime = message.listTime;
            if (message.priceSpread != null && message.hasOwnProperty("priceSpread"))
                object.priceSpread = options.json && !isFinite(message.priceSpread) ? String(message.priceSpread) : message.priceSpread;
            if (message.updateTime != null && message.hasOwnProperty("updateTime"))
                object.updateTime = message.updateTime;
            if (message.highPrice != null && message.hasOwnProperty("highPrice"))
                object.highPrice = options.json && !isFinite(message.highPrice) ? String(message.highPrice) : message.highPrice;
            if (message.openPrice != null && message.hasOwnProperty("openPrice"))
                object.openPrice = options.json && !isFinite(message.openPrice) ? String(message.openPrice) : message.openPrice;
            if (message.lowPrice != null && message.hasOwnProperty("lowPrice"))
                object.lowPrice = options.json && !isFinite(message.lowPrice) ? String(message.lowPrice) : message.lowPrice;
            if (message.curPrice != null && message.hasOwnProperty("curPrice"))
                object.curPrice = options.json && !isFinite(message.curPrice) ? String(message.curPrice) : message.curPrice;
            if (message.lastClosePrice != null && message.hasOwnProperty("lastClosePrice"))
                object.lastClosePrice = options.json && !isFinite(message.lastClosePrice) ? String(message.lastClosePrice) : message.lastClosePrice;
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (typeof message.volume === "number")
                    object.volume = options.longs === String ? String(message.volume) : message.volume;
                else
                    object.volume = options.longs === String ? $util.Long.prototype.toString.call(message.volume) : options.longs === Number ? new $util.LongBits(message.volume.low >>> 0, message.volume.high >>> 0).toNumber() : message.volume;
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                object.turnover = options.json && !isFinite(message.turnover) ? String(message.turnover) : message.turnover;
            if (message.turnoverRate != null && message.hasOwnProperty("turnoverRate"))
                object.turnoverRate = options.json && !isFinite(message.turnoverRate) ? String(message.turnoverRate) : message.turnoverRate;
            if (message.amplitude != null && message.hasOwnProperty("amplitude"))
                object.amplitude = options.json && !isFinite(message.amplitude) ? String(message.amplitude) : message.amplitude;
            if (message.darkStatus != null && message.hasOwnProperty("darkStatus"))
                object.darkStatus = message.darkStatus;
            if (message.optionExData != null && message.hasOwnProperty("optionExData"))
                object.optionExData = $root.Qot_Common.OptionBasicQotExData.toObject(message.optionExData, options);
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                object.listTimestamp = options.json && !isFinite(message.listTimestamp) ? String(message.listTimestamp) : message.listTimestamp;
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                object.updateTimestamp = options.json && !isFinite(message.updateTimestamp) ? String(message.updateTimestamp) : message.updateTimestamp;
            if (message.preMarket != null && message.hasOwnProperty("preMarket"))
                object.preMarket = $root.Qot_Common.PreAfterMarketData.toObject(message.preMarket, options);
            if (message.afterMarket != null && message.hasOwnProperty("afterMarket"))
                object.afterMarket = $root.Qot_Common.PreAfterMarketData.toObject(message.afterMarket, options);
            if (message.secStatus != null && message.hasOwnProperty("secStatus"))
                object.secStatus = message.secStatus;
            if (message.futureExData != null && message.hasOwnProperty("futureExData"))
                object.futureExData = $root.Qot_Common.FutureBasicQotExData.toObject(message.futureExData, options);
            if (message.warrantExData != null && message.hasOwnProperty("warrantExData"))
                object.warrantExData = $root.Qot_Common.WarrantBasicQotExData.toObject(message.warrantExData, options);
            return object;
        };

        /**
         * Converts this BasicQot to JSON.
         * @function toJSON
         * @memberof Qot_Common.BasicQot
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BasicQot.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BasicQot;
    })();

    Qot_Common.TimeShare = (function() {

        /**
         * Properties of a TimeShare.
         * @memberof Qot_Common
         * @interface ITimeShare
         * @property {string} time TimeShare time
         * @property {number} minute TimeShare minute
         * @property {boolean} isBlank TimeShare isBlank
         * @property {number|null} [price] TimeShare price
         * @property {number|null} [lastClosePrice] TimeShare lastClosePrice
         * @property {number|null} [avgPrice] TimeShare avgPrice
         * @property {number|Long|null} [volume] TimeShare volume
         * @property {number|null} [turnover] TimeShare turnover
         * @property {number|null} [timestamp] TimeShare timestamp
         */

        /**
         * Constructs a new TimeShare.
         * @memberof Qot_Common
         * @classdesc Represents a TimeShare.
         * @implements ITimeShare
         * @constructor
         * @param {Qot_Common.ITimeShare=} [properties] Properties to set
         */
        function TimeShare(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TimeShare time.
         * @member {string} time
         * @memberof Qot_Common.TimeShare
         * @instance
         */
        TimeShare.prototype.time = "";

        /**
         * TimeShare minute.
         * @member {number} minute
         * @memberof Qot_Common.TimeShare
         * @instance
         */
        TimeShare.prototype.minute = 0;

        /**
         * TimeShare isBlank.
         * @member {boolean} isBlank
         * @memberof Qot_Common.TimeShare
         * @instance
         */
        TimeShare.prototype.isBlank = false;

        /**
         * TimeShare price.
         * @member {number} price
         * @memberof Qot_Common.TimeShare
         * @instance
         */
        TimeShare.prototype.price = 0;

        /**
         * TimeShare lastClosePrice.
         * @member {number} lastClosePrice
         * @memberof Qot_Common.TimeShare
         * @instance
         */
        TimeShare.prototype.lastClosePrice = 0;

        /**
         * TimeShare avgPrice.
         * @member {number} avgPrice
         * @memberof Qot_Common.TimeShare
         * @instance
         */
        TimeShare.prototype.avgPrice = 0;

        /**
         * TimeShare volume.
         * @member {number|Long} volume
         * @memberof Qot_Common.TimeShare
         * @instance
         */
        TimeShare.prototype.volume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TimeShare turnover.
         * @member {number} turnover
         * @memberof Qot_Common.TimeShare
         * @instance
         */
        TimeShare.prototype.turnover = 0;

        /**
         * TimeShare timestamp.
         * @member {number} timestamp
         * @memberof Qot_Common.TimeShare
         * @instance
         */
        TimeShare.prototype.timestamp = 0;

        /**
         * Creates a new TimeShare instance using the specified properties.
         * @function create
         * @memberof Qot_Common.TimeShare
         * @static
         * @param {Qot_Common.ITimeShare=} [properties] Properties to set
         * @returns {Qot_Common.TimeShare} TimeShare instance
         */
        TimeShare.create = function create(properties) {
            return new TimeShare(properties);
        };

        /**
         * Encodes the specified TimeShare message. Does not implicitly {@link Qot_Common.TimeShare.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.TimeShare
         * @static
         * @param {Qot_Common.ITimeShare} message TimeShare message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TimeShare.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.time);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.minute);
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isBlank);
            if (message.price != null && message.hasOwnProperty("price"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.price);
            if (message.lastClosePrice != null && message.hasOwnProperty("lastClosePrice"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.lastClosePrice);
            if (message.avgPrice != null && message.hasOwnProperty("avgPrice"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.avgPrice);
            if (message.volume != null && message.hasOwnProperty("volume"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.volume);
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.turnover);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified TimeShare message, length delimited. Does not implicitly {@link Qot_Common.TimeShare.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.TimeShare
         * @static
         * @param {Qot_Common.ITimeShare} message TimeShare message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TimeShare.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TimeShare message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.TimeShare
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.TimeShare} TimeShare
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TimeShare.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.TimeShare();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.string();
                    break;
                case 2:
                    message.minute = reader.int32();
                    break;
                case 3:
                    message.isBlank = reader.bool();
                    break;
                case 4:
                    message.price = reader.double();
                    break;
                case 5:
                    message.lastClosePrice = reader.double();
                    break;
                case 6:
                    message.avgPrice = reader.double();
                    break;
                case 7:
                    message.volume = reader.int64();
                    break;
                case 8:
                    message.turnover = reader.double();
                    break;
                case 9:
                    message.timestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("time"))
                throw $util.ProtocolError("missing required 'time'", { instance: message });
            if (!message.hasOwnProperty("minute"))
                throw $util.ProtocolError("missing required 'minute'", { instance: message });
            if (!message.hasOwnProperty("isBlank"))
                throw $util.ProtocolError("missing required 'isBlank'", { instance: message });
            return message;
        };

        /**
         * Decodes a TimeShare message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.TimeShare
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.TimeShare} TimeShare
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TimeShare.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TimeShare message.
         * @function verify
         * @memberof Qot_Common.TimeShare
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TimeShare.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.time))
                return "time: string expected";
            if (!$util.isInteger(message.minute))
                return "minute: integer expected";
            if (typeof message.isBlank !== "boolean")
                return "isBlank: boolean expected";
            if (message.price != null && message.hasOwnProperty("price"))
                if (typeof message.price !== "number")
                    return "price: number expected";
            if (message.lastClosePrice != null && message.hasOwnProperty("lastClosePrice"))
                if (typeof message.lastClosePrice !== "number")
                    return "lastClosePrice: number expected";
            if (message.avgPrice != null && message.hasOwnProperty("avgPrice"))
                if (typeof message.avgPrice !== "number")
                    return "avgPrice: number expected";
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (!$util.isInteger(message.volume) && !(message.volume && $util.isInteger(message.volume.low) && $util.isInteger(message.volume.high)))
                    return "volume: integer|Long expected";
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                if (typeof message.turnover !== "number")
                    return "turnover: number expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp !== "number")
                    return "timestamp: number expected";
            return null;
        };

        /**
         * Creates a TimeShare message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.TimeShare
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.TimeShare} TimeShare
         */
        TimeShare.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.TimeShare)
                return object;
            var message = new $root.Qot_Common.TimeShare();
            if (object.time != null)
                message.time = String(object.time);
            if (object.minute != null)
                message.minute = object.minute | 0;
            if (object.isBlank != null)
                message.isBlank = Boolean(object.isBlank);
            if (object.price != null)
                message.price = Number(object.price);
            if (object.lastClosePrice != null)
                message.lastClosePrice = Number(object.lastClosePrice);
            if (object.avgPrice != null)
                message.avgPrice = Number(object.avgPrice);
            if (object.volume != null)
                if ($util.Long)
                    (message.volume = $util.Long.fromValue(object.volume)).unsigned = false;
                else if (typeof object.volume === "string")
                    message.volume = parseInt(object.volume, 10);
                else if (typeof object.volume === "number")
                    message.volume = object.volume;
                else if (typeof object.volume === "object")
                    message.volume = new $util.LongBits(object.volume.low >>> 0, object.volume.high >>> 0).toNumber();
            if (object.turnover != null)
                message.turnover = Number(object.turnover);
            if (object.timestamp != null)
                message.timestamp = Number(object.timestamp);
            return message;
        };

        /**
         * Creates a plain object from a TimeShare message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.TimeShare
         * @static
         * @param {Qot_Common.TimeShare} message TimeShare
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TimeShare.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.time = "";
                object.minute = 0;
                object.isBlank = false;
                object.price = 0;
                object.lastClosePrice = 0;
                object.avgPrice = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.volume = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.volume = options.longs === String ? "0" : 0;
                object.turnover = 0;
                object.timestamp = 0;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.minute != null && message.hasOwnProperty("minute"))
                object.minute = message.minute;
            if (message.isBlank != null && message.hasOwnProperty("isBlank"))
                object.isBlank = message.isBlank;
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
            if (message.lastClosePrice != null && message.hasOwnProperty("lastClosePrice"))
                object.lastClosePrice = options.json && !isFinite(message.lastClosePrice) ? String(message.lastClosePrice) : message.lastClosePrice;
            if (message.avgPrice != null && message.hasOwnProperty("avgPrice"))
                object.avgPrice = options.json && !isFinite(message.avgPrice) ? String(message.avgPrice) : message.avgPrice;
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (typeof message.volume === "number")
                    object.volume = options.longs === String ? String(message.volume) : message.volume;
                else
                    object.volume = options.longs === String ? $util.Long.prototype.toString.call(message.volume) : options.longs === Number ? new $util.LongBits(message.volume.low >>> 0, message.volume.high >>> 0).toNumber() : message.volume;
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                object.turnover = options.json && !isFinite(message.turnover) ? String(message.turnover) : message.turnover;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            return object;
        };

        /**
         * Converts this TimeShare to JSON.
         * @function toJSON
         * @memberof Qot_Common.TimeShare
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TimeShare.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TimeShare;
    })();

    Qot_Common.SecurityStaticBasic = (function() {

        /**
         * Properties of a SecurityStaticBasic.
         * @memberof Qot_Common
         * @interface ISecurityStaticBasic
         * @property {Qot_Common.ISecurity} security SecurityStaticBasic security
         * @property {number|Long} id SecurityStaticBasic id
         * @property {number} lotSize SecurityStaticBasic lotSize
         * @property {number} secType SecurityStaticBasic secType
         * @property {string} name SecurityStaticBasic name
         * @property {string} listTime SecurityStaticBasic listTime
         * @property {boolean|null} [delisting] SecurityStaticBasic delisting
         * @property {number|null} [listTimestamp] SecurityStaticBasic listTimestamp
         */

        /**
         * Constructs a new SecurityStaticBasic.
         * @memberof Qot_Common
         * @classdesc Represents a SecurityStaticBasic.
         * @implements ISecurityStaticBasic
         * @constructor
         * @param {Qot_Common.ISecurityStaticBasic=} [properties] Properties to set
         */
        function SecurityStaticBasic(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityStaticBasic security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_Common.SecurityStaticBasic
         * @instance
         */
        SecurityStaticBasic.prototype.security = null;

        /**
         * SecurityStaticBasic id.
         * @member {number|Long} id
         * @memberof Qot_Common.SecurityStaticBasic
         * @instance
         */
        SecurityStaticBasic.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SecurityStaticBasic lotSize.
         * @member {number} lotSize
         * @memberof Qot_Common.SecurityStaticBasic
         * @instance
         */
        SecurityStaticBasic.prototype.lotSize = 0;

        /**
         * SecurityStaticBasic secType.
         * @member {number} secType
         * @memberof Qot_Common.SecurityStaticBasic
         * @instance
         */
        SecurityStaticBasic.prototype.secType = 0;

        /**
         * SecurityStaticBasic name.
         * @member {string} name
         * @memberof Qot_Common.SecurityStaticBasic
         * @instance
         */
        SecurityStaticBasic.prototype.name = "";

        /**
         * SecurityStaticBasic listTime.
         * @member {string} listTime
         * @memberof Qot_Common.SecurityStaticBasic
         * @instance
         */
        SecurityStaticBasic.prototype.listTime = "";

        /**
         * SecurityStaticBasic delisting.
         * @member {boolean} delisting
         * @memberof Qot_Common.SecurityStaticBasic
         * @instance
         */
        SecurityStaticBasic.prototype.delisting = false;

        /**
         * SecurityStaticBasic listTimestamp.
         * @member {number} listTimestamp
         * @memberof Qot_Common.SecurityStaticBasic
         * @instance
         */
        SecurityStaticBasic.prototype.listTimestamp = 0;

        /**
         * Creates a new SecurityStaticBasic instance using the specified properties.
         * @function create
         * @memberof Qot_Common.SecurityStaticBasic
         * @static
         * @param {Qot_Common.ISecurityStaticBasic=} [properties] Properties to set
         * @returns {Qot_Common.SecurityStaticBasic} SecurityStaticBasic instance
         */
        SecurityStaticBasic.create = function create(properties) {
            return new SecurityStaticBasic(properties);
        };

        /**
         * Encodes the specified SecurityStaticBasic message. Does not implicitly {@link Qot_Common.SecurityStaticBasic.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.SecurityStaticBasic
         * @static
         * @param {Qot_Common.ISecurityStaticBasic} message SecurityStaticBasic message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityStaticBasic.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.id);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lotSize);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.secType);
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.name);
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.listTime);
            if (message.delisting != null && message.hasOwnProperty("delisting"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.delisting);
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.listTimestamp);
            return writer;
        };

        /**
         * Encodes the specified SecurityStaticBasic message, length delimited. Does not implicitly {@link Qot_Common.SecurityStaticBasic.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.SecurityStaticBasic
         * @static
         * @param {Qot_Common.ISecurityStaticBasic} message SecurityStaticBasic message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityStaticBasic.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityStaticBasic message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.SecurityStaticBasic
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.SecurityStaticBasic} SecurityStaticBasic
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityStaticBasic.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.SecurityStaticBasic();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.id = reader.int64();
                    break;
                case 3:
                    message.lotSize = reader.int32();
                    break;
                case 4:
                    message.secType = reader.int32();
                    break;
                case 5:
                    message.name = reader.string();
                    break;
                case 6:
                    message.listTime = reader.string();
                    break;
                case 7:
                    message.delisting = reader.bool();
                    break;
                case 8:
                    message.listTimestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("lotSize"))
                throw $util.ProtocolError("missing required 'lotSize'", { instance: message });
            if (!message.hasOwnProperty("secType"))
                throw $util.ProtocolError("missing required 'secType'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("listTime"))
                throw $util.ProtocolError("missing required 'listTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a SecurityStaticBasic message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.SecurityStaticBasic
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.SecurityStaticBasic} SecurityStaticBasic
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityStaticBasic.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityStaticBasic message.
         * @function verify
         * @memberof Qot_Common.SecurityStaticBasic
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityStaticBasic.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
            if (!$util.isInteger(message.lotSize))
                return "lotSize: integer expected";
            if (!$util.isInteger(message.secType))
                return "secType: integer expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (!$util.isString(message.listTime))
                return "listTime: string expected";
            if (message.delisting != null && message.hasOwnProperty("delisting"))
                if (typeof message.delisting !== "boolean")
                    return "delisting: boolean expected";
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                if (typeof message.listTimestamp !== "number")
                    return "listTimestamp: number expected";
            return null;
        };

        /**
         * Creates a SecurityStaticBasic message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.SecurityStaticBasic
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.SecurityStaticBasic} SecurityStaticBasic
         */
        SecurityStaticBasic.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.SecurityStaticBasic)
                return object;
            var message = new $root.Qot_Common.SecurityStaticBasic();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_Common.SecurityStaticBasic.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            if (object.lotSize != null)
                message.lotSize = object.lotSize | 0;
            if (object.secType != null)
                message.secType = object.secType | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.listTime != null)
                message.listTime = String(object.listTime);
            if (object.delisting != null)
                message.delisting = Boolean(object.delisting);
            if (object.listTimestamp != null)
                message.listTimestamp = Number(object.listTimestamp);
            return message;
        };

        /**
         * Creates a plain object from a SecurityStaticBasic message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.SecurityStaticBasic
         * @static
         * @param {Qot_Common.SecurityStaticBasic} message SecurityStaticBasic
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityStaticBasic.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.security = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.lotSize = 0;
                object.secType = 0;
                object.name = "";
                object.listTime = "";
                object.delisting = false;
                object.listTimestamp = 0;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            if (message.lotSize != null && message.hasOwnProperty("lotSize"))
                object.lotSize = message.lotSize;
            if (message.secType != null && message.hasOwnProperty("secType"))
                object.secType = message.secType;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.listTime != null && message.hasOwnProperty("listTime"))
                object.listTime = message.listTime;
            if (message.delisting != null && message.hasOwnProperty("delisting"))
                object.delisting = message.delisting;
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                object.listTimestamp = options.json && !isFinite(message.listTimestamp) ? String(message.listTimestamp) : message.listTimestamp;
            return object;
        };

        /**
         * Converts this SecurityStaticBasic to JSON.
         * @function toJSON
         * @memberof Qot_Common.SecurityStaticBasic
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityStaticBasic.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityStaticBasic;
    })();

    Qot_Common.WarrantStaticExData = (function() {

        /**
         * Properties of a WarrantStaticExData.
         * @memberof Qot_Common
         * @interface IWarrantStaticExData
         * @property {number} type WarrantStaticExData type
         * @property {Qot_Common.ISecurity} owner WarrantStaticExData owner
         */

        /**
         * Constructs a new WarrantStaticExData.
         * @memberof Qot_Common
         * @classdesc Represents a WarrantStaticExData.
         * @implements IWarrantStaticExData
         * @constructor
         * @param {Qot_Common.IWarrantStaticExData=} [properties] Properties to set
         */
        function WarrantStaticExData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WarrantStaticExData type.
         * @member {number} type
         * @memberof Qot_Common.WarrantStaticExData
         * @instance
         */
        WarrantStaticExData.prototype.type = 0;

        /**
         * WarrantStaticExData owner.
         * @member {Qot_Common.ISecurity} owner
         * @memberof Qot_Common.WarrantStaticExData
         * @instance
         */
        WarrantStaticExData.prototype.owner = null;

        /**
         * Creates a new WarrantStaticExData instance using the specified properties.
         * @function create
         * @memberof Qot_Common.WarrantStaticExData
         * @static
         * @param {Qot_Common.IWarrantStaticExData=} [properties] Properties to set
         * @returns {Qot_Common.WarrantStaticExData} WarrantStaticExData instance
         */
        WarrantStaticExData.create = function create(properties) {
            return new WarrantStaticExData(properties);
        };

        /**
         * Encodes the specified WarrantStaticExData message. Does not implicitly {@link Qot_Common.WarrantStaticExData.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.WarrantStaticExData
         * @static
         * @param {Qot_Common.IWarrantStaticExData} message WarrantStaticExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarrantStaticExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            $root.Qot_Common.Security.encode(message.owner, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified WarrantStaticExData message, length delimited. Does not implicitly {@link Qot_Common.WarrantStaticExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.WarrantStaticExData
         * @static
         * @param {Qot_Common.IWarrantStaticExData} message WarrantStaticExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarrantStaticExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WarrantStaticExData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.WarrantStaticExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.WarrantStaticExData} WarrantStaticExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarrantStaticExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.WarrantStaticExData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.owner = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("owner"))
                throw $util.ProtocolError("missing required 'owner'", { instance: message });
            return message;
        };

        /**
         * Decodes a WarrantStaticExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.WarrantStaticExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.WarrantStaticExData} WarrantStaticExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarrantStaticExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WarrantStaticExData message.
         * @function verify
         * @memberof Qot_Common.WarrantStaticExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WarrantStaticExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            {
                var error = $root.Qot_Common.Security.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            return null;
        };

        /**
         * Creates a WarrantStaticExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.WarrantStaticExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.WarrantStaticExData} WarrantStaticExData
         */
        WarrantStaticExData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.WarrantStaticExData)
                return object;
            var message = new $root.Qot_Common.WarrantStaticExData();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".Qot_Common.WarrantStaticExData.owner: object expected");
                message.owner = $root.Qot_Common.Security.fromObject(object.owner);
            }
            return message;
        };

        /**
         * Creates a plain object from a WarrantStaticExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.WarrantStaticExData
         * @static
         * @param {Qot_Common.WarrantStaticExData} message WarrantStaticExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WarrantStaticExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.owner = null;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.Qot_Common.Security.toObject(message.owner, options);
            return object;
        };

        /**
         * Converts this WarrantStaticExData to JSON.
         * @function toJSON
         * @memberof Qot_Common.WarrantStaticExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WarrantStaticExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WarrantStaticExData;
    })();

    Qot_Common.OptionStaticExData = (function() {

        /**
         * Properties of an OptionStaticExData.
         * @memberof Qot_Common
         * @interface IOptionStaticExData
         * @property {number} type OptionStaticExData type
         * @property {Qot_Common.ISecurity} owner OptionStaticExData owner
         * @property {string} strikeTime OptionStaticExData strikeTime
         * @property {number} strikePrice OptionStaticExData strikePrice
         * @property {boolean} suspend OptionStaticExData suspend
         * @property {string} market OptionStaticExData market
         * @property {number|null} [strikeTimestamp] OptionStaticExData strikeTimestamp
         * @property {number|null} [indexOptionType] OptionStaticExData indexOptionType
         */

        /**
         * Constructs a new OptionStaticExData.
         * @memberof Qot_Common
         * @classdesc Represents an OptionStaticExData.
         * @implements IOptionStaticExData
         * @constructor
         * @param {Qot_Common.IOptionStaticExData=} [properties] Properties to set
         */
        function OptionStaticExData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OptionStaticExData type.
         * @member {number} type
         * @memberof Qot_Common.OptionStaticExData
         * @instance
         */
        OptionStaticExData.prototype.type = 0;

        /**
         * OptionStaticExData owner.
         * @member {Qot_Common.ISecurity} owner
         * @memberof Qot_Common.OptionStaticExData
         * @instance
         */
        OptionStaticExData.prototype.owner = null;

        /**
         * OptionStaticExData strikeTime.
         * @member {string} strikeTime
         * @memberof Qot_Common.OptionStaticExData
         * @instance
         */
        OptionStaticExData.prototype.strikeTime = "";

        /**
         * OptionStaticExData strikePrice.
         * @member {number} strikePrice
         * @memberof Qot_Common.OptionStaticExData
         * @instance
         */
        OptionStaticExData.prototype.strikePrice = 0;

        /**
         * OptionStaticExData suspend.
         * @member {boolean} suspend
         * @memberof Qot_Common.OptionStaticExData
         * @instance
         */
        OptionStaticExData.prototype.suspend = false;

        /**
         * OptionStaticExData market.
         * @member {string} market
         * @memberof Qot_Common.OptionStaticExData
         * @instance
         */
        OptionStaticExData.prototype.market = "";

        /**
         * OptionStaticExData strikeTimestamp.
         * @member {number} strikeTimestamp
         * @memberof Qot_Common.OptionStaticExData
         * @instance
         */
        OptionStaticExData.prototype.strikeTimestamp = 0;

        /**
         * OptionStaticExData indexOptionType.
         * @member {number} indexOptionType
         * @memberof Qot_Common.OptionStaticExData
         * @instance
         */
        OptionStaticExData.prototype.indexOptionType = 0;

        /**
         * Creates a new OptionStaticExData instance using the specified properties.
         * @function create
         * @memberof Qot_Common.OptionStaticExData
         * @static
         * @param {Qot_Common.IOptionStaticExData=} [properties] Properties to set
         * @returns {Qot_Common.OptionStaticExData} OptionStaticExData instance
         */
        OptionStaticExData.create = function create(properties) {
            return new OptionStaticExData(properties);
        };

        /**
         * Encodes the specified OptionStaticExData message. Does not implicitly {@link Qot_Common.OptionStaticExData.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.OptionStaticExData
         * @static
         * @param {Qot_Common.IOptionStaticExData} message OptionStaticExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionStaticExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            $root.Qot_Common.Security.encode(message.owner, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.strikeTime);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.strikePrice);
            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.suspend);
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.market);
            if (message.strikeTimestamp != null && message.hasOwnProperty("strikeTimestamp"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.strikeTimestamp);
            if (message.indexOptionType != null && message.hasOwnProperty("indexOptionType"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.indexOptionType);
            return writer;
        };

        /**
         * Encodes the specified OptionStaticExData message, length delimited. Does not implicitly {@link Qot_Common.OptionStaticExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.OptionStaticExData
         * @static
         * @param {Qot_Common.IOptionStaticExData} message OptionStaticExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionStaticExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OptionStaticExData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.OptionStaticExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.OptionStaticExData} OptionStaticExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionStaticExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.OptionStaticExData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.owner = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.strikeTime = reader.string();
                    break;
                case 4:
                    message.strikePrice = reader.double();
                    break;
                case 5:
                    message.suspend = reader.bool();
                    break;
                case 6:
                    message.market = reader.string();
                    break;
                case 7:
                    message.strikeTimestamp = reader.double();
                    break;
                case 8:
                    message.indexOptionType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("owner"))
                throw $util.ProtocolError("missing required 'owner'", { instance: message });
            if (!message.hasOwnProperty("strikeTime"))
                throw $util.ProtocolError("missing required 'strikeTime'", { instance: message });
            if (!message.hasOwnProperty("strikePrice"))
                throw $util.ProtocolError("missing required 'strikePrice'", { instance: message });
            if (!message.hasOwnProperty("suspend"))
                throw $util.ProtocolError("missing required 'suspend'", { instance: message });
            if (!message.hasOwnProperty("market"))
                throw $util.ProtocolError("missing required 'market'", { instance: message });
            return message;
        };

        /**
         * Decodes an OptionStaticExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.OptionStaticExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.OptionStaticExData} OptionStaticExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionStaticExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OptionStaticExData message.
         * @function verify
         * @memberof Qot_Common.OptionStaticExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OptionStaticExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            {
                var error = $root.Qot_Common.Security.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            if (!$util.isString(message.strikeTime))
                return "strikeTime: string expected";
            if (typeof message.strikePrice !== "number")
                return "strikePrice: number expected";
            if (typeof message.suspend !== "boolean")
                return "suspend: boolean expected";
            if (!$util.isString(message.market))
                return "market: string expected";
            if (message.strikeTimestamp != null && message.hasOwnProperty("strikeTimestamp"))
                if (typeof message.strikeTimestamp !== "number")
                    return "strikeTimestamp: number expected";
            if (message.indexOptionType != null && message.hasOwnProperty("indexOptionType"))
                if (!$util.isInteger(message.indexOptionType))
                    return "indexOptionType: integer expected";
            return null;
        };

        /**
         * Creates an OptionStaticExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.OptionStaticExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.OptionStaticExData} OptionStaticExData
         */
        OptionStaticExData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.OptionStaticExData)
                return object;
            var message = new $root.Qot_Common.OptionStaticExData();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".Qot_Common.OptionStaticExData.owner: object expected");
                message.owner = $root.Qot_Common.Security.fromObject(object.owner);
            }
            if (object.strikeTime != null)
                message.strikeTime = String(object.strikeTime);
            if (object.strikePrice != null)
                message.strikePrice = Number(object.strikePrice);
            if (object.suspend != null)
                message.suspend = Boolean(object.suspend);
            if (object.market != null)
                message.market = String(object.market);
            if (object.strikeTimestamp != null)
                message.strikeTimestamp = Number(object.strikeTimestamp);
            if (object.indexOptionType != null)
                message.indexOptionType = object.indexOptionType | 0;
            return message;
        };

        /**
         * Creates a plain object from an OptionStaticExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.OptionStaticExData
         * @static
         * @param {Qot_Common.OptionStaticExData} message OptionStaticExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OptionStaticExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.owner = null;
                object.strikeTime = "";
                object.strikePrice = 0;
                object.suspend = false;
                object.market = "";
                object.strikeTimestamp = 0;
                object.indexOptionType = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.Qot_Common.Security.toObject(message.owner, options);
            if (message.strikeTime != null && message.hasOwnProperty("strikeTime"))
                object.strikeTime = message.strikeTime;
            if (message.strikePrice != null && message.hasOwnProperty("strikePrice"))
                object.strikePrice = options.json && !isFinite(message.strikePrice) ? String(message.strikePrice) : message.strikePrice;
            if (message.suspend != null && message.hasOwnProperty("suspend"))
                object.suspend = message.suspend;
            if (message.market != null && message.hasOwnProperty("market"))
                object.market = message.market;
            if (message.strikeTimestamp != null && message.hasOwnProperty("strikeTimestamp"))
                object.strikeTimestamp = options.json && !isFinite(message.strikeTimestamp) ? String(message.strikeTimestamp) : message.strikeTimestamp;
            if (message.indexOptionType != null && message.hasOwnProperty("indexOptionType"))
                object.indexOptionType = message.indexOptionType;
            return object;
        };

        /**
         * Converts this OptionStaticExData to JSON.
         * @function toJSON
         * @memberof Qot_Common.OptionStaticExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OptionStaticExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OptionStaticExData;
    })();

    Qot_Common.FutureStaticExData = (function() {

        /**
         * Properties of a FutureStaticExData.
         * @memberof Qot_Common
         * @interface IFutureStaticExData
         * @property {string} lastTradeTime FutureStaticExData lastTradeTime
         * @property {number|null} [lastTradeTimestamp] FutureStaticExData lastTradeTimestamp
         * @property {boolean} isMainContract FutureStaticExData isMainContract
         */

        /**
         * Constructs a new FutureStaticExData.
         * @memberof Qot_Common
         * @classdesc Represents a FutureStaticExData.
         * @implements IFutureStaticExData
         * @constructor
         * @param {Qot_Common.IFutureStaticExData=} [properties] Properties to set
         */
        function FutureStaticExData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FutureStaticExData lastTradeTime.
         * @member {string} lastTradeTime
         * @memberof Qot_Common.FutureStaticExData
         * @instance
         */
        FutureStaticExData.prototype.lastTradeTime = "";

        /**
         * FutureStaticExData lastTradeTimestamp.
         * @member {number} lastTradeTimestamp
         * @memberof Qot_Common.FutureStaticExData
         * @instance
         */
        FutureStaticExData.prototype.lastTradeTimestamp = 0;

        /**
         * FutureStaticExData isMainContract.
         * @member {boolean} isMainContract
         * @memberof Qot_Common.FutureStaticExData
         * @instance
         */
        FutureStaticExData.prototype.isMainContract = false;

        /**
         * Creates a new FutureStaticExData instance using the specified properties.
         * @function create
         * @memberof Qot_Common.FutureStaticExData
         * @static
         * @param {Qot_Common.IFutureStaticExData=} [properties] Properties to set
         * @returns {Qot_Common.FutureStaticExData} FutureStaticExData instance
         */
        FutureStaticExData.create = function create(properties) {
            return new FutureStaticExData(properties);
        };

        /**
         * Encodes the specified FutureStaticExData message. Does not implicitly {@link Qot_Common.FutureStaticExData.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.FutureStaticExData
         * @static
         * @param {Qot_Common.IFutureStaticExData} message FutureStaticExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FutureStaticExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.lastTradeTime);
            if (message.lastTradeTimestamp != null && message.hasOwnProperty("lastTradeTimestamp"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.lastTradeTimestamp);
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isMainContract);
            return writer;
        };

        /**
         * Encodes the specified FutureStaticExData message, length delimited. Does not implicitly {@link Qot_Common.FutureStaticExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.FutureStaticExData
         * @static
         * @param {Qot_Common.IFutureStaticExData} message FutureStaticExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FutureStaticExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FutureStaticExData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.FutureStaticExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.FutureStaticExData} FutureStaticExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FutureStaticExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.FutureStaticExData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lastTradeTime = reader.string();
                    break;
                case 2:
                    message.lastTradeTimestamp = reader.double();
                    break;
                case 3:
                    message.isMainContract = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("lastTradeTime"))
                throw $util.ProtocolError("missing required 'lastTradeTime'", { instance: message });
            if (!message.hasOwnProperty("isMainContract"))
                throw $util.ProtocolError("missing required 'isMainContract'", { instance: message });
            return message;
        };

        /**
         * Decodes a FutureStaticExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.FutureStaticExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.FutureStaticExData} FutureStaticExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FutureStaticExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FutureStaticExData message.
         * @function verify
         * @memberof Qot_Common.FutureStaticExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FutureStaticExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.lastTradeTime))
                return "lastTradeTime: string expected";
            if (message.lastTradeTimestamp != null && message.hasOwnProperty("lastTradeTimestamp"))
                if (typeof message.lastTradeTimestamp !== "number")
                    return "lastTradeTimestamp: number expected";
            if (typeof message.isMainContract !== "boolean")
                return "isMainContract: boolean expected";
            return null;
        };

        /**
         * Creates a FutureStaticExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.FutureStaticExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.FutureStaticExData} FutureStaticExData
         */
        FutureStaticExData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.FutureStaticExData)
                return object;
            var message = new $root.Qot_Common.FutureStaticExData();
            if (object.lastTradeTime != null)
                message.lastTradeTime = String(object.lastTradeTime);
            if (object.lastTradeTimestamp != null)
                message.lastTradeTimestamp = Number(object.lastTradeTimestamp);
            if (object.isMainContract != null)
                message.isMainContract = Boolean(object.isMainContract);
            return message;
        };

        /**
         * Creates a plain object from a FutureStaticExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.FutureStaticExData
         * @static
         * @param {Qot_Common.FutureStaticExData} message FutureStaticExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FutureStaticExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.lastTradeTime = "";
                object.lastTradeTimestamp = 0;
                object.isMainContract = false;
            }
            if (message.lastTradeTime != null && message.hasOwnProperty("lastTradeTime"))
                object.lastTradeTime = message.lastTradeTime;
            if (message.lastTradeTimestamp != null && message.hasOwnProperty("lastTradeTimestamp"))
                object.lastTradeTimestamp = options.json && !isFinite(message.lastTradeTimestamp) ? String(message.lastTradeTimestamp) : message.lastTradeTimestamp;
            if (message.isMainContract != null && message.hasOwnProperty("isMainContract"))
                object.isMainContract = message.isMainContract;
            return object;
        };

        /**
         * Converts this FutureStaticExData to JSON.
         * @function toJSON
         * @memberof Qot_Common.FutureStaticExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FutureStaticExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FutureStaticExData;
    })();

    Qot_Common.SecurityStaticInfo = (function() {

        /**
         * Properties of a SecurityStaticInfo.
         * @memberof Qot_Common
         * @interface ISecurityStaticInfo
         * @property {Qot_Common.ISecurityStaticBasic} basic SecurityStaticInfo basic
         * @property {Qot_Common.IWarrantStaticExData|null} [warrantExData] SecurityStaticInfo warrantExData
         * @property {Qot_Common.IOptionStaticExData|null} [optionExData] SecurityStaticInfo optionExData
         * @property {Qot_Common.IFutureStaticExData|null} [futureExData] SecurityStaticInfo futureExData
         */

        /**
         * Constructs a new SecurityStaticInfo.
         * @memberof Qot_Common
         * @classdesc Represents a SecurityStaticInfo.
         * @implements ISecurityStaticInfo
         * @constructor
         * @param {Qot_Common.ISecurityStaticInfo=} [properties] Properties to set
         */
        function SecurityStaticInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityStaticInfo basic.
         * @member {Qot_Common.ISecurityStaticBasic} basic
         * @memberof Qot_Common.SecurityStaticInfo
         * @instance
         */
        SecurityStaticInfo.prototype.basic = null;

        /**
         * SecurityStaticInfo warrantExData.
         * @member {Qot_Common.IWarrantStaticExData|null|undefined} warrantExData
         * @memberof Qot_Common.SecurityStaticInfo
         * @instance
         */
        SecurityStaticInfo.prototype.warrantExData = null;

        /**
         * SecurityStaticInfo optionExData.
         * @member {Qot_Common.IOptionStaticExData|null|undefined} optionExData
         * @memberof Qot_Common.SecurityStaticInfo
         * @instance
         */
        SecurityStaticInfo.prototype.optionExData = null;

        /**
         * SecurityStaticInfo futureExData.
         * @member {Qot_Common.IFutureStaticExData|null|undefined} futureExData
         * @memberof Qot_Common.SecurityStaticInfo
         * @instance
         */
        SecurityStaticInfo.prototype.futureExData = null;

        /**
         * Creates a new SecurityStaticInfo instance using the specified properties.
         * @function create
         * @memberof Qot_Common.SecurityStaticInfo
         * @static
         * @param {Qot_Common.ISecurityStaticInfo=} [properties] Properties to set
         * @returns {Qot_Common.SecurityStaticInfo} SecurityStaticInfo instance
         */
        SecurityStaticInfo.create = function create(properties) {
            return new SecurityStaticInfo(properties);
        };

        /**
         * Encodes the specified SecurityStaticInfo message. Does not implicitly {@link Qot_Common.SecurityStaticInfo.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.SecurityStaticInfo
         * @static
         * @param {Qot_Common.ISecurityStaticInfo} message SecurityStaticInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityStaticInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.SecurityStaticBasic.encode(message.basic, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.warrantExData != null && message.hasOwnProperty("warrantExData"))
                $root.Qot_Common.WarrantStaticExData.encode(message.warrantExData, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.optionExData != null && message.hasOwnProperty("optionExData"))
                $root.Qot_Common.OptionStaticExData.encode(message.optionExData, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.futureExData != null && message.hasOwnProperty("futureExData"))
                $root.Qot_Common.FutureStaticExData.encode(message.futureExData, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SecurityStaticInfo message, length delimited. Does not implicitly {@link Qot_Common.SecurityStaticInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.SecurityStaticInfo
         * @static
         * @param {Qot_Common.ISecurityStaticInfo} message SecurityStaticInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityStaticInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityStaticInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.SecurityStaticInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.SecurityStaticInfo} SecurityStaticInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityStaticInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.SecurityStaticInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.basic = $root.Qot_Common.SecurityStaticBasic.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.warrantExData = $root.Qot_Common.WarrantStaticExData.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.optionExData = $root.Qot_Common.OptionStaticExData.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.futureExData = $root.Qot_Common.FutureStaticExData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("basic"))
                throw $util.ProtocolError("missing required 'basic'", { instance: message });
            return message;
        };

        /**
         * Decodes a SecurityStaticInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.SecurityStaticInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.SecurityStaticInfo} SecurityStaticInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityStaticInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityStaticInfo message.
         * @function verify
         * @memberof Qot_Common.SecurityStaticInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityStaticInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.SecurityStaticBasic.verify(message.basic);
                if (error)
                    return "basic." + error;
            }
            if (message.warrantExData != null && message.hasOwnProperty("warrantExData")) {
                var error = $root.Qot_Common.WarrantStaticExData.verify(message.warrantExData);
                if (error)
                    return "warrantExData." + error;
            }
            if (message.optionExData != null && message.hasOwnProperty("optionExData")) {
                var error = $root.Qot_Common.OptionStaticExData.verify(message.optionExData);
                if (error)
                    return "optionExData." + error;
            }
            if (message.futureExData != null && message.hasOwnProperty("futureExData")) {
                var error = $root.Qot_Common.FutureStaticExData.verify(message.futureExData);
                if (error)
                    return "futureExData." + error;
            }
            return null;
        };

        /**
         * Creates a SecurityStaticInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.SecurityStaticInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.SecurityStaticInfo} SecurityStaticInfo
         */
        SecurityStaticInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.SecurityStaticInfo)
                return object;
            var message = new $root.Qot_Common.SecurityStaticInfo();
            if (object.basic != null) {
                if (typeof object.basic !== "object")
                    throw TypeError(".Qot_Common.SecurityStaticInfo.basic: object expected");
                message.basic = $root.Qot_Common.SecurityStaticBasic.fromObject(object.basic);
            }
            if (object.warrantExData != null) {
                if (typeof object.warrantExData !== "object")
                    throw TypeError(".Qot_Common.SecurityStaticInfo.warrantExData: object expected");
                message.warrantExData = $root.Qot_Common.WarrantStaticExData.fromObject(object.warrantExData);
            }
            if (object.optionExData != null) {
                if (typeof object.optionExData !== "object")
                    throw TypeError(".Qot_Common.SecurityStaticInfo.optionExData: object expected");
                message.optionExData = $root.Qot_Common.OptionStaticExData.fromObject(object.optionExData);
            }
            if (object.futureExData != null) {
                if (typeof object.futureExData !== "object")
                    throw TypeError(".Qot_Common.SecurityStaticInfo.futureExData: object expected");
                message.futureExData = $root.Qot_Common.FutureStaticExData.fromObject(object.futureExData);
            }
            return message;
        };

        /**
         * Creates a plain object from a SecurityStaticInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.SecurityStaticInfo
         * @static
         * @param {Qot_Common.SecurityStaticInfo} message SecurityStaticInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityStaticInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.basic = null;
                object.warrantExData = null;
                object.optionExData = null;
                object.futureExData = null;
            }
            if (message.basic != null && message.hasOwnProperty("basic"))
                object.basic = $root.Qot_Common.SecurityStaticBasic.toObject(message.basic, options);
            if (message.warrantExData != null && message.hasOwnProperty("warrantExData"))
                object.warrantExData = $root.Qot_Common.WarrantStaticExData.toObject(message.warrantExData, options);
            if (message.optionExData != null && message.hasOwnProperty("optionExData"))
                object.optionExData = $root.Qot_Common.OptionStaticExData.toObject(message.optionExData, options);
            if (message.futureExData != null && message.hasOwnProperty("futureExData"))
                object.futureExData = $root.Qot_Common.FutureStaticExData.toObject(message.futureExData, options);
            return object;
        };

        /**
         * Converts this SecurityStaticInfo to JSON.
         * @function toJSON
         * @memberof Qot_Common.SecurityStaticInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityStaticInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityStaticInfo;
    })();

    Qot_Common.Broker = (function() {

        /**
         * Properties of a Broker.
         * @memberof Qot_Common
         * @interface IBroker
         * @property {number|Long} id Broker id
         * @property {string} name Broker name
         * @property {number} pos Broker pos
         * @property {number|Long|null} [orderID] Broker orderID
         * @property {number|Long|null} [volume] Broker volume
         */

        /**
         * Constructs a new Broker.
         * @memberof Qot_Common
         * @classdesc Represents a Broker.
         * @implements IBroker
         * @constructor
         * @param {Qot_Common.IBroker=} [properties] Properties to set
         */
        function Broker(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Broker id.
         * @member {number|Long} id
         * @memberof Qot_Common.Broker
         * @instance
         */
        Broker.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Broker name.
         * @member {string} name
         * @memberof Qot_Common.Broker
         * @instance
         */
        Broker.prototype.name = "";

        /**
         * Broker pos.
         * @member {number} pos
         * @memberof Qot_Common.Broker
         * @instance
         */
        Broker.prototype.pos = 0;

        /**
         * Broker orderID.
         * @member {number|Long} orderID
         * @memberof Qot_Common.Broker
         * @instance
         */
        Broker.prototype.orderID = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Broker volume.
         * @member {number|Long} volume
         * @memberof Qot_Common.Broker
         * @instance
         */
        Broker.prototype.volume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Broker instance using the specified properties.
         * @function create
         * @memberof Qot_Common.Broker
         * @static
         * @param {Qot_Common.IBroker=} [properties] Properties to set
         * @returns {Qot_Common.Broker} Broker instance
         */
        Broker.create = function create(properties) {
            return new Broker(properties);
        };

        /**
         * Encodes the specified Broker message. Does not implicitly {@link Qot_Common.Broker.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.Broker
         * @static
         * @param {Qot_Common.IBroker} message Broker message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Broker.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.pos);
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.orderID);
            if (message.volume != null && message.hasOwnProperty("volume"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.volume);
            return writer;
        };

        /**
         * Encodes the specified Broker message, length delimited. Does not implicitly {@link Qot_Common.Broker.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.Broker
         * @static
         * @param {Qot_Common.IBroker} message Broker message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Broker.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Broker message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.Broker
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.Broker} Broker
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Broker.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.Broker();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int64();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.pos = reader.int32();
                    break;
                case 4:
                    message.orderID = reader.int64();
                    break;
                case 5:
                    message.volume = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("pos"))
                throw $util.ProtocolError("missing required 'pos'", { instance: message });
            return message;
        };

        /**
         * Decodes a Broker message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.Broker
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.Broker} Broker
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Broker.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Broker message.
         * @function verify
         * @memberof Qot_Common.Broker
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Broker.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (!$util.isInteger(message.pos))
                return "pos: integer expected";
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (!$util.isInteger(message.orderID) && !(message.orderID && $util.isInteger(message.orderID.low) && $util.isInteger(message.orderID.high)))
                    return "orderID: integer|Long expected";
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (!$util.isInteger(message.volume) && !(message.volume && $util.isInteger(message.volume.low) && $util.isInteger(message.volume.high)))
                    return "volume: integer|Long expected";
            return null;
        };

        /**
         * Creates a Broker message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.Broker
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.Broker} Broker
         */
        Broker.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.Broker)
                return object;
            var message = new $root.Qot_Common.Broker();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            if (object.pos != null)
                message.pos = object.pos | 0;
            if (object.orderID != null)
                if ($util.Long)
                    (message.orderID = $util.Long.fromValue(object.orderID)).unsigned = false;
                else if (typeof object.orderID === "string")
                    message.orderID = parseInt(object.orderID, 10);
                else if (typeof object.orderID === "number")
                    message.orderID = object.orderID;
                else if (typeof object.orderID === "object")
                    message.orderID = new $util.LongBits(object.orderID.low >>> 0, object.orderID.high >>> 0).toNumber();
            if (object.volume != null)
                if ($util.Long)
                    (message.volume = $util.Long.fromValue(object.volume)).unsigned = false;
                else if (typeof object.volume === "string")
                    message.volume = parseInt(object.volume, 10);
                else if (typeof object.volume === "number")
                    message.volume = object.volume;
                else if (typeof object.volume === "object")
                    message.volume = new $util.LongBits(object.volume.low >>> 0, object.volume.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Broker message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.Broker
         * @static
         * @param {Qot_Common.Broker} message Broker
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Broker.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.name = "";
                object.pos = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.orderID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.orderID = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.volume = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.volume = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = message.pos;
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (typeof message.orderID === "number")
                    object.orderID = options.longs === String ? String(message.orderID) : message.orderID;
                else
                    object.orderID = options.longs === String ? $util.Long.prototype.toString.call(message.orderID) : options.longs === Number ? new $util.LongBits(message.orderID.low >>> 0, message.orderID.high >>> 0).toNumber() : message.orderID;
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (typeof message.volume === "number")
                    object.volume = options.longs === String ? String(message.volume) : message.volume;
                else
                    object.volume = options.longs === String ? $util.Long.prototype.toString.call(message.volume) : options.longs === Number ? new $util.LongBits(message.volume.low >>> 0, message.volume.high >>> 0).toNumber() : message.volume;
            return object;
        };

        /**
         * Converts this Broker to JSON.
         * @function toJSON
         * @memberof Qot_Common.Broker
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Broker.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Broker;
    })();

    Qot_Common.Ticker = (function() {

        /**
         * Properties of a Ticker.
         * @memberof Qot_Common
         * @interface ITicker
         * @property {string} time Ticker time
         * @property {number|Long} sequence Ticker sequence
         * @property {number} dir Ticker dir
         * @property {number} price Ticker price
         * @property {number|Long} volume Ticker volume
         * @property {number} turnover Ticker turnover
         * @property {number|null} [recvTime] Ticker recvTime
         * @property {number|null} [type] Ticker type
         * @property {number|null} [typeSign] Ticker typeSign
         * @property {number|null} [pushDataType] Ticker pushDataType
         * @property {number|null} [timestamp] Ticker timestamp
         */

        /**
         * Constructs a new Ticker.
         * @memberof Qot_Common
         * @classdesc Represents a Ticker.
         * @implements ITicker
         * @constructor
         * @param {Qot_Common.ITicker=} [properties] Properties to set
         */
        function Ticker(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Ticker time.
         * @member {string} time
         * @memberof Qot_Common.Ticker
         * @instance
         */
        Ticker.prototype.time = "";

        /**
         * Ticker sequence.
         * @member {number|Long} sequence
         * @memberof Qot_Common.Ticker
         * @instance
         */
        Ticker.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Ticker dir.
         * @member {number} dir
         * @memberof Qot_Common.Ticker
         * @instance
         */
        Ticker.prototype.dir = 0;

        /**
         * Ticker price.
         * @member {number} price
         * @memberof Qot_Common.Ticker
         * @instance
         */
        Ticker.prototype.price = 0;

        /**
         * Ticker volume.
         * @member {number|Long} volume
         * @memberof Qot_Common.Ticker
         * @instance
         */
        Ticker.prototype.volume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Ticker turnover.
         * @member {number} turnover
         * @memberof Qot_Common.Ticker
         * @instance
         */
        Ticker.prototype.turnover = 0;

        /**
         * Ticker recvTime.
         * @member {number} recvTime
         * @memberof Qot_Common.Ticker
         * @instance
         */
        Ticker.prototype.recvTime = 0;

        /**
         * Ticker type.
         * @member {number} type
         * @memberof Qot_Common.Ticker
         * @instance
         */
        Ticker.prototype.type = 0;

        /**
         * Ticker typeSign.
         * @member {number} typeSign
         * @memberof Qot_Common.Ticker
         * @instance
         */
        Ticker.prototype.typeSign = 0;

        /**
         * Ticker pushDataType.
         * @member {number} pushDataType
         * @memberof Qot_Common.Ticker
         * @instance
         */
        Ticker.prototype.pushDataType = 0;

        /**
         * Ticker timestamp.
         * @member {number} timestamp
         * @memberof Qot_Common.Ticker
         * @instance
         */
        Ticker.prototype.timestamp = 0;

        /**
         * Creates a new Ticker instance using the specified properties.
         * @function create
         * @memberof Qot_Common.Ticker
         * @static
         * @param {Qot_Common.ITicker=} [properties] Properties to set
         * @returns {Qot_Common.Ticker} Ticker instance
         */
        Ticker.create = function create(properties) {
            return new Ticker(properties);
        };

        /**
         * Encodes the specified Ticker message. Does not implicitly {@link Qot_Common.Ticker.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.Ticker
         * @static
         * @param {Qot_Common.ITicker} message Ticker message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ticker.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.time);
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.sequence);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.dir);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.price);
            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.volume);
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.turnover);
            if (message.recvTime != null && message.hasOwnProperty("recvTime"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.recvTime);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.type);
            if (message.typeSign != null && message.hasOwnProperty("typeSign"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.typeSign);
            if (message.pushDataType != null && message.hasOwnProperty("pushDataType"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.pushDataType);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 11, wireType 1 =*/89).double(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified Ticker message, length delimited. Does not implicitly {@link Qot_Common.Ticker.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.Ticker
         * @static
         * @param {Qot_Common.ITicker} message Ticker message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ticker.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Ticker message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.Ticker
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.Ticker} Ticker
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ticker.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.Ticker();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.string();
                    break;
                case 2:
                    message.sequence = reader.int64();
                    break;
                case 3:
                    message.dir = reader.int32();
                    break;
                case 4:
                    message.price = reader.double();
                    break;
                case 5:
                    message.volume = reader.int64();
                    break;
                case 6:
                    message.turnover = reader.double();
                    break;
                case 7:
                    message.recvTime = reader.double();
                    break;
                case 8:
                    message.type = reader.int32();
                    break;
                case 9:
                    message.typeSign = reader.int32();
                    break;
                case 10:
                    message.pushDataType = reader.int32();
                    break;
                case 11:
                    message.timestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("time"))
                throw $util.ProtocolError("missing required 'time'", { instance: message });
            if (!message.hasOwnProperty("sequence"))
                throw $util.ProtocolError("missing required 'sequence'", { instance: message });
            if (!message.hasOwnProperty("dir"))
                throw $util.ProtocolError("missing required 'dir'", { instance: message });
            if (!message.hasOwnProperty("price"))
                throw $util.ProtocolError("missing required 'price'", { instance: message });
            if (!message.hasOwnProperty("volume"))
                throw $util.ProtocolError("missing required 'volume'", { instance: message });
            if (!message.hasOwnProperty("turnover"))
                throw $util.ProtocolError("missing required 'turnover'", { instance: message });
            return message;
        };

        /**
         * Decodes a Ticker message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.Ticker
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.Ticker} Ticker
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ticker.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Ticker message.
         * @function verify
         * @memberof Qot_Common.Ticker
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Ticker.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.time))
                return "time: string expected";
            if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                return "sequence: integer|Long expected";
            if (!$util.isInteger(message.dir))
                return "dir: integer expected";
            if (typeof message.price !== "number")
                return "price: number expected";
            if (!$util.isInteger(message.volume) && !(message.volume && $util.isInteger(message.volume.low) && $util.isInteger(message.volume.high)))
                return "volume: integer|Long expected";
            if (typeof message.turnover !== "number")
                return "turnover: number expected";
            if (message.recvTime != null && message.hasOwnProperty("recvTime"))
                if (typeof message.recvTime !== "number")
                    return "recvTime: number expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.typeSign != null && message.hasOwnProperty("typeSign"))
                if (!$util.isInteger(message.typeSign))
                    return "typeSign: integer expected";
            if (message.pushDataType != null && message.hasOwnProperty("pushDataType"))
                if (!$util.isInteger(message.pushDataType))
                    return "pushDataType: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp !== "number")
                    return "timestamp: number expected";
            return null;
        };

        /**
         * Creates a Ticker message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.Ticker
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.Ticker} Ticker
         */
        Ticker.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.Ticker)
                return object;
            var message = new $root.Qot_Common.Ticker();
            if (object.time != null)
                message.time = String(object.time);
            if (object.sequence != null)
                if ($util.Long)
                    (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                else if (typeof object.sequence === "string")
                    message.sequence = parseInt(object.sequence, 10);
                else if (typeof object.sequence === "number")
                    message.sequence = object.sequence;
                else if (typeof object.sequence === "object")
                    message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
            if (object.dir != null)
                message.dir = object.dir | 0;
            if (object.price != null)
                message.price = Number(object.price);
            if (object.volume != null)
                if ($util.Long)
                    (message.volume = $util.Long.fromValue(object.volume)).unsigned = false;
                else if (typeof object.volume === "string")
                    message.volume = parseInt(object.volume, 10);
                else if (typeof object.volume === "number")
                    message.volume = object.volume;
                else if (typeof object.volume === "object")
                    message.volume = new $util.LongBits(object.volume.low >>> 0, object.volume.high >>> 0).toNumber();
            if (object.turnover != null)
                message.turnover = Number(object.turnover);
            if (object.recvTime != null)
                message.recvTime = Number(object.recvTime);
            if (object.type != null)
                message.type = object.type | 0;
            if (object.typeSign != null)
                message.typeSign = object.typeSign | 0;
            if (object.pushDataType != null)
                message.pushDataType = object.pushDataType | 0;
            if (object.timestamp != null)
                message.timestamp = Number(object.timestamp);
            return message;
        };

        /**
         * Creates a plain object from a Ticker message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.Ticker
         * @static
         * @param {Qot_Common.Ticker} message Ticker
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Ticker.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.time = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sequence = options.longs === String ? "0" : 0;
                object.dir = 0;
                object.price = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.volume = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.volume = options.longs === String ? "0" : 0;
                object.turnover = 0;
                object.recvTime = 0;
                object.type = 0;
                object.typeSign = 0;
                object.pushDataType = 0;
                object.timestamp = 0;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.sequence != null && message.hasOwnProperty("sequence"))
                if (typeof message.sequence === "number")
                    object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                else
                    object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
            if (message.dir != null && message.hasOwnProperty("dir"))
                object.dir = message.dir;
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (typeof message.volume === "number")
                    object.volume = options.longs === String ? String(message.volume) : message.volume;
                else
                    object.volume = options.longs === String ? $util.Long.prototype.toString.call(message.volume) : options.longs === Number ? new $util.LongBits(message.volume.low >>> 0, message.volume.high >>> 0).toNumber() : message.volume;
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                object.turnover = options.json && !isFinite(message.turnover) ? String(message.turnover) : message.turnover;
            if (message.recvTime != null && message.hasOwnProperty("recvTime"))
                object.recvTime = options.json && !isFinite(message.recvTime) ? String(message.recvTime) : message.recvTime;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.typeSign != null && message.hasOwnProperty("typeSign"))
                object.typeSign = message.typeSign;
            if (message.pushDataType != null && message.hasOwnProperty("pushDataType"))
                object.pushDataType = message.pushDataType;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            return object;
        };

        /**
         * Converts this Ticker to JSON.
         * @function toJSON
         * @memberof Qot_Common.Ticker
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Ticker.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Ticker;
    })();

    Qot_Common.OrderBookDetail = (function() {

        /**
         * Properties of an OrderBookDetail.
         * @memberof Qot_Common
         * @interface IOrderBookDetail
         * @property {number|Long} orderID OrderBookDetail orderID
         * @property {number|Long} volume OrderBookDetail volume
         */

        /**
         * Constructs a new OrderBookDetail.
         * @memberof Qot_Common
         * @classdesc Represents an OrderBookDetail.
         * @implements IOrderBookDetail
         * @constructor
         * @param {Qot_Common.IOrderBookDetail=} [properties] Properties to set
         */
        function OrderBookDetail(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OrderBookDetail orderID.
         * @member {number|Long} orderID
         * @memberof Qot_Common.OrderBookDetail
         * @instance
         */
        OrderBookDetail.prototype.orderID = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OrderBookDetail volume.
         * @member {number|Long} volume
         * @memberof Qot_Common.OrderBookDetail
         * @instance
         */
        OrderBookDetail.prototype.volume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new OrderBookDetail instance using the specified properties.
         * @function create
         * @memberof Qot_Common.OrderBookDetail
         * @static
         * @param {Qot_Common.IOrderBookDetail=} [properties] Properties to set
         * @returns {Qot_Common.OrderBookDetail} OrderBookDetail instance
         */
        OrderBookDetail.create = function create(properties) {
            return new OrderBookDetail(properties);
        };

        /**
         * Encodes the specified OrderBookDetail message. Does not implicitly {@link Qot_Common.OrderBookDetail.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.OrderBookDetail
         * @static
         * @param {Qot_Common.IOrderBookDetail} message OrderBookDetail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderBookDetail.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.orderID);
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.volume);
            return writer;
        };

        /**
         * Encodes the specified OrderBookDetail message, length delimited. Does not implicitly {@link Qot_Common.OrderBookDetail.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.OrderBookDetail
         * @static
         * @param {Qot_Common.IOrderBookDetail} message OrderBookDetail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderBookDetail.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OrderBookDetail message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.OrderBookDetail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.OrderBookDetail} OrderBookDetail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderBookDetail.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.OrderBookDetail();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.orderID = reader.int64();
                    break;
                case 2:
                    message.volume = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("orderID"))
                throw $util.ProtocolError("missing required 'orderID'", { instance: message });
            if (!message.hasOwnProperty("volume"))
                throw $util.ProtocolError("missing required 'volume'", { instance: message });
            return message;
        };

        /**
         * Decodes an OrderBookDetail message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.OrderBookDetail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.OrderBookDetail} OrderBookDetail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderBookDetail.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OrderBookDetail message.
         * @function verify
         * @memberof Qot_Common.OrderBookDetail
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OrderBookDetail.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.orderID) && !(message.orderID && $util.isInteger(message.orderID.low) && $util.isInteger(message.orderID.high)))
                return "orderID: integer|Long expected";
            if (!$util.isInteger(message.volume) && !(message.volume && $util.isInteger(message.volume.low) && $util.isInteger(message.volume.high)))
                return "volume: integer|Long expected";
            return null;
        };

        /**
         * Creates an OrderBookDetail message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.OrderBookDetail
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.OrderBookDetail} OrderBookDetail
         */
        OrderBookDetail.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.OrderBookDetail)
                return object;
            var message = new $root.Qot_Common.OrderBookDetail();
            if (object.orderID != null)
                if ($util.Long)
                    (message.orderID = $util.Long.fromValue(object.orderID)).unsigned = false;
                else if (typeof object.orderID === "string")
                    message.orderID = parseInt(object.orderID, 10);
                else if (typeof object.orderID === "number")
                    message.orderID = object.orderID;
                else if (typeof object.orderID === "object")
                    message.orderID = new $util.LongBits(object.orderID.low >>> 0, object.orderID.high >>> 0).toNumber();
            if (object.volume != null)
                if ($util.Long)
                    (message.volume = $util.Long.fromValue(object.volume)).unsigned = false;
                else if (typeof object.volume === "string")
                    message.volume = parseInt(object.volume, 10);
                else if (typeof object.volume === "number")
                    message.volume = object.volume;
                else if (typeof object.volume === "object")
                    message.volume = new $util.LongBits(object.volume.low >>> 0, object.volume.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an OrderBookDetail message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.OrderBookDetail
         * @static
         * @param {Qot_Common.OrderBookDetail} message OrderBookDetail
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OrderBookDetail.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.orderID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.orderID = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.volume = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.volume = options.longs === String ? "0" : 0;
            }
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (typeof message.orderID === "number")
                    object.orderID = options.longs === String ? String(message.orderID) : message.orderID;
                else
                    object.orderID = options.longs === String ? $util.Long.prototype.toString.call(message.orderID) : options.longs === Number ? new $util.LongBits(message.orderID.low >>> 0, message.orderID.high >>> 0).toNumber() : message.orderID;
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (typeof message.volume === "number")
                    object.volume = options.longs === String ? String(message.volume) : message.volume;
                else
                    object.volume = options.longs === String ? $util.Long.prototype.toString.call(message.volume) : options.longs === Number ? new $util.LongBits(message.volume.low >>> 0, message.volume.high >>> 0).toNumber() : message.volume;
            return object;
        };

        /**
         * Converts this OrderBookDetail to JSON.
         * @function toJSON
         * @memberof Qot_Common.OrderBookDetail
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OrderBookDetail.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OrderBookDetail;
    })();

    Qot_Common.OrderBook = (function() {

        /**
         * Properties of an OrderBook.
         * @memberof Qot_Common
         * @interface IOrderBook
         * @property {number} price OrderBook price
         * @property {number|Long} volume OrderBook volume
         * @property {number} orederCount OrderBook orederCount
         * @property {Array.<Qot_Common.IOrderBookDetail>|null} [detailList] OrderBook detailList
         */

        /**
         * Constructs a new OrderBook.
         * @memberof Qot_Common
         * @classdesc Represents an OrderBook.
         * @implements IOrderBook
         * @constructor
         * @param {Qot_Common.IOrderBook=} [properties] Properties to set
         */
        function OrderBook(properties) {
            this.detailList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OrderBook price.
         * @member {number} price
         * @memberof Qot_Common.OrderBook
         * @instance
         */
        OrderBook.prototype.price = 0;

        /**
         * OrderBook volume.
         * @member {number|Long} volume
         * @memberof Qot_Common.OrderBook
         * @instance
         */
        OrderBook.prototype.volume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OrderBook orederCount.
         * @member {number} orederCount
         * @memberof Qot_Common.OrderBook
         * @instance
         */
        OrderBook.prototype.orederCount = 0;

        /**
         * OrderBook detailList.
         * @member {Array.<Qot_Common.IOrderBookDetail>} detailList
         * @memberof Qot_Common.OrderBook
         * @instance
         */
        OrderBook.prototype.detailList = $util.emptyArray;

        /**
         * Creates a new OrderBook instance using the specified properties.
         * @function create
         * @memberof Qot_Common.OrderBook
         * @static
         * @param {Qot_Common.IOrderBook=} [properties] Properties to set
         * @returns {Qot_Common.OrderBook} OrderBook instance
         */
        OrderBook.create = function create(properties) {
            return new OrderBook(properties);
        };

        /**
         * Encodes the specified OrderBook message. Does not implicitly {@link Qot_Common.OrderBook.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.OrderBook
         * @static
         * @param {Qot_Common.IOrderBook} message OrderBook message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderBook.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.price);
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.volume);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.orederCount);
            if (message.detailList != null && message.detailList.length)
                for (var i = 0; i < message.detailList.length; ++i)
                    $root.Qot_Common.OrderBookDetail.encode(message.detailList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified OrderBook message, length delimited. Does not implicitly {@link Qot_Common.OrderBook.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.OrderBook
         * @static
         * @param {Qot_Common.IOrderBook} message OrderBook message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderBook.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OrderBook message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.OrderBook
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.OrderBook} OrderBook
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderBook.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.OrderBook();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.price = reader.double();
                    break;
                case 2:
                    message.volume = reader.int64();
                    break;
                case 3:
                    message.orederCount = reader.int32();
                    break;
                case 4:
                    if (!(message.detailList && message.detailList.length))
                        message.detailList = [];
                    message.detailList.push($root.Qot_Common.OrderBookDetail.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("price"))
                throw $util.ProtocolError("missing required 'price'", { instance: message });
            if (!message.hasOwnProperty("volume"))
                throw $util.ProtocolError("missing required 'volume'", { instance: message });
            if (!message.hasOwnProperty("orederCount"))
                throw $util.ProtocolError("missing required 'orederCount'", { instance: message });
            return message;
        };

        /**
         * Decodes an OrderBook message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.OrderBook
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.OrderBook} OrderBook
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderBook.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OrderBook message.
         * @function verify
         * @memberof Qot_Common.OrderBook
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OrderBook.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.price !== "number")
                return "price: number expected";
            if (!$util.isInteger(message.volume) && !(message.volume && $util.isInteger(message.volume.low) && $util.isInteger(message.volume.high)))
                return "volume: integer|Long expected";
            if (!$util.isInteger(message.orederCount))
                return "orederCount: integer expected";
            if (message.detailList != null && message.hasOwnProperty("detailList")) {
                if (!Array.isArray(message.detailList))
                    return "detailList: array expected";
                for (var i = 0; i < message.detailList.length; ++i) {
                    var error = $root.Qot_Common.OrderBookDetail.verify(message.detailList[i]);
                    if (error)
                        return "detailList." + error;
                }
            }
            return null;
        };

        /**
         * Creates an OrderBook message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.OrderBook
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.OrderBook} OrderBook
         */
        OrderBook.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.OrderBook)
                return object;
            var message = new $root.Qot_Common.OrderBook();
            if (object.price != null)
                message.price = Number(object.price);
            if (object.volume != null)
                if ($util.Long)
                    (message.volume = $util.Long.fromValue(object.volume)).unsigned = false;
                else if (typeof object.volume === "string")
                    message.volume = parseInt(object.volume, 10);
                else if (typeof object.volume === "number")
                    message.volume = object.volume;
                else if (typeof object.volume === "object")
                    message.volume = new $util.LongBits(object.volume.low >>> 0, object.volume.high >>> 0).toNumber();
            if (object.orederCount != null)
                message.orederCount = object.orederCount | 0;
            if (object.detailList) {
                if (!Array.isArray(object.detailList))
                    throw TypeError(".Qot_Common.OrderBook.detailList: array expected");
                message.detailList = [];
                for (var i = 0; i < object.detailList.length; ++i) {
                    if (typeof object.detailList[i] !== "object")
                        throw TypeError(".Qot_Common.OrderBook.detailList: object expected");
                    message.detailList[i] = $root.Qot_Common.OrderBookDetail.fromObject(object.detailList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an OrderBook message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.OrderBook
         * @static
         * @param {Qot_Common.OrderBook} message OrderBook
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OrderBook.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.detailList = [];
            if (options.defaults) {
                object.price = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.volume = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.volume = options.longs === String ? "0" : 0;
                object.orederCount = 0;
            }
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (typeof message.volume === "number")
                    object.volume = options.longs === String ? String(message.volume) : message.volume;
                else
                    object.volume = options.longs === String ? $util.Long.prototype.toString.call(message.volume) : options.longs === Number ? new $util.LongBits(message.volume.low >>> 0, message.volume.high >>> 0).toNumber() : message.volume;
            if (message.orederCount != null && message.hasOwnProperty("orederCount"))
                object.orederCount = message.orederCount;
            if (message.detailList && message.detailList.length) {
                object.detailList = [];
                for (var j = 0; j < message.detailList.length; ++j)
                    object.detailList[j] = $root.Qot_Common.OrderBookDetail.toObject(message.detailList[j], options);
            }
            return object;
        };

        /**
         * Converts this OrderBook to JSON.
         * @function toJSON
         * @memberof Qot_Common.OrderBook
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OrderBook.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OrderBook;
    })();

    Qot_Common.OrderDetail = (function() {

        /**
         * Properties of an OrderDetail.
         * @memberof Qot_Common
         * @interface IOrderDetail
         * @property {number} orderCount OrderDetail orderCount
         * @property {Array.<number>|null} [orderVol] OrderDetail orderVol
         */

        /**
         * Constructs a new OrderDetail.
         * @memberof Qot_Common
         * @classdesc Represents an OrderDetail.
         * @implements IOrderDetail
         * @constructor
         * @param {Qot_Common.IOrderDetail=} [properties] Properties to set
         */
        function OrderDetail(properties) {
            this.orderVol = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OrderDetail orderCount.
         * @member {number} orderCount
         * @memberof Qot_Common.OrderDetail
         * @instance
         */
        OrderDetail.prototype.orderCount = 0;

        /**
         * OrderDetail orderVol.
         * @member {Array.<number>} orderVol
         * @memberof Qot_Common.OrderDetail
         * @instance
         */
        OrderDetail.prototype.orderVol = $util.emptyArray;

        /**
         * Creates a new OrderDetail instance using the specified properties.
         * @function create
         * @memberof Qot_Common.OrderDetail
         * @static
         * @param {Qot_Common.IOrderDetail=} [properties] Properties to set
         * @returns {Qot_Common.OrderDetail} OrderDetail instance
         */
        OrderDetail.create = function create(properties) {
            return new OrderDetail(properties);
        };

        /**
         * Encodes the specified OrderDetail message. Does not implicitly {@link Qot_Common.OrderDetail.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.OrderDetail
         * @static
         * @param {Qot_Common.IOrderDetail} message OrderDetail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderDetail.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.orderCount);
            if (message.orderVol != null && message.orderVol.length)
                for (var i = 0; i < message.orderVol.length; ++i)
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.orderVol[i]);
            return writer;
        };

        /**
         * Encodes the specified OrderDetail message, length delimited. Does not implicitly {@link Qot_Common.OrderDetail.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.OrderDetail
         * @static
         * @param {Qot_Common.IOrderDetail} message OrderDetail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderDetail.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OrderDetail message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.OrderDetail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.OrderDetail} OrderDetail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderDetail.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.OrderDetail();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.orderCount = reader.int32();
                    break;
                case 2:
                    if (!(message.orderVol && message.orderVol.length))
                        message.orderVol = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.orderVol.push(reader.double());
                    } else
                        message.orderVol.push(reader.double());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("orderCount"))
                throw $util.ProtocolError("missing required 'orderCount'", { instance: message });
            return message;
        };

        /**
         * Decodes an OrderDetail message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.OrderDetail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.OrderDetail} OrderDetail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderDetail.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OrderDetail message.
         * @function verify
         * @memberof Qot_Common.OrderDetail
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OrderDetail.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.orderCount))
                return "orderCount: integer expected";
            if (message.orderVol != null && message.hasOwnProperty("orderVol")) {
                if (!Array.isArray(message.orderVol))
                    return "orderVol: array expected";
                for (var i = 0; i < message.orderVol.length; ++i)
                    if (typeof message.orderVol[i] !== "number")
                        return "orderVol: number[] expected";
            }
            return null;
        };

        /**
         * Creates an OrderDetail message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.OrderDetail
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.OrderDetail} OrderDetail
         */
        OrderDetail.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.OrderDetail)
                return object;
            var message = new $root.Qot_Common.OrderDetail();
            if (object.orderCount != null)
                message.orderCount = object.orderCount | 0;
            if (object.orderVol) {
                if (!Array.isArray(object.orderVol))
                    throw TypeError(".Qot_Common.OrderDetail.orderVol: array expected");
                message.orderVol = [];
                for (var i = 0; i < object.orderVol.length; ++i)
                    message.orderVol[i] = Number(object.orderVol[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from an OrderDetail message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.OrderDetail
         * @static
         * @param {Qot_Common.OrderDetail} message OrderDetail
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OrderDetail.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.orderVol = [];
            if (options.defaults)
                object.orderCount = 0;
            if (message.orderCount != null && message.hasOwnProperty("orderCount"))
                object.orderCount = message.orderCount;
            if (message.orderVol && message.orderVol.length) {
                object.orderVol = [];
                for (var j = 0; j < message.orderVol.length; ++j)
                    object.orderVol[j] = options.json && !isFinite(message.orderVol[j]) ? String(message.orderVol[j]) : message.orderVol[j];
            }
            return object;
        };

        /**
         * Converts this OrderDetail to JSON.
         * @function toJSON
         * @memberof Qot_Common.OrderDetail
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OrderDetail.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OrderDetail;
    })();

    Qot_Common.ShareHoldingChange = (function() {

        /**
         * Properties of a ShareHoldingChange.
         * @memberof Qot_Common
         * @interface IShareHoldingChange
         * @property {string} holderName ShareHoldingChange holderName
         * @property {number} holdingQty ShareHoldingChange holdingQty
         * @property {number} holdingRatio ShareHoldingChange holdingRatio
         * @property {number} changeQty ShareHoldingChange changeQty
         * @property {number} changeRatio ShareHoldingChange changeRatio
         * @property {string} time ShareHoldingChange time
         * @property {number|null} [timestamp] ShareHoldingChange timestamp
         */

        /**
         * Constructs a new ShareHoldingChange.
         * @memberof Qot_Common
         * @classdesc Represents a ShareHoldingChange.
         * @implements IShareHoldingChange
         * @constructor
         * @param {Qot_Common.IShareHoldingChange=} [properties] Properties to set
         */
        function ShareHoldingChange(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShareHoldingChange holderName.
         * @member {string} holderName
         * @memberof Qot_Common.ShareHoldingChange
         * @instance
         */
        ShareHoldingChange.prototype.holderName = "";

        /**
         * ShareHoldingChange holdingQty.
         * @member {number} holdingQty
         * @memberof Qot_Common.ShareHoldingChange
         * @instance
         */
        ShareHoldingChange.prototype.holdingQty = 0;

        /**
         * ShareHoldingChange holdingRatio.
         * @member {number} holdingRatio
         * @memberof Qot_Common.ShareHoldingChange
         * @instance
         */
        ShareHoldingChange.prototype.holdingRatio = 0;

        /**
         * ShareHoldingChange changeQty.
         * @member {number} changeQty
         * @memberof Qot_Common.ShareHoldingChange
         * @instance
         */
        ShareHoldingChange.prototype.changeQty = 0;

        /**
         * ShareHoldingChange changeRatio.
         * @member {number} changeRatio
         * @memberof Qot_Common.ShareHoldingChange
         * @instance
         */
        ShareHoldingChange.prototype.changeRatio = 0;

        /**
         * ShareHoldingChange time.
         * @member {string} time
         * @memberof Qot_Common.ShareHoldingChange
         * @instance
         */
        ShareHoldingChange.prototype.time = "";

        /**
         * ShareHoldingChange timestamp.
         * @member {number} timestamp
         * @memberof Qot_Common.ShareHoldingChange
         * @instance
         */
        ShareHoldingChange.prototype.timestamp = 0;

        /**
         * Creates a new ShareHoldingChange instance using the specified properties.
         * @function create
         * @memberof Qot_Common.ShareHoldingChange
         * @static
         * @param {Qot_Common.IShareHoldingChange=} [properties] Properties to set
         * @returns {Qot_Common.ShareHoldingChange} ShareHoldingChange instance
         */
        ShareHoldingChange.create = function create(properties) {
            return new ShareHoldingChange(properties);
        };

        /**
         * Encodes the specified ShareHoldingChange message. Does not implicitly {@link Qot_Common.ShareHoldingChange.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.ShareHoldingChange
         * @static
         * @param {Qot_Common.IShareHoldingChange} message ShareHoldingChange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShareHoldingChange.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.holderName);
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.holdingQty);
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.holdingRatio);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.changeQty);
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.changeRatio);
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.time);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified ShareHoldingChange message, length delimited. Does not implicitly {@link Qot_Common.ShareHoldingChange.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.ShareHoldingChange
         * @static
         * @param {Qot_Common.IShareHoldingChange} message ShareHoldingChange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShareHoldingChange.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShareHoldingChange message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.ShareHoldingChange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.ShareHoldingChange} ShareHoldingChange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShareHoldingChange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.ShareHoldingChange();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.holderName = reader.string();
                    break;
                case 2:
                    message.holdingQty = reader.double();
                    break;
                case 3:
                    message.holdingRatio = reader.double();
                    break;
                case 4:
                    message.changeQty = reader.double();
                    break;
                case 5:
                    message.changeRatio = reader.double();
                    break;
                case 6:
                    message.time = reader.string();
                    break;
                case 7:
                    message.timestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("holderName"))
                throw $util.ProtocolError("missing required 'holderName'", { instance: message });
            if (!message.hasOwnProperty("holdingQty"))
                throw $util.ProtocolError("missing required 'holdingQty'", { instance: message });
            if (!message.hasOwnProperty("holdingRatio"))
                throw $util.ProtocolError("missing required 'holdingRatio'", { instance: message });
            if (!message.hasOwnProperty("changeQty"))
                throw $util.ProtocolError("missing required 'changeQty'", { instance: message });
            if (!message.hasOwnProperty("changeRatio"))
                throw $util.ProtocolError("missing required 'changeRatio'", { instance: message });
            if (!message.hasOwnProperty("time"))
                throw $util.ProtocolError("missing required 'time'", { instance: message });
            return message;
        };

        /**
         * Decodes a ShareHoldingChange message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.ShareHoldingChange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.ShareHoldingChange} ShareHoldingChange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShareHoldingChange.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShareHoldingChange message.
         * @function verify
         * @memberof Qot_Common.ShareHoldingChange
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShareHoldingChange.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.holderName))
                return "holderName: string expected";
            if (typeof message.holdingQty !== "number")
                return "holdingQty: number expected";
            if (typeof message.holdingRatio !== "number")
                return "holdingRatio: number expected";
            if (typeof message.changeQty !== "number")
                return "changeQty: number expected";
            if (typeof message.changeRatio !== "number")
                return "changeRatio: number expected";
            if (!$util.isString(message.time))
                return "time: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp !== "number")
                    return "timestamp: number expected";
            return null;
        };

        /**
         * Creates a ShareHoldingChange message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.ShareHoldingChange
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.ShareHoldingChange} ShareHoldingChange
         */
        ShareHoldingChange.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.ShareHoldingChange)
                return object;
            var message = new $root.Qot_Common.ShareHoldingChange();
            if (object.holderName != null)
                message.holderName = String(object.holderName);
            if (object.holdingQty != null)
                message.holdingQty = Number(object.holdingQty);
            if (object.holdingRatio != null)
                message.holdingRatio = Number(object.holdingRatio);
            if (object.changeQty != null)
                message.changeQty = Number(object.changeQty);
            if (object.changeRatio != null)
                message.changeRatio = Number(object.changeRatio);
            if (object.time != null)
                message.time = String(object.time);
            if (object.timestamp != null)
                message.timestamp = Number(object.timestamp);
            return message;
        };

        /**
         * Creates a plain object from a ShareHoldingChange message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.ShareHoldingChange
         * @static
         * @param {Qot_Common.ShareHoldingChange} message ShareHoldingChange
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShareHoldingChange.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.holderName = "";
                object.holdingQty = 0;
                object.holdingRatio = 0;
                object.changeQty = 0;
                object.changeRatio = 0;
                object.time = "";
                object.timestamp = 0;
            }
            if (message.holderName != null && message.hasOwnProperty("holderName"))
                object.holderName = message.holderName;
            if (message.holdingQty != null && message.hasOwnProperty("holdingQty"))
                object.holdingQty = options.json && !isFinite(message.holdingQty) ? String(message.holdingQty) : message.holdingQty;
            if (message.holdingRatio != null && message.hasOwnProperty("holdingRatio"))
                object.holdingRatio = options.json && !isFinite(message.holdingRatio) ? String(message.holdingRatio) : message.holdingRatio;
            if (message.changeQty != null && message.hasOwnProperty("changeQty"))
                object.changeQty = options.json && !isFinite(message.changeQty) ? String(message.changeQty) : message.changeQty;
            if (message.changeRatio != null && message.hasOwnProperty("changeRatio"))
                object.changeRatio = options.json && !isFinite(message.changeRatio) ? String(message.changeRatio) : message.changeRatio;
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            return object;
        };

        /**
         * Converts this ShareHoldingChange to JSON.
         * @function toJSON
         * @memberof Qot_Common.ShareHoldingChange
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShareHoldingChange.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ShareHoldingChange;
    })();

    Qot_Common.SubInfo = (function() {

        /**
         * Properties of a SubInfo.
         * @memberof Qot_Common
         * @interface ISubInfo
         * @property {number} subType SubInfo subType
         * @property {Array.<Qot_Common.ISecurity>|null} [securityList] SubInfo securityList
         */

        /**
         * Constructs a new SubInfo.
         * @memberof Qot_Common
         * @classdesc Represents a SubInfo.
         * @implements ISubInfo
         * @constructor
         * @param {Qot_Common.ISubInfo=} [properties] Properties to set
         */
        function SubInfo(properties) {
            this.securityList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubInfo subType.
         * @member {number} subType
         * @memberof Qot_Common.SubInfo
         * @instance
         */
        SubInfo.prototype.subType = 0;

        /**
         * SubInfo securityList.
         * @member {Array.<Qot_Common.ISecurity>} securityList
         * @memberof Qot_Common.SubInfo
         * @instance
         */
        SubInfo.prototype.securityList = $util.emptyArray;

        /**
         * Creates a new SubInfo instance using the specified properties.
         * @function create
         * @memberof Qot_Common.SubInfo
         * @static
         * @param {Qot_Common.ISubInfo=} [properties] Properties to set
         * @returns {Qot_Common.SubInfo} SubInfo instance
         */
        SubInfo.create = function create(properties) {
            return new SubInfo(properties);
        };

        /**
         * Encodes the specified SubInfo message. Does not implicitly {@link Qot_Common.SubInfo.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.SubInfo
         * @static
         * @param {Qot_Common.ISubInfo} message SubInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.subType);
            if (message.securityList != null && message.securityList.length)
                for (var i = 0; i < message.securityList.length; ++i)
                    $root.Qot_Common.Security.encode(message.securityList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SubInfo message, length delimited. Does not implicitly {@link Qot_Common.SubInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.SubInfo
         * @static
         * @param {Qot_Common.ISubInfo} message SubInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.SubInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.SubInfo} SubInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.SubInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.subType = reader.int32();
                    break;
                case 2:
                    if (!(message.securityList && message.securityList.length))
                        message.securityList = [];
                    message.securityList.push($root.Qot_Common.Security.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("subType"))
                throw $util.ProtocolError("missing required 'subType'", { instance: message });
            return message;
        };

        /**
         * Decodes a SubInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.SubInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.SubInfo} SubInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubInfo message.
         * @function verify
         * @memberof Qot_Common.SubInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.subType))
                return "subType: integer expected";
            if (message.securityList != null && message.hasOwnProperty("securityList")) {
                if (!Array.isArray(message.securityList))
                    return "securityList: array expected";
                for (var i = 0; i < message.securityList.length; ++i) {
                    var error = $root.Qot_Common.Security.verify(message.securityList[i]);
                    if (error)
                        return "securityList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SubInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.SubInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.SubInfo} SubInfo
         */
        SubInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.SubInfo)
                return object;
            var message = new $root.Qot_Common.SubInfo();
            if (object.subType != null)
                message.subType = object.subType | 0;
            if (object.securityList) {
                if (!Array.isArray(object.securityList))
                    throw TypeError(".Qot_Common.SubInfo.securityList: array expected");
                message.securityList = [];
                for (var i = 0; i < object.securityList.length; ++i) {
                    if (typeof object.securityList[i] !== "object")
                        throw TypeError(".Qot_Common.SubInfo.securityList: object expected");
                    message.securityList[i] = $root.Qot_Common.Security.fromObject(object.securityList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SubInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.SubInfo
         * @static
         * @param {Qot_Common.SubInfo} message SubInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.securityList = [];
            if (options.defaults)
                object.subType = 0;
            if (message.subType != null && message.hasOwnProperty("subType"))
                object.subType = message.subType;
            if (message.securityList && message.securityList.length) {
                object.securityList = [];
                for (var j = 0; j < message.securityList.length; ++j)
                    object.securityList[j] = $root.Qot_Common.Security.toObject(message.securityList[j], options);
            }
            return object;
        };

        /**
         * Converts this SubInfo to JSON.
         * @function toJSON
         * @memberof Qot_Common.SubInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SubInfo;
    })();

    Qot_Common.ConnSubInfo = (function() {

        /**
         * Properties of a ConnSubInfo.
         * @memberof Qot_Common
         * @interface IConnSubInfo
         * @property {Array.<Qot_Common.ISubInfo>|null} [subInfoList] ConnSubInfo subInfoList
         * @property {number} usedQuota ConnSubInfo usedQuota
         * @property {boolean} isOwnConnData ConnSubInfo isOwnConnData
         */

        /**
         * Constructs a new ConnSubInfo.
         * @memberof Qot_Common
         * @classdesc Represents a ConnSubInfo.
         * @implements IConnSubInfo
         * @constructor
         * @param {Qot_Common.IConnSubInfo=} [properties] Properties to set
         */
        function ConnSubInfo(properties) {
            this.subInfoList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConnSubInfo subInfoList.
         * @member {Array.<Qot_Common.ISubInfo>} subInfoList
         * @memberof Qot_Common.ConnSubInfo
         * @instance
         */
        ConnSubInfo.prototype.subInfoList = $util.emptyArray;

        /**
         * ConnSubInfo usedQuota.
         * @member {number} usedQuota
         * @memberof Qot_Common.ConnSubInfo
         * @instance
         */
        ConnSubInfo.prototype.usedQuota = 0;

        /**
         * ConnSubInfo isOwnConnData.
         * @member {boolean} isOwnConnData
         * @memberof Qot_Common.ConnSubInfo
         * @instance
         */
        ConnSubInfo.prototype.isOwnConnData = false;

        /**
         * Creates a new ConnSubInfo instance using the specified properties.
         * @function create
         * @memberof Qot_Common.ConnSubInfo
         * @static
         * @param {Qot_Common.IConnSubInfo=} [properties] Properties to set
         * @returns {Qot_Common.ConnSubInfo} ConnSubInfo instance
         */
        ConnSubInfo.create = function create(properties) {
            return new ConnSubInfo(properties);
        };

        /**
         * Encodes the specified ConnSubInfo message. Does not implicitly {@link Qot_Common.ConnSubInfo.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.ConnSubInfo
         * @static
         * @param {Qot_Common.IConnSubInfo} message ConnSubInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnSubInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.subInfoList != null && message.subInfoList.length)
                for (var i = 0; i < message.subInfoList.length; ++i)
                    $root.Qot_Common.SubInfo.encode(message.subInfoList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.usedQuota);
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isOwnConnData);
            return writer;
        };

        /**
         * Encodes the specified ConnSubInfo message, length delimited. Does not implicitly {@link Qot_Common.ConnSubInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.ConnSubInfo
         * @static
         * @param {Qot_Common.IConnSubInfo} message ConnSubInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnSubInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConnSubInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.ConnSubInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.ConnSubInfo} ConnSubInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnSubInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.ConnSubInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.subInfoList && message.subInfoList.length))
                        message.subInfoList = [];
                    message.subInfoList.push($root.Qot_Common.SubInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.usedQuota = reader.int32();
                    break;
                case 3:
                    message.isOwnConnData = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("usedQuota"))
                throw $util.ProtocolError("missing required 'usedQuota'", { instance: message });
            if (!message.hasOwnProperty("isOwnConnData"))
                throw $util.ProtocolError("missing required 'isOwnConnData'", { instance: message });
            return message;
        };

        /**
         * Decodes a ConnSubInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.ConnSubInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.ConnSubInfo} ConnSubInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnSubInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConnSubInfo message.
         * @function verify
         * @memberof Qot_Common.ConnSubInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConnSubInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.subInfoList != null && message.hasOwnProperty("subInfoList")) {
                if (!Array.isArray(message.subInfoList))
                    return "subInfoList: array expected";
                for (var i = 0; i < message.subInfoList.length; ++i) {
                    var error = $root.Qot_Common.SubInfo.verify(message.subInfoList[i]);
                    if (error)
                        return "subInfoList." + error;
                }
            }
            if (!$util.isInteger(message.usedQuota))
                return "usedQuota: integer expected";
            if (typeof message.isOwnConnData !== "boolean")
                return "isOwnConnData: boolean expected";
            return null;
        };

        /**
         * Creates a ConnSubInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.ConnSubInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.ConnSubInfo} ConnSubInfo
         */
        ConnSubInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.ConnSubInfo)
                return object;
            var message = new $root.Qot_Common.ConnSubInfo();
            if (object.subInfoList) {
                if (!Array.isArray(object.subInfoList))
                    throw TypeError(".Qot_Common.ConnSubInfo.subInfoList: array expected");
                message.subInfoList = [];
                for (var i = 0; i < object.subInfoList.length; ++i) {
                    if (typeof object.subInfoList[i] !== "object")
                        throw TypeError(".Qot_Common.ConnSubInfo.subInfoList: object expected");
                    message.subInfoList[i] = $root.Qot_Common.SubInfo.fromObject(object.subInfoList[i]);
                }
            }
            if (object.usedQuota != null)
                message.usedQuota = object.usedQuota | 0;
            if (object.isOwnConnData != null)
                message.isOwnConnData = Boolean(object.isOwnConnData);
            return message;
        };

        /**
         * Creates a plain object from a ConnSubInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.ConnSubInfo
         * @static
         * @param {Qot_Common.ConnSubInfo} message ConnSubInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConnSubInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.subInfoList = [];
            if (options.defaults) {
                object.usedQuota = 0;
                object.isOwnConnData = false;
            }
            if (message.subInfoList && message.subInfoList.length) {
                object.subInfoList = [];
                for (var j = 0; j < message.subInfoList.length; ++j)
                    object.subInfoList[j] = $root.Qot_Common.SubInfo.toObject(message.subInfoList[j], options);
            }
            if (message.usedQuota != null && message.hasOwnProperty("usedQuota"))
                object.usedQuota = message.usedQuota;
            if (message.isOwnConnData != null && message.hasOwnProperty("isOwnConnData"))
                object.isOwnConnData = message.isOwnConnData;
            return object;
        };

        /**
         * Converts this ConnSubInfo to JSON.
         * @function toJSON
         * @memberof Qot_Common.ConnSubInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConnSubInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConnSubInfo;
    })();

    Qot_Common.PlateInfo = (function() {

        /**
         * Properties of a PlateInfo.
         * @memberof Qot_Common
         * @interface IPlateInfo
         * @property {Qot_Common.ISecurity} plate PlateInfo plate
         * @property {string} name PlateInfo name
         * @property {number|null} [plateType] PlateInfo plateType
         */

        /**
         * Constructs a new PlateInfo.
         * @memberof Qot_Common
         * @classdesc Represents a PlateInfo.
         * @implements IPlateInfo
         * @constructor
         * @param {Qot_Common.IPlateInfo=} [properties] Properties to set
         */
        function PlateInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlateInfo plate.
         * @member {Qot_Common.ISecurity} plate
         * @memberof Qot_Common.PlateInfo
         * @instance
         */
        PlateInfo.prototype.plate = null;

        /**
         * PlateInfo name.
         * @member {string} name
         * @memberof Qot_Common.PlateInfo
         * @instance
         */
        PlateInfo.prototype.name = "";

        /**
         * PlateInfo plateType.
         * @member {number} plateType
         * @memberof Qot_Common.PlateInfo
         * @instance
         */
        PlateInfo.prototype.plateType = 0;

        /**
         * Creates a new PlateInfo instance using the specified properties.
         * @function create
         * @memberof Qot_Common.PlateInfo
         * @static
         * @param {Qot_Common.IPlateInfo=} [properties] Properties to set
         * @returns {Qot_Common.PlateInfo} PlateInfo instance
         */
        PlateInfo.create = function create(properties) {
            return new PlateInfo(properties);
        };

        /**
         * Encodes the specified PlateInfo message. Does not implicitly {@link Qot_Common.PlateInfo.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.PlateInfo
         * @static
         * @param {Qot_Common.IPlateInfo} message PlateInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlateInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.plate, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.plateType != null && message.hasOwnProperty("plateType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.plateType);
            return writer;
        };

        /**
         * Encodes the specified PlateInfo message, length delimited. Does not implicitly {@link Qot_Common.PlateInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.PlateInfo
         * @static
         * @param {Qot_Common.IPlateInfo} message PlateInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlateInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlateInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.PlateInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.PlateInfo} PlateInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlateInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.PlateInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.plate = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.plateType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("plate"))
                throw $util.ProtocolError("missing required 'plate'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            return message;
        };

        /**
         * Decodes a PlateInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.PlateInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.PlateInfo} PlateInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlateInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlateInfo message.
         * @function verify
         * @memberof Qot_Common.PlateInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlateInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.plate);
                if (error)
                    return "plate." + error;
            }
            if (!$util.isString(message.name))
                return "name: string expected";
            if (message.plateType != null && message.hasOwnProperty("plateType"))
                if (!$util.isInteger(message.plateType))
                    return "plateType: integer expected";
            return null;
        };

        /**
         * Creates a PlateInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.PlateInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.PlateInfo} PlateInfo
         */
        PlateInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.PlateInfo)
                return object;
            var message = new $root.Qot_Common.PlateInfo();
            if (object.plate != null) {
                if (typeof object.plate !== "object")
                    throw TypeError(".Qot_Common.PlateInfo.plate: object expected");
                message.plate = $root.Qot_Common.Security.fromObject(object.plate);
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.plateType != null)
                message.plateType = object.plateType | 0;
            return message;
        };

        /**
         * Creates a plain object from a PlateInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.PlateInfo
         * @static
         * @param {Qot_Common.PlateInfo} message PlateInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlateInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.plate = null;
                object.name = "";
                object.plateType = 0;
            }
            if (message.plate != null && message.hasOwnProperty("plate"))
                object.plate = $root.Qot_Common.Security.toObject(message.plate, options);
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.plateType != null && message.hasOwnProperty("plateType"))
                object.plateType = message.plateType;
            return object;
        };

        /**
         * Converts this PlateInfo to JSON.
         * @function toJSON
         * @memberof Qot_Common.PlateInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlateInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlateInfo;
    })();

    Qot_Common.Rehab = (function() {

        /**
         * Properties of a Rehab.
         * @memberof Qot_Common
         * @interface IRehab
         * @property {string} time Rehab time
         * @property {number|Long} companyActFlag Rehab companyActFlag
         * @property {number} fwdFactorA Rehab fwdFactorA
         * @property {number} fwdFactorB Rehab fwdFactorB
         * @property {number} bwdFactorA Rehab bwdFactorA
         * @property {number} bwdFactorB Rehab bwdFactorB
         * @property {number|null} [splitBase] Rehab splitBase
         * @property {number|null} [splitErt] Rehab splitErt
         * @property {number|null} [joinBase] Rehab joinBase
         * @property {number|null} [joinErt] Rehab joinErt
         * @property {number|null} [bonusBase] Rehab bonusBase
         * @property {number|null} [bonusErt] Rehab bonusErt
         * @property {number|null} [transferBase] Rehab transferBase
         * @property {number|null} [transferErt] Rehab transferErt
         * @property {number|null} [allotBase] Rehab allotBase
         * @property {number|null} [allotErt] Rehab allotErt
         * @property {number|null} [allotPrice] Rehab allotPrice
         * @property {number|null} [addBase] Rehab addBase
         * @property {number|null} [addErt] Rehab addErt
         * @property {number|null} [addPrice] Rehab addPrice
         * @property {number|null} [dividend] Rehab dividend
         * @property {number|null} [spDividend] Rehab spDividend
         * @property {number|null} [timestamp] Rehab timestamp
         */

        /**
         * Constructs a new Rehab.
         * @memberof Qot_Common
         * @classdesc Represents a Rehab.
         * @implements IRehab
         * @constructor
         * @param {Qot_Common.IRehab=} [properties] Properties to set
         */
        function Rehab(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Rehab time.
         * @member {string} time
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.time = "";

        /**
         * Rehab companyActFlag.
         * @member {number|Long} companyActFlag
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.companyActFlag = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Rehab fwdFactorA.
         * @member {number} fwdFactorA
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.fwdFactorA = 0;

        /**
         * Rehab fwdFactorB.
         * @member {number} fwdFactorB
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.fwdFactorB = 0;

        /**
         * Rehab bwdFactorA.
         * @member {number} bwdFactorA
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.bwdFactorA = 0;

        /**
         * Rehab bwdFactorB.
         * @member {number} bwdFactorB
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.bwdFactorB = 0;

        /**
         * Rehab splitBase.
         * @member {number} splitBase
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.splitBase = 0;

        /**
         * Rehab splitErt.
         * @member {number} splitErt
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.splitErt = 0;

        /**
         * Rehab joinBase.
         * @member {number} joinBase
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.joinBase = 0;

        /**
         * Rehab joinErt.
         * @member {number} joinErt
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.joinErt = 0;

        /**
         * Rehab bonusBase.
         * @member {number} bonusBase
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.bonusBase = 0;

        /**
         * Rehab bonusErt.
         * @member {number} bonusErt
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.bonusErt = 0;

        /**
         * Rehab transferBase.
         * @member {number} transferBase
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.transferBase = 0;

        /**
         * Rehab transferErt.
         * @member {number} transferErt
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.transferErt = 0;

        /**
         * Rehab allotBase.
         * @member {number} allotBase
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.allotBase = 0;

        /**
         * Rehab allotErt.
         * @member {number} allotErt
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.allotErt = 0;

        /**
         * Rehab allotPrice.
         * @member {number} allotPrice
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.allotPrice = 0;

        /**
         * Rehab addBase.
         * @member {number} addBase
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.addBase = 0;

        /**
         * Rehab addErt.
         * @member {number} addErt
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.addErt = 0;

        /**
         * Rehab addPrice.
         * @member {number} addPrice
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.addPrice = 0;

        /**
         * Rehab dividend.
         * @member {number} dividend
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.dividend = 0;

        /**
         * Rehab spDividend.
         * @member {number} spDividend
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.spDividend = 0;

        /**
         * Rehab timestamp.
         * @member {number} timestamp
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.timestamp = 0;

        /**
         * Creates a new Rehab instance using the specified properties.
         * @function create
         * @memberof Qot_Common.Rehab
         * @static
         * @param {Qot_Common.IRehab=} [properties] Properties to set
         * @returns {Qot_Common.Rehab} Rehab instance
         */
        Rehab.create = function create(properties) {
            return new Rehab(properties);
        };

        /**
         * Encodes the specified Rehab message. Does not implicitly {@link Qot_Common.Rehab.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.Rehab
         * @static
         * @param {Qot_Common.IRehab} message Rehab message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Rehab.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.time);
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.companyActFlag);
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.fwdFactorA);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.fwdFactorB);
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.bwdFactorA);
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.bwdFactorB);
            if (message.splitBase != null && message.hasOwnProperty("splitBase"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.splitBase);
            if (message.splitErt != null && message.hasOwnProperty("splitErt"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.splitErt);
            if (message.joinBase != null && message.hasOwnProperty("joinBase"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.joinBase);
            if (message.joinErt != null && message.hasOwnProperty("joinErt"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.joinErt);
            if (message.bonusBase != null && message.hasOwnProperty("bonusBase"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.bonusBase);
            if (message.bonusErt != null && message.hasOwnProperty("bonusErt"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.bonusErt);
            if (message.transferBase != null && message.hasOwnProperty("transferBase"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.transferBase);
            if (message.transferErt != null && message.hasOwnProperty("transferErt"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.transferErt);
            if (message.allotBase != null && message.hasOwnProperty("allotBase"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.allotBase);
            if (message.allotErt != null && message.hasOwnProperty("allotErt"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.allotErt);
            if (message.allotPrice != null && message.hasOwnProperty("allotPrice"))
                writer.uint32(/* id 17, wireType 1 =*/137).double(message.allotPrice);
            if (message.addBase != null && message.hasOwnProperty("addBase"))
                writer.uint32(/* id 18, wireType 0 =*/144).int32(message.addBase);
            if (message.addErt != null && message.hasOwnProperty("addErt"))
                writer.uint32(/* id 19, wireType 0 =*/152).int32(message.addErt);
            if (message.addPrice != null && message.hasOwnProperty("addPrice"))
                writer.uint32(/* id 20, wireType 1 =*/161).double(message.addPrice);
            if (message.dividend != null && message.hasOwnProperty("dividend"))
                writer.uint32(/* id 21, wireType 1 =*/169).double(message.dividend);
            if (message.spDividend != null && message.hasOwnProperty("spDividend"))
                writer.uint32(/* id 22, wireType 1 =*/177).double(message.spDividend);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 23, wireType 1 =*/185).double(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified Rehab message, length delimited. Does not implicitly {@link Qot_Common.Rehab.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.Rehab
         * @static
         * @param {Qot_Common.IRehab} message Rehab message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Rehab.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Rehab message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.Rehab
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.Rehab} Rehab
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Rehab.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.Rehab();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.string();
                    break;
                case 2:
                    message.companyActFlag = reader.int64();
                    break;
                case 3:
                    message.fwdFactorA = reader.double();
                    break;
                case 4:
                    message.fwdFactorB = reader.double();
                    break;
                case 5:
                    message.bwdFactorA = reader.double();
                    break;
                case 6:
                    message.bwdFactorB = reader.double();
                    break;
                case 7:
                    message.splitBase = reader.int32();
                    break;
                case 8:
                    message.splitErt = reader.int32();
                    break;
                case 9:
                    message.joinBase = reader.int32();
                    break;
                case 10:
                    message.joinErt = reader.int32();
                    break;
                case 11:
                    message.bonusBase = reader.int32();
                    break;
                case 12:
                    message.bonusErt = reader.int32();
                    break;
                case 13:
                    message.transferBase = reader.int32();
                    break;
                case 14:
                    message.transferErt = reader.int32();
                    break;
                case 15:
                    message.allotBase = reader.int32();
                    break;
                case 16:
                    message.allotErt = reader.int32();
                    break;
                case 17:
                    message.allotPrice = reader.double();
                    break;
                case 18:
                    message.addBase = reader.int32();
                    break;
                case 19:
                    message.addErt = reader.int32();
                    break;
                case 20:
                    message.addPrice = reader.double();
                    break;
                case 21:
                    message.dividend = reader.double();
                    break;
                case 22:
                    message.spDividend = reader.double();
                    break;
                case 23:
                    message.timestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("time"))
                throw $util.ProtocolError("missing required 'time'", { instance: message });
            if (!message.hasOwnProperty("companyActFlag"))
                throw $util.ProtocolError("missing required 'companyActFlag'", { instance: message });
            if (!message.hasOwnProperty("fwdFactorA"))
                throw $util.ProtocolError("missing required 'fwdFactorA'", { instance: message });
            if (!message.hasOwnProperty("fwdFactorB"))
                throw $util.ProtocolError("missing required 'fwdFactorB'", { instance: message });
            if (!message.hasOwnProperty("bwdFactorA"))
                throw $util.ProtocolError("missing required 'bwdFactorA'", { instance: message });
            if (!message.hasOwnProperty("bwdFactorB"))
                throw $util.ProtocolError("missing required 'bwdFactorB'", { instance: message });
            return message;
        };

        /**
         * Decodes a Rehab message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.Rehab
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.Rehab} Rehab
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Rehab.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Rehab message.
         * @function verify
         * @memberof Qot_Common.Rehab
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Rehab.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.time))
                return "time: string expected";
            if (!$util.isInteger(message.companyActFlag) && !(message.companyActFlag && $util.isInteger(message.companyActFlag.low) && $util.isInteger(message.companyActFlag.high)))
                return "companyActFlag: integer|Long expected";
            if (typeof message.fwdFactorA !== "number")
                return "fwdFactorA: number expected";
            if (typeof message.fwdFactorB !== "number")
                return "fwdFactorB: number expected";
            if (typeof message.bwdFactorA !== "number")
                return "bwdFactorA: number expected";
            if (typeof message.bwdFactorB !== "number")
                return "bwdFactorB: number expected";
            if (message.splitBase != null && message.hasOwnProperty("splitBase"))
                if (!$util.isInteger(message.splitBase))
                    return "splitBase: integer expected";
            if (message.splitErt != null && message.hasOwnProperty("splitErt"))
                if (!$util.isInteger(message.splitErt))
                    return "splitErt: integer expected";
            if (message.joinBase != null && message.hasOwnProperty("joinBase"))
                if (!$util.isInteger(message.joinBase))
                    return "joinBase: integer expected";
            if (message.joinErt != null && message.hasOwnProperty("joinErt"))
                if (!$util.isInteger(message.joinErt))
                    return "joinErt: integer expected";
            if (message.bonusBase != null && message.hasOwnProperty("bonusBase"))
                if (!$util.isInteger(message.bonusBase))
                    return "bonusBase: integer expected";
            if (message.bonusErt != null && message.hasOwnProperty("bonusErt"))
                if (!$util.isInteger(message.bonusErt))
                    return "bonusErt: integer expected";
            if (message.transferBase != null && message.hasOwnProperty("transferBase"))
                if (!$util.isInteger(message.transferBase))
                    return "transferBase: integer expected";
            if (message.transferErt != null && message.hasOwnProperty("transferErt"))
                if (!$util.isInteger(message.transferErt))
                    return "transferErt: integer expected";
            if (message.allotBase != null && message.hasOwnProperty("allotBase"))
                if (!$util.isInteger(message.allotBase))
                    return "allotBase: integer expected";
            if (message.allotErt != null && message.hasOwnProperty("allotErt"))
                if (!$util.isInteger(message.allotErt))
                    return "allotErt: integer expected";
            if (message.allotPrice != null && message.hasOwnProperty("allotPrice"))
                if (typeof message.allotPrice !== "number")
                    return "allotPrice: number expected";
            if (message.addBase != null && message.hasOwnProperty("addBase"))
                if (!$util.isInteger(message.addBase))
                    return "addBase: integer expected";
            if (message.addErt != null && message.hasOwnProperty("addErt"))
                if (!$util.isInteger(message.addErt))
                    return "addErt: integer expected";
            if (message.addPrice != null && message.hasOwnProperty("addPrice"))
                if (typeof message.addPrice !== "number")
                    return "addPrice: number expected";
            if (message.dividend != null && message.hasOwnProperty("dividend"))
                if (typeof message.dividend !== "number")
                    return "dividend: number expected";
            if (message.spDividend != null && message.hasOwnProperty("spDividend"))
                if (typeof message.spDividend !== "number")
                    return "spDividend: number expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp !== "number")
                    return "timestamp: number expected";
            return null;
        };

        /**
         * Creates a Rehab message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.Rehab
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.Rehab} Rehab
         */
        Rehab.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.Rehab)
                return object;
            var message = new $root.Qot_Common.Rehab();
            if (object.time != null)
                message.time = String(object.time);
            if (object.companyActFlag != null)
                if ($util.Long)
                    (message.companyActFlag = $util.Long.fromValue(object.companyActFlag)).unsigned = false;
                else if (typeof object.companyActFlag === "string")
                    message.companyActFlag = parseInt(object.companyActFlag, 10);
                else if (typeof object.companyActFlag === "number")
                    message.companyActFlag = object.companyActFlag;
                else if (typeof object.companyActFlag === "object")
                    message.companyActFlag = new $util.LongBits(object.companyActFlag.low >>> 0, object.companyActFlag.high >>> 0).toNumber();
            if (object.fwdFactorA != null)
                message.fwdFactorA = Number(object.fwdFactorA);
            if (object.fwdFactorB != null)
                message.fwdFactorB = Number(object.fwdFactorB);
            if (object.bwdFactorA != null)
                message.bwdFactorA = Number(object.bwdFactorA);
            if (object.bwdFactorB != null)
                message.bwdFactorB = Number(object.bwdFactorB);
            if (object.splitBase != null)
                message.splitBase = object.splitBase | 0;
            if (object.splitErt != null)
                message.splitErt = object.splitErt | 0;
            if (object.joinBase != null)
                message.joinBase = object.joinBase | 0;
            if (object.joinErt != null)
                message.joinErt = object.joinErt | 0;
            if (object.bonusBase != null)
                message.bonusBase = object.bonusBase | 0;
            if (object.bonusErt != null)
                message.bonusErt = object.bonusErt | 0;
            if (object.transferBase != null)
                message.transferBase = object.transferBase | 0;
            if (object.transferErt != null)
                message.transferErt = object.transferErt | 0;
            if (object.allotBase != null)
                message.allotBase = object.allotBase | 0;
            if (object.allotErt != null)
                message.allotErt = object.allotErt | 0;
            if (object.allotPrice != null)
                message.allotPrice = Number(object.allotPrice);
            if (object.addBase != null)
                message.addBase = object.addBase | 0;
            if (object.addErt != null)
                message.addErt = object.addErt | 0;
            if (object.addPrice != null)
                message.addPrice = Number(object.addPrice);
            if (object.dividend != null)
                message.dividend = Number(object.dividend);
            if (object.spDividend != null)
                message.spDividend = Number(object.spDividend);
            if (object.timestamp != null)
                message.timestamp = Number(object.timestamp);
            return message;
        };

        /**
         * Creates a plain object from a Rehab message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.Rehab
         * @static
         * @param {Qot_Common.Rehab} message Rehab
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Rehab.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.time = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.companyActFlag = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.companyActFlag = options.longs === String ? "0" : 0;
                object.fwdFactorA = 0;
                object.fwdFactorB = 0;
                object.bwdFactorA = 0;
                object.bwdFactorB = 0;
                object.splitBase = 0;
                object.splitErt = 0;
                object.joinBase = 0;
                object.joinErt = 0;
                object.bonusBase = 0;
                object.bonusErt = 0;
                object.transferBase = 0;
                object.transferErt = 0;
                object.allotBase = 0;
                object.allotErt = 0;
                object.allotPrice = 0;
                object.addBase = 0;
                object.addErt = 0;
                object.addPrice = 0;
                object.dividend = 0;
                object.spDividend = 0;
                object.timestamp = 0;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.companyActFlag != null && message.hasOwnProperty("companyActFlag"))
                if (typeof message.companyActFlag === "number")
                    object.companyActFlag = options.longs === String ? String(message.companyActFlag) : message.companyActFlag;
                else
                    object.companyActFlag = options.longs === String ? $util.Long.prototype.toString.call(message.companyActFlag) : options.longs === Number ? new $util.LongBits(message.companyActFlag.low >>> 0, message.companyActFlag.high >>> 0).toNumber() : message.companyActFlag;
            if (message.fwdFactorA != null && message.hasOwnProperty("fwdFactorA"))
                object.fwdFactorA = options.json && !isFinite(message.fwdFactorA) ? String(message.fwdFactorA) : message.fwdFactorA;
            if (message.fwdFactorB != null && message.hasOwnProperty("fwdFactorB"))
                object.fwdFactorB = options.json && !isFinite(message.fwdFactorB) ? String(message.fwdFactorB) : message.fwdFactorB;
            if (message.bwdFactorA != null && message.hasOwnProperty("bwdFactorA"))
                object.bwdFactorA = options.json && !isFinite(message.bwdFactorA) ? String(message.bwdFactorA) : message.bwdFactorA;
            if (message.bwdFactorB != null && message.hasOwnProperty("bwdFactorB"))
                object.bwdFactorB = options.json && !isFinite(message.bwdFactorB) ? String(message.bwdFactorB) : message.bwdFactorB;
            if (message.splitBase != null && message.hasOwnProperty("splitBase"))
                object.splitBase = message.splitBase;
            if (message.splitErt != null && message.hasOwnProperty("splitErt"))
                object.splitErt = message.splitErt;
            if (message.joinBase != null && message.hasOwnProperty("joinBase"))
                object.joinBase = message.joinBase;
            if (message.joinErt != null && message.hasOwnProperty("joinErt"))
                object.joinErt = message.joinErt;
            if (message.bonusBase != null && message.hasOwnProperty("bonusBase"))
                object.bonusBase = message.bonusBase;
            if (message.bonusErt != null && message.hasOwnProperty("bonusErt"))
                object.bonusErt = message.bonusErt;
            if (message.transferBase != null && message.hasOwnProperty("transferBase"))
                object.transferBase = message.transferBase;
            if (message.transferErt != null && message.hasOwnProperty("transferErt"))
                object.transferErt = message.transferErt;
            if (message.allotBase != null && message.hasOwnProperty("allotBase"))
                object.allotBase = message.allotBase;
            if (message.allotErt != null && message.hasOwnProperty("allotErt"))
                object.allotErt = message.allotErt;
            if (message.allotPrice != null && message.hasOwnProperty("allotPrice"))
                object.allotPrice = options.json && !isFinite(message.allotPrice) ? String(message.allotPrice) : message.allotPrice;
            if (message.addBase != null && message.hasOwnProperty("addBase"))
                object.addBase = message.addBase;
            if (message.addErt != null && message.hasOwnProperty("addErt"))
                object.addErt = message.addErt;
            if (message.addPrice != null && message.hasOwnProperty("addPrice"))
                object.addPrice = options.json && !isFinite(message.addPrice) ? String(message.addPrice) : message.addPrice;
            if (message.dividend != null && message.hasOwnProperty("dividend"))
                object.dividend = options.json && !isFinite(message.dividend) ? String(message.dividend) : message.dividend;
            if (message.spDividend != null && message.hasOwnProperty("spDividend"))
                object.spDividend = options.json && !isFinite(message.spDividend) ? String(message.spDividend) : message.spDividend;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            return object;
        };

        /**
         * Converts this Rehab to JSON.
         * @function toJSON
         * @memberof Qot_Common.Rehab
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Rehab.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Rehab;
    })();

    return Qot_Common;
})();

$root.GetUserInfo = (function() {

    /**
     * Namespace GetUserInfo.
     * @exports GetUserInfo
     * @namespace
     */
    var GetUserInfo = {};

    /**
     * UpdateType enum.
     * @name GetUserInfo.UpdateType
     * @enum {string}
     * @property {number} UpdateType_None=0 UpdateType_None value
     * @property {number} UpdateType_Advice=1 UpdateType_Advice value
     * @property {number} UpdateType_Force=2 UpdateType_Force value
     */
    GetUserInfo.UpdateType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UpdateType_None"] = 0;
        values[valuesById[1] = "UpdateType_Advice"] = 1;
        values[valuesById[2] = "UpdateType_Force"] = 2;
        return values;
    })();

    /**
     * UserInfoField enum.
     * @name GetUserInfo.UserInfoField
     * @enum {string}
     * @property {number} UserInfoField_Basic=1 UserInfoField_Basic value
     * @property {number} UserInfoField_API=2 UserInfoField_API value
     * @property {number} UserInfoField_QotRight=4 UserInfoField_QotRight value
     * @property {number} UserInfoField_Disclaimer=8 UserInfoField_Disclaimer value
     * @property {number} UserInfoField_Update=16 UserInfoField_Update value
     * @property {number} UserInfoField_WebKey=2048 UserInfoField_WebKey value
     */
    GetUserInfo.UserInfoField = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "UserInfoField_Basic"] = 1;
        values[valuesById[2] = "UserInfoField_API"] = 2;
        values[valuesById[4] = "UserInfoField_QotRight"] = 4;
        values[valuesById[8] = "UserInfoField_Disclaimer"] = 8;
        values[valuesById[16] = "UserInfoField_Update"] = 16;
        values[valuesById[2048] = "UserInfoField_WebKey"] = 2048;
        return values;
    })();

    GetUserInfo.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof GetUserInfo
         * @interface IC2S
         * @property {number|null} [flag] C2S flag
         */

        /**
         * Constructs a new C2S.
         * @memberof GetUserInfo
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {GetUserInfo.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S flag.
         * @member {number} flag
         * @memberof GetUserInfo.C2S
         * @instance
         */
        C2S.prototype.flag = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof GetUserInfo.C2S
         * @static
         * @param {GetUserInfo.IC2S=} [properties] Properties to set
         * @returns {GetUserInfo.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link GetUserInfo.C2S.verify|verify} messages.
         * @function encode
         * @memberof GetUserInfo.C2S
         * @static
         * @param {GetUserInfo.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.flag != null && message.hasOwnProperty("flag"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.flag);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link GetUserInfo.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetUserInfo.C2S
         * @static
         * @param {GetUserInfo.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof GetUserInfo.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetUserInfo.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetUserInfo.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.flag = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetUserInfo.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetUserInfo.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof GetUserInfo.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.flag != null && message.hasOwnProperty("flag"))
                if (!$util.isInteger(message.flag))
                    return "flag: integer expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetUserInfo.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetUserInfo.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.GetUserInfo.C2S)
                return object;
            var message = new $root.GetUserInfo.C2S();
            if (object.flag != null)
                message.flag = object.flag | 0;
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetUserInfo.C2S
         * @static
         * @param {GetUserInfo.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.flag = 0;
            if (message.flag != null && message.hasOwnProperty("flag"))
                object.flag = message.flag;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof GetUserInfo.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    GetUserInfo.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof GetUserInfo
         * @interface IS2C
         * @property {string|null} [nickName] S2C nickName
         * @property {string|null} [avatarUrl] S2C avatarUrl
         * @property {string|null} [apiLevel] S2C apiLevel
         * @property {number|null} [hkQotRight] S2C hkQotRight
         * @property {number|null} [usQotRight] S2C usQotRight
         * @property {number|null} [cnQotRight] S2C cnQotRight
         * @property {boolean|null} [isNeedAgreeDisclaimer] S2C isNeedAgreeDisclaimer
         * @property {number|Long|null} [userID] S2C userID
         * @property {number|null} [updateType] S2C updateType
         * @property {string|null} [webKey] S2C webKey
         * @property {number|null} [hkOptionQotRight] S2C hkOptionQotRight
         * @property {boolean|null} [hasUSOptionQotRight] S2C hasUSOptionQotRight
         * @property {number|null} [hkFutureQotRight] S2C hkFutureQotRight
         * @property {number|null} [subQuota] S2C subQuota
         * @property {number|null} [historyKLQuota] S2C historyKLQuota
         */

        /**
         * Constructs a new S2C.
         * @memberof GetUserInfo
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {GetUserInfo.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C nickName.
         * @member {string} nickName
         * @memberof GetUserInfo.S2C
         * @instance
         */
        S2C.prototype.nickName = "";

        /**
         * S2C avatarUrl.
         * @member {string} avatarUrl
         * @memberof GetUserInfo.S2C
         * @instance
         */
        S2C.prototype.avatarUrl = "";

        /**
         * S2C apiLevel.
         * @member {string} apiLevel
         * @memberof GetUserInfo.S2C
         * @instance
         */
        S2C.prototype.apiLevel = "";

        /**
         * S2C hkQotRight.
         * @member {number} hkQotRight
         * @memberof GetUserInfo.S2C
         * @instance
         */
        S2C.prototype.hkQotRight = 0;

        /**
         * S2C usQotRight.
         * @member {number} usQotRight
         * @memberof GetUserInfo.S2C
         * @instance
         */
        S2C.prototype.usQotRight = 0;

        /**
         * S2C cnQotRight.
         * @member {number} cnQotRight
         * @memberof GetUserInfo.S2C
         * @instance
         */
        S2C.prototype.cnQotRight = 0;

        /**
         * S2C isNeedAgreeDisclaimer.
         * @member {boolean} isNeedAgreeDisclaimer
         * @memberof GetUserInfo.S2C
         * @instance
         */
        S2C.prototype.isNeedAgreeDisclaimer = false;

        /**
         * S2C userID.
         * @member {number|Long} userID
         * @memberof GetUserInfo.S2C
         * @instance
         */
        S2C.prototype.userID = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * S2C updateType.
         * @member {number} updateType
         * @memberof GetUserInfo.S2C
         * @instance
         */
        S2C.prototype.updateType = 0;

        /**
         * S2C webKey.
         * @member {string} webKey
         * @memberof GetUserInfo.S2C
         * @instance
         */
        S2C.prototype.webKey = "";

        /**
         * S2C hkOptionQotRight.
         * @member {number} hkOptionQotRight
         * @memberof GetUserInfo.S2C
         * @instance
         */
        S2C.prototype.hkOptionQotRight = 0;

        /**
         * S2C hasUSOptionQotRight.
         * @member {boolean} hasUSOptionQotRight
         * @memberof GetUserInfo.S2C
         * @instance
         */
        S2C.prototype.hasUSOptionQotRight = false;

        /**
         * S2C hkFutureQotRight.
         * @member {number} hkFutureQotRight
         * @memberof GetUserInfo.S2C
         * @instance
         */
        S2C.prototype.hkFutureQotRight = 0;

        /**
         * S2C subQuota.
         * @member {number} subQuota
         * @memberof GetUserInfo.S2C
         * @instance
         */
        S2C.prototype.subQuota = 0;

        /**
         * S2C historyKLQuota.
         * @member {number} historyKLQuota
         * @memberof GetUserInfo.S2C
         * @instance
         */
        S2C.prototype.historyKLQuota = 0;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof GetUserInfo.S2C
         * @static
         * @param {GetUserInfo.IS2C=} [properties] Properties to set
         * @returns {GetUserInfo.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link GetUserInfo.S2C.verify|verify} messages.
         * @function encode
         * @memberof GetUserInfo.S2C
         * @static
         * @param {GetUserInfo.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nickName != null && message.hasOwnProperty("nickName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.nickName);
            if (message.avatarUrl != null && message.hasOwnProperty("avatarUrl"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.avatarUrl);
            if (message.apiLevel != null && message.hasOwnProperty("apiLevel"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.apiLevel);
            if (message.hkQotRight != null && message.hasOwnProperty("hkQotRight"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.hkQotRight);
            if (message.usQotRight != null && message.hasOwnProperty("usQotRight"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.usQotRight);
            if (message.cnQotRight != null && message.hasOwnProperty("cnQotRight"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.cnQotRight);
            if (message.isNeedAgreeDisclaimer != null && message.hasOwnProperty("isNeedAgreeDisclaimer"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.isNeedAgreeDisclaimer);
            if (message.userID != null && message.hasOwnProperty("userID"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.userID);
            if (message.updateType != null && message.hasOwnProperty("updateType"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.updateType);
            if (message.webKey != null && message.hasOwnProperty("webKey"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.webKey);
            if (message.hkOptionQotRight != null && message.hasOwnProperty("hkOptionQotRight"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.hkOptionQotRight);
            if (message.hasUSOptionQotRight != null && message.hasOwnProperty("hasUSOptionQotRight"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.hasUSOptionQotRight);
            if (message.hkFutureQotRight != null && message.hasOwnProperty("hkFutureQotRight"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.hkFutureQotRight);
            if (message.subQuota != null && message.hasOwnProperty("subQuota"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.subQuota);
            if (message.historyKLQuota != null && message.hasOwnProperty("historyKLQuota"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.historyKLQuota);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link GetUserInfo.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetUserInfo.S2C
         * @static
         * @param {GetUserInfo.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof GetUserInfo.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetUserInfo.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetUserInfo.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nickName = reader.string();
                    break;
                case 2:
                    message.avatarUrl = reader.string();
                    break;
                case 3:
                    message.apiLevel = reader.string();
                    break;
                case 4:
                    message.hkQotRight = reader.int32();
                    break;
                case 5:
                    message.usQotRight = reader.int32();
                    break;
                case 6:
                    message.cnQotRight = reader.int32();
                    break;
                case 7:
                    message.isNeedAgreeDisclaimer = reader.bool();
                    break;
                case 8:
                    message.userID = reader.int64();
                    break;
                case 9:
                    message.updateType = reader.int32();
                    break;
                case 10:
                    message.webKey = reader.string();
                    break;
                case 11:
                    message.hkOptionQotRight = reader.int32();
                    break;
                case 12:
                    message.hasUSOptionQotRight = reader.bool();
                    break;
                case 13:
                    message.hkFutureQotRight = reader.int32();
                    break;
                case 14:
                    message.subQuota = reader.int32();
                    break;
                case 15:
                    message.historyKLQuota = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetUserInfo.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetUserInfo.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof GetUserInfo.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nickName != null && message.hasOwnProperty("nickName"))
                if (!$util.isString(message.nickName))
                    return "nickName: string expected";
            if (message.avatarUrl != null && message.hasOwnProperty("avatarUrl"))
                if (!$util.isString(message.avatarUrl))
                    return "avatarUrl: string expected";
            if (message.apiLevel != null && message.hasOwnProperty("apiLevel"))
                if (!$util.isString(message.apiLevel))
                    return "apiLevel: string expected";
            if (message.hkQotRight != null && message.hasOwnProperty("hkQotRight"))
                if (!$util.isInteger(message.hkQotRight))
                    return "hkQotRight: integer expected";
            if (message.usQotRight != null && message.hasOwnProperty("usQotRight"))
                if (!$util.isInteger(message.usQotRight))
                    return "usQotRight: integer expected";
            if (message.cnQotRight != null && message.hasOwnProperty("cnQotRight"))
                if (!$util.isInteger(message.cnQotRight))
                    return "cnQotRight: integer expected";
            if (message.isNeedAgreeDisclaimer != null && message.hasOwnProperty("isNeedAgreeDisclaimer"))
                if (typeof message.isNeedAgreeDisclaimer !== "boolean")
                    return "isNeedAgreeDisclaimer: boolean expected";
            if (message.userID != null && message.hasOwnProperty("userID"))
                if (!$util.isInteger(message.userID) && !(message.userID && $util.isInteger(message.userID.low) && $util.isInteger(message.userID.high)))
                    return "userID: integer|Long expected";
            if (message.updateType != null && message.hasOwnProperty("updateType"))
                if (!$util.isInteger(message.updateType))
                    return "updateType: integer expected";
            if (message.webKey != null && message.hasOwnProperty("webKey"))
                if (!$util.isString(message.webKey))
                    return "webKey: string expected";
            if (message.hkOptionQotRight != null && message.hasOwnProperty("hkOptionQotRight"))
                if (!$util.isInteger(message.hkOptionQotRight))
                    return "hkOptionQotRight: integer expected";
            if (message.hasUSOptionQotRight != null && message.hasOwnProperty("hasUSOptionQotRight"))
                if (typeof message.hasUSOptionQotRight !== "boolean")
                    return "hasUSOptionQotRight: boolean expected";
            if (message.hkFutureQotRight != null && message.hasOwnProperty("hkFutureQotRight"))
                if (!$util.isInteger(message.hkFutureQotRight))
                    return "hkFutureQotRight: integer expected";
            if (message.subQuota != null && message.hasOwnProperty("subQuota"))
                if (!$util.isInteger(message.subQuota))
                    return "subQuota: integer expected";
            if (message.historyKLQuota != null && message.hasOwnProperty("historyKLQuota"))
                if (!$util.isInteger(message.historyKLQuota))
                    return "historyKLQuota: integer expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetUserInfo.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetUserInfo.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.GetUserInfo.S2C)
                return object;
            var message = new $root.GetUserInfo.S2C();
            if (object.nickName != null)
                message.nickName = String(object.nickName);
            if (object.avatarUrl != null)
                message.avatarUrl = String(object.avatarUrl);
            if (object.apiLevel != null)
                message.apiLevel = String(object.apiLevel);
            if (object.hkQotRight != null)
                message.hkQotRight = object.hkQotRight | 0;
            if (object.usQotRight != null)
                message.usQotRight = object.usQotRight | 0;
            if (object.cnQotRight != null)
                message.cnQotRight = object.cnQotRight | 0;
            if (object.isNeedAgreeDisclaimer != null)
                message.isNeedAgreeDisclaimer = Boolean(object.isNeedAgreeDisclaimer);
            if (object.userID != null)
                if ($util.Long)
                    (message.userID = $util.Long.fromValue(object.userID)).unsigned = false;
                else if (typeof object.userID === "string")
                    message.userID = parseInt(object.userID, 10);
                else if (typeof object.userID === "number")
                    message.userID = object.userID;
                else if (typeof object.userID === "object")
                    message.userID = new $util.LongBits(object.userID.low >>> 0, object.userID.high >>> 0).toNumber();
            if (object.updateType != null)
                message.updateType = object.updateType | 0;
            if (object.webKey != null)
                message.webKey = String(object.webKey);
            if (object.hkOptionQotRight != null)
                message.hkOptionQotRight = object.hkOptionQotRight | 0;
            if (object.hasUSOptionQotRight != null)
                message.hasUSOptionQotRight = Boolean(object.hasUSOptionQotRight);
            if (object.hkFutureQotRight != null)
                message.hkFutureQotRight = object.hkFutureQotRight | 0;
            if (object.subQuota != null)
                message.subQuota = object.subQuota | 0;
            if (object.historyKLQuota != null)
                message.historyKLQuota = object.historyKLQuota | 0;
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetUserInfo.S2C
         * @static
         * @param {GetUserInfo.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.nickName = "";
                object.avatarUrl = "";
                object.apiLevel = "";
                object.hkQotRight = 0;
                object.usQotRight = 0;
                object.cnQotRight = 0;
                object.isNeedAgreeDisclaimer = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.userID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.userID = options.longs === String ? "0" : 0;
                object.updateType = 0;
                object.webKey = "";
                object.hkOptionQotRight = 0;
                object.hasUSOptionQotRight = false;
                object.hkFutureQotRight = 0;
                object.subQuota = 0;
                object.historyKLQuota = 0;
            }
            if (message.nickName != null && message.hasOwnProperty("nickName"))
                object.nickName = message.nickName;
            if (message.avatarUrl != null && message.hasOwnProperty("avatarUrl"))
                object.avatarUrl = message.avatarUrl;
            if (message.apiLevel != null && message.hasOwnProperty("apiLevel"))
                object.apiLevel = message.apiLevel;
            if (message.hkQotRight != null && message.hasOwnProperty("hkQotRight"))
                object.hkQotRight = message.hkQotRight;
            if (message.usQotRight != null && message.hasOwnProperty("usQotRight"))
                object.usQotRight = message.usQotRight;
            if (message.cnQotRight != null && message.hasOwnProperty("cnQotRight"))
                object.cnQotRight = message.cnQotRight;
            if (message.isNeedAgreeDisclaimer != null && message.hasOwnProperty("isNeedAgreeDisclaimer"))
                object.isNeedAgreeDisclaimer = message.isNeedAgreeDisclaimer;
            if (message.userID != null && message.hasOwnProperty("userID"))
                if (typeof message.userID === "number")
                    object.userID = options.longs === String ? String(message.userID) : message.userID;
                else
                    object.userID = options.longs === String ? $util.Long.prototype.toString.call(message.userID) : options.longs === Number ? new $util.LongBits(message.userID.low >>> 0, message.userID.high >>> 0).toNumber() : message.userID;
            if (message.updateType != null && message.hasOwnProperty("updateType"))
                object.updateType = message.updateType;
            if (message.webKey != null && message.hasOwnProperty("webKey"))
                object.webKey = message.webKey;
            if (message.hkOptionQotRight != null && message.hasOwnProperty("hkOptionQotRight"))
                object.hkOptionQotRight = message.hkOptionQotRight;
            if (message.hasUSOptionQotRight != null && message.hasOwnProperty("hasUSOptionQotRight"))
                object.hasUSOptionQotRight = message.hasUSOptionQotRight;
            if (message.hkFutureQotRight != null && message.hasOwnProperty("hkFutureQotRight"))
                object.hkFutureQotRight = message.hkFutureQotRight;
            if (message.subQuota != null && message.hasOwnProperty("subQuota"))
                object.subQuota = message.subQuota;
            if (message.historyKLQuota != null && message.hasOwnProperty("historyKLQuota"))
                object.historyKLQuota = message.historyKLQuota;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof GetUserInfo.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    GetUserInfo.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof GetUserInfo
         * @interface IRequest
         * @property {GetUserInfo.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof GetUserInfo
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {GetUserInfo.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {GetUserInfo.IC2S} c2s
         * @memberof GetUserInfo.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof GetUserInfo.Request
         * @static
         * @param {GetUserInfo.IRequest=} [properties] Properties to set
         * @returns {GetUserInfo.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link GetUserInfo.Request.verify|verify} messages.
         * @function encode
         * @memberof GetUserInfo.Request
         * @static
         * @param {GetUserInfo.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.GetUserInfo.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link GetUserInfo.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetUserInfo.Request
         * @static
         * @param {GetUserInfo.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof GetUserInfo.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetUserInfo.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetUserInfo.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.GetUserInfo.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetUserInfo.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetUserInfo.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof GetUserInfo.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.GetUserInfo.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetUserInfo.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetUserInfo.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.GetUserInfo.Request)
                return object;
            var message = new $root.GetUserInfo.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".GetUserInfo.Request.c2s: object expected");
                message.c2s = $root.GetUserInfo.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetUserInfo.Request
         * @static
         * @param {GetUserInfo.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.GetUserInfo.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof GetUserInfo.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    GetUserInfo.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof GetUserInfo
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {GetUserInfo.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof GetUserInfo
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {GetUserInfo.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof GetUserInfo.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof GetUserInfo.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof GetUserInfo.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {GetUserInfo.IS2C|null|undefined} s2c
         * @memberof GetUserInfo.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof GetUserInfo.Response
         * @static
         * @param {GetUserInfo.IResponse=} [properties] Properties to set
         * @returns {GetUserInfo.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link GetUserInfo.Response.verify|verify} messages.
         * @function encode
         * @memberof GetUserInfo.Response
         * @static
         * @param {GetUserInfo.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.GetUserInfo.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link GetUserInfo.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetUserInfo.Response
         * @static
         * @param {GetUserInfo.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof GetUserInfo.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetUserInfo.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetUserInfo.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.GetUserInfo.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetUserInfo.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetUserInfo.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof GetUserInfo.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.GetUserInfo.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetUserInfo.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetUserInfo.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.GetUserInfo.Response)
                return object;
            var message = new $root.GetUserInfo.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".GetUserInfo.Response.s2c: object expected");
                message.s2c = $root.GetUserInfo.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetUserInfo.Response
         * @static
         * @param {GetUserInfo.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.GetUserInfo.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof GetUserInfo.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return GetUserInfo;
})();

$root.InitConnect = (function() {

    /**
     * Namespace InitConnect.
     * @exports InitConnect
     * @namespace
     */
    var InitConnect = {};

    InitConnect.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof InitConnect
         * @interface IC2S
         * @property {number} clientVer C2S clientVer
         * @property {string} clientID C2S clientID
         * @property {boolean|null} [recvNotify] C2S recvNotify
         * @property {number|null} [packetEncAlgo] C2S packetEncAlgo
         * @property {number|null} [pushProtoFmt] C2S pushProtoFmt
         * @property {string|null} [programmingLanguage] C2S programmingLanguage
         */

        /**
         * Constructs a new C2S.
         * @memberof InitConnect
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {InitConnect.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S clientVer.
         * @member {number} clientVer
         * @memberof InitConnect.C2S
         * @instance
         */
        C2S.prototype.clientVer = 0;

        /**
         * C2S clientID.
         * @member {string} clientID
         * @memberof InitConnect.C2S
         * @instance
         */
        C2S.prototype.clientID = "";

        /**
         * C2S recvNotify.
         * @member {boolean} recvNotify
         * @memberof InitConnect.C2S
         * @instance
         */
        C2S.prototype.recvNotify = false;

        /**
         * C2S packetEncAlgo.
         * @member {number} packetEncAlgo
         * @memberof InitConnect.C2S
         * @instance
         */
        C2S.prototype.packetEncAlgo = 0;

        /**
         * C2S pushProtoFmt.
         * @member {number} pushProtoFmt
         * @memberof InitConnect.C2S
         * @instance
         */
        C2S.prototype.pushProtoFmt = 0;

        /**
         * C2S programmingLanguage.
         * @member {string} programmingLanguage
         * @memberof InitConnect.C2S
         * @instance
         */
        C2S.prototype.programmingLanguage = "";

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof InitConnect.C2S
         * @static
         * @param {InitConnect.IC2S=} [properties] Properties to set
         * @returns {InitConnect.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link InitConnect.C2S.verify|verify} messages.
         * @function encode
         * @memberof InitConnect.C2S
         * @static
         * @param {InitConnect.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.clientVer);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.clientID);
            if (message.recvNotify != null && message.hasOwnProperty("recvNotify"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.recvNotify);
            if (message.packetEncAlgo != null && message.hasOwnProperty("packetEncAlgo"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.packetEncAlgo);
            if (message.pushProtoFmt != null && message.hasOwnProperty("pushProtoFmt"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.pushProtoFmt);
            if (message.programmingLanguage != null && message.hasOwnProperty("programmingLanguage"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.programmingLanguage);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link InitConnect.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof InitConnect.C2S
         * @static
         * @param {InitConnect.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof InitConnect.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {InitConnect.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.InitConnect.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.clientVer = reader.int32();
                    break;
                case 2:
                    message.clientID = reader.string();
                    break;
                case 3:
                    message.recvNotify = reader.bool();
                    break;
                case 4:
                    message.packetEncAlgo = reader.int32();
                    break;
                case 5:
                    message.pushProtoFmt = reader.int32();
                    break;
                case 6:
                    message.programmingLanguage = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("clientVer"))
                throw $util.ProtocolError("missing required 'clientVer'", { instance: message });
            if (!message.hasOwnProperty("clientID"))
                throw $util.ProtocolError("missing required 'clientID'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof InitConnect.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {InitConnect.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof InitConnect.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.clientVer))
                return "clientVer: integer expected";
            if (!$util.isString(message.clientID))
                return "clientID: string expected";
            if (message.recvNotify != null && message.hasOwnProperty("recvNotify"))
                if (typeof message.recvNotify !== "boolean")
                    return "recvNotify: boolean expected";
            if (message.packetEncAlgo != null && message.hasOwnProperty("packetEncAlgo"))
                if (!$util.isInteger(message.packetEncAlgo))
                    return "packetEncAlgo: integer expected";
            if (message.pushProtoFmt != null && message.hasOwnProperty("pushProtoFmt"))
                if (!$util.isInteger(message.pushProtoFmt))
                    return "pushProtoFmt: integer expected";
            if (message.programmingLanguage != null && message.hasOwnProperty("programmingLanguage"))
                if (!$util.isString(message.programmingLanguage))
                    return "programmingLanguage: string expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof InitConnect.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {InitConnect.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.InitConnect.C2S)
                return object;
            var message = new $root.InitConnect.C2S();
            if (object.clientVer != null)
                message.clientVer = object.clientVer | 0;
            if (object.clientID != null)
                message.clientID = String(object.clientID);
            if (object.recvNotify != null)
                message.recvNotify = Boolean(object.recvNotify);
            if (object.packetEncAlgo != null)
                message.packetEncAlgo = object.packetEncAlgo | 0;
            if (object.pushProtoFmt != null)
                message.pushProtoFmt = object.pushProtoFmt | 0;
            if (object.programmingLanguage != null)
                message.programmingLanguage = String(object.programmingLanguage);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof InitConnect.C2S
         * @static
         * @param {InitConnect.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.clientVer = 0;
                object.clientID = "";
                object.recvNotify = false;
                object.packetEncAlgo = 0;
                object.pushProtoFmt = 0;
                object.programmingLanguage = "";
            }
            if (message.clientVer != null && message.hasOwnProperty("clientVer"))
                object.clientVer = message.clientVer;
            if (message.clientID != null && message.hasOwnProperty("clientID"))
                object.clientID = message.clientID;
            if (message.recvNotify != null && message.hasOwnProperty("recvNotify"))
                object.recvNotify = message.recvNotify;
            if (message.packetEncAlgo != null && message.hasOwnProperty("packetEncAlgo"))
                object.packetEncAlgo = message.packetEncAlgo;
            if (message.pushProtoFmt != null && message.hasOwnProperty("pushProtoFmt"))
                object.pushProtoFmt = message.pushProtoFmt;
            if (message.programmingLanguage != null && message.hasOwnProperty("programmingLanguage"))
                object.programmingLanguage = message.programmingLanguage;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof InitConnect.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    InitConnect.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof InitConnect
         * @interface IS2C
         * @property {number} serverVer S2C serverVer
         * @property {number|Long} loginUserID S2C loginUserID
         * @property {number|Long} connID S2C connID
         * @property {string} connAESKey S2C connAESKey
         * @property {number} keepAliveInterval S2C keepAliveInterval
         * @property {string|null} [aesCBCiv] S2C aesCBCiv
         */

        /**
         * Constructs a new S2C.
         * @memberof InitConnect
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {InitConnect.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C serverVer.
         * @member {number} serverVer
         * @memberof InitConnect.S2C
         * @instance
         */
        S2C.prototype.serverVer = 0;

        /**
         * S2C loginUserID.
         * @member {number|Long} loginUserID
         * @memberof InitConnect.S2C
         * @instance
         */
        S2C.prototype.loginUserID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * S2C connID.
         * @member {number|Long} connID
         * @memberof InitConnect.S2C
         * @instance
         */
        S2C.prototype.connID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * S2C connAESKey.
         * @member {string} connAESKey
         * @memberof InitConnect.S2C
         * @instance
         */
        S2C.prototype.connAESKey = "";

        /**
         * S2C keepAliveInterval.
         * @member {number} keepAliveInterval
         * @memberof InitConnect.S2C
         * @instance
         */
        S2C.prototype.keepAliveInterval = 0;

        /**
         * S2C aesCBCiv.
         * @member {string} aesCBCiv
         * @memberof InitConnect.S2C
         * @instance
         */
        S2C.prototype.aesCBCiv = "";

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof InitConnect.S2C
         * @static
         * @param {InitConnect.IS2C=} [properties] Properties to set
         * @returns {InitConnect.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link InitConnect.S2C.verify|verify} messages.
         * @function encode
         * @memberof InitConnect.S2C
         * @static
         * @param {InitConnect.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.serverVer);
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.loginUserID);
            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.connID);
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.connAESKey);
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.keepAliveInterval);
            if (message.aesCBCiv != null && message.hasOwnProperty("aesCBCiv"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.aesCBCiv);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link InitConnect.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof InitConnect.S2C
         * @static
         * @param {InitConnect.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof InitConnect.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {InitConnect.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.InitConnect.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverVer = reader.int32();
                    break;
                case 2:
                    message.loginUserID = reader.uint64();
                    break;
                case 3:
                    message.connID = reader.uint64();
                    break;
                case 4:
                    message.connAESKey = reader.string();
                    break;
                case 5:
                    message.keepAliveInterval = reader.int32();
                    break;
                case 6:
                    message.aesCBCiv = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("serverVer"))
                throw $util.ProtocolError("missing required 'serverVer'", { instance: message });
            if (!message.hasOwnProperty("loginUserID"))
                throw $util.ProtocolError("missing required 'loginUserID'", { instance: message });
            if (!message.hasOwnProperty("connID"))
                throw $util.ProtocolError("missing required 'connID'", { instance: message });
            if (!message.hasOwnProperty("connAESKey"))
                throw $util.ProtocolError("missing required 'connAESKey'", { instance: message });
            if (!message.hasOwnProperty("keepAliveInterval"))
                throw $util.ProtocolError("missing required 'keepAliveInterval'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof InitConnect.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {InitConnect.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof InitConnect.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.serverVer))
                return "serverVer: integer expected";
            if (!$util.isInteger(message.loginUserID) && !(message.loginUserID && $util.isInteger(message.loginUserID.low) && $util.isInteger(message.loginUserID.high)))
                return "loginUserID: integer|Long expected";
            if (!$util.isInteger(message.connID) && !(message.connID && $util.isInteger(message.connID.low) && $util.isInteger(message.connID.high)))
                return "connID: integer|Long expected";
            if (!$util.isString(message.connAESKey))
                return "connAESKey: string expected";
            if (!$util.isInteger(message.keepAliveInterval))
                return "keepAliveInterval: integer expected";
            if (message.aesCBCiv != null && message.hasOwnProperty("aesCBCiv"))
                if (!$util.isString(message.aesCBCiv))
                    return "aesCBCiv: string expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof InitConnect.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {InitConnect.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.InitConnect.S2C)
                return object;
            var message = new $root.InitConnect.S2C();
            if (object.serverVer != null)
                message.serverVer = object.serverVer | 0;
            if (object.loginUserID != null)
                if ($util.Long)
                    (message.loginUserID = $util.Long.fromValue(object.loginUserID)).unsigned = true;
                else if (typeof object.loginUserID === "string")
                    message.loginUserID = parseInt(object.loginUserID, 10);
                else if (typeof object.loginUserID === "number")
                    message.loginUserID = object.loginUserID;
                else if (typeof object.loginUserID === "object")
                    message.loginUserID = new $util.LongBits(object.loginUserID.low >>> 0, object.loginUserID.high >>> 0).toNumber(true);
            if (object.connID != null)
                if ($util.Long)
                    (message.connID = $util.Long.fromValue(object.connID)).unsigned = true;
                else if (typeof object.connID === "string")
                    message.connID = parseInt(object.connID, 10);
                else if (typeof object.connID === "number")
                    message.connID = object.connID;
                else if (typeof object.connID === "object")
                    message.connID = new $util.LongBits(object.connID.low >>> 0, object.connID.high >>> 0).toNumber(true);
            if (object.connAESKey != null)
                message.connAESKey = String(object.connAESKey);
            if (object.keepAliveInterval != null)
                message.keepAliveInterval = object.keepAliveInterval | 0;
            if (object.aesCBCiv != null)
                message.aesCBCiv = String(object.aesCBCiv);
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof InitConnect.S2C
         * @static
         * @param {InitConnect.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.serverVer = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.loginUserID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.loginUserID = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.connID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.connID = options.longs === String ? "0" : 0;
                object.connAESKey = "";
                object.keepAliveInterval = 0;
                object.aesCBCiv = "";
            }
            if (message.serverVer != null && message.hasOwnProperty("serverVer"))
                object.serverVer = message.serverVer;
            if (message.loginUserID != null && message.hasOwnProperty("loginUserID"))
                if (typeof message.loginUserID === "number")
                    object.loginUserID = options.longs === String ? String(message.loginUserID) : message.loginUserID;
                else
                    object.loginUserID = options.longs === String ? $util.Long.prototype.toString.call(message.loginUserID) : options.longs === Number ? new $util.LongBits(message.loginUserID.low >>> 0, message.loginUserID.high >>> 0).toNumber(true) : message.loginUserID;
            if (message.connID != null && message.hasOwnProperty("connID"))
                if (typeof message.connID === "number")
                    object.connID = options.longs === String ? String(message.connID) : message.connID;
                else
                    object.connID = options.longs === String ? $util.Long.prototype.toString.call(message.connID) : options.longs === Number ? new $util.LongBits(message.connID.low >>> 0, message.connID.high >>> 0).toNumber(true) : message.connID;
            if (message.connAESKey != null && message.hasOwnProperty("connAESKey"))
                object.connAESKey = message.connAESKey;
            if (message.keepAliveInterval != null && message.hasOwnProperty("keepAliveInterval"))
                object.keepAliveInterval = message.keepAliveInterval;
            if (message.aesCBCiv != null && message.hasOwnProperty("aesCBCiv"))
                object.aesCBCiv = message.aesCBCiv;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof InitConnect.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    InitConnect.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof InitConnect
         * @interface IRequest
         * @property {InitConnect.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof InitConnect
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {InitConnect.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {InitConnect.IC2S} c2s
         * @memberof InitConnect.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof InitConnect.Request
         * @static
         * @param {InitConnect.IRequest=} [properties] Properties to set
         * @returns {InitConnect.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link InitConnect.Request.verify|verify} messages.
         * @function encode
         * @memberof InitConnect.Request
         * @static
         * @param {InitConnect.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.InitConnect.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link InitConnect.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof InitConnect.Request
         * @static
         * @param {InitConnect.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof InitConnect.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {InitConnect.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.InitConnect.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.InitConnect.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof InitConnect.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {InitConnect.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof InitConnect.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.InitConnect.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof InitConnect.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {InitConnect.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.InitConnect.Request)
                return object;
            var message = new $root.InitConnect.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".InitConnect.Request.c2s: object expected");
                message.c2s = $root.InitConnect.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof InitConnect.Request
         * @static
         * @param {InitConnect.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.InitConnect.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof InitConnect.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    InitConnect.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof InitConnect
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {InitConnect.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof InitConnect
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {InitConnect.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof InitConnect.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof InitConnect.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof InitConnect.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {InitConnect.IS2C|null|undefined} s2c
         * @memberof InitConnect.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof InitConnect.Response
         * @static
         * @param {InitConnect.IResponse=} [properties] Properties to set
         * @returns {InitConnect.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link InitConnect.Response.verify|verify} messages.
         * @function encode
         * @memberof InitConnect.Response
         * @static
         * @param {InitConnect.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.InitConnect.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link InitConnect.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof InitConnect.Response
         * @static
         * @param {InitConnect.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof InitConnect.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {InitConnect.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.InitConnect.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.InitConnect.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof InitConnect.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {InitConnect.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof InitConnect.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.InitConnect.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof InitConnect.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {InitConnect.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.InitConnect.Response)
                return object;
            var message = new $root.InitConnect.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".InitConnect.Response.s2c: object expected");
                message.s2c = $root.InitConnect.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof InitConnect.Response
         * @static
         * @param {InitConnect.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.InitConnect.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof InitConnect.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return InitConnect;
})();

$root.KeepAlive = (function() {

    /**
     * Namespace KeepAlive.
     * @exports KeepAlive
     * @namespace
     */
    var KeepAlive = {};

    KeepAlive.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof KeepAlive
         * @interface IC2S
         * @property {number|Long} time C2S time
         */

        /**
         * Constructs a new C2S.
         * @memberof KeepAlive
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {KeepAlive.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S time.
         * @member {number|Long} time
         * @memberof KeepAlive.C2S
         * @instance
         */
        C2S.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof KeepAlive.C2S
         * @static
         * @param {KeepAlive.IC2S=} [properties] Properties to set
         * @returns {KeepAlive.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link KeepAlive.C2S.verify|verify} messages.
         * @function encode
         * @memberof KeepAlive.C2S
         * @static
         * @param {KeepAlive.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.time);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link KeepAlive.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof KeepAlive.C2S
         * @static
         * @param {KeepAlive.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof KeepAlive.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {KeepAlive.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.KeepAlive.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("time"))
                throw $util.ProtocolError("missing required 'time'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof KeepAlive.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {KeepAlive.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof KeepAlive.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                return "time: integer|Long expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof KeepAlive.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {KeepAlive.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.KeepAlive.C2S)
                return object;
            var message = new $root.KeepAlive.C2S();
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof KeepAlive.C2S
         * @static
         * @param {KeepAlive.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time = options.longs === String ? "0" : 0;
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof KeepAlive.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    KeepAlive.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof KeepAlive
         * @interface IS2C
         * @property {number|Long} time S2C time
         */

        /**
         * Constructs a new S2C.
         * @memberof KeepAlive
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {KeepAlive.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C time.
         * @member {number|Long} time
         * @memberof KeepAlive.S2C
         * @instance
         */
        S2C.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof KeepAlive.S2C
         * @static
         * @param {KeepAlive.IS2C=} [properties] Properties to set
         * @returns {KeepAlive.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link KeepAlive.S2C.verify|verify} messages.
         * @function encode
         * @memberof KeepAlive.S2C
         * @static
         * @param {KeepAlive.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.time);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link KeepAlive.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof KeepAlive.S2C
         * @static
         * @param {KeepAlive.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof KeepAlive.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {KeepAlive.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.KeepAlive.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("time"))
                throw $util.ProtocolError("missing required 'time'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof KeepAlive.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {KeepAlive.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof KeepAlive.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                return "time: integer|Long expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof KeepAlive.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {KeepAlive.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.KeepAlive.S2C)
                return object;
            var message = new $root.KeepAlive.S2C();
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof KeepAlive.S2C
         * @static
         * @param {KeepAlive.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time = options.longs === String ? "0" : 0;
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof KeepAlive.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    KeepAlive.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof KeepAlive
         * @interface IRequest
         * @property {KeepAlive.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof KeepAlive
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {KeepAlive.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {KeepAlive.IC2S} c2s
         * @memberof KeepAlive.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof KeepAlive.Request
         * @static
         * @param {KeepAlive.IRequest=} [properties] Properties to set
         * @returns {KeepAlive.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link KeepAlive.Request.verify|verify} messages.
         * @function encode
         * @memberof KeepAlive.Request
         * @static
         * @param {KeepAlive.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.KeepAlive.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link KeepAlive.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof KeepAlive.Request
         * @static
         * @param {KeepAlive.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof KeepAlive.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {KeepAlive.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.KeepAlive.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.KeepAlive.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof KeepAlive.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {KeepAlive.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof KeepAlive.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.KeepAlive.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof KeepAlive.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {KeepAlive.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.KeepAlive.Request)
                return object;
            var message = new $root.KeepAlive.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".KeepAlive.Request.c2s: object expected");
                message.c2s = $root.KeepAlive.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof KeepAlive.Request
         * @static
         * @param {KeepAlive.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.KeepAlive.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof KeepAlive.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    KeepAlive.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof KeepAlive
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {KeepAlive.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof KeepAlive
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {KeepAlive.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof KeepAlive.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof KeepAlive.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof KeepAlive.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {KeepAlive.IS2C|null|undefined} s2c
         * @memberof KeepAlive.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof KeepAlive.Response
         * @static
         * @param {KeepAlive.IResponse=} [properties] Properties to set
         * @returns {KeepAlive.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link KeepAlive.Response.verify|verify} messages.
         * @function encode
         * @memberof KeepAlive.Response
         * @static
         * @param {KeepAlive.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.KeepAlive.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link KeepAlive.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof KeepAlive.Response
         * @static
         * @param {KeepAlive.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof KeepAlive.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {KeepAlive.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.KeepAlive.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.KeepAlive.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof KeepAlive.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {KeepAlive.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof KeepAlive.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.KeepAlive.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof KeepAlive.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {KeepAlive.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.KeepAlive.Response)
                return object;
            var message = new $root.KeepAlive.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".KeepAlive.Response.s2c: object expected");
                message.s2c = $root.KeepAlive.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof KeepAlive.Response
         * @static
         * @param {KeepAlive.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.KeepAlive.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof KeepAlive.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return KeepAlive;
})();

$root.Notify = (function() {

    /**
     * Namespace Notify.
     * @exports Notify
     * @namespace
     */
    var Notify = {};

    /**
     * NotifyType enum.
     * @name Notify.NotifyType
     * @enum {string}
     * @property {number} NotifyType_None=0 NotifyType_None value
     * @property {number} NotifyType_GtwEvent=1 NotifyType_GtwEvent value
     * @property {number} NotifyType_ProgramStatus=2 NotifyType_ProgramStatus value
     * @property {number} NotifyType_ConnStatus=3 NotifyType_ConnStatus value
     * @property {number} NotifyType_QotRight=4 NotifyType_QotRight value
     * @property {number} NotifyType_APILevel=5 NotifyType_APILevel value
     * @property {number} NotifyType_APIQuota=6 NotifyType_APIQuota value
     */
    Notify.NotifyType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NotifyType_None"] = 0;
        values[valuesById[1] = "NotifyType_GtwEvent"] = 1;
        values[valuesById[2] = "NotifyType_ProgramStatus"] = 2;
        values[valuesById[3] = "NotifyType_ConnStatus"] = 3;
        values[valuesById[4] = "NotifyType_QotRight"] = 4;
        values[valuesById[5] = "NotifyType_APILevel"] = 5;
        values[valuesById[6] = "NotifyType_APIQuota"] = 6;
        return values;
    })();

    /**
     * GtwEventType enum.
     * @name Notify.GtwEventType
     * @enum {string}
     * @property {number} GtwEventType_None=0 GtwEventType_None value
     * @property {number} GtwEventType_LocalCfgLoadFailed=1 GtwEventType_LocalCfgLoadFailed value
     * @property {number} GtwEventType_APISvrRunFailed=2 GtwEventType_APISvrRunFailed value
     * @property {number} GtwEventType_ForceUpdate=3 GtwEventType_ForceUpdate value
     * @property {number} GtwEventType_LoginFailed=4 GtwEventType_LoginFailed value
     * @property {number} GtwEventType_UnAgreeDisclaimer=5 GtwEventType_UnAgreeDisclaimer value
     * @property {number} GtwEventType_NetCfgMissing=6 GtwEventType_NetCfgMissing value
     * @property {number} GtwEventType_KickedOut=7 GtwEventType_KickedOut value
     * @property {number} GtwEventType_LoginPwdChanged=8 GtwEventType_LoginPwdChanged value
     * @property {number} GtwEventType_BanLogin=9 GtwEventType_BanLogin value
     * @property {number} GtwEventType_NeedPicVerifyCode=10 GtwEventType_NeedPicVerifyCode value
     * @property {number} GtwEventType_NeedPhoneVerifyCode=11 GtwEventType_NeedPhoneVerifyCode value
     * @property {number} GtwEventType_AppDataNotExist=12 GtwEventType_AppDataNotExist value
     * @property {number} GtwEventType_NessaryDataMissing=13 GtwEventType_NessaryDataMissing value
     * @property {number} GtwEventType_TradePwdChanged=14 GtwEventType_TradePwdChanged value
     * @property {number} GtwEventType_EnableDeviceLock=15 GtwEventType_EnableDeviceLock value
     */
    Notify.GtwEventType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "GtwEventType_None"] = 0;
        values[valuesById[1] = "GtwEventType_LocalCfgLoadFailed"] = 1;
        values[valuesById[2] = "GtwEventType_APISvrRunFailed"] = 2;
        values[valuesById[3] = "GtwEventType_ForceUpdate"] = 3;
        values[valuesById[4] = "GtwEventType_LoginFailed"] = 4;
        values[valuesById[5] = "GtwEventType_UnAgreeDisclaimer"] = 5;
        values[valuesById[6] = "GtwEventType_NetCfgMissing"] = 6;
        values[valuesById[7] = "GtwEventType_KickedOut"] = 7;
        values[valuesById[8] = "GtwEventType_LoginPwdChanged"] = 8;
        values[valuesById[9] = "GtwEventType_BanLogin"] = 9;
        values[valuesById[10] = "GtwEventType_NeedPicVerifyCode"] = 10;
        values[valuesById[11] = "GtwEventType_NeedPhoneVerifyCode"] = 11;
        values[valuesById[12] = "GtwEventType_AppDataNotExist"] = 12;
        values[valuesById[13] = "GtwEventType_NessaryDataMissing"] = 13;
        values[valuesById[14] = "GtwEventType_TradePwdChanged"] = 14;
        values[valuesById[15] = "GtwEventType_EnableDeviceLock"] = 15;
        return values;
    })();

    Notify.GtwEvent = (function() {

        /**
         * Properties of a GtwEvent.
         * @memberof Notify
         * @interface IGtwEvent
         * @property {number} eventType GtwEvent eventType
         * @property {string} desc GtwEvent desc
         */

        /**
         * Constructs a new GtwEvent.
         * @memberof Notify
         * @classdesc Represents a GtwEvent.
         * @implements IGtwEvent
         * @constructor
         * @param {Notify.IGtwEvent=} [properties] Properties to set
         */
        function GtwEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GtwEvent eventType.
         * @member {number} eventType
         * @memberof Notify.GtwEvent
         * @instance
         */
        GtwEvent.prototype.eventType = 0;

        /**
         * GtwEvent desc.
         * @member {string} desc
         * @memberof Notify.GtwEvent
         * @instance
         */
        GtwEvent.prototype.desc = "";

        /**
         * Creates a new GtwEvent instance using the specified properties.
         * @function create
         * @memberof Notify.GtwEvent
         * @static
         * @param {Notify.IGtwEvent=} [properties] Properties to set
         * @returns {Notify.GtwEvent} GtwEvent instance
         */
        GtwEvent.create = function create(properties) {
            return new GtwEvent(properties);
        };

        /**
         * Encodes the specified GtwEvent message. Does not implicitly {@link Notify.GtwEvent.verify|verify} messages.
         * @function encode
         * @memberof Notify.GtwEvent
         * @static
         * @param {Notify.IGtwEvent} message GtwEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GtwEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.eventType);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.desc);
            return writer;
        };

        /**
         * Encodes the specified GtwEvent message, length delimited. Does not implicitly {@link Notify.GtwEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Notify.GtwEvent
         * @static
         * @param {Notify.IGtwEvent} message GtwEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GtwEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GtwEvent message from the specified reader or buffer.
         * @function decode
         * @memberof Notify.GtwEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Notify.GtwEvent} GtwEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GtwEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Notify.GtwEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.eventType = reader.int32();
                    break;
                case 2:
                    message.desc = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("eventType"))
                throw $util.ProtocolError("missing required 'eventType'", { instance: message });
            if (!message.hasOwnProperty("desc"))
                throw $util.ProtocolError("missing required 'desc'", { instance: message });
            return message;
        };

        /**
         * Decodes a GtwEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Notify.GtwEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Notify.GtwEvent} GtwEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GtwEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GtwEvent message.
         * @function verify
         * @memberof Notify.GtwEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GtwEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.eventType))
                return "eventType: integer expected";
            if (!$util.isString(message.desc))
                return "desc: string expected";
            return null;
        };

        /**
         * Creates a GtwEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Notify.GtwEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Notify.GtwEvent} GtwEvent
         */
        GtwEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.Notify.GtwEvent)
                return object;
            var message = new $root.Notify.GtwEvent();
            if (object.eventType != null)
                message.eventType = object.eventType | 0;
            if (object.desc != null)
                message.desc = String(object.desc);
            return message;
        };

        /**
         * Creates a plain object from a GtwEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Notify.GtwEvent
         * @static
         * @param {Notify.GtwEvent} message GtwEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GtwEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eventType = 0;
                object.desc = "";
            }
            if (message.eventType != null && message.hasOwnProperty("eventType"))
                object.eventType = message.eventType;
            if (message.desc != null && message.hasOwnProperty("desc"))
                object.desc = message.desc;
            return object;
        };

        /**
         * Converts this GtwEvent to JSON.
         * @function toJSON
         * @memberof Notify.GtwEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GtwEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GtwEvent;
    })();

    Notify.ProgramStatus = (function() {

        /**
         * Properties of a ProgramStatus.
         * @memberof Notify
         * @interface IProgramStatus
         * @property {Common.IProgramStatus} programStatus ProgramStatus programStatus
         */

        /**
         * Constructs a new ProgramStatus.
         * @memberof Notify
         * @classdesc Represents a ProgramStatus.
         * @implements IProgramStatus
         * @constructor
         * @param {Notify.IProgramStatus=} [properties] Properties to set
         */
        function ProgramStatus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProgramStatus programStatus.
         * @member {Common.IProgramStatus} programStatus
         * @memberof Notify.ProgramStatus
         * @instance
         */
        ProgramStatus.prototype.programStatus = null;

        /**
         * Creates a new ProgramStatus instance using the specified properties.
         * @function create
         * @memberof Notify.ProgramStatus
         * @static
         * @param {Notify.IProgramStatus=} [properties] Properties to set
         * @returns {Notify.ProgramStatus} ProgramStatus instance
         */
        ProgramStatus.create = function create(properties) {
            return new ProgramStatus(properties);
        };

        /**
         * Encodes the specified ProgramStatus message. Does not implicitly {@link Notify.ProgramStatus.verify|verify} messages.
         * @function encode
         * @memberof Notify.ProgramStatus
         * @static
         * @param {Notify.IProgramStatus} message ProgramStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProgramStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Common.ProgramStatus.encode(message.programStatus, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ProgramStatus message, length delimited. Does not implicitly {@link Notify.ProgramStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Notify.ProgramStatus
         * @static
         * @param {Notify.IProgramStatus} message ProgramStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProgramStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProgramStatus message from the specified reader or buffer.
         * @function decode
         * @memberof Notify.ProgramStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Notify.ProgramStatus} ProgramStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProgramStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Notify.ProgramStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.programStatus = $root.Common.ProgramStatus.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("programStatus"))
                throw $util.ProtocolError("missing required 'programStatus'", { instance: message });
            return message;
        };

        /**
         * Decodes a ProgramStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Notify.ProgramStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Notify.ProgramStatus} ProgramStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProgramStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProgramStatus message.
         * @function verify
         * @memberof Notify.ProgramStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProgramStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Common.ProgramStatus.verify(message.programStatus);
                if (error)
                    return "programStatus." + error;
            }
            return null;
        };

        /**
         * Creates a ProgramStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Notify.ProgramStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Notify.ProgramStatus} ProgramStatus
         */
        ProgramStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.Notify.ProgramStatus)
                return object;
            var message = new $root.Notify.ProgramStatus();
            if (object.programStatus != null) {
                if (typeof object.programStatus !== "object")
                    throw TypeError(".Notify.ProgramStatus.programStatus: object expected");
                message.programStatus = $root.Common.ProgramStatus.fromObject(object.programStatus);
            }
            return message;
        };

        /**
         * Creates a plain object from a ProgramStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Notify.ProgramStatus
         * @static
         * @param {Notify.ProgramStatus} message ProgramStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProgramStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.programStatus = null;
            if (message.programStatus != null && message.hasOwnProperty("programStatus"))
                object.programStatus = $root.Common.ProgramStatus.toObject(message.programStatus, options);
            return object;
        };

        /**
         * Converts this ProgramStatus to JSON.
         * @function toJSON
         * @memberof Notify.ProgramStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProgramStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProgramStatus;
    })();

    Notify.ConnectStatus = (function() {

        /**
         * Properties of a ConnectStatus.
         * @memberof Notify
         * @interface IConnectStatus
         * @property {boolean} qotLogined ConnectStatus qotLogined
         * @property {boolean} trdLogined ConnectStatus trdLogined
         */

        /**
         * Constructs a new ConnectStatus.
         * @memberof Notify
         * @classdesc Represents a ConnectStatus.
         * @implements IConnectStatus
         * @constructor
         * @param {Notify.IConnectStatus=} [properties] Properties to set
         */
        function ConnectStatus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConnectStatus qotLogined.
         * @member {boolean} qotLogined
         * @memberof Notify.ConnectStatus
         * @instance
         */
        ConnectStatus.prototype.qotLogined = false;

        /**
         * ConnectStatus trdLogined.
         * @member {boolean} trdLogined
         * @memberof Notify.ConnectStatus
         * @instance
         */
        ConnectStatus.prototype.trdLogined = false;

        /**
         * Creates a new ConnectStatus instance using the specified properties.
         * @function create
         * @memberof Notify.ConnectStatus
         * @static
         * @param {Notify.IConnectStatus=} [properties] Properties to set
         * @returns {Notify.ConnectStatus} ConnectStatus instance
         */
        ConnectStatus.create = function create(properties) {
            return new ConnectStatus(properties);
        };

        /**
         * Encodes the specified ConnectStatus message. Does not implicitly {@link Notify.ConnectStatus.verify|verify} messages.
         * @function encode
         * @memberof Notify.ConnectStatus
         * @static
         * @param {Notify.IConnectStatus} message ConnectStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.qotLogined);
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.trdLogined);
            return writer;
        };

        /**
         * Encodes the specified ConnectStatus message, length delimited. Does not implicitly {@link Notify.ConnectStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Notify.ConnectStatus
         * @static
         * @param {Notify.IConnectStatus} message ConnectStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConnectStatus message from the specified reader or buffer.
         * @function decode
         * @memberof Notify.ConnectStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Notify.ConnectStatus} ConnectStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Notify.ConnectStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.qotLogined = reader.bool();
                    break;
                case 2:
                    message.trdLogined = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("qotLogined"))
                throw $util.ProtocolError("missing required 'qotLogined'", { instance: message });
            if (!message.hasOwnProperty("trdLogined"))
                throw $util.ProtocolError("missing required 'trdLogined'", { instance: message });
            return message;
        };

        /**
         * Decodes a ConnectStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Notify.ConnectStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Notify.ConnectStatus} ConnectStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConnectStatus message.
         * @function verify
         * @memberof Notify.ConnectStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConnectStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.qotLogined !== "boolean")
                return "qotLogined: boolean expected";
            if (typeof message.trdLogined !== "boolean")
                return "trdLogined: boolean expected";
            return null;
        };

        /**
         * Creates a ConnectStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Notify.ConnectStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Notify.ConnectStatus} ConnectStatus
         */
        ConnectStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.Notify.ConnectStatus)
                return object;
            var message = new $root.Notify.ConnectStatus();
            if (object.qotLogined != null)
                message.qotLogined = Boolean(object.qotLogined);
            if (object.trdLogined != null)
                message.trdLogined = Boolean(object.trdLogined);
            return message;
        };

        /**
         * Creates a plain object from a ConnectStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Notify.ConnectStatus
         * @static
         * @param {Notify.ConnectStatus} message ConnectStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConnectStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.qotLogined = false;
                object.trdLogined = false;
            }
            if (message.qotLogined != null && message.hasOwnProperty("qotLogined"))
                object.qotLogined = message.qotLogined;
            if (message.trdLogined != null && message.hasOwnProperty("trdLogined"))
                object.trdLogined = message.trdLogined;
            return object;
        };

        /**
         * Converts this ConnectStatus to JSON.
         * @function toJSON
         * @memberof Notify.ConnectStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConnectStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConnectStatus;
    })();

    Notify.QotRight = (function() {

        /**
         * Properties of a QotRight.
         * @memberof Notify
         * @interface IQotRight
         * @property {number} hkQotRight QotRight hkQotRight
         * @property {number} usQotRight QotRight usQotRight
         * @property {number} cnQotRight QotRight cnQotRight
         * @property {number|null} [hkOptionQotRight] QotRight hkOptionQotRight
         * @property {boolean|null} [hasUSOptionQotRight] QotRight hasUSOptionQotRight
         * @property {number|null} [hkFutureQotRight] QotRight hkFutureQotRight
         */

        /**
         * Constructs a new QotRight.
         * @memberof Notify
         * @classdesc Represents a QotRight.
         * @implements IQotRight
         * @constructor
         * @param {Notify.IQotRight=} [properties] Properties to set
         */
        function QotRight(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QotRight hkQotRight.
         * @member {number} hkQotRight
         * @memberof Notify.QotRight
         * @instance
         */
        QotRight.prototype.hkQotRight = 0;

        /**
         * QotRight usQotRight.
         * @member {number} usQotRight
         * @memberof Notify.QotRight
         * @instance
         */
        QotRight.prototype.usQotRight = 0;

        /**
         * QotRight cnQotRight.
         * @member {number} cnQotRight
         * @memberof Notify.QotRight
         * @instance
         */
        QotRight.prototype.cnQotRight = 0;

        /**
         * QotRight hkOptionQotRight.
         * @member {number} hkOptionQotRight
         * @memberof Notify.QotRight
         * @instance
         */
        QotRight.prototype.hkOptionQotRight = 0;

        /**
         * QotRight hasUSOptionQotRight.
         * @member {boolean} hasUSOptionQotRight
         * @memberof Notify.QotRight
         * @instance
         */
        QotRight.prototype.hasUSOptionQotRight = false;

        /**
         * QotRight hkFutureQotRight.
         * @member {number} hkFutureQotRight
         * @memberof Notify.QotRight
         * @instance
         */
        QotRight.prototype.hkFutureQotRight = 0;

        /**
         * Creates a new QotRight instance using the specified properties.
         * @function create
         * @memberof Notify.QotRight
         * @static
         * @param {Notify.IQotRight=} [properties] Properties to set
         * @returns {Notify.QotRight} QotRight instance
         */
        QotRight.create = function create(properties) {
            return new QotRight(properties);
        };

        /**
         * Encodes the specified QotRight message. Does not implicitly {@link Notify.QotRight.verify|verify} messages.
         * @function encode
         * @memberof Notify.QotRight
         * @static
         * @param {Notify.IQotRight} message QotRight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QotRight.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.hkQotRight);
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.usQotRight);
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.cnQotRight);
            if (message.hkOptionQotRight != null && message.hasOwnProperty("hkOptionQotRight"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.hkOptionQotRight);
            if (message.hasUSOptionQotRight != null && message.hasOwnProperty("hasUSOptionQotRight"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.hasUSOptionQotRight);
            if (message.hkFutureQotRight != null && message.hasOwnProperty("hkFutureQotRight"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.hkFutureQotRight);
            return writer;
        };

        /**
         * Encodes the specified QotRight message, length delimited. Does not implicitly {@link Notify.QotRight.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Notify.QotRight
         * @static
         * @param {Notify.IQotRight} message QotRight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QotRight.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QotRight message from the specified reader or buffer.
         * @function decode
         * @memberof Notify.QotRight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Notify.QotRight} QotRight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QotRight.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Notify.QotRight();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 4:
                    message.hkQotRight = reader.int32();
                    break;
                case 5:
                    message.usQotRight = reader.int32();
                    break;
                case 6:
                    message.cnQotRight = reader.int32();
                    break;
                case 7:
                    message.hkOptionQotRight = reader.int32();
                    break;
                case 8:
                    message.hasUSOptionQotRight = reader.bool();
                    break;
                case 9:
                    message.hkFutureQotRight = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("hkQotRight"))
                throw $util.ProtocolError("missing required 'hkQotRight'", { instance: message });
            if (!message.hasOwnProperty("usQotRight"))
                throw $util.ProtocolError("missing required 'usQotRight'", { instance: message });
            if (!message.hasOwnProperty("cnQotRight"))
                throw $util.ProtocolError("missing required 'cnQotRight'", { instance: message });
            return message;
        };

        /**
         * Decodes a QotRight message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Notify.QotRight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Notify.QotRight} QotRight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QotRight.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QotRight message.
         * @function verify
         * @memberof Notify.QotRight
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QotRight.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.hkQotRight))
                return "hkQotRight: integer expected";
            if (!$util.isInteger(message.usQotRight))
                return "usQotRight: integer expected";
            if (!$util.isInteger(message.cnQotRight))
                return "cnQotRight: integer expected";
            if (message.hkOptionQotRight != null && message.hasOwnProperty("hkOptionQotRight"))
                if (!$util.isInteger(message.hkOptionQotRight))
                    return "hkOptionQotRight: integer expected";
            if (message.hasUSOptionQotRight != null && message.hasOwnProperty("hasUSOptionQotRight"))
                if (typeof message.hasUSOptionQotRight !== "boolean")
                    return "hasUSOptionQotRight: boolean expected";
            if (message.hkFutureQotRight != null && message.hasOwnProperty("hkFutureQotRight"))
                if (!$util.isInteger(message.hkFutureQotRight))
                    return "hkFutureQotRight: integer expected";
            return null;
        };

        /**
         * Creates a QotRight message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Notify.QotRight
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Notify.QotRight} QotRight
         */
        QotRight.fromObject = function fromObject(object) {
            if (object instanceof $root.Notify.QotRight)
                return object;
            var message = new $root.Notify.QotRight();
            if (object.hkQotRight != null)
                message.hkQotRight = object.hkQotRight | 0;
            if (object.usQotRight != null)
                message.usQotRight = object.usQotRight | 0;
            if (object.cnQotRight != null)
                message.cnQotRight = object.cnQotRight | 0;
            if (object.hkOptionQotRight != null)
                message.hkOptionQotRight = object.hkOptionQotRight | 0;
            if (object.hasUSOptionQotRight != null)
                message.hasUSOptionQotRight = Boolean(object.hasUSOptionQotRight);
            if (object.hkFutureQotRight != null)
                message.hkFutureQotRight = object.hkFutureQotRight | 0;
            return message;
        };

        /**
         * Creates a plain object from a QotRight message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Notify.QotRight
         * @static
         * @param {Notify.QotRight} message QotRight
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QotRight.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.hkQotRight = 0;
                object.usQotRight = 0;
                object.cnQotRight = 0;
                object.hkOptionQotRight = 0;
                object.hasUSOptionQotRight = false;
                object.hkFutureQotRight = 0;
            }
            if (message.hkQotRight != null && message.hasOwnProperty("hkQotRight"))
                object.hkQotRight = message.hkQotRight;
            if (message.usQotRight != null && message.hasOwnProperty("usQotRight"))
                object.usQotRight = message.usQotRight;
            if (message.cnQotRight != null && message.hasOwnProperty("cnQotRight"))
                object.cnQotRight = message.cnQotRight;
            if (message.hkOptionQotRight != null && message.hasOwnProperty("hkOptionQotRight"))
                object.hkOptionQotRight = message.hkOptionQotRight;
            if (message.hasUSOptionQotRight != null && message.hasOwnProperty("hasUSOptionQotRight"))
                object.hasUSOptionQotRight = message.hasUSOptionQotRight;
            if (message.hkFutureQotRight != null && message.hasOwnProperty("hkFutureQotRight"))
                object.hkFutureQotRight = message.hkFutureQotRight;
            return object;
        };

        /**
         * Converts this QotRight to JSON.
         * @function toJSON
         * @memberof Notify.QotRight
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QotRight.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QotRight;
    })();

    Notify.APILevel = (function() {

        /**
         * Properties of a APILevel.
         * @memberof Notify
         * @interface IAPILevel
         * @property {string} apiLevel APILevel apiLevel
         */

        /**
         * Constructs a new APILevel.
         * @memberof Notify
         * @classdesc Represents a APILevel.
         * @implements IAPILevel
         * @constructor
         * @param {Notify.IAPILevel=} [properties] Properties to set
         */
        function APILevel(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * APILevel apiLevel.
         * @member {string} apiLevel
         * @memberof Notify.APILevel
         * @instance
         */
        APILevel.prototype.apiLevel = "";

        /**
         * Creates a new APILevel instance using the specified properties.
         * @function create
         * @memberof Notify.APILevel
         * @static
         * @param {Notify.IAPILevel=} [properties] Properties to set
         * @returns {Notify.APILevel} APILevel instance
         */
        APILevel.create = function create(properties) {
            return new APILevel(properties);
        };

        /**
         * Encodes the specified APILevel message. Does not implicitly {@link Notify.APILevel.verify|verify} messages.
         * @function encode
         * @memberof Notify.APILevel
         * @static
         * @param {Notify.IAPILevel} message APILevel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        APILevel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.apiLevel);
            return writer;
        };

        /**
         * Encodes the specified APILevel message, length delimited. Does not implicitly {@link Notify.APILevel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Notify.APILevel
         * @static
         * @param {Notify.IAPILevel} message APILevel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        APILevel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a APILevel message from the specified reader or buffer.
         * @function decode
         * @memberof Notify.APILevel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Notify.APILevel} APILevel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        APILevel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Notify.APILevel();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 3:
                    message.apiLevel = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("apiLevel"))
                throw $util.ProtocolError("missing required 'apiLevel'", { instance: message });
            return message;
        };

        /**
         * Decodes a APILevel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Notify.APILevel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Notify.APILevel} APILevel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        APILevel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a APILevel message.
         * @function verify
         * @memberof Notify.APILevel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        APILevel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.apiLevel))
                return "apiLevel: string expected";
            return null;
        };

        /**
         * Creates a APILevel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Notify.APILevel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Notify.APILevel} APILevel
         */
        APILevel.fromObject = function fromObject(object) {
            if (object instanceof $root.Notify.APILevel)
                return object;
            var message = new $root.Notify.APILevel();
            if (object.apiLevel != null)
                message.apiLevel = String(object.apiLevel);
            return message;
        };

        /**
         * Creates a plain object from a APILevel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Notify.APILevel
         * @static
         * @param {Notify.APILevel} message APILevel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        APILevel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.apiLevel = "";
            if (message.apiLevel != null && message.hasOwnProperty("apiLevel"))
                object.apiLevel = message.apiLevel;
            return object;
        };

        /**
         * Converts this APILevel to JSON.
         * @function toJSON
         * @memberof Notify.APILevel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        APILevel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return APILevel;
    })();

    Notify.APIQuota = (function() {

        /**
         * Properties of a APIQuota.
         * @memberof Notify
         * @interface IAPIQuota
         * @property {number} subQuota APIQuota subQuota
         * @property {number} historyKLQuota APIQuota historyKLQuota
         */

        /**
         * Constructs a new APIQuota.
         * @memberof Notify
         * @classdesc Represents a APIQuota.
         * @implements IAPIQuota
         * @constructor
         * @param {Notify.IAPIQuota=} [properties] Properties to set
         */
        function APIQuota(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * APIQuota subQuota.
         * @member {number} subQuota
         * @memberof Notify.APIQuota
         * @instance
         */
        APIQuota.prototype.subQuota = 0;

        /**
         * APIQuota historyKLQuota.
         * @member {number} historyKLQuota
         * @memberof Notify.APIQuota
         * @instance
         */
        APIQuota.prototype.historyKLQuota = 0;

        /**
         * Creates a new APIQuota instance using the specified properties.
         * @function create
         * @memberof Notify.APIQuota
         * @static
         * @param {Notify.IAPIQuota=} [properties] Properties to set
         * @returns {Notify.APIQuota} APIQuota instance
         */
        APIQuota.create = function create(properties) {
            return new APIQuota(properties);
        };

        /**
         * Encodes the specified APIQuota message. Does not implicitly {@link Notify.APIQuota.verify|verify} messages.
         * @function encode
         * @memberof Notify.APIQuota
         * @static
         * @param {Notify.IAPIQuota} message APIQuota message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        APIQuota.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.subQuota);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.historyKLQuota);
            return writer;
        };

        /**
         * Encodes the specified APIQuota message, length delimited. Does not implicitly {@link Notify.APIQuota.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Notify.APIQuota
         * @static
         * @param {Notify.IAPIQuota} message APIQuota message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        APIQuota.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a APIQuota message from the specified reader or buffer.
         * @function decode
         * @memberof Notify.APIQuota
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Notify.APIQuota} APIQuota
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        APIQuota.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Notify.APIQuota();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.subQuota = reader.int32();
                    break;
                case 2:
                    message.historyKLQuota = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("subQuota"))
                throw $util.ProtocolError("missing required 'subQuota'", { instance: message });
            if (!message.hasOwnProperty("historyKLQuota"))
                throw $util.ProtocolError("missing required 'historyKLQuota'", { instance: message });
            return message;
        };

        /**
         * Decodes a APIQuota message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Notify.APIQuota
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Notify.APIQuota} APIQuota
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        APIQuota.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a APIQuota message.
         * @function verify
         * @memberof Notify.APIQuota
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        APIQuota.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.subQuota))
                return "subQuota: integer expected";
            if (!$util.isInteger(message.historyKLQuota))
                return "historyKLQuota: integer expected";
            return null;
        };

        /**
         * Creates a APIQuota message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Notify.APIQuota
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Notify.APIQuota} APIQuota
         */
        APIQuota.fromObject = function fromObject(object) {
            if (object instanceof $root.Notify.APIQuota)
                return object;
            var message = new $root.Notify.APIQuota();
            if (object.subQuota != null)
                message.subQuota = object.subQuota | 0;
            if (object.historyKLQuota != null)
                message.historyKLQuota = object.historyKLQuota | 0;
            return message;
        };

        /**
         * Creates a plain object from a APIQuota message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Notify.APIQuota
         * @static
         * @param {Notify.APIQuota} message APIQuota
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        APIQuota.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.subQuota = 0;
                object.historyKLQuota = 0;
            }
            if (message.subQuota != null && message.hasOwnProperty("subQuota"))
                object.subQuota = message.subQuota;
            if (message.historyKLQuota != null && message.hasOwnProperty("historyKLQuota"))
                object.historyKLQuota = message.historyKLQuota;
            return object;
        };

        /**
         * Converts this APIQuota to JSON.
         * @function toJSON
         * @memberof Notify.APIQuota
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        APIQuota.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return APIQuota;
    })();

    Notify.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Notify
         * @interface IS2C
         * @property {number} type S2C type
         * @property {Notify.IGtwEvent|null} [event] S2C event
         * @property {Notify.IProgramStatus|null} [programStatus] S2C programStatus
         * @property {Notify.IConnectStatus|null} [connectStatus] S2C connectStatus
         * @property {Notify.IQotRight|null} [qotRight] S2C qotRight
         * @property {Notify.IAPILevel|null} [apiLevel] S2C apiLevel
         * @property {Notify.IAPIQuota|null} [apiQuota] S2C apiQuota
         */

        /**
         * Constructs a new S2C.
         * @memberof Notify
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Notify.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C type.
         * @member {number} type
         * @memberof Notify.S2C
         * @instance
         */
        S2C.prototype.type = 0;

        /**
         * S2C event.
         * @member {Notify.IGtwEvent|null|undefined} event
         * @memberof Notify.S2C
         * @instance
         */
        S2C.prototype.event = null;

        /**
         * S2C programStatus.
         * @member {Notify.IProgramStatus|null|undefined} programStatus
         * @memberof Notify.S2C
         * @instance
         */
        S2C.prototype.programStatus = null;

        /**
         * S2C connectStatus.
         * @member {Notify.IConnectStatus|null|undefined} connectStatus
         * @memberof Notify.S2C
         * @instance
         */
        S2C.prototype.connectStatus = null;

        /**
         * S2C qotRight.
         * @member {Notify.IQotRight|null|undefined} qotRight
         * @memberof Notify.S2C
         * @instance
         */
        S2C.prototype.qotRight = null;

        /**
         * S2C apiLevel.
         * @member {Notify.IAPILevel|null|undefined} apiLevel
         * @memberof Notify.S2C
         * @instance
         */
        S2C.prototype.apiLevel = null;

        /**
         * S2C apiQuota.
         * @member {Notify.IAPIQuota|null|undefined} apiQuota
         * @memberof Notify.S2C
         * @instance
         */
        S2C.prototype.apiQuota = null;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Notify.S2C
         * @static
         * @param {Notify.IS2C=} [properties] Properties to set
         * @returns {Notify.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Notify.S2C.verify|verify} messages.
         * @function encode
         * @memberof Notify.S2C
         * @static
         * @param {Notify.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.event != null && message.hasOwnProperty("event"))
                $root.Notify.GtwEvent.encode(message.event, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.programStatus != null && message.hasOwnProperty("programStatus"))
                $root.Notify.ProgramStatus.encode(message.programStatus, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.connectStatus != null && message.hasOwnProperty("connectStatus"))
                $root.Notify.ConnectStatus.encode(message.connectStatus, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.qotRight != null && message.hasOwnProperty("qotRight"))
                $root.Notify.QotRight.encode(message.qotRight, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.apiLevel != null && message.hasOwnProperty("apiLevel"))
                $root.Notify.APILevel.encode(message.apiLevel, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.apiQuota != null && message.hasOwnProperty("apiQuota"))
                $root.Notify.APIQuota.encode(message.apiQuota, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Notify.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Notify.S2C
         * @static
         * @param {Notify.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Notify.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Notify.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Notify.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.event = $root.Notify.GtwEvent.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.programStatus = $root.Notify.ProgramStatus.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.connectStatus = $root.Notify.ConnectStatus.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.qotRight = $root.Notify.QotRight.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.apiLevel = $root.Notify.APILevel.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.apiQuota = $root.Notify.APIQuota.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Notify.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Notify.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Notify.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            if (message.event != null && message.hasOwnProperty("event")) {
                var error = $root.Notify.GtwEvent.verify(message.event);
                if (error)
                    return "event." + error;
            }
            if (message.programStatus != null && message.hasOwnProperty("programStatus")) {
                var error = $root.Notify.ProgramStatus.verify(message.programStatus);
                if (error)
                    return "programStatus." + error;
            }
            if (message.connectStatus != null && message.hasOwnProperty("connectStatus")) {
                var error = $root.Notify.ConnectStatus.verify(message.connectStatus);
                if (error)
                    return "connectStatus." + error;
            }
            if (message.qotRight != null && message.hasOwnProperty("qotRight")) {
                var error = $root.Notify.QotRight.verify(message.qotRight);
                if (error)
                    return "qotRight." + error;
            }
            if (message.apiLevel != null && message.hasOwnProperty("apiLevel")) {
                var error = $root.Notify.APILevel.verify(message.apiLevel);
                if (error)
                    return "apiLevel." + error;
            }
            if (message.apiQuota != null && message.hasOwnProperty("apiQuota")) {
                var error = $root.Notify.APIQuota.verify(message.apiQuota);
                if (error)
                    return "apiQuota." + error;
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Notify.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Notify.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Notify.S2C)
                return object;
            var message = new $root.Notify.S2C();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.event != null) {
                if (typeof object.event !== "object")
                    throw TypeError(".Notify.S2C.event: object expected");
                message.event = $root.Notify.GtwEvent.fromObject(object.event);
            }
            if (object.programStatus != null) {
                if (typeof object.programStatus !== "object")
                    throw TypeError(".Notify.S2C.programStatus: object expected");
                message.programStatus = $root.Notify.ProgramStatus.fromObject(object.programStatus);
            }
            if (object.connectStatus != null) {
                if (typeof object.connectStatus !== "object")
                    throw TypeError(".Notify.S2C.connectStatus: object expected");
                message.connectStatus = $root.Notify.ConnectStatus.fromObject(object.connectStatus);
            }
            if (object.qotRight != null) {
                if (typeof object.qotRight !== "object")
                    throw TypeError(".Notify.S2C.qotRight: object expected");
                message.qotRight = $root.Notify.QotRight.fromObject(object.qotRight);
            }
            if (object.apiLevel != null) {
                if (typeof object.apiLevel !== "object")
                    throw TypeError(".Notify.S2C.apiLevel: object expected");
                message.apiLevel = $root.Notify.APILevel.fromObject(object.apiLevel);
            }
            if (object.apiQuota != null) {
                if (typeof object.apiQuota !== "object")
                    throw TypeError(".Notify.S2C.apiQuota: object expected");
                message.apiQuota = $root.Notify.APIQuota.fromObject(object.apiQuota);
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Notify.S2C
         * @static
         * @param {Notify.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.event = null;
                object.programStatus = null;
                object.connectStatus = null;
                object.qotRight = null;
                object.apiLevel = null;
                object.apiQuota = null;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.event != null && message.hasOwnProperty("event"))
                object.event = $root.Notify.GtwEvent.toObject(message.event, options);
            if (message.programStatus != null && message.hasOwnProperty("programStatus"))
                object.programStatus = $root.Notify.ProgramStatus.toObject(message.programStatus, options);
            if (message.connectStatus != null && message.hasOwnProperty("connectStatus"))
                object.connectStatus = $root.Notify.ConnectStatus.toObject(message.connectStatus, options);
            if (message.qotRight != null && message.hasOwnProperty("qotRight"))
                object.qotRight = $root.Notify.QotRight.toObject(message.qotRight, options);
            if (message.apiLevel != null && message.hasOwnProperty("apiLevel"))
                object.apiLevel = $root.Notify.APILevel.toObject(message.apiLevel, options);
            if (message.apiQuota != null && message.hasOwnProperty("apiQuota"))
                object.apiQuota = $root.Notify.APIQuota.toObject(message.apiQuota, options);
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Notify.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Notify.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Notify
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Notify.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Notify
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Notify.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Notify.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Notify.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Notify.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Notify.IS2C|null|undefined} s2c
         * @memberof Notify.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Notify.Response
         * @static
         * @param {Notify.IResponse=} [properties] Properties to set
         * @returns {Notify.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Notify.Response.verify|verify} messages.
         * @function encode
         * @memberof Notify.Response
         * @static
         * @param {Notify.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Notify.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Notify.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Notify.Response
         * @static
         * @param {Notify.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Notify.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Notify.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Notify.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Notify.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Notify.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Notify.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Notify.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Notify.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Notify.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Notify.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Notify.Response)
                return object;
            var message = new $root.Notify.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Notify.Response.s2c: object expected");
                message.s2c = $root.Notify.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Notify.Response
         * @static
         * @param {Notify.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Notify.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Notify.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Notify;
})();

$root.Qot_GetBasicQot = (function() {

    /**
     * Namespace Qot_GetBasicQot.
     * @exports Qot_GetBasicQot
     * @namespace
     */
    var Qot_GetBasicQot = {};

    Qot_GetBasicQot.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetBasicQot
         * @interface IC2S
         * @property {Array.<Qot_Common.ISecurity>|null} [securityList] C2S securityList
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetBasicQot
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetBasicQot.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.securityList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S securityList.
         * @member {Array.<Qot_Common.ISecurity>} securityList
         * @memberof Qot_GetBasicQot.C2S
         * @instance
         */
        C2S.prototype.securityList = $util.emptyArray;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetBasicQot.C2S
         * @static
         * @param {Qot_GetBasicQot.IC2S=} [properties] Properties to set
         * @returns {Qot_GetBasicQot.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetBasicQot.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetBasicQot.C2S
         * @static
         * @param {Qot_GetBasicQot.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.securityList != null && message.securityList.length)
                for (var i = 0; i < message.securityList.length; ++i)
                    $root.Qot_Common.Security.encode(message.securityList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetBasicQot.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetBasicQot.C2S
         * @static
         * @param {Qot_GetBasicQot.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetBasicQot.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetBasicQot.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetBasicQot.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.securityList && message.securityList.length))
                        message.securityList = [];
                    message.securityList.push($root.Qot_Common.Security.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetBasicQot.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetBasicQot.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetBasicQot.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.securityList != null && message.hasOwnProperty("securityList")) {
                if (!Array.isArray(message.securityList))
                    return "securityList: array expected";
                for (var i = 0; i < message.securityList.length; ++i) {
                    var error = $root.Qot_Common.Security.verify(message.securityList[i]);
                    if (error)
                        return "securityList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetBasicQot.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetBasicQot.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetBasicQot.C2S)
                return object;
            var message = new $root.Qot_GetBasicQot.C2S();
            if (object.securityList) {
                if (!Array.isArray(object.securityList))
                    throw TypeError(".Qot_GetBasicQot.C2S.securityList: array expected");
                message.securityList = [];
                for (var i = 0; i < object.securityList.length; ++i) {
                    if (typeof object.securityList[i] !== "object")
                        throw TypeError(".Qot_GetBasicQot.C2S.securityList: object expected");
                    message.securityList[i] = $root.Qot_Common.Security.fromObject(object.securityList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetBasicQot.C2S
         * @static
         * @param {Qot_GetBasicQot.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.securityList = [];
            if (message.securityList && message.securityList.length) {
                object.securityList = [];
                for (var j = 0; j < message.securityList.length; ++j)
                    object.securityList[j] = $root.Qot_Common.Security.toObject(message.securityList[j], options);
            }
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetBasicQot.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetBasicQot.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetBasicQot
         * @interface IS2C
         * @property {Array.<Qot_Common.IBasicQot>|null} [basicQotList] S2C basicQotList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetBasicQot
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetBasicQot.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.basicQotList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C basicQotList.
         * @member {Array.<Qot_Common.IBasicQot>} basicQotList
         * @memberof Qot_GetBasicQot.S2C
         * @instance
         */
        S2C.prototype.basicQotList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetBasicQot.S2C
         * @static
         * @param {Qot_GetBasicQot.IS2C=} [properties] Properties to set
         * @returns {Qot_GetBasicQot.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetBasicQot.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetBasicQot.S2C
         * @static
         * @param {Qot_GetBasicQot.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.basicQotList != null && message.basicQotList.length)
                for (var i = 0; i < message.basicQotList.length; ++i)
                    $root.Qot_Common.BasicQot.encode(message.basicQotList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetBasicQot.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetBasicQot.S2C
         * @static
         * @param {Qot_GetBasicQot.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetBasicQot.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetBasicQot.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetBasicQot.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.basicQotList && message.basicQotList.length))
                        message.basicQotList = [];
                    message.basicQotList.push($root.Qot_Common.BasicQot.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetBasicQot.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetBasicQot.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetBasicQot.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.basicQotList != null && message.hasOwnProperty("basicQotList")) {
                if (!Array.isArray(message.basicQotList))
                    return "basicQotList: array expected";
                for (var i = 0; i < message.basicQotList.length; ++i) {
                    var error = $root.Qot_Common.BasicQot.verify(message.basicQotList[i]);
                    if (error)
                        return "basicQotList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetBasicQot.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetBasicQot.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetBasicQot.S2C)
                return object;
            var message = new $root.Qot_GetBasicQot.S2C();
            if (object.basicQotList) {
                if (!Array.isArray(object.basicQotList))
                    throw TypeError(".Qot_GetBasicQot.S2C.basicQotList: array expected");
                message.basicQotList = [];
                for (var i = 0; i < object.basicQotList.length; ++i) {
                    if (typeof object.basicQotList[i] !== "object")
                        throw TypeError(".Qot_GetBasicQot.S2C.basicQotList: object expected");
                    message.basicQotList[i] = $root.Qot_Common.BasicQot.fromObject(object.basicQotList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetBasicQot.S2C
         * @static
         * @param {Qot_GetBasicQot.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.basicQotList = [];
            if (message.basicQotList && message.basicQotList.length) {
                object.basicQotList = [];
                for (var j = 0; j < message.basicQotList.length; ++j)
                    object.basicQotList[j] = $root.Qot_Common.BasicQot.toObject(message.basicQotList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetBasicQot.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetBasicQot.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetBasicQot
         * @interface IRequest
         * @property {Qot_GetBasicQot.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetBasicQot
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetBasicQot.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetBasicQot.IC2S} c2s
         * @memberof Qot_GetBasicQot.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetBasicQot.Request
         * @static
         * @param {Qot_GetBasicQot.IRequest=} [properties] Properties to set
         * @returns {Qot_GetBasicQot.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetBasicQot.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetBasicQot.Request
         * @static
         * @param {Qot_GetBasicQot.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetBasicQot.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetBasicQot.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetBasicQot.Request
         * @static
         * @param {Qot_GetBasicQot.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetBasicQot.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetBasicQot.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetBasicQot.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetBasicQot.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetBasicQot.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetBasicQot.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetBasicQot.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetBasicQot.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetBasicQot.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetBasicQot.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetBasicQot.Request)
                return object;
            var message = new $root.Qot_GetBasicQot.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetBasicQot.Request.c2s: object expected");
                message.c2s = $root.Qot_GetBasicQot.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetBasicQot.Request
         * @static
         * @param {Qot_GetBasicQot.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetBasicQot.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetBasicQot.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetBasicQot.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetBasicQot
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetBasicQot.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetBasicQot
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetBasicQot.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetBasicQot.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetBasicQot.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetBasicQot.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetBasicQot.IS2C|null|undefined} s2c
         * @memberof Qot_GetBasicQot.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetBasicQot.Response
         * @static
         * @param {Qot_GetBasicQot.IResponse=} [properties] Properties to set
         * @returns {Qot_GetBasicQot.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetBasicQot.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetBasicQot.Response
         * @static
         * @param {Qot_GetBasicQot.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetBasicQot.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetBasicQot.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetBasicQot.Response
         * @static
         * @param {Qot_GetBasicQot.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetBasicQot.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetBasicQot.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetBasicQot.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetBasicQot.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetBasicQot.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetBasicQot.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetBasicQot.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetBasicQot.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetBasicQot.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetBasicQot.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetBasicQot.Response)
                return object;
            var message = new $root.Qot_GetBasicQot.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetBasicQot.Response.s2c: object expected");
                message.s2c = $root.Qot_GetBasicQot.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetBasicQot.Response
         * @static
         * @param {Qot_GetBasicQot.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetBasicQot.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetBasicQot.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetBasicQot;
})();

$root.Qot_GetBroker = (function() {

    /**
     * Namespace Qot_GetBroker.
     * @exports Qot_GetBroker
     * @namespace
     */
    var Qot_GetBroker = {};

    Qot_GetBroker.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetBroker
         * @interface IC2S
         * @property {Qot_Common.ISecurity} security C2S security
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetBroker
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetBroker.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetBroker.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetBroker.C2S
         * @static
         * @param {Qot_GetBroker.IC2S=} [properties] Properties to set
         * @returns {Qot_GetBroker.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetBroker.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetBroker.C2S
         * @static
         * @param {Qot_GetBroker.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetBroker.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetBroker.C2S
         * @static
         * @param {Qot_GetBroker.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetBroker.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetBroker.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetBroker.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetBroker.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetBroker.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetBroker.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetBroker.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetBroker.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetBroker.C2S)
                return object;
            var message = new $root.Qot_GetBroker.C2S();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetBroker.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetBroker.C2S
         * @static
         * @param {Qot_GetBroker.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetBroker.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetBroker.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetBroker
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.IBroker>|null} [brokerAskList] S2C brokerAskList
         * @property {Array.<Qot_Common.IBroker>|null} [brokerBidList] S2C brokerBidList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetBroker
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetBroker.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.brokerAskList = [];
            this.brokerBidList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetBroker.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C brokerAskList.
         * @member {Array.<Qot_Common.IBroker>} brokerAskList
         * @memberof Qot_GetBroker.S2C
         * @instance
         */
        S2C.prototype.brokerAskList = $util.emptyArray;

        /**
         * S2C brokerBidList.
         * @member {Array.<Qot_Common.IBroker>} brokerBidList
         * @memberof Qot_GetBroker.S2C
         * @instance
         */
        S2C.prototype.brokerBidList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetBroker.S2C
         * @static
         * @param {Qot_GetBroker.IS2C=} [properties] Properties to set
         * @returns {Qot_GetBroker.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetBroker.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetBroker.S2C
         * @static
         * @param {Qot_GetBroker.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.brokerAskList != null && message.brokerAskList.length)
                for (var i = 0; i < message.brokerAskList.length; ++i)
                    $root.Qot_Common.Broker.encode(message.brokerAskList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.brokerBidList != null && message.brokerBidList.length)
                for (var i = 0; i < message.brokerBidList.length; ++i)
                    $root.Qot_Common.Broker.encode(message.brokerBidList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetBroker.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetBroker.S2C
         * @static
         * @param {Qot_GetBroker.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetBroker.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetBroker.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetBroker.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.brokerAskList && message.brokerAskList.length))
                        message.brokerAskList = [];
                    message.brokerAskList.push($root.Qot_Common.Broker.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.brokerBidList && message.brokerBidList.length))
                        message.brokerBidList = [];
                    message.brokerBidList.push($root.Qot_Common.Broker.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetBroker.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetBroker.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetBroker.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.brokerAskList != null && message.hasOwnProperty("brokerAskList")) {
                if (!Array.isArray(message.brokerAskList))
                    return "brokerAskList: array expected";
                for (var i = 0; i < message.brokerAskList.length; ++i) {
                    var error = $root.Qot_Common.Broker.verify(message.brokerAskList[i]);
                    if (error)
                        return "brokerAskList." + error;
                }
            }
            if (message.brokerBidList != null && message.hasOwnProperty("brokerBidList")) {
                if (!Array.isArray(message.brokerBidList))
                    return "brokerBidList: array expected";
                for (var i = 0; i < message.brokerBidList.length; ++i) {
                    var error = $root.Qot_Common.Broker.verify(message.brokerBidList[i]);
                    if (error)
                        return "brokerBidList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetBroker.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetBroker.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetBroker.S2C)
                return object;
            var message = new $root.Qot_GetBroker.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetBroker.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.brokerAskList) {
                if (!Array.isArray(object.brokerAskList))
                    throw TypeError(".Qot_GetBroker.S2C.brokerAskList: array expected");
                message.brokerAskList = [];
                for (var i = 0; i < object.brokerAskList.length; ++i) {
                    if (typeof object.brokerAskList[i] !== "object")
                        throw TypeError(".Qot_GetBroker.S2C.brokerAskList: object expected");
                    message.brokerAskList[i] = $root.Qot_Common.Broker.fromObject(object.brokerAskList[i]);
                }
            }
            if (object.brokerBidList) {
                if (!Array.isArray(object.brokerBidList))
                    throw TypeError(".Qot_GetBroker.S2C.brokerBidList: array expected");
                message.brokerBidList = [];
                for (var i = 0; i < object.brokerBidList.length; ++i) {
                    if (typeof object.brokerBidList[i] !== "object")
                        throw TypeError(".Qot_GetBroker.S2C.brokerBidList: object expected");
                    message.brokerBidList[i] = $root.Qot_Common.Broker.fromObject(object.brokerBidList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetBroker.S2C
         * @static
         * @param {Qot_GetBroker.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.brokerAskList = [];
                object.brokerBidList = [];
            }
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.brokerAskList && message.brokerAskList.length) {
                object.brokerAskList = [];
                for (var j = 0; j < message.brokerAskList.length; ++j)
                    object.brokerAskList[j] = $root.Qot_Common.Broker.toObject(message.brokerAskList[j], options);
            }
            if (message.brokerBidList && message.brokerBidList.length) {
                object.brokerBidList = [];
                for (var j = 0; j < message.brokerBidList.length; ++j)
                    object.brokerBidList[j] = $root.Qot_Common.Broker.toObject(message.brokerBidList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetBroker.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetBroker.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetBroker
         * @interface IRequest
         * @property {Qot_GetBroker.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetBroker
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetBroker.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetBroker.IC2S} c2s
         * @memberof Qot_GetBroker.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetBroker.Request
         * @static
         * @param {Qot_GetBroker.IRequest=} [properties] Properties to set
         * @returns {Qot_GetBroker.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetBroker.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetBroker.Request
         * @static
         * @param {Qot_GetBroker.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetBroker.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetBroker.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetBroker.Request
         * @static
         * @param {Qot_GetBroker.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetBroker.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetBroker.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetBroker.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetBroker.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetBroker.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetBroker.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetBroker.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetBroker.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetBroker.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetBroker.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetBroker.Request)
                return object;
            var message = new $root.Qot_GetBroker.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetBroker.Request.c2s: object expected");
                message.c2s = $root.Qot_GetBroker.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetBroker.Request
         * @static
         * @param {Qot_GetBroker.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetBroker.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetBroker.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetBroker.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetBroker
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetBroker.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetBroker
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetBroker.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetBroker.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetBroker.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetBroker.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetBroker.IS2C|null|undefined} s2c
         * @memberof Qot_GetBroker.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetBroker.Response
         * @static
         * @param {Qot_GetBroker.IResponse=} [properties] Properties to set
         * @returns {Qot_GetBroker.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetBroker.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetBroker.Response
         * @static
         * @param {Qot_GetBroker.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetBroker.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetBroker.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetBroker.Response
         * @static
         * @param {Qot_GetBroker.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetBroker.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetBroker.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetBroker.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetBroker.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetBroker.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetBroker.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetBroker.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetBroker.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetBroker.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetBroker.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetBroker.Response)
                return object;
            var message = new $root.Qot_GetBroker.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetBroker.Response.s2c: object expected");
                message.s2c = $root.Qot_GetBroker.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetBroker.Response
         * @static
         * @param {Qot_GetBroker.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetBroker.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetBroker.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetBroker;
})();

$root.Qot_GetCapitalDistribution = (function() {

    /**
     * Namespace Qot_GetCapitalDistribution.
     * @exports Qot_GetCapitalDistribution
     * @namespace
     */
    var Qot_GetCapitalDistribution = {};

    Qot_GetCapitalDistribution.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetCapitalDistribution
         * @interface IC2S
         * @property {Qot_Common.ISecurity} security C2S security
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetCapitalDistribution
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetCapitalDistribution.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetCapitalDistribution.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetCapitalDistribution.C2S
         * @static
         * @param {Qot_GetCapitalDistribution.IC2S=} [properties] Properties to set
         * @returns {Qot_GetCapitalDistribution.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetCapitalDistribution.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetCapitalDistribution.C2S
         * @static
         * @param {Qot_GetCapitalDistribution.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetCapitalDistribution.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetCapitalDistribution.C2S
         * @static
         * @param {Qot_GetCapitalDistribution.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetCapitalDistribution.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetCapitalDistribution.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetCapitalDistribution.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetCapitalDistribution.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetCapitalDistribution.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetCapitalDistribution.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetCapitalDistribution.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetCapitalDistribution.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetCapitalDistribution.C2S)
                return object;
            var message = new $root.Qot_GetCapitalDistribution.C2S();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetCapitalDistribution.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetCapitalDistribution.C2S
         * @static
         * @param {Qot_GetCapitalDistribution.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetCapitalDistribution.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetCapitalDistribution.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetCapitalDistribution
         * @interface IS2C
         * @property {number} capitalInBig S2C capitalInBig
         * @property {number} capitalInMid S2C capitalInMid
         * @property {number} capitalInSmall S2C capitalInSmall
         * @property {number} capitalOutBig S2C capitalOutBig
         * @property {number} capitalOutMid S2C capitalOutMid
         * @property {number} capitalOutSmall S2C capitalOutSmall
         * @property {string|null} [updateTime] S2C updateTime
         * @property {number|null} [updateTimestamp] S2C updateTimestamp
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetCapitalDistribution
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetCapitalDistribution.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C capitalInBig.
         * @member {number} capitalInBig
         * @memberof Qot_GetCapitalDistribution.S2C
         * @instance
         */
        S2C.prototype.capitalInBig = 0;

        /**
         * S2C capitalInMid.
         * @member {number} capitalInMid
         * @memberof Qot_GetCapitalDistribution.S2C
         * @instance
         */
        S2C.prototype.capitalInMid = 0;

        /**
         * S2C capitalInSmall.
         * @member {number} capitalInSmall
         * @memberof Qot_GetCapitalDistribution.S2C
         * @instance
         */
        S2C.prototype.capitalInSmall = 0;

        /**
         * S2C capitalOutBig.
         * @member {number} capitalOutBig
         * @memberof Qot_GetCapitalDistribution.S2C
         * @instance
         */
        S2C.prototype.capitalOutBig = 0;

        /**
         * S2C capitalOutMid.
         * @member {number} capitalOutMid
         * @memberof Qot_GetCapitalDistribution.S2C
         * @instance
         */
        S2C.prototype.capitalOutMid = 0;

        /**
         * S2C capitalOutSmall.
         * @member {number} capitalOutSmall
         * @memberof Qot_GetCapitalDistribution.S2C
         * @instance
         */
        S2C.prototype.capitalOutSmall = 0;

        /**
         * S2C updateTime.
         * @member {string} updateTime
         * @memberof Qot_GetCapitalDistribution.S2C
         * @instance
         */
        S2C.prototype.updateTime = "";

        /**
         * S2C updateTimestamp.
         * @member {number} updateTimestamp
         * @memberof Qot_GetCapitalDistribution.S2C
         * @instance
         */
        S2C.prototype.updateTimestamp = 0;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetCapitalDistribution.S2C
         * @static
         * @param {Qot_GetCapitalDistribution.IS2C=} [properties] Properties to set
         * @returns {Qot_GetCapitalDistribution.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetCapitalDistribution.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetCapitalDistribution.S2C
         * @static
         * @param {Qot_GetCapitalDistribution.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.capitalInBig);
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.capitalInMid);
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.capitalInSmall);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.capitalOutBig);
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.capitalOutMid);
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.capitalOutSmall);
            if (message.updateTime != null && message.hasOwnProperty("updateTime"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.updateTime);
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.updateTimestamp);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetCapitalDistribution.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetCapitalDistribution.S2C
         * @static
         * @param {Qot_GetCapitalDistribution.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetCapitalDistribution.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetCapitalDistribution.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetCapitalDistribution.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.capitalInBig = reader.double();
                    break;
                case 2:
                    message.capitalInMid = reader.double();
                    break;
                case 3:
                    message.capitalInSmall = reader.double();
                    break;
                case 4:
                    message.capitalOutBig = reader.double();
                    break;
                case 5:
                    message.capitalOutMid = reader.double();
                    break;
                case 6:
                    message.capitalOutSmall = reader.double();
                    break;
                case 7:
                    message.updateTime = reader.string();
                    break;
                case 8:
                    message.updateTimestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("capitalInBig"))
                throw $util.ProtocolError("missing required 'capitalInBig'", { instance: message });
            if (!message.hasOwnProperty("capitalInMid"))
                throw $util.ProtocolError("missing required 'capitalInMid'", { instance: message });
            if (!message.hasOwnProperty("capitalInSmall"))
                throw $util.ProtocolError("missing required 'capitalInSmall'", { instance: message });
            if (!message.hasOwnProperty("capitalOutBig"))
                throw $util.ProtocolError("missing required 'capitalOutBig'", { instance: message });
            if (!message.hasOwnProperty("capitalOutMid"))
                throw $util.ProtocolError("missing required 'capitalOutMid'", { instance: message });
            if (!message.hasOwnProperty("capitalOutSmall"))
                throw $util.ProtocolError("missing required 'capitalOutSmall'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetCapitalDistribution.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetCapitalDistribution.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetCapitalDistribution.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.capitalInBig !== "number")
                return "capitalInBig: number expected";
            if (typeof message.capitalInMid !== "number")
                return "capitalInMid: number expected";
            if (typeof message.capitalInSmall !== "number")
                return "capitalInSmall: number expected";
            if (typeof message.capitalOutBig !== "number")
                return "capitalOutBig: number expected";
            if (typeof message.capitalOutMid !== "number")
                return "capitalOutMid: number expected";
            if (typeof message.capitalOutSmall !== "number")
                return "capitalOutSmall: number expected";
            if (message.updateTime != null && message.hasOwnProperty("updateTime"))
                if (!$util.isString(message.updateTime))
                    return "updateTime: string expected";
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                if (typeof message.updateTimestamp !== "number")
                    return "updateTimestamp: number expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetCapitalDistribution.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetCapitalDistribution.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetCapitalDistribution.S2C)
                return object;
            var message = new $root.Qot_GetCapitalDistribution.S2C();
            if (object.capitalInBig != null)
                message.capitalInBig = Number(object.capitalInBig);
            if (object.capitalInMid != null)
                message.capitalInMid = Number(object.capitalInMid);
            if (object.capitalInSmall != null)
                message.capitalInSmall = Number(object.capitalInSmall);
            if (object.capitalOutBig != null)
                message.capitalOutBig = Number(object.capitalOutBig);
            if (object.capitalOutMid != null)
                message.capitalOutMid = Number(object.capitalOutMid);
            if (object.capitalOutSmall != null)
                message.capitalOutSmall = Number(object.capitalOutSmall);
            if (object.updateTime != null)
                message.updateTime = String(object.updateTime);
            if (object.updateTimestamp != null)
                message.updateTimestamp = Number(object.updateTimestamp);
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetCapitalDistribution.S2C
         * @static
         * @param {Qot_GetCapitalDistribution.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.capitalInBig = 0;
                object.capitalInMid = 0;
                object.capitalInSmall = 0;
                object.capitalOutBig = 0;
                object.capitalOutMid = 0;
                object.capitalOutSmall = 0;
                object.updateTime = "";
                object.updateTimestamp = 0;
            }
            if (message.capitalInBig != null && message.hasOwnProperty("capitalInBig"))
                object.capitalInBig = options.json && !isFinite(message.capitalInBig) ? String(message.capitalInBig) : message.capitalInBig;
            if (message.capitalInMid != null && message.hasOwnProperty("capitalInMid"))
                object.capitalInMid = options.json && !isFinite(message.capitalInMid) ? String(message.capitalInMid) : message.capitalInMid;
            if (message.capitalInSmall != null && message.hasOwnProperty("capitalInSmall"))
                object.capitalInSmall = options.json && !isFinite(message.capitalInSmall) ? String(message.capitalInSmall) : message.capitalInSmall;
            if (message.capitalOutBig != null && message.hasOwnProperty("capitalOutBig"))
                object.capitalOutBig = options.json && !isFinite(message.capitalOutBig) ? String(message.capitalOutBig) : message.capitalOutBig;
            if (message.capitalOutMid != null && message.hasOwnProperty("capitalOutMid"))
                object.capitalOutMid = options.json && !isFinite(message.capitalOutMid) ? String(message.capitalOutMid) : message.capitalOutMid;
            if (message.capitalOutSmall != null && message.hasOwnProperty("capitalOutSmall"))
                object.capitalOutSmall = options.json && !isFinite(message.capitalOutSmall) ? String(message.capitalOutSmall) : message.capitalOutSmall;
            if (message.updateTime != null && message.hasOwnProperty("updateTime"))
                object.updateTime = message.updateTime;
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                object.updateTimestamp = options.json && !isFinite(message.updateTimestamp) ? String(message.updateTimestamp) : message.updateTimestamp;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetCapitalDistribution.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetCapitalDistribution.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetCapitalDistribution
         * @interface IRequest
         * @property {Qot_GetCapitalDistribution.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetCapitalDistribution
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetCapitalDistribution.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetCapitalDistribution.IC2S} c2s
         * @memberof Qot_GetCapitalDistribution.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetCapitalDistribution.Request
         * @static
         * @param {Qot_GetCapitalDistribution.IRequest=} [properties] Properties to set
         * @returns {Qot_GetCapitalDistribution.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetCapitalDistribution.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetCapitalDistribution.Request
         * @static
         * @param {Qot_GetCapitalDistribution.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetCapitalDistribution.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetCapitalDistribution.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetCapitalDistribution.Request
         * @static
         * @param {Qot_GetCapitalDistribution.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetCapitalDistribution.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetCapitalDistribution.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetCapitalDistribution.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetCapitalDistribution.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetCapitalDistribution.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetCapitalDistribution.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetCapitalDistribution.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetCapitalDistribution.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetCapitalDistribution.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetCapitalDistribution.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetCapitalDistribution.Request)
                return object;
            var message = new $root.Qot_GetCapitalDistribution.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetCapitalDistribution.Request.c2s: object expected");
                message.c2s = $root.Qot_GetCapitalDistribution.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetCapitalDistribution.Request
         * @static
         * @param {Qot_GetCapitalDistribution.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetCapitalDistribution.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetCapitalDistribution.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetCapitalDistribution.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetCapitalDistribution
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetCapitalDistribution.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetCapitalDistribution
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetCapitalDistribution.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetCapitalDistribution.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetCapitalDistribution.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetCapitalDistribution.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetCapitalDistribution.IS2C|null|undefined} s2c
         * @memberof Qot_GetCapitalDistribution.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetCapitalDistribution.Response
         * @static
         * @param {Qot_GetCapitalDistribution.IResponse=} [properties] Properties to set
         * @returns {Qot_GetCapitalDistribution.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetCapitalDistribution.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetCapitalDistribution.Response
         * @static
         * @param {Qot_GetCapitalDistribution.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetCapitalDistribution.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetCapitalDistribution.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetCapitalDistribution.Response
         * @static
         * @param {Qot_GetCapitalDistribution.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetCapitalDistribution.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetCapitalDistribution.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetCapitalDistribution.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetCapitalDistribution.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetCapitalDistribution.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetCapitalDistribution.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetCapitalDistribution.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetCapitalDistribution.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetCapitalDistribution.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetCapitalDistribution.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetCapitalDistribution.Response)
                return object;
            var message = new $root.Qot_GetCapitalDistribution.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetCapitalDistribution.Response.s2c: object expected");
                message.s2c = $root.Qot_GetCapitalDistribution.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetCapitalDistribution.Response
         * @static
         * @param {Qot_GetCapitalDistribution.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetCapitalDistribution.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetCapitalDistribution.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetCapitalDistribution;
})();

$root.Qot_GetCapitalFlow = (function() {

    /**
     * Namespace Qot_GetCapitalFlow.
     * @exports Qot_GetCapitalFlow
     * @namespace
     */
    var Qot_GetCapitalFlow = {};

    Qot_GetCapitalFlow.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetCapitalFlow
         * @interface IC2S
         * @property {Qot_Common.ISecurity} security C2S security
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetCapitalFlow
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetCapitalFlow.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetCapitalFlow.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetCapitalFlow.C2S
         * @static
         * @param {Qot_GetCapitalFlow.IC2S=} [properties] Properties to set
         * @returns {Qot_GetCapitalFlow.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetCapitalFlow.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetCapitalFlow.C2S
         * @static
         * @param {Qot_GetCapitalFlow.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetCapitalFlow.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetCapitalFlow.C2S
         * @static
         * @param {Qot_GetCapitalFlow.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetCapitalFlow.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetCapitalFlow.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetCapitalFlow.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetCapitalFlow.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetCapitalFlow.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetCapitalFlow.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetCapitalFlow.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetCapitalFlow.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetCapitalFlow.C2S)
                return object;
            var message = new $root.Qot_GetCapitalFlow.C2S();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetCapitalFlow.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetCapitalFlow.C2S
         * @static
         * @param {Qot_GetCapitalFlow.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetCapitalFlow.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetCapitalFlow.CapitalFlowItem = (function() {

        /**
         * Properties of a CapitalFlowItem.
         * @memberof Qot_GetCapitalFlow
         * @interface ICapitalFlowItem
         * @property {number} inFlow CapitalFlowItem inFlow
         * @property {string|null} [time] CapitalFlowItem time
         * @property {number|null} [timestamp] CapitalFlowItem timestamp
         */

        /**
         * Constructs a new CapitalFlowItem.
         * @memberof Qot_GetCapitalFlow
         * @classdesc Represents a CapitalFlowItem.
         * @implements ICapitalFlowItem
         * @constructor
         * @param {Qot_GetCapitalFlow.ICapitalFlowItem=} [properties] Properties to set
         */
        function CapitalFlowItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CapitalFlowItem inFlow.
         * @member {number} inFlow
         * @memberof Qot_GetCapitalFlow.CapitalFlowItem
         * @instance
         */
        CapitalFlowItem.prototype.inFlow = 0;

        /**
         * CapitalFlowItem time.
         * @member {string} time
         * @memberof Qot_GetCapitalFlow.CapitalFlowItem
         * @instance
         */
        CapitalFlowItem.prototype.time = "";

        /**
         * CapitalFlowItem timestamp.
         * @member {number} timestamp
         * @memberof Qot_GetCapitalFlow.CapitalFlowItem
         * @instance
         */
        CapitalFlowItem.prototype.timestamp = 0;

        /**
         * Creates a new CapitalFlowItem instance using the specified properties.
         * @function create
         * @memberof Qot_GetCapitalFlow.CapitalFlowItem
         * @static
         * @param {Qot_GetCapitalFlow.ICapitalFlowItem=} [properties] Properties to set
         * @returns {Qot_GetCapitalFlow.CapitalFlowItem} CapitalFlowItem instance
         */
        CapitalFlowItem.create = function create(properties) {
            return new CapitalFlowItem(properties);
        };

        /**
         * Encodes the specified CapitalFlowItem message. Does not implicitly {@link Qot_GetCapitalFlow.CapitalFlowItem.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetCapitalFlow.CapitalFlowItem
         * @static
         * @param {Qot_GetCapitalFlow.ICapitalFlowItem} message CapitalFlowItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CapitalFlowItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.inFlow);
            if (message.time != null && message.hasOwnProperty("time"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.time);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified CapitalFlowItem message, length delimited. Does not implicitly {@link Qot_GetCapitalFlow.CapitalFlowItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetCapitalFlow.CapitalFlowItem
         * @static
         * @param {Qot_GetCapitalFlow.ICapitalFlowItem} message CapitalFlowItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CapitalFlowItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CapitalFlowItem message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetCapitalFlow.CapitalFlowItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetCapitalFlow.CapitalFlowItem} CapitalFlowItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CapitalFlowItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetCapitalFlow.CapitalFlowItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.inFlow = reader.double();
                    break;
                case 2:
                    message.time = reader.string();
                    break;
                case 3:
                    message.timestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("inFlow"))
                throw $util.ProtocolError("missing required 'inFlow'", { instance: message });
            return message;
        };

        /**
         * Decodes a CapitalFlowItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetCapitalFlow.CapitalFlowItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetCapitalFlow.CapitalFlowItem} CapitalFlowItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CapitalFlowItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CapitalFlowItem message.
         * @function verify
         * @memberof Qot_GetCapitalFlow.CapitalFlowItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CapitalFlowItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.inFlow !== "number")
                return "inFlow: number expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isString(message.time))
                    return "time: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp !== "number")
                    return "timestamp: number expected";
            return null;
        };

        /**
         * Creates a CapitalFlowItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetCapitalFlow.CapitalFlowItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetCapitalFlow.CapitalFlowItem} CapitalFlowItem
         */
        CapitalFlowItem.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetCapitalFlow.CapitalFlowItem)
                return object;
            var message = new $root.Qot_GetCapitalFlow.CapitalFlowItem();
            if (object.inFlow != null)
                message.inFlow = Number(object.inFlow);
            if (object.time != null)
                message.time = String(object.time);
            if (object.timestamp != null)
                message.timestamp = Number(object.timestamp);
            return message;
        };

        /**
         * Creates a plain object from a CapitalFlowItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetCapitalFlow.CapitalFlowItem
         * @static
         * @param {Qot_GetCapitalFlow.CapitalFlowItem} message CapitalFlowItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CapitalFlowItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.inFlow = 0;
                object.time = "";
                object.timestamp = 0;
            }
            if (message.inFlow != null && message.hasOwnProperty("inFlow"))
                object.inFlow = options.json && !isFinite(message.inFlow) ? String(message.inFlow) : message.inFlow;
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            return object;
        };

        /**
         * Converts this CapitalFlowItem to JSON.
         * @function toJSON
         * @memberof Qot_GetCapitalFlow.CapitalFlowItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CapitalFlowItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CapitalFlowItem;
    })();

    Qot_GetCapitalFlow.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetCapitalFlow
         * @interface IS2C
         * @property {Array.<Qot_GetCapitalFlow.ICapitalFlowItem>|null} [flowItemList] S2C flowItemList
         * @property {string|null} [lastValidTime] S2C lastValidTime
         * @property {number|null} [lastValidTimestamp] S2C lastValidTimestamp
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetCapitalFlow
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetCapitalFlow.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.flowItemList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C flowItemList.
         * @member {Array.<Qot_GetCapitalFlow.ICapitalFlowItem>} flowItemList
         * @memberof Qot_GetCapitalFlow.S2C
         * @instance
         */
        S2C.prototype.flowItemList = $util.emptyArray;

        /**
         * S2C lastValidTime.
         * @member {string} lastValidTime
         * @memberof Qot_GetCapitalFlow.S2C
         * @instance
         */
        S2C.prototype.lastValidTime = "";

        /**
         * S2C lastValidTimestamp.
         * @member {number} lastValidTimestamp
         * @memberof Qot_GetCapitalFlow.S2C
         * @instance
         */
        S2C.prototype.lastValidTimestamp = 0;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetCapitalFlow.S2C
         * @static
         * @param {Qot_GetCapitalFlow.IS2C=} [properties] Properties to set
         * @returns {Qot_GetCapitalFlow.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetCapitalFlow.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetCapitalFlow.S2C
         * @static
         * @param {Qot_GetCapitalFlow.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.flowItemList != null && message.flowItemList.length)
                for (var i = 0; i < message.flowItemList.length; ++i)
                    $root.Qot_GetCapitalFlow.CapitalFlowItem.encode(message.flowItemList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.lastValidTime != null && message.hasOwnProperty("lastValidTime"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.lastValidTime);
            if (message.lastValidTimestamp != null && message.hasOwnProperty("lastValidTimestamp"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.lastValidTimestamp);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetCapitalFlow.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetCapitalFlow.S2C
         * @static
         * @param {Qot_GetCapitalFlow.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetCapitalFlow.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetCapitalFlow.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetCapitalFlow.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.flowItemList && message.flowItemList.length))
                        message.flowItemList = [];
                    message.flowItemList.push($root.Qot_GetCapitalFlow.CapitalFlowItem.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.lastValidTime = reader.string();
                    break;
                case 3:
                    message.lastValidTimestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetCapitalFlow.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetCapitalFlow.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetCapitalFlow.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.flowItemList != null && message.hasOwnProperty("flowItemList")) {
                if (!Array.isArray(message.flowItemList))
                    return "flowItemList: array expected";
                for (var i = 0; i < message.flowItemList.length; ++i) {
                    var error = $root.Qot_GetCapitalFlow.CapitalFlowItem.verify(message.flowItemList[i]);
                    if (error)
                        return "flowItemList." + error;
                }
            }
            if (message.lastValidTime != null && message.hasOwnProperty("lastValidTime"))
                if (!$util.isString(message.lastValidTime))
                    return "lastValidTime: string expected";
            if (message.lastValidTimestamp != null && message.hasOwnProperty("lastValidTimestamp"))
                if (typeof message.lastValidTimestamp !== "number")
                    return "lastValidTimestamp: number expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetCapitalFlow.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetCapitalFlow.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetCapitalFlow.S2C)
                return object;
            var message = new $root.Qot_GetCapitalFlow.S2C();
            if (object.flowItemList) {
                if (!Array.isArray(object.flowItemList))
                    throw TypeError(".Qot_GetCapitalFlow.S2C.flowItemList: array expected");
                message.flowItemList = [];
                for (var i = 0; i < object.flowItemList.length; ++i) {
                    if (typeof object.flowItemList[i] !== "object")
                        throw TypeError(".Qot_GetCapitalFlow.S2C.flowItemList: object expected");
                    message.flowItemList[i] = $root.Qot_GetCapitalFlow.CapitalFlowItem.fromObject(object.flowItemList[i]);
                }
            }
            if (object.lastValidTime != null)
                message.lastValidTime = String(object.lastValidTime);
            if (object.lastValidTimestamp != null)
                message.lastValidTimestamp = Number(object.lastValidTimestamp);
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetCapitalFlow.S2C
         * @static
         * @param {Qot_GetCapitalFlow.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.flowItemList = [];
            if (options.defaults) {
                object.lastValidTime = "";
                object.lastValidTimestamp = 0;
            }
            if (message.flowItemList && message.flowItemList.length) {
                object.flowItemList = [];
                for (var j = 0; j < message.flowItemList.length; ++j)
                    object.flowItemList[j] = $root.Qot_GetCapitalFlow.CapitalFlowItem.toObject(message.flowItemList[j], options);
            }
            if (message.lastValidTime != null && message.hasOwnProperty("lastValidTime"))
                object.lastValidTime = message.lastValidTime;
            if (message.lastValidTimestamp != null && message.hasOwnProperty("lastValidTimestamp"))
                object.lastValidTimestamp = options.json && !isFinite(message.lastValidTimestamp) ? String(message.lastValidTimestamp) : message.lastValidTimestamp;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetCapitalFlow.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetCapitalFlow.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetCapitalFlow
         * @interface IRequest
         * @property {Qot_GetCapitalFlow.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetCapitalFlow
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetCapitalFlow.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetCapitalFlow.IC2S} c2s
         * @memberof Qot_GetCapitalFlow.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetCapitalFlow.Request
         * @static
         * @param {Qot_GetCapitalFlow.IRequest=} [properties] Properties to set
         * @returns {Qot_GetCapitalFlow.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetCapitalFlow.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetCapitalFlow.Request
         * @static
         * @param {Qot_GetCapitalFlow.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetCapitalFlow.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetCapitalFlow.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetCapitalFlow.Request
         * @static
         * @param {Qot_GetCapitalFlow.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetCapitalFlow.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetCapitalFlow.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetCapitalFlow.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetCapitalFlow.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetCapitalFlow.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetCapitalFlow.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetCapitalFlow.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetCapitalFlow.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetCapitalFlow.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetCapitalFlow.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetCapitalFlow.Request)
                return object;
            var message = new $root.Qot_GetCapitalFlow.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetCapitalFlow.Request.c2s: object expected");
                message.c2s = $root.Qot_GetCapitalFlow.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetCapitalFlow.Request
         * @static
         * @param {Qot_GetCapitalFlow.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetCapitalFlow.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetCapitalFlow.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetCapitalFlow.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetCapitalFlow
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetCapitalFlow.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetCapitalFlow
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetCapitalFlow.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetCapitalFlow.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetCapitalFlow.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetCapitalFlow.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetCapitalFlow.IS2C|null|undefined} s2c
         * @memberof Qot_GetCapitalFlow.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetCapitalFlow.Response
         * @static
         * @param {Qot_GetCapitalFlow.IResponse=} [properties] Properties to set
         * @returns {Qot_GetCapitalFlow.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetCapitalFlow.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetCapitalFlow.Response
         * @static
         * @param {Qot_GetCapitalFlow.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetCapitalFlow.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetCapitalFlow.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetCapitalFlow.Response
         * @static
         * @param {Qot_GetCapitalFlow.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetCapitalFlow.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetCapitalFlow.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetCapitalFlow.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetCapitalFlow.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetCapitalFlow.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetCapitalFlow.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetCapitalFlow.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetCapitalFlow.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetCapitalFlow.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetCapitalFlow.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetCapitalFlow.Response)
                return object;
            var message = new $root.Qot_GetCapitalFlow.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetCapitalFlow.Response.s2c: object expected");
                message.s2c = $root.Qot_GetCapitalFlow.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetCapitalFlow.Response
         * @static
         * @param {Qot_GetCapitalFlow.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetCapitalFlow.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetCapitalFlow.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetCapitalFlow;
})();

$root.Qot_GetCodeChange = (function() {

    /**
     * Namespace Qot_GetCodeChange.
     * @exports Qot_GetCodeChange
     * @namespace
     */
    var Qot_GetCodeChange = {};

    /**
     * CodeChangeType enum.
     * @name Qot_GetCodeChange.CodeChangeType
     * @enum {string}
     * @property {number} CodeChangeType_Unkown=0 CodeChangeType_Unkown value
     * @property {number} CodeChangeType_GemToMain=1 CodeChangeType_GemToMain value
     * @property {number} CodeChangeType_Unpaid=2 CodeChangeType_Unpaid value
     * @property {number} CodeChangeType_ChangeLot=3 CodeChangeType_ChangeLot value
     * @property {number} CodeChangeType_Split=4 CodeChangeType_Split value
     * @property {number} CodeChangeType_Joint=5 CodeChangeType_Joint value
     * @property {number} CodeChangeType_JointSplit=6 CodeChangeType_JointSplit value
     * @property {number} CodeChangeType_SplitJoint=7 CodeChangeType_SplitJoint value
     * @property {number} CodeChangeType_Other=8 CodeChangeType_Other value
     */
    Qot_GetCodeChange.CodeChangeType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "CodeChangeType_Unkown"] = 0;
        values[valuesById[1] = "CodeChangeType_GemToMain"] = 1;
        values[valuesById[2] = "CodeChangeType_Unpaid"] = 2;
        values[valuesById[3] = "CodeChangeType_ChangeLot"] = 3;
        values[valuesById[4] = "CodeChangeType_Split"] = 4;
        values[valuesById[5] = "CodeChangeType_Joint"] = 5;
        values[valuesById[6] = "CodeChangeType_JointSplit"] = 6;
        values[valuesById[7] = "CodeChangeType_SplitJoint"] = 7;
        values[valuesById[8] = "CodeChangeType_Other"] = 8;
        return values;
    })();

    Qot_GetCodeChange.CodeChangeInfo = (function() {

        /**
         * Properties of a CodeChangeInfo.
         * @memberof Qot_GetCodeChange
         * @interface ICodeChangeInfo
         * @property {number} type CodeChangeInfo type
         * @property {Qot_Common.ISecurity} security CodeChangeInfo security
         * @property {Qot_Common.ISecurity} relatedSecurity CodeChangeInfo relatedSecurity
         * @property {string|null} [publicTime] CodeChangeInfo publicTime
         * @property {number|null} [publicTimestamp] CodeChangeInfo publicTimestamp
         * @property {string|null} [effectiveTime] CodeChangeInfo effectiveTime
         * @property {number|null} [effectiveTimestamp] CodeChangeInfo effectiveTimestamp
         * @property {string|null} [endTime] CodeChangeInfo endTime
         * @property {number|null} [endTimestamp] CodeChangeInfo endTimestamp
         */

        /**
         * Constructs a new CodeChangeInfo.
         * @memberof Qot_GetCodeChange
         * @classdesc Represents a CodeChangeInfo.
         * @implements ICodeChangeInfo
         * @constructor
         * @param {Qot_GetCodeChange.ICodeChangeInfo=} [properties] Properties to set
         */
        function CodeChangeInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CodeChangeInfo type.
         * @member {number} type
         * @memberof Qot_GetCodeChange.CodeChangeInfo
         * @instance
         */
        CodeChangeInfo.prototype.type = 0;

        /**
         * CodeChangeInfo security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetCodeChange.CodeChangeInfo
         * @instance
         */
        CodeChangeInfo.prototype.security = null;

        /**
         * CodeChangeInfo relatedSecurity.
         * @member {Qot_Common.ISecurity} relatedSecurity
         * @memberof Qot_GetCodeChange.CodeChangeInfo
         * @instance
         */
        CodeChangeInfo.prototype.relatedSecurity = null;

        /**
         * CodeChangeInfo publicTime.
         * @member {string} publicTime
         * @memberof Qot_GetCodeChange.CodeChangeInfo
         * @instance
         */
        CodeChangeInfo.prototype.publicTime = "";

        /**
         * CodeChangeInfo publicTimestamp.
         * @member {number} publicTimestamp
         * @memberof Qot_GetCodeChange.CodeChangeInfo
         * @instance
         */
        CodeChangeInfo.prototype.publicTimestamp = 0;

        /**
         * CodeChangeInfo effectiveTime.
         * @member {string} effectiveTime
         * @memberof Qot_GetCodeChange.CodeChangeInfo
         * @instance
         */
        CodeChangeInfo.prototype.effectiveTime = "";

        /**
         * CodeChangeInfo effectiveTimestamp.
         * @member {number} effectiveTimestamp
         * @memberof Qot_GetCodeChange.CodeChangeInfo
         * @instance
         */
        CodeChangeInfo.prototype.effectiveTimestamp = 0;

        /**
         * CodeChangeInfo endTime.
         * @member {string} endTime
         * @memberof Qot_GetCodeChange.CodeChangeInfo
         * @instance
         */
        CodeChangeInfo.prototype.endTime = "";

        /**
         * CodeChangeInfo endTimestamp.
         * @member {number} endTimestamp
         * @memberof Qot_GetCodeChange.CodeChangeInfo
         * @instance
         */
        CodeChangeInfo.prototype.endTimestamp = 0;

        /**
         * Creates a new CodeChangeInfo instance using the specified properties.
         * @function create
         * @memberof Qot_GetCodeChange.CodeChangeInfo
         * @static
         * @param {Qot_GetCodeChange.ICodeChangeInfo=} [properties] Properties to set
         * @returns {Qot_GetCodeChange.CodeChangeInfo} CodeChangeInfo instance
         */
        CodeChangeInfo.create = function create(properties) {
            return new CodeChangeInfo(properties);
        };

        /**
         * Encodes the specified CodeChangeInfo message. Does not implicitly {@link Qot_GetCodeChange.CodeChangeInfo.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetCodeChange.CodeChangeInfo
         * @static
         * @param {Qot_GetCodeChange.ICodeChangeInfo} message CodeChangeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CodeChangeInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            $root.Qot_Common.Security.encode(message.relatedSecurity, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.publicTime != null && message.hasOwnProperty("publicTime"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.publicTime);
            if (message.publicTimestamp != null && message.hasOwnProperty("publicTimestamp"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.publicTimestamp);
            if (message.effectiveTime != null && message.hasOwnProperty("effectiveTime"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.effectiveTime);
            if (message.effectiveTimestamp != null && message.hasOwnProperty("effectiveTimestamp"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.effectiveTimestamp);
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.endTime);
            if (message.endTimestamp != null && message.hasOwnProperty("endTimestamp"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.endTimestamp);
            return writer;
        };

        /**
         * Encodes the specified CodeChangeInfo message, length delimited. Does not implicitly {@link Qot_GetCodeChange.CodeChangeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetCodeChange.CodeChangeInfo
         * @static
         * @param {Qot_GetCodeChange.ICodeChangeInfo} message CodeChangeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CodeChangeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CodeChangeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetCodeChange.CodeChangeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetCodeChange.CodeChangeInfo} CodeChangeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CodeChangeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetCodeChange.CodeChangeInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.relatedSecurity = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.publicTime = reader.string();
                    break;
                case 5:
                    message.publicTimestamp = reader.double();
                    break;
                case 6:
                    message.effectiveTime = reader.string();
                    break;
                case 7:
                    message.effectiveTimestamp = reader.double();
                    break;
                case 8:
                    message.endTime = reader.string();
                    break;
                case 9:
                    message.endTimestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("relatedSecurity"))
                throw $util.ProtocolError("missing required 'relatedSecurity'", { instance: message });
            return message;
        };

        /**
         * Decodes a CodeChangeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetCodeChange.CodeChangeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetCodeChange.CodeChangeInfo} CodeChangeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CodeChangeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CodeChangeInfo message.
         * @function verify
         * @memberof Qot_GetCodeChange.CodeChangeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CodeChangeInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            {
                var error = $root.Qot_Common.Security.verify(message.relatedSecurity);
                if (error)
                    return "relatedSecurity." + error;
            }
            if (message.publicTime != null && message.hasOwnProperty("publicTime"))
                if (!$util.isString(message.publicTime))
                    return "publicTime: string expected";
            if (message.publicTimestamp != null && message.hasOwnProperty("publicTimestamp"))
                if (typeof message.publicTimestamp !== "number")
                    return "publicTimestamp: number expected";
            if (message.effectiveTime != null && message.hasOwnProperty("effectiveTime"))
                if (!$util.isString(message.effectiveTime))
                    return "effectiveTime: string expected";
            if (message.effectiveTimestamp != null && message.hasOwnProperty("effectiveTimestamp"))
                if (typeof message.effectiveTimestamp !== "number")
                    return "effectiveTimestamp: number expected";
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isString(message.endTime))
                    return "endTime: string expected";
            if (message.endTimestamp != null && message.hasOwnProperty("endTimestamp"))
                if (typeof message.endTimestamp !== "number")
                    return "endTimestamp: number expected";
            return null;
        };

        /**
         * Creates a CodeChangeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetCodeChange.CodeChangeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetCodeChange.CodeChangeInfo} CodeChangeInfo
         */
        CodeChangeInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetCodeChange.CodeChangeInfo)
                return object;
            var message = new $root.Qot_GetCodeChange.CodeChangeInfo();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetCodeChange.CodeChangeInfo.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.relatedSecurity != null) {
                if (typeof object.relatedSecurity !== "object")
                    throw TypeError(".Qot_GetCodeChange.CodeChangeInfo.relatedSecurity: object expected");
                message.relatedSecurity = $root.Qot_Common.Security.fromObject(object.relatedSecurity);
            }
            if (object.publicTime != null)
                message.publicTime = String(object.publicTime);
            if (object.publicTimestamp != null)
                message.publicTimestamp = Number(object.publicTimestamp);
            if (object.effectiveTime != null)
                message.effectiveTime = String(object.effectiveTime);
            if (object.effectiveTimestamp != null)
                message.effectiveTimestamp = Number(object.effectiveTimestamp);
            if (object.endTime != null)
                message.endTime = String(object.endTime);
            if (object.endTimestamp != null)
                message.endTimestamp = Number(object.endTimestamp);
            return message;
        };

        /**
         * Creates a plain object from a CodeChangeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetCodeChange.CodeChangeInfo
         * @static
         * @param {Qot_GetCodeChange.CodeChangeInfo} message CodeChangeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CodeChangeInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.security = null;
                object.relatedSecurity = null;
                object.publicTime = "";
                object.publicTimestamp = 0;
                object.effectiveTime = "";
                object.effectiveTimestamp = 0;
                object.endTime = "";
                object.endTimestamp = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.relatedSecurity != null && message.hasOwnProperty("relatedSecurity"))
                object.relatedSecurity = $root.Qot_Common.Security.toObject(message.relatedSecurity, options);
            if (message.publicTime != null && message.hasOwnProperty("publicTime"))
                object.publicTime = message.publicTime;
            if (message.publicTimestamp != null && message.hasOwnProperty("publicTimestamp"))
                object.publicTimestamp = options.json && !isFinite(message.publicTimestamp) ? String(message.publicTimestamp) : message.publicTimestamp;
            if (message.effectiveTime != null && message.hasOwnProperty("effectiveTime"))
                object.effectiveTime = message.effectiveTime;
            if (message.effectiveTimestamp != null && message.hasOwnProperty("effectiveTimestamp"))
                object.effectiveTimestamp = options.json && !isFinite(message.effectiveTimestamp) ? String(message.effectiveTimestamp) : message.effectiveTimestamp;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            if (message.endTimestamp != null && message.hasOwnProperty("endTimestamp"))
                object.endTimestamp = options.json && !isFinite(message.endTimestamp) ? String(message.endTimestamp) : message.endTimestamp;
            return object;
        };

        /**
         * Converts this CodeChangeInfo to JSON.
         * @function toJSON
         * @memberof Qot_GetCodeChange.CodeChangeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CodeChangeInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CodeChangeInfo;
    })();

    /**
     * TimeFilterType enum.
     * @name Qot_GetCodeChange.TimeFilterType
     * @enum {string}
     * @property {number} TimeFilterType_Unknow=0 TimeFilterType_Unknow value
     * @property {number} TimeFilterType_Public=1 TimeFilterType_Public value
     * @property {number} TimeFilterType_Effective=2 TimeFilterType_Effective value
     * @property {number} TimeFilterType_End=3 TimeFilterType_End value
     */
    Qot_GetCodeChange.TimeFilterType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TimeFilterType_Unknow"] = 0;
        values[valuesById[1] = "TimeFilterType_Public"] = 1;
        values[valuesById[2] = "TimeFilterType_Effective"] = 2;
        values[valuesById[3] = "TimeFilterType_End"] = 3;
        return values;
    })();

    Qot_GetCodeChange.TimeFilter = (function() {

        /**
         * Properties of a TimeFilter.
         * @memberof Qot_GetCodeChange
         * @interface ITimeFilter
         * @property {number} type TimeFilter type
         * @property {string|null} [beginTime] TimeFilter beginTime
         * @property {string|null} [endTime] TimeFilter endTime
         */

        /**
         * Constructs a new TimeFilter.
         * @memberof Qot_GetCodeChange
         * @classdesc Represents a TimeFilter.
         * @implements ITimeFilter
         * @constructor
         * @param {Qot_GetCodeChange.ITimeFilter=} [properties] Properties to set
         */
        function TimeFilter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TimeFilter type.
         * @member {number} type
         * @memberof Qot_GetCodeChange.TimeFilter
         * @instance
         */
        TimeFilter.prototype.type = 0;

        /**
         * TimeFilter beginTime.
         * @member {string} beginTime
         * @memberof Qot_GetCodeChange.TimeFilter
         * @instance
         */
        TimeFilter.prototype.beginTime = "";

        /**
         * TimeFilter endTime.
         * @member {string} endTime
         * @memberof Qot_GetCodeChange.TimeFilter
         * @instance
         */
        TimeFilter.prototype.endTime = "";

        /**
         * Creates a new TimeFilter instance using the specified properties.
         * @function create
         * @memberof Qot_GetCodeChange.TimeFilter
         * @static
         * @param {Qot_GetCodeChange.ITimeFilter=} [properties] Properties to set
         * @returns {Qot_GetCodeChange.TimeFilter} TimeFilter instance
         */
        TimeFilter.create = function create(properties) {
            return new TimeFilter(properties);
        };

        /**
         * Encodes the specified TimeFilter message. Does not implicitly {@link Qot_GetCodeChange.TimeFilter.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetCodeChange.TimeFilter
         * @static
         * @param {Qot_GetCodeChange.ITimeFilter} message TimeFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TimeFilter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.beginTime);
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.endTime);
            return writer;
        };

        /**
         * Encodes the specified TimeFilter message, length delimited. Does not implicitly {@link Qot_GetCodeChange.TimeFilter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetCodeChange.TimeFilter
         * @static
         * @param {Qot_GetCodeChange.ITimeFilter} message TimeFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TimeFilter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TimeFilter message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetCodeChange.TimeFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetCodeChange.TimeFilter} TimeFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TimeFilter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetCodeChange.TimeFilter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.beginTime = reader.string();
                    break;
                case 3:
                    message.endTime = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };

        /**
         * Decodes a TimeFilter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetCodeChange.TimeFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetCodeChange.TimeFilter} TimeFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TimeFilter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TimeFilter message.
         * @function verify
         * @memberof Qot_GetCodeChange.TimeFilter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TimeFilter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                if (!$util.isString(message.beginTime))
                    return "beginTime: string expected";
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isString(message.endTime))
                    return "endTime: string expected";
            return null;
        };

        /**
         * Creates a TimeFilter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetCodeChange.TimeFilter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetCodeChange.TimeFilter} TimeFilter
         */
        TimeFilter.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetCodeChange.TimeFilter)
                return object;
            var message = new $root.Qot_GetCodeChange.TimeFilter();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.beginTime != null)
                message.beginTime = String(object.beginTime);
            if (object.endTime != null)
                message.endTime = String(object.endTime);
            return message;
        };

        /**
         * Creates a plain object from a TimeFilter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetCodeChange.TimeFilter
         * @static
         * @param {Qot_GetCodeChange.TimeFilter} message TimeFilter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TimeFilter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.beginTime = "";
                object.endTime = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                object.beginTime = message.beginTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            return object;
        };

        /**
         * Converts this TimeFilter to JSON.
         * @function toJSON
         * @memberof Qot_GetCodeChange.TimeFilter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TimeFilter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TimeFilter;
    })();

    Qot_GetCodeChange.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetCodeChange
         * @interface IC2S
         * @property {number|null} [placeHolder] C2S placeHolder
         * @property {Array.<Qot_Common.ISecurity>|null} [securityList] C2S securityList
         * @property {Array.<Qot_GetCodeChange.ITimeFilter>|null} [timeFilterList] C2S timeFilterList
         * @property {Array.<number>|null} [typeList] C2S typeList
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetCodeChange
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetCodeChange.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.securityList = [];
            this.timeFilterList = [];
            this.typeList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S placeHolder.
         * @member {number} placeHolder
         * @memberof Qot_GetCodeChange.C2S
         * @instance
         */
        C2S.prototype.placeHolder = 0;

        /**
         * C2S securityList.
         * @member {Array.<Qot_Common.ISecurity>} securityList
         * @memberof Qot_GetCodeChange.C2S
         * @instance
         */
        C2S.prototype.securityList = $util.emptyArray;

        /**
         * C2S timeFilterList.
         * @member {Array.<Qot_GetCodeChange.ITimeFilter>} timeFilterList
         * @memberof Qot_GetCodeChange.C2S
         * @instance
         */
        C2S.prototype.timeFilterList = $util.emptyArray;

        /**
         * C2S typeList.
         * @member {Array.<number>} typeList
         * @memberof Qot_GetCodeChange.C2S
         * @instance
         */
        C2S.prototype.typeList = $util.emptyArray;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetCodeChange.C2S
         * @static
         * @param {Qot_GetCodeChange.IC2S=} [properties] Properties to set
         * @returns {Qot_GetCodeChange.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetCodeChange.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetCodeChange.C2S
         * @static
         * @param {Qot_GetCodeChange.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.placeHolder != null && message.hasOwnProperty("placeHolder"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.placeHolder);
            if (message.securityList != null && message.securityList.length)
                for (var i = 0; i < message.securityList.length; ++i)
                    $root.Qot_Common.Security.encode(message.securityList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.timeFilterList != null && message.timeFilterList.length)
                for (var i = 0; i < message.timeFilterList.length; ++i)
                    $root.Qot_GetCodeChange.TimeFilter.encode(message.timeFilterList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.typeList != null && message.typeList.length)
                for (var i = 0; i < message.typeList.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.typeList[i]);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetCodeChange.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetCodeChange.C2S
         * @static
         * @param {Qot_GetCodeChange.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetCodeChange.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetCodeChange.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetCodeChange.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.placeHolder = reader.int32();
                    break;
                case 2:
                    if (!(message.securityList && message.securityList.length))
                        message.securityList = [];
                    message.securityList.push($root.Qot_Common.Security.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.timeFilterList && message.timeFilterList.length))
                        message.timeFilterList = [];
                    message.timeFilterList.push($root.Qot_GetCodeChange.TimeFilter.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.typeList && message.typeList.length))
                        message.typeList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.typeList.push(reader.int32());
                    } else
                        message.typeList.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetCodeChange.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetCodeChange.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetCodeChange.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.placeHolder != null && message.hasOwnProperty("placeHolder"))
                if (!$util.isInteger(message.placeHolder))
                    return "placeHolder: integer expected";
            if (message.securityList != null && message.hasOwnProperty("securityList")) {
                if (!Array.isArray(message.securityList))
                    return "securityList: array expected";
                for (var i = 0; i < message.securityList.length; ++i) {
                    var error = $root.Qot_Common.Security.verify(message.securityList[i]);
                    if (error)
                        return "securityList." + error;
                }
            }
            if (message.timeFilterList != null && message.hasOwnProperty("timeFilterList")) {
                if (!Array.isArray(message.timeFilterList))
                    return "timeFilterList: array expected";
                for (var i = 0; i < message.timeFilterList.length; ++i) {
                    var error = $root.Qot_GetCodeChange.TimeFilter.verify(message.timeFilterList[i]);
                    if (error)
                        return "timeFilterList." + error;
                }
            }
            if (message.typeList != null && message.hasOwnProperty("typeList")) {
                if (!Array.isArray(message.typeList))
                    return "typeList: array expected";
                for (var i = 0; i < message.typeList.length; ++i)
                    if (!$util.isInteger(message.typeList[i]))
                        return "typeList: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetCodeChange.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetCodeChange.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetCodeChange.C2S)
                return object;
            var message = new $root.Qot_GetCodeChange.C2S();
            if (object.placeHolder != null)
                message.placeHolder = object.placeHolder | 0;
            if (object.securityList) {
                if (!Array.isArray(object.securityList))
                    throw TypeError(".Qot_GetCodeChange.C2S.securityList: array expected");
                message.securityList = [];
                for (var i = 0; i < object.securityList.length; ++i) {
                    if (typeof object.securityList[i] !== "object")
                        throw TypeError(".Qot_GetCodeChange.C2S.securityList: object expected");
                    message.securityList[i] = $root.Qot_Common.Security.fromObject(object.securityList[i]);
                }
            }
            if (object.timeFilterList) {
                if (!Array.isArray(object.timeFilterList))
                    throw TypeError(".Qot_GetCodeChange.C2S.timeFilterList: array expected");
                message.timeFilterList = [];
                for (var i = 0; i < object.timeFilterList.length; ++i) {
                    if (typeof object.timeFilterList[i] !== "object")
                        throw TypeError(".Qot_GetCodeChange.C2S.timeFilterList: object expected");
                    message.timeFilterList[i] = $root.Qot_GetCodeChange.TimeFilter.fromObject(object.timeFilterList[i]);
                }
            }
            if (object.typeList) {
                if (!Array.isArray(object.typeList))
                    throw TypeError(".Qot_GetCodeChange.C2S.typeList: array expected");
                message.typeList = [];
                for (var i = 0; i < object.typeList.length; ++i)
                    message.typeList[i] = object.typeList[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetCodeChange.C2S
         * @static
         * @param {Qot_GetCodeChange.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.securityList = [];
                object.timeFilterList = [];
                object.typeList = [];
            }
            if (options.defaults)
                object.placeHolder = 0;
            if (message.placeHolder != null && message.hasOwnProperty("placeHolder"))
                object.placeHolder = message.placeHolder;
            if (message.securityList && message.securityList.length) {
                object.securityList = [];
                for (var j = 0; j < message.securityList.length; ++j)
                    object.securityList[j] = $root.Qot_Common.Security.toObject(message.securityList[j], options);
            }
            if (message.timeFilterList && message.timeFilterList.length) {
                object.timeFilterList = [];
                for (var j = 0; j < message.timeFilterList.length; ++j)
                    object.timeFilterList[j] = $root.Qot_GetCodeChange.TimeFilter.toObject(message.timeFilterList[j], options);
            }
            if (message.typeList && message.typeList.length) {
                object.typeList = [];
                for (var j = 0; j < message.typeList.length; ++j)
                    object.typeList[j] = message.typeList[j];
            }
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetCodeChange.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetCodeChange.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetCodeChange
         * @interface IS2C
         * @property {Array.<Qot_GetCodeChange.ICodeChangeInfo>|null} [codeChangeList] S2C codeChangeList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetCodeChange
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetCodeChange.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.codeChangeList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C codeChangeList.
         * @member {Array.<Qot_GetCodeChange.ICodeChangeInfo>} codeChangeList
         * @memberof Qot_GetCodeChange.S2C
         * @instance
         */
        S2C.prototype.codeChangeList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetCodeChange.S2C
         * @static
         * @param {Qot_GetCodeChange.IS2C=} [properties] Properties to set
         * @returns {Qot_GetCodeChange.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetCodeChange.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetCodeChange.S2C
         * @static
         * @param {Qot_GetCodeChange.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.codeChangeList != null && message.codeChangeList.length)
                for (var i = 0; i < message.codeChangeList.length; ++i)
                    $root.Qot_GetCodeChange.CodeChangeInfo.encode(message.codeChangeList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetCodeChange.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetCodeChange.S2C
         * @static
         * @param {Qot_GetCodeChange.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetCodeChange.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetCodeChange.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetCodeChange.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.codeChangeList && message.codeChangeList.length))
                        message.codeChangeList = [];
                    message.codeChangeList.push($root.Qot_GetCodeChange.CodeChangeInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetCodeChange.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetCodeChange.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetCodeChange.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.codeChangeList != null && message.hasOwnProperty("codeChangeList")) {
                if (!Array.isArray(message.codeChangeList))
                    return "codeChangeList: array expected";
                for (var i = 0; i < message.codeChangeList.length; ++i) {
                    var error = $root.Qot_GetCodeChange.CodeChangeInfo.verify(message.codeChangeList[i]);
                    if (error)
                        return "codeChangeList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetCodeChange.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetCodeChange.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetCodeChange.S2C)
                return object;
            var message = new $root.Qot_GetCodeChange.S2C();
            if (object.codeChangeList) {
                if (!Array.isArray(object.codeChangeList))
                    throw TypeError(".Qot_GetCodeChange.S2C.codeChangeList: array expected");
                message.codeChangeList = [];
                for (var i = 0; i < object.codeChangeList.length; ++i) {
                    if (typeof object.codeChangeList[i] !== "object")
                        throw TypeError(".Qot_GetCodeChange.S2C.codeChangeList: object expected");
                    message.codeChangeList[i] = $root.Qot_GetCodeChange.CodeChangeInfo.fromObject(object.codeChangeList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetCodeChange.S2C
         * @static
         * @param {Qot_GetCodeChange.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.codeChangeList = [];
            if (message.codeChangeList && message.codeChangeList.length) {
                object.codeChangeList = [];
                for (var j = 0; j < message.codeChangeList.length; ++j)
                    object.codeChangeList[j] = $root.Qot_GetCodeChange.CodeChangeInfo.toObject(message.codeChangeList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetCodeChange.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetCodeChange.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetCodeChange
         * @interface IRequest
         * @property {Qot_GetCodeChange.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetCodeChange
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetCodeChange.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetCodeChange.IC2S} c2s
         * @memberof Qot_GetCodeChange.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetCodeChange.Request
         * @static
         * @param {Qot_GetCodeChange.IRequest=} [properties] Properties to set
         * @returns {Qot_GetCodeChange.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetCodeChange.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetCodeChange.Request
         * @static
         * @param {Qot_GetCodeChange.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetCodeChange.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetCodeChange.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetCodeChange.Request
         * @static
         * @param {Qot_GetCodeChange.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetCodeChange.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetCodeChange.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetCodeChange.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetCodeChange.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetCodeChange.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetCodeChange.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetCodeChange.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetCodeChange.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetCodeChange.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetCodeChange.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetCodeChange.Request)
                return object;
            var message = new $root.Qot_GetCodeChange.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetCodeChange.Request.c2s: object expected");
                message.c2s = $root.Qot_GetCodeChange.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetCodeChange.Request
         * @static
         * @param {Qot_GetCodeChange.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetCodeChange.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetCodeChange.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetCodeChange.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetCodeChange
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetCodeChange.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetCodeChange
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetCodeChange.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetCodeChange.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetCodeChange.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetCodeChange.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetCodeChange.IS2C|null|undefined} s2c
         * @memberof Qot_GetCodeChange.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetCodeChange.Response
         * @static
         * @param {Qot_GetCodeChange.IResponse=} [properties] Properties to set
         * @returns {Qot_GetCodeChange.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetCodeChange.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetCodeChange.Response
         * @static
         * @param {Qot_GetCodeChange.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetCodeChange.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetCodeChange.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetCodeChange.Response
         * @static
         * @param {Qot_GetCodeChange.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetCodeChange.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetCodeChange.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetCodeChange.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetCodeChange.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetCodeChange.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetCodeChange.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetCodeChange.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetCodeChange.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetCodeChange.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetCodeChange.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetCodeChange.Response)
                return object;
            var message = new $root.Qot_GetCodeChange.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetCodeChange.Response.s2c: object expected");
                message.s2c = $root.Qot_GetCodeChange.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetCodeChange.Response
         * @static
         * @param {Qot_GetCodeChange.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetCodeChange.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetCodeChange.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetCodeChange;
})();

$root.Qot_GetFutureInfo = (function() {

    /**
     * Namespace Qot_GetFutureInfo.
     * @exports Qot_GetFutureInfo
     * @namespace
     */
    var Qot_GetFutureInfo = {};

    Qot_GetFutureInfo.TradeTime = (function() {

        /**
         * Properties of a TradeTime.
         * @memberof Qot_GetFutureInfo
         * @interface ITradeTime
         * @property {number|null} [begin] TradeTime begin
         * @property {number|null} [end] TradeTime end
         */

        /**
         * Constructs a new TradeTime.
         * @memberof Qot_GetFutureInfo
         * @classdesc Represents a TradeTime.
         * @implements ITradeTime
         * @constructor
         * @param {Qot_GetFutureInfo.ITradeTime=} [properties] Properties to set
         */
        function TradeTime(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TradeTime begin.
         * @member {number} begin
         * @memberof Qot_GetFutureInfo.TradeTime
         * @instance
         */
        TradeTime.prototype.begin = 0;

        /**
         * TradeTime end.
         * @member {number} end
         * @memberof Qot_GetFutureInfo.TradeTime
         * @instance
         */
        TradeTime.prototype.end = 0;

        /**
         * Creates a new TradeTime instance using the specified properties.
         * @function create
         * @memberof Qot_GetFutureInfo.TradeTime
         * @static
         * @param {Qot_GetFutureInfo.ITradeTime=} [properties] Properties to set
         * @returns {Qot_GetFutureInfo.TradeTime} TradeTime instance
         */
        TradeTime.create = function create(properties) {
            return new TradeTime(properties);
        };

        /**
         * Encodes the specified TradeTime message. Does not implicitly {@link Qot_GetFutureInfo.TradeTime.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetFutureInfo.TradeTime
         * @static
         * @param {Qot_GetFutureInfo.ITradeTime} message TradeTime message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeTime.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.begin != null && message.hasOwnProperty("begin"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.begin);
            if (message.end != null && message.hasOwnProperty("end"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.end);
            return writer;
        };

        /**
         * Encodes the specified TradeTime message, length delimited. Does not implicitly {@link Qot_GetFutureInfo.TradeTime.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetFutureInfo.TradeTime
         * @static
         * @param {Qot_GetFutureInfo.ITradeTime} message TradeTime message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeTime.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TradeTime message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetFutureInfo.TradeTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetFutureInfo.TradeTime} TradeTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeTime.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetFutureInfo.TradeTime();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.begin = reader.double();
                    break;
                case 2:
                    message.end = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TradeTime message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetFutureInfo.TradeTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetFutureInfo.TradeTime} TradeTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeTime.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TradeTime message.
         * @function verify
         * @memberof Qot_GetFutureInfo.TradeTime
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TradeTime.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.begin != null && message.hasOwnProperty("begin"))
                if (typeof message.begin !== "number")
                    return "begin: number expected";
            if (message.end != null && message.hasOwnProperty("end"))
                if (typeof message.end !== "number")
                    return "end: number expected";
            return null;
        };

        /**
         * Creates a TradeTime message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetFutureInfo.TradeTime
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetFutureInfo.TradeTime} TradeTime
         */
        TradeTime.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetFutureInfo.TradeTime)
                return object;
            var message = new $root.Qot_GetFutureInfo.TradeTime();
            if (object.begin != null)
                message.begin = Number(object.begin);
            if (object.end != null)
                message.end = Number(object.end);
            return message;
        };

        /**
         * Creates a plain object from a TradeTime message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetFutureInfo.TradeTime
         * @static
         * @param {Qot_GetFutureInfo.TradeTime} message TradeTime
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TradeTime.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.begin = 0;
                object.end = 0;
            }
            if (message.begin != null && message.hasOwnProperty("begin"))
                object.begin = options.json && !isFinite(message.begin) ? String(message.begin) : message.begin;
            if (message.end != null && message.hasOwnProperty("end"))
                object.end = options.json && !isFinite(message.end) ? String(message.end) : message.end;
            return object;
        };

        /**
         * Converts this TradeTime to JSON.
         * @function toJSON
         * @memberof Qot_GetFutureInfo.TradeTime
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TradeTime.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TradeTime;
    })();

    Qot_GetFutureInfo.FutureInfo = (function() {

        /**
         * Properties of a FutureInfo.
         * @memberof Qot_GetFutureInfo
         * @interface IFutureInfo
         * @property {string} name FutureInfo name
         * @property {Qot_Common.ISecurity} security FutureInfo security
         * @property {string} lastTradeTime FutureInfo lastTradeTime
         * @property {number|null} [lastTradeTimestamp] FutureInfo lastTradeTimestamp
         * @property {Qot_Common.ISecurity|null} [owner] FutureInfo owner
         * @property {string} ownerOther FutureInfo ownerOther
         * @property {string} exchange FutureInfo exchange
         * @property {string} contractType FutureInfo contractType
         * @property {number} contractSize FutureInfo contractSize
         * @property {string} contractSizeUnit FutureInfo contractSizeUnit
         * @property {string} quoteCurrency FutureInfo quoteCurrency
         * @property {number} minVar FutureInfo minVar
         * @property {string} minVarUnit FutureInfo minVarUnit
         * @property {string|null} [quoteUnit] FutureInfo quoteUnit
         * @property {Array.<Qot_GetFutureInfo.ITradeTime>|null} [tradeTime] FutureInfo tradeTime
         * @property {string} timeZone FutureInfo timeZone
         * @property {string} exchangeFormatUrl FutureInfo exchangeFormatUrl
         */

        /**
         * Constructs a new FutureInfo.
         * @memberof Qot_GetFutureInfo
         * @classdesc Represents a FutureInfo.
         * @implements IFutureInfo
         * @constructor
         * @param {Qot_GetFutureInfo.IFutureInfo=} [properties] Properties to set
         */
        function FutureInfo(properties) {
            this.tradeTime = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FutureInfo name.
         * @member {string} name
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @instance
         */
        FutureInfo.prototype.name = "";

        /**
         * FutureInfo security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @instance
         */
        FutureInfo.prototype.security = null;

        /**
         * FutureInfo lastTradeTime.
         * @member {string} lastTradeTime
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @instance
         */
        FutureInfo.prototype.lastTradeTime = "";

        /**
         * FutureInfo lastTradeTimestamp.
         * @member {number} lastTradeTimestamp
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @instance
         */
        FutureInfo.prototype.lastTradeTimestamp = 0;

        /**
         * FutureInfo owner.
         * @member {Qot_Common.ISecurity|null|undefined} owner
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @instance
         */
        FutureInfo.prototype.owner = null;

        /**
         * FutureInfo ownerOther.
         * @member {string} ownerOther
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @instance
         */
        FutureInfo.prototype.ownerOther = "";

        /**
         * FutureInfo exchange.
         * @member {string} exchange
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @instance
         */
        FutureInfo.prototype.exchange = "";

        /**
         * FutureInfo contractType.
         * @member {string} contractType
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @instance
         */
        FutureInfo.prototype.contractType = "";

        /**
         * FutureInfo contractSize.
         * @member {number} contractSize
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @instance
         */
        FutureInfo.prototype.contractSize = 0;

        /**
         * FutureInfo contractSizeUnit.
         * @member {string} contractSizeUnit
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @instance
         */
        FutureInfo.prototype.contractSizeUnit = "";

        /**
         * FutureInfo quoteCurrency.
         * @member {string} quoteCurrency
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @instance
         */
        FutureInfo.prototype.quoteCurrency = "";

        /**
         * FutureInfo minVar.
         * @member {number} minVar
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @instance
         */
        FutureInfo.prototype.minVar = 0;

        /**
         * FutureInfo minVarUnit.
         * @member {string} minVarUnit
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @instance
         */
        FutureInfo.prototype.minVarUnit = "";

        /**
         * FutureInfo quoteUnit.
         * @member {string} quoteUnit
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @instance
         */
        FutureInfo.prototype.quoteUnit = "";

        /**
         * FutureInfo tradeTime.
         * @member {Array.<Qot_GetFutureInfo.ITradeTime>} tradeTime
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @instance
         */
        FutureInfo.prototype.tradeTime = $util.emptyArray;

        /**
         * FutureInfo timeZone.
         * @member {string} timeZone
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @instance
         */
        FutureInfo.prototype.timeZone = "";

        /**
         * FutureInfo exchangeFormatUrl.
         * @member {string} exchangeFormatUrl
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @instance
         */
        FutureInfo.prototype.exchangeFormatUrl = "";

        /**
         * Creates a new FutureInfo instance using the specified properties.
         * @function create
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @static
         * @param {Qot_GetFutureInfo.IFutureInfo=} [properties] Properties to set
         * @returns {Qot_GetFutureInfo.FutureInfo} FutureInfo instance
         */
        FutureInfo.create = function create(properties) {
            return new FutureInfo(properties);
        };

        /**
         * Encodes the specified FutureInfo message. Does not implicitly {@link Qot_GetFutureInfo.FutureInfo.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @static
         * @param {Qot_GetFutureInfo.IFutureInfo} message FutureInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FutureInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.lastTradeTime);
            if (message.lastTradeTimestamp != null && message.hasOwnProperty("lastTradeTimestamp"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.lastTradeTimestamp);
            if (message.owner != null && message.hasOwnProperty("owner"))
                $root.Qot_Common.Security.encode(message.owner, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.ownerOther);
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.exchange);
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.contractType);
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.contractSize);
            writer.uint32(/* id 10, wireType 2 =*/82).string(message.contractSizeUnit);
            writer.uint32(/* id 11, wireType 2 =*/90).string(message.quoteCurrency);
            writer.uint32(/* id 12, wireType 1 =*/97).double(message.minVar);
            writer.uint32(/* id 13, wireType 2 =*/106).string(message.minVarUnit);
            if (message.quoteUnit != null && message.hasOwnProperty("quoteUnit"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.quoteUnit);
            if (message.tradeTime != null && message.tradeTime.length)
                for (var i = 0; i < message.tradeTime.length; ++i)
                    $root.Qot_GetFutureInfo.TradeTime.encode(message.tradeTime[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            writer.uint32(/* id 16, wireType 2 =*/130).string(message.timeZone);
            writer.uint32(/* id 17, wireType 2 =*/138).string(message.exchangeFormatUrl);
            return writer;
        };

        /**
         * Encodes the specified FutureInfo message, length delimited. Does not implicitly {@link Qot_GetFutureInfo.FutureInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @static
         * @param {Qot_GetFutureInfo.IFutureInfo} message FutureInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FutureInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FutureInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetFutureInfo.FutureInfo} FutureInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FutureInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetFutureInfo.FutureInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.lastTradeTime = reader.string();
                    break;
                case 4:
                    message.lastTradeTimestamp = reader.double();
                    break;
                case 5:
                    message.owner = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.ownerOther = reader.string();
                    break;
                case 7:
                    message.exchange = reader.string();
                    break;
                case 8:
                    message.contractType = reader.string();
                    break;
                case 9:
                    message.contractSize = reader.double();
                    break;
                case 10:
                    message.contractSizeUnit = reader.string();
                    break;
                case 11:
                    message.quoteCurrency = reader.string();
                    break;
                case 12:
                    message.minVar = reader.double();
                    break;
                case 13:
                    message.minVarUnit = reader.string();
                    break;
                case 14:
                    message.quoteUnit = reader.string();
                    break;
                case 15:
                    if (!(message.tradeTime && message.tradeTime.length))
                        message.tradeTime = [];
                    message.tradeTime.push($root.Qot_GetFutureInfo.TradeTime.decode(reader, reader.uint32()));
                    break;
                case 16:
                    message.timeZone = reader.string();
                    break;
                case 17:
                    message.exchangeFormatUrl = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("lastTradeTime"))
                throw $util.ProtocolError("missing required 'lastTradeTime'", { instance: message });
            if (!message.hasOwnProperty("ownerOther"))
                throw $util.ProtocolError("missing required 'ownerOther'", { instance: message });
            if (!message.hasOwnProperty("exchange"))
                throw $util.ProtocolError("missing required 'exchange'", { instance: message });
            if (!message.hasOwnProperty("contractType"))
                throw $util.ProtocolError("missing required 'contractType'", { instance: message });
            if (!message.hasOwnProperty("contractSize"))
                throw $util.ProtocolError("missing required 'contractSize'", { instance: message });
            if (!message.hasOwnProperty("contractSizeUnit"))
                throw $util.ProtocolError("missing required 'contractSizeUnit'", { instance: message });
            if (!message.hasOwnProperty("quoteCurrency"))
                throw $util.ProtocolError("missing required 'quoteCurrency'", { instance: message });
            if (!message.hasOwnProperty("minVar"))
                throw $util.ProtocolError("missing required 'minVar'", { instance: message });
            if (!message.hasOwnProperty("minVarUnit"))
                throw $util.ProtocolError("missing required 'minVarUnit'", { instance: message });
            if (!message.hasOwnProperty("timeZone"))
                throw $util.ProtocolError("missing required 'timeZone'", { instance: message });
            if (!message.hasOwnProperty("exchangeFormatUrl"))
                throw $util.ProtocolError("missing required 'exchangeFormatUrl'", { instance: message });
            return message;
        };

        /**
         * Decodes a FutureInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetFutureInfo.FutureInfo} FutureInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FutureInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FutureInfo message.
         * @function verify
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FutureInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (!$util.isString(message.lastTradeTime))
                return "lastTradeTime: string expected";
            if (message.lastTradeTimestamp != null && message.hasOwnProperty("lastTradeTimestamp"))
                if (typeof message.lastTradeTimestamp !== "number")
                    return "lastTradeTimestamp: number expected";
            if (message.owner != null && message.hasOwnProperty("owner")) {
                var error = $root.Qot_Common.Security.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            if (!$util.isString(message.ownerOther))
                return "ownerOther: string expected";
            if (!$util.isString(message.exchange))
                return "exchange: string expected";
            if (!$util.isString(message.contractType))
                return "contractType: string expected";
            if (typeof message.contractSize !== "number")
                return "contractSize: number expected";
            if (!$util.isString(message.contractSizeUnit))
                return "contractSizeUnit: string expected";
            if (!$util.isString(message.quoteCurrency))
                return "quoteCurrency: string expected";
            if (typeof message.minVar !== "number")
                return "minVar: number expected";
            if (!$util.isString(message.minVarUnit))
                return "minVarUnit: string expected";
            if (message.quoteUnit != null && message.hasOwnProperty("quoteUnit"))
                if (!$util.isString(message.quoteUnit))
                    return "quoteUnit: string expected";
            if (message.tradeTime != null && message.hasOwnProperty("tradeTime")) {
                if (!Array.isArray(message.tradeTime))
                    return "tradeTime: array expected";
                for (var i = 0; i < message.tradeTime.length; ++i) {
                    var error = $root.Qot_GetFutureInfo.TradeTime.verify(message.tradeTime[i]);
                    if (error)
                        return "tradeTime." + error;
                }
            }
            if (!$util.isString(message.timeZone))
                return "timeZone: string expected";
            if (!$util.isString(message.exchangeFormatUrl))
                return "exchangeFormatUrl: string expected";
            return null;
        };

        /**
         * Creates a FutureInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetFutureInfo.FutureInfo} FutureInfo
         */
        FutureInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetFutureInfo.FutureInfo)
                return object;
            var message = new $root.Qot_GetFutureInfo.FutureInfo();
            if (object.name != null)
                message.name = String(object.name);
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetFutureInfo.FutureInfo.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.lastTradeTime != null)
                message.lastTradeTime = String(object.lastTradeTime);
            if (object.lastTradeTimestamp != null)
                message.lastTradeTimestamp = Number(object.lastTradeTimestamp);
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".Qot_GetFutureInfo.FutureInfo.owner: object expected");
                message.owner = $root.Qot_Common.Security.fromObject(object.owner);
            }
            if (object.ownerOther != null)
                message.ownerOther = String(object.ownerOther);
            if (object.exchange != null)
                message.exchange = String(object.exchange);
            if (object.contractType != null)
                message.contractType = String(object.contractType);
            if (object.contractSize != null)
                message.contractSize = Number(object.contractSize);
            if (object.contractSizeUnit != null)
                message.contractSizeUnit = String(object.contractSizeUnit);
            if (object.quoteCurrency != null)
                message.quoteCurrency = String(object.quoteCurrency);
            if (object.minVar != null)
                message.minVar = Number(object.minVar);
            if (object.minVarUnit != null)
                message.minVarUnit = String(object.minVarUnit);
            if (object.quoteUnit != null)
                message.quoteUnit = String(object.quoteUnit);
            if (object.tradeTime) {
                if (!Array.isArray(object.tradeTime))
                    throw TypeError(".Qot_GetFutureInfo.FutureInfo.tradeTime: array expected");
                message.tradeTime = [];
                for (var i = 0; i < object.tradeTime.length; ++i) {
                    if (typeof object.tradeTime[i] !== "object")
                        throw TypeError(".Qot_GetFutureInfo.FutureInfo.tradeTime: object expected");
                    message.tradeTime[i] = $root.Qot_GetFutureInfo.TradeTime.fromObject(object.tradeTime[i]);
                }
            }
            if (object.timeZone != null)
                message.timeZone = String(object.timeZone);
            if (object.exchangeFormatUrl != null)
                message.exchangeFormatUrl = String(object.exchangeFormatUrl);
            return message;
        };

        /**
         * Creates a plain object from a FutureInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @static
         * @param {Qot_GetFutureInfo.FutureInfo} message FutureInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FutureInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tradeTime = [];
            if (options.defaults) {
                object.name = "";
                object.security = null;
                object.lastTradeTime = "";
                object.lastTradeTimestamp = 0;
                object.owner = null;
                object.ownerOther = "";
                object.exchange = "";
                object.contractType = "";
                object.contractSize = 0;
                object.contractSizeUnit = "";
                object.quoteCurrency = "";
                object.minVar = 0;
                object.minVarUnit = "";
                object.quoteUnit = "";
                object.timeZone = "";
                object.exchangeFormatUrl = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.lastTradeTime != null && message.hasOwnProperty("lastTradeTime"))
                object.lastTradeTime = message.lastTradeTime;
            if (message.lastTradeTimestamp != null && message.hasOwnProperty("lastTradeTimestamp"))
                object.lastTradeTimestamp = options.json && !isFinite(message.lastTradeTimestamp) ? String(message.lastTradeTimestamp) : message.lastTradeTimestamp;
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.Qot_Common.Security.toObject(message.owner, options);
            if (message.ownerOther != null && message.hasOwnProperty("ownerOther"))
                object.ownerOther = message.ownerOther;
            if (message.exchange != null && message.hasOwnProperty("exchange"))
                object.exchange = message.exchange;
            if (message.contractType != null && message.hasOwnProperty("contractType"))
                object.contractType = message.contractType;
            if (message.contractSize != null && message.hasOwnProperty("contractSize"))
                object.contractSize = options.json && !isFinite(message.contractSize) ? String(message.contractSize) : message.contractSize;
            if (message.contractSizeUnit != null && message.hasOwnProperty("contractSizeUnit"))
                object.contractSizeUnit = message.contractSizeUnit;
            if (message.quoteCurrency != null && message.hasOwnProperty("quoteCurrency"))
                object.quoteCurrency = message.quoteCurrency;
            if (message.minVar != null && message.hasOwnProperty("minVar"))
                object.minVar = options.json && !isFinite(message.minVar) ? String(message.minVar) : message.minVar;
            if (message.minVarUnit != null && message.hasOwnProperty("minVarUnit"))
                object.minVarUnit = message.minVarUnit;
            if (message.quoteUnit != null && message.hasOwnProperty("quoteUnit"))
                object.quoteUnit = message.quoteUnit;
            if (message.tradeTime && message.tradeTime.length) {
                object.tradeTime = [];
                for (var j = 0; j < message.tradeTime.length; ++j)
                    object.tradeTime[j] = $root.Qot_GetFutureInfo.TradeTime.toObject(message.tradeTime[j], options);
            }
            if (message.timeZone != null && message.hasOwnProperty("timeZone"))
                object.timeZone = message.timeZone;
            if (message.exchangeFormatUrl != null && message.hasOwnProperty("exchangeFormatUrl"))
                object.exchangeFormatUrl = message.exchangeFormatUrl;
            return object;
        };

        /**
         * Converts this FutureInfo to JSON.
         * @function toJSON
         * @memberof Qot_GetFutureInfo.FutureInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FutureInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FutureInfo;
    })();

    Qot_GetFutureInfo.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetFutureInfo
         * @interface IC2S
         * @property {Array.<Qot_Common.ISecurity>|null} [securityList] C2S securityList
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetFutureInfo
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetFutureInfo.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.securityList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S securityList.
         * @member {Array.<Qot_Common.ISecurity>} securityList
         * @memberof Qot_GetFutureInfo.C2S
         * @instance
         */
        C2S.prototype.securityList = $util.emptyArray;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetFutureInfo.C2S
         * @static
         * @param {Qot_GetFutureInfo.IC2S=} [properties] Properties to set
         * @returns {Qot_GetFutureInfo.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetFutureInfo.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetFutureInfo.C2S
         * @static
         * @param {Qot_GetFutureInfo.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.securityList != null && message.securityList.length)
                for (var i = 0; i < message.securityList.length; ++i)
                    $root.Qot_Common.Security.encode(message.securityList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetFutureInfo.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetFutureInfo.C2S
         * @static
         * @param {Qot_GetFutureInfo.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetFutureInfo.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetFutureInfo.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetFutureInfo.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.securityList && message.securityList.length))
                        message.securityList = [];
                    message.securityList.push($root.Qot_Common.Security.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetFutureInfo.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetFutureInfo.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetFutureInfo.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.securityList != null && message.hasOwnProperty("securityList")) {
                if (!Array.isArray(message.securityList))
                    return "securityList: array expected";
                for (var i = 0; i < message.securityList.length; ++i) {
                    var error = $root.Qot_Common.Security.verify(message.securityList[i]);
                    if (error)
                        return "securityList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetFutureInfo.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetFutureInfo.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetFutureInfo.C2S)
                return object;
            var message = new $root.Qot_GetFutureInfo.C2S();
            if (object.securityList) {
                if (!Array.isArray(object.securityList))
                    throw TypeError(".Qot_GetFutureInfo.C2S.securityList: array expected");
                message.securityList = [];
                for (var i = 0; i < object.securityList.length; ++i) {
                    if (typeof object.securityList[i] !== "object")
                        throw TypeError(".Qot_GetFutureInfo.C2S.securityList: object expected");
                    message.securityList[i] = $root.Qot_Common.Security.fromObject(object.securityList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetFutureInfo.C2S
         * @static
         * @param {Qot_GetFutureInfo.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.securityList = [];
            if (message.securityList && message.securityList.length) {
                object.securityList = [];
                for (var j = 0; j < message.securityList.length; ++j)
                    object.securityList[j] = $root.Qot_Common.Security.toObject(message.securityList[j], options);
            }
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetFutureInfo.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetFutureInfo.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetFutureInfo
         * @interface IS2C
         * @property {Array.<Qot_GetFutureInfo.IFutureInfo>|null} [futureInfoList] S2C futureInfoList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetFutureInfo
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetFutureInfo.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.futureInfoList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C futureInfoList.
         * @member {Array.<Qot_GetFutureInfo.IFutureInfo>} futureInfoList
         * @memberof Qot_GetFutureInfo.S2C
         * @instance
         */
        S2C.prototype.futureInfoList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetFutureInfo.S2C
         * @static
         * @param {Qot_GetFutureInfo.IS2C=} [properties] Properties to set
         * @returns {Qot_GetFutureInfo.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetFutureInfo.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetFutureInfo.S2C
         * @static
         * @param {Qot_GetFutureInfo.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.futureInfoList != null && message.futureInfoList.length)
                for (var i = 0; i < message.futureInfoList.length; ++i)
                    $root.Qot_GetFutureInfo.FutureInfo.encode(message.futureInfoList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetFutureInfo.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetFutureInfo.S2C
         * @static
         * @param {Qot_GetFutureInfo.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetFutureInfo.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetFutureInfo.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetFutureInfo.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.futureInfoList && message.futureInfoList.length))
                        message.futureInfoList = [];
                    message.futureInfoList.push($root.Qot_GetFutureInfo.FutureInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetFutureInfo.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetFutureInfo.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetFutureInfo.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.futureInfoList != null && message.hasOwnProperty("futureInfoList")) {
                if (!Array.isArray(message.futureInfoList))
                    return "futureInfoList: array expected";
                for (var i = 0; i < message.futureInfoList.length; ++i) {
                    var error = $root.Qot_GetFutureInfo.FutureInfo.verify(message.futureInfoList[i]);
                    if (error)
                        return "futureInfoList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetFutureInfo.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetFutureInfo.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetFutureInfo.S2C)
                return object;
            var message = new $root.Qot_GetFutureInfo.S2C();
            if (object.futureInfoList) {
                if (!Array.isArray(object.futureInfoList))
                    throw TypeError(".Qot_GetFutureInfo.S2C.futureInfoList: array expected");
                message.futureInfoList = [];
                for (var i = 0; i < object.futureInfoList.length; ++i) {
                    if (typeof object.futureInfoList[i] !== "object")
                        throw TypeError(".Qot_GetFutureInfo.S2C.futureInfoList: object expected");
                    message.futureInfoList[i] = $root.Qot_GetFutureInfo.FutureInfo.fromObject(object.futureInfoList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetFutureInfo.S2C
         * @static
         * @param {Qot_GetFutureInfo.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.futureInfoList = [];
            if (message.futureInfoList && message.futureInfoList.length) {
                object.futureInfoList = [];
                for (var j = 0; j < message.futureInfoList.length; ++j)
                    object.futureInfoList[j] = $root.Qot_GetFutureInfo.FutureInfo.toObject(message.futureInfoList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetFutureInfo.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetFutureInfo.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetFutureInfo
         * @interface IRequest
         * @property {Qot_GetFutureInfo.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetFutureInfo
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetFutureInfo.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetFutureInfo.IC2S} c2s
         * @memberof Qot_GetFutureInfo.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetFutureInfo.Request
         * @static
         * @param {Qot_GetFutureInfo.IRequest=} [properties] Properties to set
         * @returns {Qot_GetFutureInfo.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetFutureInfo.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetFutureInfo.Request
         * @static
         * @param {Qot_GetFutureInfo.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetFutureInfo.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetFutureInfo.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetFutureInfo.Request
         * @static
         * @param {Qot_GetFutureInfo.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetFutureInfo.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetFutureInfo.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetFutureInfo.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetFutureInfo.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetFutureInfo.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetFutureInfo.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetFutureInfo.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetFutureInfo.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetFutureInfo.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetFutureInfo.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetFutureInfo.Request)
                return object;
            var message = new $root.Qot_GetFutureInfo.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetFutureInfo.Request.c2s: object expected");
                message.c2s = $root.Qot_GetFutureInfo.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetFutureInfo.Request
         * @static
         * @param {Qot_GetFutureInfo.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetFutureInfo.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetFutureInfo.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetFutureInfo.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetFutureInfo
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetFutureInfo.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetFutureInfo
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetFutureInfo.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetFutureInfo.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetFutureInfo.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetFutureInfo.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetFutureInfo.IS2C|null|undefined} s2c
         * @memberof Qot_GetFutureInfo.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetFutureInfo.Response
         * @static
         * @param {Qot_GetFutureInfo.IResponse=} [properties] Properties to set
         * @returns {Qot_GetFutureInfo.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetFutureInfo.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetFutureInfo.Response
         * @static
         * @param {Qot_GetFutureInfo.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetFutureInfo.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetFutureInfo.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetFutureInfo.Response
         * @static
         * @param {Qot_GetFutureInfo.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetFutureInfo.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetFutureInfo.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetFutureInfo.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetFutureInfo.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetFutureInfo.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetFutureInfo.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetFutureInfo.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetFutureInfo.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetFutureInfo.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetFutureInfo.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetFutureInfo.Response)
                return object;
            var message = new $root.Qot_GetFutureInfo.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetFutureInfo.Response.s2c: object expected");
                message.s2c = $root.Qot_GetFutureInfo.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetFutureInfo.Response
         * @static
         * @param {Qot_GetFutureInfo.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetFutureInfo.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetFutureInfo.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetFutureInfo;
})();

$root.Qot_GetHistoryKLPoints = (function() {

    /**
     * Namespace Qot_GetHistoryKLPoints.
     * @exports Qot_GetHistoryKLPoints
     * @namespace
     */
    var Qot_GetHistoryKLPoints = {};

    /**
     * NoDataMode enum.
     * @name Qot_GetHistoryKLPoints.NoDataMode
     * @enum {string}
     * @property {number} NoDataMode_Null=0 NoDataMode_Null value
     * @property {number} NoDataMode_Forward=1 NoDataMode_Forward value
     * @property {number} NoDataMode_Backward=2 NoDataMode_Backward value
     */
    Qot_GetHistoryKLPoints.NoDataMode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NoDataMode_Null"] = 0;
        values[valuesById[1] = "NoDataMode_Forward"] = 1;
        values[valuesById[2] = "NoDataMode_Backward"] = 2;
        return values;
    })();

    /**
     * DataStatus enum.
     * @name Qot_GetHistoryKLPoints.DataStatus
     * @enum {string}
     * @property {number} DataStatus_Null=0 DataStatus_Null value
     * @property {number} DataStatus_Current=1 DataStatus_Current value
     * @property {number} DataStatus_Previous=2 DataStatus_Previous value
     * @property {number} DataStatus_Back=3 DataStatus_Back value
     */
    Qot_GetHistoryKLPoints.DataStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DataStatus_Null"] = 0;
        values[valuesById[1] = "DataStatus_Current"] = 1;
        values[valuesById[2] = "DataStatus_Previous"] = 2;
        values[valuesById[3] = "DataStatus_Back"] = 3;
        return values;
    })();

    Qot_GetHistoryKLPoints.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetHistoryKLPoints
         * @interface IC2S
         * @property {number} rehabType C2S rehabType
         * @property {number} klType C2S klType
         * @property {number} noDataMode C2S noDataMode
         * @property {Array.<Qot_Common.ISecurity>|null} [securityList] C2S securityList
         * @property {Array.<string>|null} [timeList] C2S timeList
         * @property {number|null} [maxReqSecurityNum] C2S maxReqSecurityNum
         * @property {number|Long|null} [needKLFieldsFlag] C2S needKLFieldsFlag
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetHistoryKLPoints
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetHistoryKLPoints.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.securityList = [];
            this.timeList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S rehabType.
         * @member {number} rehabType
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @instance
         */
        C2S.prototype.rehabType = 0;

        /**
         * C2S klType.
         * @member {number} klType
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @instance
         */
        C2S.prototype.klType = 0;

        /**
         * C2S noDataMode.
         * @member {number} noDataMode
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @instance
         */
        C2S.prototype.noDataMode = 0;

        /**
         * C2S securityList.
         * @member {Array.<Qot_Common.ISecurity>} securityList
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @instance
         */
        C2S.prototype.securityList = $util.emptyArray;

        /**
         * C2S timeList.
         * @member {Array.<string>} timeList
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @instance
         */
        C2S.prototype.timeList = $util.emptyArray;

        /**
         * C2S maxReqSecurityNum.
         * @member {number} maxReqSecurityNum
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @instance
         */
        C2S.prototype.maxReqSecurityNum = 0;

        /**
         * C2S needKLFieldsFlag.
         * @member {number|Long} needKLFieldsFlag
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @instance
         */
        C2S.prototype.needKLFieldsFlag = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @static
         * @param {Qot_GetHistoryKLPoints.IC2S=} [properties] Properties to set
         * @returns {Qot_GetHistoryKLPoints.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetHistoryKLPoints.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @static
         * @param {Qot_GetHistoryKLPoints.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rehabType);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.klType);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.noDataMode);
            if (message.securityList != null && message.securityList.length)
                for (var i = 0; i < message.securityList.length; ++i)
                    $root.Qot_Common.Security.encode(message.securityList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.timeList != null && message.timeList.length)
                for (var i = 0; i < message.timeList.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.timeList[i]);
            if (message.maxReqSecurityNum != null && message.hasOwnProperty("maxReqSecurityNum"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.maxReqSecurityNum);
            if (message.needKLFieldsFlag != null && message.hasOwnProperty("needKLFieldsFlag"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.needKLFieldsFlag);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetHistoryKLPoints.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @static
         * @param {Qot_GetHistoryKLPoints.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHistoryKLPoints.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHistoryKLPoints.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rehabType = reader.int32();
                    break;
                case 2:
                    message.klType = reader.int32();
                    break;
                case 3:
                    message.noDataMode = reader.int32();
                    break;
                case 4:
                    if (!(message.securityList && message.securityList.length))
                        message.securityList = [];
                    message.securityList.push($root.Qot_Common.Security.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.timeList && message.timeList.length))
                        message.timeList = [];
                    message.timeList.push(reader.string());
                    break;
                case 6:
                    message.maxReqSecurityNum = reader.int32();
                    break;
                case 7:
                    message.needKLFieldsFlag = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("rehabType"))
                throw $util.ProtocolError("missing required 'rehabType'", { instance: message });
            if (!message.hasOwnProperty("klType"))
                throw $util.ProtocolError("missing required 'klType'", { instance: message });
            if (!message.hasOwnProperty("noDataMode"))
                throw $util.ProtocolError("missing required 'noDataMode'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHistoryKLPoints.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.rehabType))
                return "rehabType: integer expected";
            if (!$util.isInteger(message.klType))
                return "klType: integer expected";
            if (!$util.isInteger(message.noDataMode))
                return "noDataMode: integer expected";
            if (message.securityList != null && message.hasOwnProperty("securityList")) {
                if (!Array.isArray(message.securityList))
                    return "securityList: array expected";
                for (var i = 0; i < message.securityList.length; ++i) {
                    var error = $root.Qot_Common.Security.verify(message.securityList[i]);
                    if (error)
                        return "securityList." + error;
                }
            }
            if (message.timeList != null && message.hasOwnProperty("timeList")) {
                if (!Array.isArray(message.timeList))
                    return "timeList: array expected";
                for (var i = 0; i < message.timeList.length; ++i)
                    if (!$util.isString(message.timeList[i]))
                        return "timeList: string[] expected";
            }
            if (message.maxReqSecurityNum != null && message.hasOwnProperty("maxReqSecurityNum"))
                if (!$util.isInteger(message.maxReqSecurityNum))
                    return "maxReqSecurityNum: integer expected";
            if (message.needKLFieldsFlag != null && message.hasOwnProperty("needKLFieldsFlag"))
                if (!$util.isInteger(message.needKLFieldsFlag) && !(message.needKLFieldsFlag && $util.isInteger(message.needKLFieldsFlag.low) && $util.isInteger(message.needKLFieldsFlag.high)))
                    return "needKLFieldsFlag: integer|Long expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHistoryKLPoints.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHistoryKLPoints.C2S)
                return object;
            var message = new $root.Qot_GetHistoryKLPoints.C2S();
            if (object.rehabType != null)
                message.rehabType = object.rehabType | 0;
            if (object.klType != null)
                message.klType = object.klType | 0;
            if (object.noDataMode != null)
                message.noDataMode = object.noDataMode | 0;
            if (object.securityList) {
                if (!Array.isArray(object.securityList))
                    throw TypeError(".Qot_GetHistoryKLPoints.C2S.securityList: array expected");
                message.securityList = [];
                for (var i = 0; i < object.securityList.length; ++i) {
                    if (typeof object.securityList[i] !== "object")
                        throw TypeError(".Qot_GetHistoryKLPoints.C2S.securityList: object expected");
                    message.securityList[i] = $root.Qot_Common.Security.fromObject(object.securityList[i]);
                }
            }
            if (object.timeList) {
                if (!Array.isArray(object.timeList))
                    throw TypeError(".Qot_GetHistoryKLPoints.C2S.timeList: array expected");
                message.timeList = [];
                for (var i = 0; i < object.timeList.length; ++i)
                    message.timeList[i] = String(object.timeList[i]);
            }
            if (object.maxReqSecurityNum != null)
                message.maxReqSecurityNum = object.maxReqSecurityNum | 0;
            if (object.needKLFieldsFlag != null)
                if ($util.Long)
                    (message.needKLFieldsFlag = $util.Long.fromValue(object.needKLFieldsFlag)).unsigned = false;
                else if (typeof object.needKLFieldsFlag === "string")
                    message.needKLFieldsFlag = parseInt(object.needKLFieldsFlag, 10);
                else if (typeof object.needKLFieldsFlag === "number")
                    message.needKLFieldsFlag = object.needKLFieldsFlag;
                else if (typeof object.needKLFieldsFlag === "object")
                    message.needKLFieldsFlag = new $util.LongBits(object.needKLFieldsFlag.low >>> 0, object.needKLFieldsFlag.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @static
         * @param {Qot_GetHistoryKLPoints.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.securityList = [];
                object.timeList = [];
            }
            if (options.defaults) {
                object.rehabType = 0;
                object.klType = 0;
                object.noDataMode = 0;
                object.maxReqSecurityNum = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.needKLFieldsFlag = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.needKLFieldsFlag = options.longs === String ? "0" : 0;
            }
            if (message.rehabType != null && message.hasOwnProperty("rehabType"))
                object.rehabType = message.rehabType;
            if (message.klType != null && message.hasOwnProperty("klType"))
                object.klType = message.klType;
            if (message.noDataMode != null && message.hasOwnProperty("noDataMode"))
                object.noDataMode = message.noDataMode;
            if (message.securityList && message.securityList.length) {
                object.securityList = [];
                for (var j = 0; j < message.securityList.length; ++j)
                    object.securityList[j] = $root.Qot_Common.Security.toObject(message.securityList[j], options);
            }
            if (message.timeList && message.timeList.length) {
                object.timeList = [];
                for (var j = 0; j < message.timeList.length; ++j)
                    object.timeList[j] = message.timeList[j];
            }
            if (message.maxReqSecurityNum != null && message.hasOwnProperty("maxReqSecurityNum"))
                object.maxReqSecurityNum = message.maxReqSecurityNum;
            if (message.needKLFieldsFlag != null && message.hasOwnProperty("needKLFieldsFlag"))
                if (typeof message.needKLFieldsFlag === "number")
                    object.needKLFieldsFlag = options.longs === String ? String(message.needKLFieldsFlag) : message.needKLFieldsFlag;
                else
                    object.needKLFieldsFlag = options.longs === String ? $util.Long.prototype.toString.call(message.needKLFieldsFlag) : options.longs === Number ? new $util.LongBits(message.needKLFieldsFlag.low >>> 0, message.needKLFieldsFlag.high >>> 0).toNumber() : message.needKLFieldsFlag;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetHistoryKLPoints.HistoryPointsKL = (function() {

        /**
         * Properties of a HistoryPointsKL.
         * @memberof Qot_GetHistoryKLPoints
         * @interface IHistoryPointsKL
         * @property {number} status HistoryPointsKL status
         * @property {string} reqTime HistoryPointsKL reqTime
         * @property {Qot_Common.IKLine} kl HistoryPointsKL kl
         */

        /**
         * Constructs a new HistoryPointsKL.
         * @memberof Qot_GetHistoryKLPoints
         * @classdesc Represents a HistoryPointsKL.
         * @implements IHistoryPointsKL
         * @constructor
         * @param {Qot_GetHistoryKLPoints.IHistoryPointsKL=} [properties] Properties to set
         */
        function HistoryPointsKL(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HistoryPointsKL status.
         * @member {number} status
         * @memberof Qot_GetHistoryKLPoints.HistoryPointsKL
         * @instance
         */
        HistoryPointsKL.prototype.status = 0;

        /**
         * HistoryPointsKL reqTime.
         * @member {string} reqTime
         * @memberof Qot_GetHistoryKLPoints.HistoryPointsKL
         * @instance
         */
        HistoryPointsKL.prototype.reqTime = "";

        /**
         * HistoryPointsKL kl.
         * @member {Qot_Common.IKLine} kl
         * @memberof Qot_GetHistoryKLPoints.HistoryPointsKL
         * @instance
         */
        HistoryPointsKL.prototype.kl = null;

        /**
         * Creates a new HistoryPointsKL instance using the specified properties.
         * @function create
         * @memberof Qot_GetHistoryKLPoints.HistoryPointsKL
         * @static
         * @param {Qot_GetHistoryKLPoints.IHistoryPointsKL=} [properties] Properties to set
         * @returns {Qot_GetHistoryKLPoints.HistoryPointsKL} HistoryPointsKL instance
         */
        HistoryPointsKL.create = function create(properties) {
            return new HistoryPointsKL(properties);
        };

        /**
         * Encodes the specified HistoryPointsKL message. Does not implicitly {@link Qot_GetHistoryKLPoints.HistoryPointsKL.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHistoryKLPoints.HistoryPointsKL
         * @static
         * @param {Qot_GetHistoryKLPoints.IHistoryPointsKL} message HistoryPointsKL message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HistoryPointsKL.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.reqTime);
            $root.Qot_Common.KLine.encode(message.kl, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified HistoryPointsKL message, length delimited. Does not implicitly {@link Qot_GetHistoryKLPoints.HistoryPointsKL.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHistoryKLPoints.HistoryPointsKL
         * @static
         * @param {Qot_GetHistoryKLPoints.IHistoryPointsKL} message HistoryPointsKL message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HistoryPointsKL.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HistoryPointsKL message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHistoryKLPoints.HistoryPointsKL
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHistoryKLPoints.HistoryPointsKL} HistoryPointsKL
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HistoryPointsKL.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHistoryKLPoints.HistoryPointsKL();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.status = reader.int32();
                    break;
                case 2:
                    message.reqTime = reader.string();
                    break;
                case 3:
                    message.kl = $root.Qot_Common.KLine.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("status"))
                throw $util.ProtocolError("missing required 'status'", { instance: message });
            if (!message.hasOwnProperty("reqTime"))
                throw $util.ProtocolError("missing required 'reqTime'", { instance: message });
            if (!message.hasOwnProperty("kl"))
                throw $util.ProtocolError("missing required 'kl'", { instance: message });
            return message;
        };

        /**
         * Decodes a HistoryPointsKL message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHistoryKLPoints.HistoryPointsKL
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHistoryKLPoints.HistoryPointsKL} HistoryPointsKL
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HistoryPointsKL.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HistoryPointsKL message.
         * @function verify
         * @memberof Qot_GetHistoryKLPoints.HistoryPointsKL
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HistoryPointsKL.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.status))
                return "status: integer expected";
            if (!$util.isString(message.reqTime))
                return "reqTime: string expected";
            {
                var error = $root.Qot_Common.KLine.verify(message.kl);
                if (error)
                    return "kl." + error;
            }
            return null;
        };

        /**
         * Creates a HistoryPointsKL message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHistoryKLPoints.HistoryPointsKL
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHistoryKLPoints.HistoryPointsKL} HistoryPointsKL
         */
        HistoryPointsKL.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHistoryKLPoints.HistoryPointsKL)
                return object;
            var message = new $root.Qot_GetHistoryKLPoints.HistoryPointsKL();
            if (object.status != null)
                message.status = object.status | 0;
            if (object.reqTime != null)
                message.reqTime = String(object.reqTime);
            if (object.kl != null) {
                if (typeof object.kl !== "object")
                    throw TypeError(".Qot_GetHistoryKLPoints.HistoryPointsKL.kl: object expected");
                message.kl = $root.Qot_Common.KLine.fromObject(object.kl);
            }
            return message;
        };

        /**
         * Creates a plain object from a HistoryPointsKL message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHistoryKLPoints.HistoryPointsKL
         * @static
         * @param {Qot_GetHistoryKLPoints.HistoryPointsKL} message HistoryPointsKL
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HistoryPointsKL.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.status = 0;
                object.reqTime = "";
                object.kl = null;
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.reqTime != null && message.hasOwnProperty("reqTime"))
                object.reqTime = message.reqTime;
            if (message.kl != null && message.hasOwnProperty("kl"))
                object.kl = $root.Qot_Common.KLine.toObject(message.kl, options);
            return object;
        };

        /**
         * Converts this HistoryPointsKL to JSON.
         * @function toJSON
         * @memberof Qot_GetHistoryKLPoints.HistoryPointsKL
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HistoryPointsKL.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HistoryPointsKL;
    })();

    Qot_GetHistoryKLPoints.SecurityHistoryKLPoints = (function() {

        /**
         * Properties of a SecurityHistoryKLPoints.
         * @memberof Qot_GetHistoryKLPoints
         * @interface ISecurityHistoryKLPoints
         * @property {Qot_Common.ISecurity} security SecurityHistoryKLPoints security
         * @property {Array.<Qot_GetHistoryKLPoints.IHistoryPointsKL>|null} [klList] SecurityHistoryKLPoints klList
         */

        /**
         * Constructs a new SecurityHistoryKLPoints.
         * @memberof Qot_GetHistoryKLPoints
         * @classdesc Represents a SecurityHistoryKLPoints.
         * @implements ISecurityHistoryKLPoints
         * @constructor
         * @param {Qot_GetHistoryKLPoints.ISecurityHistoryKLPoints=} [properties] Properties to set
         */
        function SecurityHistoryKLPoints(properties) {
            this.klList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityHistoryKLPoints security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetHistoryKLPoints.SecurityHistoryKLPoints
         * @instance
         */
        SecurityHistoryKLPoints.prototype.security = null;

        /**
         * SecurityHistoryKLPoints klList.
         * @member {Array.<Qot_GetHistoryKLPoints.IHistoryPointsKL>} klList
         * @memberof Qot_GetHistoryKLPoints.SecurityHistoryKLPoints
         * @instance
         */
        SecurityHistoryKLPoints.prototype.klList = $util.emptyArray;

        /**
         * Creates a new SecurityHistoryKLPoints instance using the specified properties.
         * @function create
         * @memberof Qot_GetHistoryKLPoints.SecurityHistoryKLPoints
         * @static
         * @param {Qot_GetHistoryKLPoints.ISecurityHistoryKLPoints=} [properties] Properties to set
         * @returns {Qot_GetHistoryKLPoints.SecurityHistoryKLPoints} SecurityHistoryKLPoints instance
         */
        SecurityHistoryKLPoints.create = function create(properties) {
            return new SecurityHistoryKLPoints(properties);
        };

        /**
         * Encodes the specified SecurityHistoryKLPoints message. Does not implicitly {@link Qot_GetHistoryKLPoints.SecurityHistoryKLPoints.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHistoryKLPoints.SecurityHistoryKLPoints
         * @static
         * @param {Qot_GetHistoryKLPoints.ISecurityHistoryKLPoints} message SecurityHistoryKLPoints message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityHistoryKLPoints.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.klList != null && message.klList.length)
                for (var i = 0; i < message.klList.length; ++i)
                    $root.Qot_GetHistoryKLPoints.HistoryPointsKL.encode(message.klList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SecurityHistoryKLPoints message, length delimited. Does not implicitly {@link Qot_GetHistoryKLPoints.SecurityHistoryKLPoints.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHistoryKLPoints.SecurityHistoryKLPoints
         * @static
         * @param {Qot_GetHistoryKLPoints.ISecurityHistoryKLPoints} message SecurityHistoryKLPoints message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityHistoryKLPoints.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityHistoryKLPoints message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHistoryKLPoints.SecurityHistoryKLPoints
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHistoryKLPoints.SecurityHistoryKLPoints} SecurityHistoryKLPoints
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityHistoryKLPoints.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHistoryKLPoints.SecurityHistoryKLPoints();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.klList && message.klList.length))
                        message.klList = [];
                    message.klList.push($root.Qot_GetHistoryKLPoints.HistoryPointsKL.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a SecurityHistoryKLPoints message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHistoryKLPoints.SecurityHistoryKLPoints
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHistoryKLPoints.SecurityHistoryKLPoints} SecurityHistoryKLPoints
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityHistoryKLPoints.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityHistoryKLPoints message.
         * @function verify
         * @memberof Qot_GetHistoryKLPoints.SecurityHistoryKLPoints
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityHistoryKLPoints.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.klList != null && message.hasOwnProperty("klList")) {
                if (!Array.isArray(message.klList))
                    return "klList: array expected";
                for (var i = 0; i < message.klList.length; ++i) {
                    var error = $root.Qot_GetHistoryKLPoints.HistoryPointsKL.verify(message.klList[i]);
                    if (error)
                        return "klList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SecurityHistoryKLPoints message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHistoryKLPoints.SecurityHistoryKLPoints
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHistoryKLPoints.SecurityHistoryKLPoints} SecurityHistoryKLPoints
         */
        SecurityHistoryKLPoints.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHistoryKLPoints.SecurityHistoryKLPoints)
                return object;
            var message = new $root.Qot_GetHistoryKLPoints.SecurityHistoryKLPoints();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetHistoryKLPoints.SecurityHistoryKLPoints.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.klList) {
                if (!Array.isArray(object.klList))
                    throw TypeError(".Qot_GetHistoryKLPoints.SecurityHistoryKLPoints.klList: array expected");
                message.klList = [];
                for (var i = 0; i < object.klList.length; ++i) {
                    if (typeof object.klList[i] !== "object")
                        throw TypeError(".Qot_GetHistoryKLPoints.SecurityHistoryKLPoints.klList: object expected");
                    message.klList[i] = $root.Qot_GetHistoryKLPoints.HistoryPointsKL.fromObject(object.klList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SecurityHistoryKLPoints message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHistoryKLPoints.SecurityHistoryKLPoints
         * @static
         * @param {Qot_GetHistoryKLPoints.SecurityHistoryKLPoints} message SecurityHistoryKLPoints
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityHistoryKLPoints.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.klList = [];
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.klList && message.klList.length) {
                object.klList = [];
                for (var j = 0; j < message.klList.length; ++j)
                    object.klList[j] = $root.Qot_GetHistoryKLPoints.HistoryPointsKL.toObject(message.klList[j], options);
            }
            return object;
        };

        /**
         * Converts this SecurityHistoryKLPoints to JSON.
         * @function toJSON
         * @memberof Qot_GetHistoryKLPoints.SecurityHistoryKLPoints
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityHistoryKLPoints.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityHistoryKLPoints;
    })();

    Qot_GetHistoryKLPoints.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetHistoryKLPoints
         * @interface IS2C
         * @property {Array.<Qot_GetHistoryKLPoints.ISecurityHistoryKLPoints>|null} [klPointList] S2C klPointList
         * @property {boolean|null} [hasNext] S2C hasNext
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetHistoryKLPoints
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetHistoryKLPoints.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.klPointList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C klPointList.
         * @member {Array.<Qot_GetHistoryKLPoints.ISecurityHistoryKLPoints>} klPointList
         * @memberof Qot_GetHistoryKLPoints.S2C
         * @instance
         */
        S2C.prototype.klPointList = $util.emptyArray;

        /**
         * S2C hasNext.
         * @member {boolean} hasNext
         * @memberof Qot_GetHistoryKLPoints.S2C
         * @instance
         */
        S2C.prototype.hasNext = false;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetHistoryKLPoints.S2C
         * @static
         * @param {Qot_GetHistoryKLPoints.IS2C=} [properties] Properties to set
         * @returns {Qot_GetHistoryKLPoints.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetHistoryKLPoints.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHistoryKLPoints.S2C
         * @static
         * @param {Qot_GetHistoryKLPoints.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.klPointList != null && message.klPointList.length)
                for (var i = 0; i < message.klPointList.length; ++i)
                    $root.Qot_GetHistoryKLPoints.SecurityHistoryKLPoints.encode(message.klPointList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.hasNext != null && message.hasOwnProperty("hasNext"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.hasNext);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetHistoryKLPoints.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHistoryKLPoints.S2C
         * @static
         * @param {Qot_GetHistoryKLPoints.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHistoryKLPoints.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHistoryKLPoints.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHistoryKLPoints.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.klPointList && message.klPointList.length))
                        message.klPointList = [];
                    message.klPointList.push($root.Qot_GetHistoryKLPoints.SecurityHistoryKLPoints.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.hasNext = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHistoryKLPoints.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHistoryKLPoints.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetHistoryKLPoints.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.klPointList != null && message.hasOwnProperty("klPointList")) {
                if (!Array.isArray(message.klPointList))
                    return "klPointList: array expected";
                for (var i = 0; i < message.klPointList.length; ++i) {
                    var error = $root.Qot_GetHistoryKLPoints.SecurityHistoryKLPoints.verify(message.klPointList[i]);
                    if (error)
                        return "klPointList." + error;
                }
            }
            if (message.hasNext != null && message.hasOwnProperty("hasNext"))
                if (typeof message.hasNext !== "boolean")
                    return "hasNext: boolean expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHistoryKLPoints.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHistoryKLPoints.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHistoryKLPoints.S2C)
                return object;
            var message = new $root.Qot_GetHistoryKLPoints.S2C();
            if (object.klPointList) {
                if (!Array.isArray(object.klPointList))
                    throw TypeError(".Qot_GetHistoryKLPoints.S2C.klPointList: array expected");
                message.klPointList = [];
                for (var i = 0; i < object.klPointList.length; ++i) {
                    if (typeof object.klPointList[i] !== "object")
                        throw TypeError(".Qot_GetHistoryKLPoints.S2C.klPointList: object expected");
                    message.klPointList[i] = $root.Qot_GetHistoryKLPoints.SecurityHistoryKLPoints.fromObject(object.klPointList[i]);
                }
            }
            if (object.hasNext != null)
                message.hasNext = Boolean(object.hasNext);
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHistoryKLPoints.S2C
         * @static
         * @param {Qot_GetHistoryKLPoints.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.klPointList = [];
            if (options.defaults)
                object.hasNext = false;
            if (message.klPointList && message.klPointList.length) {
                object.klPointList = [];
                for (var j = 0; j < message.klPointList.length; ++j)
                    object.klPointList[j] = $root.Qot_GetHistoryKLPoints.SecurityHistoryKLPoints.toObject(message.klPointList[j], options);
            }
            if (message.hasNext != null && message.hasOwnProperty("hasNext"))
                object.hasNext = message.hasNext;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetHistoryKLPoints.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetHistoryKLPoints.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetHistoryKLPoints
         * @interface IRequest
         * @property {Qot_GetHistoryKLPoints.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetHistoryKLPoints
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetHistoryKLPoints.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetHistoryKLPoints.IC2S} c2s
         * @memberof Qot_GetHistoryKLPoints.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetHistoryKLPoints.Request
         * @static
         * @param {Qot_GetHistoryKLPoints.IRequest=} [properties] Properties to set
         * @returns {Qot_GetHistoryKLPoints.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetHistoryKLPoints.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHistoryKLPoints.Request
         * @static
         * @param {Qot_GetHistoryKLPoints.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetHistoryKLPoints.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetHistoryKLPoints.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHistoryKLPoints.Request
         * @static
         * @param {Qot_GetHistoryKLPoints.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHistoryKLPoints.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHistoryKLPoints.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHistoryKLPoints.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetHistoryKLPoints.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHistoryKLPoints.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHistoryKLPoints.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetHistoryKLPoints.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetHistoryKLPoints.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHistoryKLPoints.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHistoryKLPoints.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHistoryKLPoints.Request)
                return object;
            var message = new $root.Qot_GetHistoryKLPoints.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetHistoryKLPoints.Request.c2s: object expected");
                message.c2s = $root.Qot_GetHistoryKLPoints.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHistoryKLPoints.Request
         * @static
         * @param {Qot_GetHistoryKLPoints.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetHistoryKLPoints.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetHistoryKLPoints.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetHistoryKLPoints.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetHistoryKLPoints
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetHistoryKLPoints.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetHistoryKLPoints
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetHistoryKLPoints.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetHistoryKLPoints.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetHistoryKLPoints.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetHistoryKLPoints.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetHistoryKLPoints.IS2C|null|undefined} s2c
         * @memberof Qot_GetHistoryKLPoints.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetHistoryKLPoints.Response
         * @static
         * @param {Qot_GetHistoryKLPoints.IResponse=} [properties] Properties to set
         * @returns {Qot_GetHistoryKLPoints.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetHistoryKLPoints.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHistoryKLPoints.Response
         * @static
         * @param {Qot_GetHistoryKLPoints.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetHistoryKLPoints.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetHistoryKLPoints.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHistoryKLPoints.Response
         * @static
         * @param {Qot_GetHistoryKLPoints.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHistoryKLPoints.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHistoryKLPoints.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHistoryKLPoints.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetHistoryKLPoints.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHistoryKLPoints.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHistoryKLPoints.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetHistoryKLPoints.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetHistoryKLPoints.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHistoryKLPoints.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHistoryKLPoints.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHistoryKLPoints.Response)
                return object;
            var message = new $root.Qot_GetHistoryKLPoints.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetHistoryKLPoints.Response.s2c: object expected");
                message.s2c = $root.Qot_GetHistoryKLPoints.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHistoryKLPoints.Response
         * @static
         * @param {Qot_GetHistoryKLPoints.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetHistoryKLPoints.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetHistoryKLPoints.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetHistoryKLPoints;
})();

$root.Qot_GetHistoryKL = (function() {

    /**
     * Namespace Qot_GetHistoryKL.
     * @exports Qot_GetHistoryKL
     * @namespace
     */
    var Qot_GetHistoryKL = {};

    Qot_GetHistoryKL.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetHistoryKL
         * @interface IC2S
         * @property {number} rehabType C2S rehabType
         * @property {number} klType C2S klType
         * @property {Qot_Common.ISecurity} security C2S security
         * @property {string} beginTime C2S beginTime
         * @property {string} endTime C2S endTime
         * @property {number|null} [maxAckKLNum] C2S maxAckKLNum
         * @property {number|Long|null} [needKLFieldsFlag] C2S needKLFieldsFlag
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetHistoryKL
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetHistoryKL.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S rehabType.
         * @member {number} rehabType
         * @memberof Qot_GetHistoryKL.C2S
         * @instance
         */
        C2S.prototype.rehabType = 0;

        /**
         * C2S klType.
         * @member {number} klType
         * @memberof Qot_GetHistoryKL.C2S
         * @instance
         */
        C2S.prototype.klType = 0;

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetHistoryKL.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * C2S beginTime.
         * @member {string} beginTime
         * @memberof Qot_GetHistoryKL.C2S
         * @instance
         */
        C2S.prototype.beginTime = "";

        /**
         * C2S endTime.
         * @member {string} endTime
         * @memberof Qot_GetHistoryKL.C2S
         * @instance
         */
        C2S.prototype.endTime = "";

        /**
         * C2S maxAckKLNum.
         * @member {number} maxAckKLNum
         * @memberof Qot_GetHistoryKL.C2S
         * @instance
         */
        C2S.prototype.maxAckKLNum = 0;

        /**
         * C2S needKLFieldsFlag.
         * @member {number|Long} needKLFieldsFlag
         * @memberof Qot_GetHistoryKL.C2S
         * @instance
         */
        C2S.prototype.needKLFieldsFlag = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetHistoryKL.C2S
         * @static
         * @param {Qot_GetHistoryKL.IC2S=} [properties] Properties to set
         * @returns {Qot_GetHistoryKL.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetHistoryKL.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHistoryKL.C2S
         * @static
         * @param {Qot_GetHistoryKL.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rehabType);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.klType);
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.beginTime);
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.endTime);
            if (message.maxAckKLNum != null && message.hasOwnProperty("maxAckKLNum"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.maxAckKLNum);
            if (message.needKLFieldsFlag != null && message.hasOwnProperty("needKLFieldsFlag"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.needKLFieldsFlag);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetHistoryKL.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHistoryKL.C2S
         * @static
         * @param {Qot_GetHistoryKL.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHistoryKL.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHistoryKL.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHistoryKL.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rehabType = reader.int32();
                    break;
                case 2:
                    message.klType = reader.int32();
                    break;
                case 3:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.beginTime = reader.string();
                    break;
                case 5:
                    message.endTime = reader.string();
                    break;
                case 6:
                    message.maxAckKLNum = reader.int32();
                    break;
                case 7:
                    message.needKLFieldsFlag = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("rehabType"))
                throw $util.ProtocolError("missing required 'rehabType'", { instance: message });
            if (!message.hasOwnProperty("klType"))
                throw $util.ProtocolError("missing required 'klType'", { instance: message });
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("beginTime"))
                throw $util.ProtocolError("missing required 'beginTime'", { instance: message });
            if (!message.hasOwnProperty("endTime"))
                throw $util.ProtocolError("missing required 'endTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHistoryKL.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHistoryKL.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetHistoryKL.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.rehabType))
                return "rehabType: integer expected";
            if (!$util.isInteger(message.klType))
                return "klType: integer expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (!$util.isString(message.beginTime))
                return "beginTime: string expected";
            if (!$util.isString(message.endTime))
                return "endTime: string expected";
            if (message.maxAckKLNum != null && message.hasOwnProperty("maxAckKLNum"))
                if (!$util.isInteger(message.maxAckKLNum))
                    return "maxAckKLNum: integer expected";
            if (message.needKLFieldsFlag != null && message.hasOwnProperty("needKLFieldsFlag"))
                if (!$util.isInteger(message.needKLFieldsFlag) && !(message.needKLFieldsFlag && $util.isInteger(message.needKLFieldsFlag.low) && $util.isInteger(message.needKLFieldsFlag.high)))
                    return "needKLFieldsFlag: integer|Long expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHistoryKL.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHistoryKL.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHistoryKL.C2S)
                return object;
            var message = new $root.Qot_GetHistoryKL.C2S();
            if (object.rehabType != null)
                message.rehabType = object.rehabType | 0;
            if (object.klType != null)
                message.klType = object.klType | 0;
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetHistoryKL.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.beginTime != null)
                message.beginTime = String(object.beginTime);
            if (object.endTime != null)
                message.endTime = String(object.endTime);
            if (object.maxAckKLNum != null)
                message.maxAckKLNum = object.maxAckKLNum | 0;
            if (object.needKLFieldsFlag != null)
                if ($util.Long)
                    (message.needKLFieldsFlag = $util.Long.fromValue(object.needKLFieldsFlag)).unsigned = false;
                else if (typeof object.needKLFieldsFlag === "string")
                    message.needKLFieldsFlag = parseInt(object.needKLFieldsFlag, 10);
                else if (typeof object.needKLFieldsFlag === "number")
                    message.needKLFieldsFlag = object.needKLFieldsFlag;
                else if (typeof object.needKLFieldsFlag === "object")
                    message.needKLFieldsFlag = new $util.LongBits(object.needKLFieldsFlag.low >>> 0, object.needKLFieldsFlag.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHistoryKL.C2S
         * @static
         * @param {Qot_GetHistoryKL.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.rehabType = 0;
                object.klType = 0;
                object.security = null;
                object.beginTime = "";
                object.endTime = "";
                object.maxAckKLNum = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.needKLFieldsFlag = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.needKLFieldsFlag = options.longs === String ? "0" : 0;
            }
            if (message.rehabType != null && message.hasOwnProperty("rehabType"))
                object.rehabType = message.rehabType;
            if (message.klType != null && message.hasOwnProperty("klType"))
                object.klType = message.klType;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                object.beginTime = message.beginTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            if (message.maxAckKLNum != null && message.hasOwnProperty("maxAckKLNum"))
                object.maxAckKLNum = message.maxAckKLNum;
            if (message.needKLFieldsFlag != null && message.hasOwnProperty("needKLFieldsFlag"))
                if (typeof message.needKLFieldsFlag === "number")
                    object.needKLFieldsFlag = options.longs === String ? String(message.needKLFieldsFlag) : message.needKLFieldsFlag;
                else
                    object.needKLFieldsFlag = options.longs === String ? $util.Long.prototype.toString.call(message.needKLFieldsFlag) : options.longs === Number ? new $util.LongBits(message.needKLFieldsFlag.low >>> 0, message.needKLFieldsFlag.high >>> 0).toNumber() : message.needKLFieldsFlag;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetHistoryKL.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetHistoryKL.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetHistoryKL
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.IKLine>|null} [klList] S2C klList
         * @property {string|null} [nextKLTime] S2C nextKLTime
         * @property {number|null} [nextKLTimestamp] S2C nextKLTimestamp
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetHistoryKL
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetHistoryKL.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.klList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetHistoryKL.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C klList.
         * @member {Array.<Qot_Common.IKLine>} klList
         * @memberof Qot_GetHistoryKL.S2C
         * @instance
         */
        S2C.prototype.klList = $util.emptyArray;

        /**
         * S2C nextKLTime.
         * @member {string} nextKLTime
         * @memberof Qot_GetHistoryKL.S2C
         * @instance
         */
        S2C.prototype.nextKLTime = "";

        /**
         * S2C nextKLTimestamp.
         * @member {number} nextKLTimestamp
         * @memberof Qot_GetHistoryKL.S2C
         * @instance
         */
        S2C.prototype.nextKLTimestamp = 0;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetHistoryKL.S2C
         * @static
         * @param {Qot_GetHistoryKL.IS2C=} [properties] Properties to set
         * @returns {Qot_GetHistoryKL.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetHistoryKL.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHistoryKL.S2C
         * @static
         * @param {Qot_GetHistoryKL.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.klList != null && message.klList.length)
                for (var i = 0; i < message.klList.length; ++i)
                    $root.Qot_Common.KLine.encode(message.klList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.nextKLTime != null && message.hasOwnProperty("nextKLTime"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.nextKLTime);
            if (message.nextKLTimestamp != null && message.hasOwnProperty("nextKLTimestamp"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.nextKLTimestamp);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetHistoryKL.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHistoryKL.S2C
         * @static
         * @param {Qot_GetHistoryKL.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHistoryKL.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHistoryKL.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHistoryKL.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.klList && message.klList.length))
                        message.klList = [];
                    message.klList.push($root.Qot_Common.KLine.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.nextKLTime = reader.string();
                    break;
                case 4:
                    message.nextKLTimestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHistoryKL.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHistoryKL.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetHistoryKL.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.klList != null && message.hasOwnProperty("klList")) {
                if (!Array.isArray(message.klList))
                    return "klList: array expected";
                for (var i = 0; i < message.klList.length; ++i) {
                    var error = $root.Qot_Common.KLine.verify(message.klList[i]);
                    if (error)
                        return "klList." + error;
                }
            }
            if (message.nextKLTime != null && message.hasOwnProperty("nextKLTime"))
                if (!$util.isString(message.nextKLTime))
                    return "nextKLTime: string expected";
            if (message.nextKLTimestamp != null && message.hasOwnProperty("nextKLTimestamp"))
                if (typeof message.nextKLTimestamp !== "number")
                    return "nextKLTimestamp: number expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHistoryKL.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHistoryKL.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHistoryKL.S2C)
                return object;
            var message = new $root.Qot_GetHistoryKL.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetHistoryKL.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.klList) {
                if (!Array.isArray(object.klList))
                    throw TypeError(".Qot_GetHistoryKL.S2C.klList: array expected");
                message.klList = [];
                for (var i = 0; i < object.klList.length; ++i) {
                    if (typeof object.klList[i] !== "object")
                        throw TypeError(".Qot_GetHistoryKL.S2C.klList: object expected");
                    message.klList[i] = $root.Qot_Common.KLine.fromObject(object.klList[i]);
                }
            }
            if (object.nextKLTime != null)
                message.nextKLTime = String(object.nextKLTime);
            if (object.nextKLTimestamp != null)
                message.nextKLTimestamp = Number(object.nextKLTimestamp);
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHistoryKL.S2C
         * @static
         * @param {Qot_GetHistoryKL.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.klList = [];
            if (options.defaults) {
                object.security = null;
                object.nextKLTime = "";
                object.nextKLTimestamp = 0;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.klList && message.klList.length) {
                object.klList = [];
                for (var j = 0; j < message.klList.length; ++j)
                    object.klList[j] = $root.Qot_Common.KLine.toObject(message.klList[j], options);
            }
            if (message.nextKLTime != null && message.hasOwnProperty("nextKLTime"))
                object.nextKLTime = message.nextKLTime;
            if (message.nextKLTimestamp != null && message.hasOwnProperty("nextKLTimestamp"))
                object.nextKLTimestamp = options.json && !isFinite(message.nextKLTimestamp) ? String(message.nextKLTimestamp) : message.nextKLTimestamp;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetHistoryKL.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetHistoryKL.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetHistoryKL
         * @interface IRequest
         * @property {Qot_GetHistoryKL.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetHistoryKL
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetHistoryKL.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetHistoryKL.IC2S} c2s
         * @memberof Qot_GetHistoryKL.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetHistoryKL.Request
         * @static
         * @param {Qot_GetHistoryKL.IRequest=} [properties] Properties to set
         * @returns {Qot_GetHistoryKL.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetHistoryKL.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHistoryKL.Request
         * @static
         * @param {Qot_GetHistoryKL.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetHistoryKL.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetHistoryKL.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHistoryKL.Request
         * @static
         * @param {Qot_GetHistoryKL.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHistoryKL.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHistoryKL.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHistoryKL.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetHistoryKL.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHistoryKL.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHistoryKL.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetHistoryKL.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetHistoryKL.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHistoryKL.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHistoryKL.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHistoryKL.Request)
                return object;
            var message = new $root.Qot_GetHistoryKL.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetHistoryKL.Request.c2s: object expected");
                message.c2s = $root.Qot_GetHistoryKL.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHistoryKL.Request
         * @static
         * @param {Qot_GetHistoryKL.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetHistoryKL.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetHistoryKL.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetHistoryKL.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetHistoryKL
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetHistoryKL.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetHistoryKL
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetHistoryKL.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetHistoryKL.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetHistoryKL.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetHistoryKL.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetHistoryKL.IS2C|null|undefined} s2c
         * @memberof Qot_GetHistoryKL.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetHistoryKL.Response
         * @static
         * @param {Qot_GetHistoryKL.IResponse=} [properties] Properties to set
         * @returns {Qot_GetHistoryKL.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetHistoryKL.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHistoryKL.Response
         * @static
         * @param {Qot_GetHistoryKL.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetHistoryKL.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetHistoryKL.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHistoryKL.Response
         * @static
         * @param {Qot_GetHistoryKL.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHistoryKL.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHistoryKL.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHistoryKL.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetHistoryKL.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHistoryKL.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHistoryKL.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetHistoryKL.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetHistoryKL.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHistoryKL.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHistoryKL.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHistoryKL.Response)
                return object;
            var message = new $root.Qot_GetHistoryKL.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetHistoryKL.Response.s2c: object expected");
                message.s2c = $root.Qot_GetHistoryKL.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHistoryKL.Response
         * @static
         * @param {Qot_GetHistoryKL.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetHistoryKL.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetHistoryKL.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetHistoryKL;
})();

$root.Qot_GetHoldingChangeList = (function() {

    /**
     * Namespace Qot_GetHoldingChangeList.
     * @exports Qot_GetHoldingChangeList
     * @namespace
     */
    var Qot_GetHoldingChangeList = {};

    Qot_GetHoldingChangeList.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetHoldingChangeList
         * @interface IC2S
         * @property {Qot_Common.ISecurity} security C2S security
         * @property {number} holderCategory C2S holderCategory
         * @property {string|null} [beginTime] C2S beginTime
         * @property {string|null} [endTime] C2S endTime
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetHoldingChangeList
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetHoldingChangeList.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetHoldingChangeList.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * C2S holderCategory.
         * @member {number} holderCategory
         * @memberof Qot_GetHoldingChangeList.C2S
         * @instance
         */
        C2S.prototype.holderCategory = 0;

        /**
         * C2S beginTime.
         * @member {string} beginTime
         * @memberof Qot_GetHoldingChangeList.C2S
         * @instance
         */
        C2S.prototype.beginTime = "";

        /**
         * C2S endTime.
         * @member {string} endTime
         * @memberof Qot_GetHoldingChangeList.C2S
         * @instance
         */
        C2S.prototype.endTime = "";

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetHoldingChangeList.C2S
         * @static
         * @param {Qot_GetHoldingChangeList.IC2S=} [properties] Properties to set
         * @returns {Qot_GetHoldingChangeList.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetHoldingChangeList.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHoldingChangeList.C2S
         * @static
         * @param {Qot_GetHoldingChangeList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.holderCategory);
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.beginTime);
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.endTime);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetHoldingChangeList.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHoldingChangeList.C2S
         * @static
         * @param {Qot_GetHoldingChangeList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHoldingChangeList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHoldingChangeList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHoldingChangeList.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.holderCategory = reader.int32();
                    break;
                case 3:
                    message.beginTime = reader.string();
                    break;
                case 4:
                    message.endTime = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("holderCategory"))
                throw $util.ProtocolError("missing required 'holderCategory'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHoldingChangeList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHoldingChangeList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetHoldingChangeList.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (!$util.isInteger(message.holderCategory))
                return "holderCategory: integer expected";
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                if (!$util.isString(message.beginTime))
                    return "beginTime: string expected";
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isString(message.endTime))
                    return "endTime: string expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHoldingChangeList.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHoldingChangeList.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHoldingChangeList.C2S)
                return object;
            var message = new $root.Qot_GetHoldingChangeList.C2S();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetHoldingChangeList.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.holderCategory != null)
                message.holderCategory = object.holderCategory | 0;
            if (object.beginTime != null)
                message.beginTime = String(object.beginTime);
            if (object.endTime != null)
                message.endTime = String(object.endTime);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHoldingChangeList.C2S
         * @static
         * @param {Qot_GetHoldingChangeList.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.security = null;
                object.holderCategory = 0;
                object.beginTime = "";
                object.endTime = "";
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.holderCategory != null && message.hasOwnProperty("holderCategory"))
                object.holderCategory = message.holderCategory;
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                object.beginTime = message.beginTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetHoldingChangeList.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetHoldingChangeList.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetHoldingChangeList
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.IShareHoldingChange>|null} [holdingChangeList] S2C holdingChangeList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetHoldingChangeList
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetHoldingChangeList.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.holdingChangeList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetHoldingChangeList.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C holdingChangeList.
         * @member {Array.<Qot_Common.IShareHoldingChange>} holdingChangeList
         * @memberof Qot_GetHoldingChangeList.S2C
         * @instance
         */
        S2C.prototype.holdingChangeList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetHoldingChangeList.S2C
         * @static
         * @param {Qot_GetHoldingChangeList.IS2C=} [properties] Properties to set
         * @returns {Qot_GetHoldingChangeList.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetHoldingChangeList.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHoldingChangeList.S2C
         * @static
         * @param {Qot_GetHoldingChangeList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.holdingChangeList != null && message.holdingChangeList.length)
                for (var i = 0; i < message.holdingChangeList.length; ++i)
                    $root.Qot_Common.ShareHoldingChange.encode(message.holdingChangeList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetHoldingChangeList.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHoldingChangeList.S2C
         * @static
         * @param {Qot_GetHoldingChangeList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHoldingChangeList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHoldingChangeList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHoldingChangeList.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.holdingChangeList && message.holdingChangeList.length))
                        message.holdingChangeList = [];
                    message.holdingChangeList.push($root.Qot_Common.ShareHoldingChange.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHoldingChangeList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHoldingChangeList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetHoldingChangeList.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.holdingChangeList != null && message.hasOwnProperty("holdingChangeList")) {
                if (!Array.isArray(message.holdingChangeList))
                    return "holdingChangeList: array expected";
                for (var i = 0; i < message.holdingChangeList.length; ++i) {
                    var error = $root.Qot_Common.ShareHoldingChange.verify(message.holdingChangeList[i]);
                    if (error)
                        return "holdingChangeList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHoldingChangeList.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHoldingChangeList.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHoldingChangeList.S2C)
                return object;
            var message = new $root.Qot_GetHoldingChangeList.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetHoldingChangeList.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.holdingChangeList) {
                if (!Array.isArray(object.holdingChangeList))
                    throw TypeError(".Qot_GetHoldingChangeList.S2C.holdingChangeList: array expected");
                message.holdingChangeList = [];
                for (var i = 0; i < object.holdingChangeList.length; ++i) {
                    if (typeof object.holdingChangeList[i] !== "object")
                        throw TypeError(".Qot_GetHoldingChangeList.S2C.holdingChangeList: object expected");
                    message.holdingChangeList[i] = $root.Qot_Common.ShareHoldingChange.fromObject(object.holdingChangeList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHoldingChangeList.S2C
         * @static
         * @param {Qot_GetHoldingChangeList.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.holdingChangeList = [];
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.holdingChangeList && message.holdingChangeList.length) {
                object.holdingChangeList = [];
                for (var j = 0; j < message.holdingChangeList.length; ++j)
                    object.holdingChangeList[j] = $root.Qot_Common.ShareHoldingChange.toObject(message.holdingChangeList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetHoldingChangeList.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetHoldingChangeList.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetHoldingChangeList
         * @interface IRequest
         * @property {Qot_GetHoldingChangeList.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetHoldingChangeList
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetHoldingChangeList.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetHoldingChangeList.IC2S} c2s
         * @memberof Qot_GetHoldingChangeList.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetHoldingChangeList.Request
         * @static
         * @param {Qot_GetHoldingChangeList.IRequest=} [properties] Properties to set
         * @returns {Qot_GetHoldingChangeList.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetHoldingChangeList.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHoldingChangeList.Request
         * @static
         * @param {Qot_GetHoldingChangeList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetHoldingChangeList.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetHoldingChangeList.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHoldingChangeList.Request
         * @static
         * @param {Qot_GetHoldingChangeList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHoldingChangeList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHoldingChangeList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHoldingChangeList.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetHoldingChangeList.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHoldingChangeList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHoldingChangeList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetHoldingChangeList.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetHoldingChangeList.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHoldingChangeList.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHoldingChangeList.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHoldingChangeList.Request)
                return object;
            var message = new $root.Qot_GetHoldingChangeList.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetHoldingChangeList.Request.c2s: object expected");
                message.c2s = $root.Qot_GetHoldingChangeList.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHoldingChangeList.Request
         * @static
         * @param {Qot_GetHoldingChangeList.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetHoldingChangeList.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetHoldingChangeList.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetHoldingChangeList.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetHoldingChangeList
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetHoldingChangeList.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetHoldingChangeList
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetHoldingChangeList.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetHoldingChangeList.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetHoldingChangeList.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetHoldingChangeList.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetHoldingChangeList.IS2C|null|undefined} s2c
         * @memberof Qot_GetHoldingChangeList.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetHoldingChangeList.Response
         * @static
         * @param {Qot_GetHoldingChangeList.IResponse=} [properties] Properties to set
         * @returns {Qot_GetHoldingChangeList.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetHoldingChangeList.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHoldingChangeList.Response
         * @static
         * @param {Qot_GetHoldingChangeList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetHoldingChangeList.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetHoldingChangeList.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHoldingChangeList.Response
         * @static
         * @param {Qot_GetHoldingChangeList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHoldingChangeList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHoldingChangeList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHoldingChangeList.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetHoldingChangeList.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHoldingChangeList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHoldingChangeList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetHoldingChangeList.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetHoldingChangeList.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHoldingChangeList.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHoldingChangeList.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHoldingChangeList.Response)
                return object;
            var message = new $root.Qot_GetHoldingChangeList.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetHoldingChangeList.Response.s2c: object expected");
                message.s2c = $root.Qot_GetHoldingChangeList.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHoldingChangeList.Response
         * @static
         * @param {Qot_GetHoldingChangeList.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetHoldingChangeList.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetHoldingChangeList.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetHoldingChangeList;
})();

$root.Qot_GetIpoList = (function() {

    /**
     * Namespace Qot_GetIpoList.
     * @exports Qot_GetIpoList
     * @namespace
     */
    var Qot_GetIpoList = {};

    Qot_GetIpoList.BasicIpoData = (function() {

        /**
         * Properties of a BasicIpoData.
         * @memberof Qot_GetIpoList
         * @interface IBasicIpoData
         * @property {Qot_Common.ISecurity} security BasicIpoData security
         * @property {string} name BasicIpoData name
         * @property {string|null} [listTime] BasicIpoData listTime
         * @property {number|null} [listTimestamp] BasicIpoData listTimestamp
         */

        /**
         * Constructs a new BasicIpoData.
         * @memberof Qot_GetIpoList
         * @classdesc Represents a BasicIpoData.
         * @implements IBasicIpoData
         * @constructor
         * @param {Qot_GetIpoList.IBasicIpoData=} [properties] Properties to set
         */
        function BasicIpoData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BasicIpoData security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetIpoList.BasicIpoData
         * @instance
         */
        BasicIpoData.prototype.security = null;

        /**
         * BasicIpoData name.
         * @member {string} name
         * @memberof Qot_GetIpoList.BasicIpoData
         * @instance
         */
        BasicIpoData.prototype.name = "";

        /**
         * BasicIpoData listTime.
         * @member {string} listTime
         * @memberof Qot_GetIpoList.BasicIpoData
         * @instance
         */
        BasicIpoData.prototype.listTime = "";

        /**
         * BasicIpoData listTimestamp.
         * @member {number} listTimestamp
         * @memberof Qot_GetIpoList.BasicIpoData
         * @instance
         */
        BasicIpoData.prototype.listTimestamp = 0;

        /**
         * Creates a new BasicIpoData instance using the specified properties.
         * @function create
         * @memberof Qot_GetIpoList.BasicIpoData
         * @static
         * @param {Qot_GetIpoList.IBasicIpoData=} [properties] Properties to set
         * @returns {Qot_GetIpoList.BasicIpoData} BasicIpoData instance
         */
        BasicIpoData.create = function create(properties) {
            return new BasicIpoData(properties);
        };

        /**
         * Encodes the specified BasicIpoData message. Does not implicitly {@link Qot_GetIpoList.BasicIpoData.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetIpoList.BasicIpoData
         * @static
         * @param {Qot_GetIpoList.IBasicIpoData} message BasicIpoData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicIpoData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.listTime != null && message.hasOwnProperty("listTime"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.listTime);
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.listTimestamp);
            return writer;
        };

        /**
         * Encodes the specified BasicIpoData message, length delimited. Does not implicitly {@link Qot_GetIpoList.BasicIpoData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetIpoList.BasicIpoData
         * @static
         * @param {Qot_GetIpoList.IBasicIpoData} message BasicIpoData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicIpoData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BasicIpoData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetIpoList.BasicIpoData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetIpoList.BasicIpoData} BasicIpoData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicIpoData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetIpoList.BasicIpoData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.listTime = reader.string();
                    break;
                case 4:
                    message.listTimestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            return message;
        };

        /**
         * Decodes a BasicIpoData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetIpoList.BasicIpoData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetIpoList.BasicIpoData} BasicIpoData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicIpoData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BasicIpoData message.
         * @function verify
         * @memberof Qot_GetIpoList.BasicIpoData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BasicIpoData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (!$util.isString(message.name))
                return "name: string expected";
            if (message.listTime != null && message.hasOwnProperty("listTime"))
                if (!$util.isString(message.listTime))
                    return "listTime: string expected";
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                if (typeof message.listTimestamp !== "number")
                    return "listTimestamp: number expected";
            return null;
        };

        /**
         * Creates a BasicIpoData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetIpoList.BasicIpoData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetIpoList.BasicIpoData} BasicIpoData
         */
        BasicIpoData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetIpoList.BasicIpoData)
                return object;
            var message = new $root.Qot_GetIpoList.BasicIpoData();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetIpoList.BasicIpoData.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.listTime != null)
                message.listTime = String(object.listTime);
            if (object.listTimestamp != null)
                message.listTimestamp = Number(object.listTimestamp);
            return message;
        };

        /**
         * Creates a plain object from a BasicIpoData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetIpoList.BasicIpoData
         * @static
         * @param {Qot_GetIpoList.BasicIpoData} message BasicIpoData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BasicIpoData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.security = null;
                object.name = "";
                object.listTime = "";
                object.listTimestamp = 0;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.listTime != null && message.hasOwnProperty("listTime"))
                object.listTime = message.listTime;
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                object.listTimestamp = options.json && !isFinite(message.listTimestamp) ? String(message.listTimestamp) : message.listTimestamp;
            return object;
        };

        /**
         * Converts this BasicIpoData to JSON.
         * @function toJSON
         * @memberof Qot_GetIpoList.BasicIpoData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BasicIpoData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BasicIpoData;
    })();

    Qot_GetIpoList.CNIpoExData = (function() {

        /**
         * Properties of a CNIpoExData.
         * @memberof Qot_GetIpoList
         * @interface ICNIpoExData
         * @property {string} applyCode CNIpoExData applyCode
         * @property {number|Long} issueSize CNIpoExData issueSize
         * @property {number|Long} onlineIssueSize CNIpoExData onlineIssueSize
         * @property {number|Long} applyUpperLimit CNIpoExData applyUpperLimit
         * @property {number|Long} applyLimitMarketValue CNIpoExData applyLimitMarketValue
         * @property {boolean} isEstimateIpoPrice CNIpoExData isEstimateIpoPrice
         * @property {number} ipoPrice CNIpoExData ipoPrice
         * @property {number} industryPeRate CNIpoExData industryPeRate
         * @property {boolean} isEstimateWinningRatio CNIpoExData isEstimateWinningRatio
         * @property {number} winningRatio CNIpoExData winningRatio
         * @property {number} issuePeRate CNIpoExData issuePeRate
         * @property {string|null} [applyTime] CNIpoExData applyTime
         * @property {number|null} [applyTimestamp] CNIpoExData applyTimestamp
         * @property {string|null} [winningTime] CNIpoExData winningTime
         * @property {number|null} [winningTimestamp] CNIpoExData winningTimestamp
         * @property {boolean} isHasWon CNIpoExData isHasWon
         * @property {Array.<Qot_GetIpoList.IWinningNumData>|null} [winningNumData] CNIpoExData winningNumData
         */

        /**
         * Constructs a new CNIpoExData.
         * @memberof Qot_GetIpoList
         * @classdesc Represents a CNIpoExData.
         * @implements ICNIpoExData
         * @constructor
         * @param {Qot_GetIpoList.ICNIpoExData=} [properties] Properties to set
         */
        function CNIpoExData(properties) {
            this.winningNumData = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CNIpoExData applyCode.
         * @member {string} applyCode
         * @memberof Qot_GetIpoList.CNIpoExData
         * @instance
         */
        CNIpoExData.prototype.applyCode = "";

        /**
         * CNIpoExData issueSize.
         * @member {number|Long} issueSize
         * @memberof Qot_GetIpoList.CNIpoExData
         * @instance
         */
        CNIpoExData.prototype.issueSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CNIpoExData onlineIssueSize.
         * @member {number|Long} onlineIssueSize
         * @memberof Qot_GetIpoList.CNIpoExData
         * @instance
         */
        CNIpoExData.prototype.onlineIssueSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CNIpoExData applyUpperLimit.
         * @member {number|Long} applyUpperLimit
         * @memberof Qot_GetIpoList.CNIpoExData
         * @instance
         */
        CNIpoExData.prototype.applyUpperLimit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CNIpoExData applyLimitMarketValue.
         * @member {number|Long} applyLimitMarketValue
         * @memberof Qot_GetIpoList.CNIpoExData
         * @instance
         */
        CNIpoExData.prototype.applyLimitMarketValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CNIpoExData isEstimateIpoPrice.
         * @member {boolean} isEstimateIpoPrice
         * @memberof Qot_GetIpoList.CNIpoExData
         * @instance
         */
        CNIpoExData.prototype.isEstimateIpoPrice = false;

        /**
         * CNIpoExData ipoPrice.
         * @member {number} ipoPrice
         * @memberof Qot_GetIpoList.CNIpoExData
         * @instance
         */
        CNIpoExData.prototype.ipoPrice = 0;

        /**
         * CNIpoExData industryPeRate.
         * @member {number} industryPeRate
         * @memberof Qot_GetIpoList.CNIpoExData
         * @instance
         */
        CNIpoExData.prototype.industryPeRate = 0;

        /**
         * CNIpoExData isEstimateWinningRatio.
         * @member {boolean} isEstimateWinningRatio
         * @memberof Qot_GetIpoList.CNIpoExData
         * @instance
         */
        CNIpoExData.prototype.isEstimateWinningRatio = false;

        /**
         * CNIpoExData winningRatio.
         * @member {number} winningRatio
         * @memberof Qot_GetIpoList.CNIpoExData
         * @instance
         */
        CNIpoExData.prototype.winningRatio = 0;

        /**
         * CNIpoExData issuePeRate.
         * @member {number} issuePeRate
         * @memberof Qot_GetIpoList.CNIpoExData
         * @instance
         */
        CNIpoExData.prototype.issuePeRate = 0;

        /**
         * CNIpoExData applyTime.
         * @member {string} applyTime
         * @memberof Qot_GetIpoList.CNIpoExData
         * @instance
         */
        CNIpoExData.prototype.applyTime = "";

        /**
         * CNIpoExData applyTimestamp.
         * @member {number} applyTimestamp
         * @memberof Qot_GetIpoList.CNIpoExData
         * @instance
         */
        CNIpoExData.prototype.applyTimestamp = 0;

        /**
         * CNIpoExData winningTime.
         * @member {string} winningTime
         * @memberof Qot_GetIpoList.CNIpoExData
         * @instance
         */
        CNIpoExData.prototype.winningTime = "";

        /**
         * CNIpoExData winningTimestamp.
         * @member {number} winningTimestamp
         * @memberof Qot_GetIpoList.CNIpoExData
         * @instance
         */
        CNIpoExData.prototype.winningTimestamp = 0;

        /**
         * CNIpoExData isHasWon.
         * @member {boolean} isHasWon
         * @memberof Qot_GetIpoList.CNIpoExData
         * @instance
         */
        CNIpoExData.prototype.isHasWon = false;

        /**
         * CNIpoExData winningNumData.
         * @member {Array.<Qot_GetIpoList.IWinningNumData>} winningNumData
         * @memberof Qot_GetIpoList.CNIpoExData
         * @instance
         */
        CNIpoExData.prototype.winningNumData = $util.emptyArray;

        /**
         * Creates a new CNIpoExData instance using the specified properties.
         * @function create
         * @memberof Qot_GetIpoList.CNIpoExData
         * @static
         * @param {Qot_GetIpoList.ICNIpoExData=} [properties] Properties to set
         * @returns {Qot_GetIpoList.CNIpoExData} CNIpoExData instance
         */
        CNIpoExData.create = function create(properties) {
            return new CNIpoExData(properties);
        };

        /**
         * Encodes the specified CNIpoExData message. Does not implicitly {@link Qot_GetIpoList.CNIpoExData.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetIpoList.CNIpoExData
         * @static
         * @param {Qot_GetIpoList.ICNIpoExData} message CNIpoExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNIpoExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.applyCode);
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.issueSize);
            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.onlineIssueSize);
            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.applyUpperLimit);
            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.applyLimitMarketValue);
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isEstimateIpoPrice);
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.ipoPrice);
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.industryPeRate);
            writer.uint32(/* id 9, wireType 0 =*/72).bool(message.isEstimateWinningRatio);
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.winningRatio);
            writer.uint32(/* id 11, wireType 1 =*/89).double(message.issuePeRate);
            if (message.applyTime != null && message.hasOwnProperty("applyTime"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.applyTime);
            if (message.applyTimestamp != null && message.hasOwnProperty("applyTimestamp"))
                writer.uint32(/* id 13, wireType 1 =*/105).double(message.applyTimestamp);
            if (message.winningTime != null && message.hasOwnProperty("winningTime"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.winningTime);
            if (message.winningTimestamp != null && message.hasOwnProperty("winningTimestamp"))
                writer.uint32(/* id 15, wireType 1 =*/121).double(message.winningTimestamp);
            writer.uint32(/* id 16, wireType 0 =*/128).bool(message.isHasWon);
            if (message.winningNumData != null && message.winningNumData.length)
                for (var i = 0; i < message.winningNumData.length; ++i)
                    $root.Qot_GetIpoList.WinningNumData.encode(message.winningNumData[i], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CNIpoExData message, length delimited. Does not implicitly {@link Qot_GetIpoList.CNIpoExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetIpoList.CNIpoExData
         * @static
         * @param {Qot_GetIpoList.ICNIpoExData} message CNIpoExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNIpoExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CNIpoExData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetIpoList.CNIpoExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetIpoList.CNIpoExData} CNIpoExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNIpoExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetIpoList.CNIpoExData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.applyCode = reader.string();
                    break;
                case 2:
                    message.issueSize = reader.int64();
                    break;
                case 3:
                    message.onlineIssueSize = reader.int64();
                    break;
                case 4:
                    message.applyUpperLimit = reader.int64();
                    break;
                case 5:
                    message.applyLimitMarketValue = reader.int64();
                    break;
                case 6:
                    message.isEstimateIpoPrice = reader.bool();
                    break;
                case 7:
                    message.ipoPrice = reader.double();
                    break;
                case 8:
                    message.industryPeRate = reader.double();
                    break;
                case 9:
                    message.isEstimateWinningRatio = reader.bool();
                    break;
                case 10:
                    message.winningRatio = reader.double();
                    break;
                case 11:
                    message.issuePeRate = reader.double();
                    break;
                case 12:
                    message.applyTime = reader.string();
                    break;
                case 13:
                    message.applyTimestamp = reader.double();
                    break;
                case 14:
                    message.winningTime = reader.string();
                    break;
                case 15:
                    message.winningTimestamp = reader.double();
                    break;
                case 16:
                    message.isHasWon = reader.bool();
                    break;
                case 17:
                    if (!(message.winningNumData && message.winningNumData.length))
                        message.winningNumData = [];
                    message.winningNumData.push($root.Qot_GetIpoList.WinningNumData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("applyCode"))
                throw $util.ProtocolError("missing required 'applyCode'", { instance: message });
            if (!message.hasOwnProperty("issueSize"))
                throw $util.ProtocolError("missing required 'issueSize'", { instance: message });
            if (!message.hasOwnProperty("onlineIssueSize"))
                throw $util.ProtocolError("missing required 'onlineIssueSize'", { instance: message });
            if (!message.hasOwnProperty("applyUpperLimit"))
                throw $util.ProtocolError("missing required 'applyUpperLimit'", { instance: message });
            if (!message.hasOwnProperty("applyLimitMarketValue"))
                throw $util.ProtocolError("missing required 'applyLimitMarketValue'", { instance: message });
            if (!message.hasOwnProperty("isEstimateIpoPrice"))
                throw $util.ProtocolError("missing required 'isEstimateIpoPrice'", { instance: message });
            if (!message.hasOwnProperty("ipoPrice"))
                throw $util.ProtocolError("missing required 'ipoPrice'", { instance: message });
            if (!message.hasOwnProperty("industryPeRate"))
                throw $util.ProtocolError("missing required 'industryPeRate'", { instance: message });
            if (!message.hasOwnProperty("isEstimateWinningRatio"))
                throw $util.ProtocolError("missing required 'isEstimateWinningRatio'", { instance: message });
            if (!message.hasOwnProperty("winningRatio"))
                throw $util.ProtocolError("missing required 'winningRatio'", { instance: message });
            if (!message.hasOwnProperty("issuePeRate"))
                throw $util.ProtocolError("missing required 'issuePeRate'", { instance: message });
            if (!message.hasOwnProperty("isHasWon"))
                throw $util.ProtocolError("missing required 'isHasWon'", { instance: message });
            return message;
        };

        /**
         * Decodes a CNIpoExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetIpoList.CNIpoExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetIpoList.CNIpoExData} CNIpoExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNIpoExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CNIpoExData message.
         * @function verify
         * @memberof Qot_GetIpoList.CNIpoExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNIpoExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.applyCode))
                return "applyCode: string expected";
            if (!$util.isInteger(message.issueSize) && !(message.issueSize && $util.isInteger(message.issueSize.low) && $util.isInteger(message.issueSize.high)))
                return "issueSize: integer|Long expected";
            if (!$util.isInteger(message.onlineIssueSize) && !(message.onlineIssueSize && $util.isInteger(message.onlineIssueSize.low) && $util.isInteger(message.onlineIssueSize.high)))
                return "onlineIssueSize: integer|Long expected";
            if (!$util.isInteger(message.applyUpperLimit) && !(message.applyUpperLimit && $util.isInteger(message.applyUpperLimit.low) && $util.isInteger(message.applyUpperLimit.high)))
                return "applyUpperLimit: integer|Long expected";
            if (!$util.isInteger(message.applyLimitMarketValue) && !(message.applyLimitMarketValue && $util.isInteger(message.applyLimitMarketValue.low) && $util.isInteger(message.applyLimitMarketValue.high)))
                return "applyLimitMarketValue: integer|Long expected";
            if (typeof message.isEstimateIpoPrice !== "boolean")
                return "isEstimateIpoPrice: boolean expected";
            if (typeof message.ipoPrice !== "number")
                return "ipoPrice: number expected";
            if (typeof message.industryPeRate !== "number")
                return "industryPeRate: number expected";
            if (typeof message.isEstimateWinningRatio !== "boolean")
                return "isEstimateWinningRatio: boolean expected";
            if (typeof message.winningRatio !== "number")
                return "winningRatio: number expected";
            if (typeof message.issuePeRate !== "number")
                return "issuePeRate: number expected";
            if (message.applyTime != null && message.hasOwnProperty("applyTime"))
                if (!$util.isString(message.applyTime))
                    return "applyTime: string expected";
            if (message.applyTimestamp != null && message.hasOwnProperty("applyTimestamp"))
                if (typeof message.applyTimestamp !== "number")
                    return "applyTimestamp: number expected";
            if (message.winningTime != null && message.hasOwnProperty("winningTime"))
                if (!$util.isString(message.winningTime))
                    return "winningTime: string expected";
            if (message.winningTimestamp != null && message.hasOwnProperty("winningTimestamp"))
                if (typeof message.winningTimestamp !== "number")
                    return "winningTimestamp: number expected";
            if (typeof message.isHasWon !== "boolean")
                return "isHasWon: boolean expected";
            if (message.winningNumData != null && message.hasOwnProperty("winningNumData")) {
                if (!Array.isArray(message.winningNumData))
                    return "winningNumData: array expected";
                for (var i = 0; i < message.winningNumData.length; ++i) {
                    var error = $root.Qot_GetIpoList.WinningNumData.verify(message.winningNumData[i]);
                    if (error)
                        return "winningNumData." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CNIpoExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetIpoList.CNIpoExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetIpoList.CNIpoExData} CNIpoExData
         */
        CNIpoExData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetIpoList.CNIpoExData)
                return object;
            var message = new $root.Qot_GetIpoList.CNIpoExData();
            if (object.applyCode != null)
                message.applyCode = String(object.applyCode);
            if (object.issueSize != null)
                if ($util.Long)
                    (message.issueSize = $util.Long.fromValue(object.issueSize)).unsigned = false;
                else if (typeof object.issueSize === "string")
                    message.issueSize = parseInt(object.issueSize, 10);
                else if (typeof object.issueSize === "number")
                    message.issueSize = object.issueSize;
                else if (typeof object.issueSize === "object")
                    message.issueSize = new $util.LongBits(object.issueSize.low >>> 0, object.issueSize.high >>> 0).toNumber();
            if (object.onlineIssueSize != null)
                if ($util.Long)
                    (message.onlineIssueSize = $util.Long.fromValue(object.onlineIssueSize)).unsigned = false;
                else if (typeof object.onlineIssueSize === "string")
                    message.onlineIssueSize = parseInt(object.onlineIssueSize, 10);
                else if (typeof object.onlineIssueSize === "number")
                    message.onlineIssueSize = object.onlineIssueSize;
                else if (typeof object.onlineIssueSize === "object")
                    message.onlineIssueSize = new $util.LongBits(object.onlineIssueSize.low >>> 0, object.onlineIssueSize.high >>> 0).toNumber();
            if (object.applyUpperLimit != null)
                if ($util.Long)
                    (message.applyUpperLimit = $util.Long.fromValue(object.applyUpperLimit)).unsigned = false;
                else if (typeof object.applyUpperLimit === "string")
                    message.applyUpperLimit = parseInt(object.applyUpperLimit, 10);
                else if (typeof object.applyUpperLimit === "number")
                    message.applyUpperLimit = object.applyUpperLimit;
                else if (typeof object.applyUpperLimit === "object")
                    message.applyUpperLimit = new $util.LongBits(object.applyUpperLimit.low >>> 0, object.applyUpperLimit.high >>> 0).toNumber();
            if (object.applyLimitMarketValue != null)
                if ($util.Long)
                    (message.applyLimitMarketValue = $util.Long.fromValue(object.applyLimitMarketValue)).unsigned = false;
                else if (typeof object.applyLimitMarketValue === "string")
                    message.applyLimitMarketValue = parseInt(object.applyLimitMarketValue, 10);
                else if (typeof object.applyLimitMarketValue === "number")
                    message.applyLimitMarketValue = object.applyLimitMarketValue;
                else if (typeof object.applyLimitMarketValue === "object")
                    message.applyLimitMarketValue = new $util.LongBits(object.applyLimitMarketValue.low >>> 0, object.applyLimitMarketValue.high >>> 0).toNumber();
            if (object.isEstimateIpoPrice != null)
                message.isEstimateIpoPrice = Boolean(object.isEstimateIpoPrice);
            if (object.ipoPrice != null)
                message.ipoPrice = Number(object.ipoPrice);
            if (object.industryPeRate != null)
                message.industryPeRate = Number(object.industryPeRate);
            if (object.isEstimateWinningRatio != null)
                message.isEstimateWinningRatio = Boolean(object.isEstimateWinningRatio);
            if (object.winningRatio != null)
                message.winningRatio = Number(object.winningRatio);
            if (object.issuePeRate != null)
                message.issuePeRate = Number(object.issuePeRate);
            if (object.applyTime != null)
                message.applyTime = String(object.applyTime);
            if (object.applyTimestamp != null)
                message.applyTimestamp = Number(object.applyTimestamp);
            if (object.winningTime != null)
                message.winningTime = String(object.winningTime);
            if (object.winningTimestamp != null)
                message.winningTimestamp = Number(object.winningTimestamp);
            if (object.isHasWon != null)
                message.isHasWon = Boolean(object.isHasWon);
            if (object.winningNumData) {
                if (!Array.isArray(object.winningNumData))
                    throw TypeError(".Qot_GetIpoList.CNIpoExData.winningNumData: array expected");
                message.winningNumData = [];
                for (var i = 0; i < object.winningNumData.length; ++i) {
                    if (typeof object.winningNumData[i] !== "object")
                        throw TypeError(".Qot_GetIpoList.CNIpoExData.winningNumData: object expected");
                    message.winningNumData[i] = $root.Qot_GetIpoList.WinningNumData.fromObject(object.winningNumData[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CNIpoExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetIpoList.CNIpoExData
         * @static
         * @param {Qot_GetIpoList.CNIpoExData} message CNIpoExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNIpoExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.winningNumData = [];
            if (options.defaults) {
                object.applyCode = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.issueSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.issueSize = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.onlineIssueSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.onlineIssueSize = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.applyUpperLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.applyUpperLimit = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.applyLimitMarketValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.applyLimitMarketValue = options.longs === String ? "0" : 0;
                object.isEstimateIpoPrice = false;
                object.ipoPrice = 0;
                object.industryPeRate = 0;
                object.isEstimateWinningRatio = false;
                object.winningRatio = 0;
                object.issuePeRate = 0;
                object.applyTime = "";
                object.applyTimestamp = 0;
                object.winningTime = "";
                object.winningTimestamp = 0;
                object.isHasWon = false;
            }
            if (message.applyCode != null && message.hasOwnProperty("applyCode"))
                object.applyCode = message.applyCode;
            if (message.issueSize != null && message.hasOwnProperty("issueSize"))
                if (typeof message.issueSize === "number")
                    object.issueSize = options.longs === String ? String(message.issueSize) : message.issueSize;
                else
                    object.issueSize = options.longs === String ? $util.Long.prototype.toString.call(message.issueSize) : options.longs === Number ? new $util.LongBits(message.issueSize.low >>> 0, message.issueSize.high >>> 0).toNumber() : message.issueSize;
            if (message.onlineIssueSize != null && message.hasOwnProperty("onlineIssueSize"))
                if (typeof message.onlineIssueSize === "number")
                    object.onlineIssueSize = options.longs === String ? String(message.onlineIssueSize) : message.onlineIssueSize;
                else
                    object.onlineIssueSize = options.longs === String ? $util.Long.prototype.toString.call(message.onlineIssueSize) : options.longs === Number ? new $util.LongBits(message.onlineIssueSize.low >>> 0, message.onlineIssueSize.high >>> 0).toNumber() : message.onlineIssueSize;
            if (message.applyUpperLimit != null && message.hasOwnProperty("applyUpperLimit"))
                if (typeof message.applyUpperLimit === "number")
                    object.applyUpperLimit = options.longs === String ? String(message.applyUpperLimit) : message.applyUpperLimit;
                else
                    object.applyUpperLimit = options.longs === String ? $util.Long.prototype.toString.call(message.applyUpperLimit) : options.longs === Number ? new $util.LongBits(message.applyUpperLimit.low >>> 0, message.applyUpperLimit.high >>> 0).toNumber() : message.applyUpperLimit;
            if (message.applyLimitMarketValue != null && message.hasOwnProperty("applyLimitMarketValue"))
                if (typeof message.applyLimitMarketValue === "number")
                    object.applyLimitMarketValue = options.longs === String ? String(message.applyLimitMarketValue) : message.applyLimitMarketValue;
                else
                    object.applyLimitMarketValue = options.longs === String ? $util.Long.prototype.toString.call(message.applyLimitMarketValue) : options.longs === Number ? new $util.LongBits(message.applyLimitMarketValue.low >>> 0, message.applyLimitMarketValue.high >>> 0).toNumber() : message.applyLimitMarketValue;
            if (message.isEstimateIpoPrice != null && message.hasOwnProperty("isEstimateIpoPrice"))
                object.isEstimateIpoPrice = message.isEstimateIpoPrice;
            if (message.ipoPrice != null && message.hasOwnProperty("ipoPrice"))
                object.ipoPrice = options.json && !isFinite(message.ipoPrice) ? String(message.ipoPrice) : message.ipoPrice;
            if (message.industryPeRate != null && message.hasOwnProperty("industryPeRate"))
                object.industryPeRate = options.json && !isFinite(message.industryPeRate) ? String(message.industryPeRate) : message.industryPeRate;
            if (message.isEstimateWinningRatio != null && message.hasOwnProperty("isEstimateWinningRatio"))
                object.isEstimateWinningRatio = message.isEstimateWinningRatio;
            if (message.winningRatio != null && message.hasOwnProperty("winningRatio"))
                object.winningRatio = options.json && !isFinite(message.winningRatio) ? String(message.winningRatio) : message.winningRatio;
            if (message.issuePeRate != null && message.hasOwnProperty("issuePeRate"))
                object.issuePeRate = options.json && !isFinite(message.issuePeRate) ? String(message.issuePeRate) : message.issuePeRate;
            if (message.applyTime != null && message.hasOwnProperty("applyTime"))
                object.applyTime = message.applyTime;
            if (message.applyTimestamp != null && message.hasOwnProperty("applyTimestamp"))
                object.applyTimestamp = options.json && !isFinite(message.applyTimestamp) ? String(message.applyTimestamp) : message.applyTimestamp;
            if (message.winningTime != null && message.hasOwnProperty("winningTime"))
                object.winningTime = message.winningTime;
            if (message.winningTimestamp != null && message.hasOwnProperty("winningTimestamp"))
                object.winningTimestamp = options.json && !isFinite(message.winningTimestamp) ? String(message.winningTimestamp) : message.winningTimestamp;
            if (message.isHasWon != null && message.hasOwnProperty("isHasWon"))
                object.isHasWon = message.isHasWon;
            if (message.winningNumData && message.winningNumData.length) {
                object.winningNumData = [];
                for (var j = 0; j < message.winningNumData.length; ++j)
                    object.winningNumData[j] = $root.Qot_GetIpoList.WinningNumData.toObject(message.winningNumData[j], options);
            }
            return object;
        };

        /**
         * Converts this CNIpoExData to JSON.
         * @function toJSON
         * @memberof Qot_GetIpoList.CNIpoExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNIpoExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CNIpoExData;
    })();

    Qot_GetIpoList.WinningNumData = (function() {

        /**
         * Properties of a WinningNumData.
         * @memberof Qot_GetIpoList
         * @interface IWinningNumData
         * @property {string} winningName WinningNumData winningName
         * @property {string} winningInfo WinningNumData winningInfo
         */

        /**
         * Constructs a new WinningNumData.
         * @memberof Qot_GetIpoList
         * @classdesc Represents a WinningNumData.
         * @implements IWinningNumData
         * @constructor
         * @param {Qot_GetIpoList.IWinningNumData=} [properties] Properties to set
         */
        function WinningNumData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WinningNumData winningName.
         * @member {string} winningName
         * @memberof Qot_GetIpoList.WinningNumData
         * @instance
         */
        WinningNumData.prototype.winningName = "";

        /**
         * WinningNumData winningInfo.
         * @member {string} winningInfo
         * @memberof Qot_GetIpoList.WinningNumData
         * @instance
         */
        WinningNumData.prototype.winningInfo = "";

        /**
         * Creates a new WinningNumData instance using the specified properties.
         * @function create
         * @memberof Qot_GetIpoList.WinningNumData
         * @static
         * @param {Qot_GetIpoList.IWinningNumData=} [properties] Properties to set
         * @returns {Qot_GetIpoList.WinningNumData} WinningNumData instance
         */
        WinningNumData.create = function create(properties) {
            return new WinningNumData(properties);
        };

        /**
         * Encodes the specified WinningNumData message. Does not implicitly {@link Qot_GetIpoList.WinningNumData.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetIpoList.WinningNumData
         * @static
         * @param {Qot_GetIpoList.IWinningNumData} message WinningNumData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WinningNumData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.winningName);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.winningInfo);
            return writer;
        };

        /**
         * Encodes the specified WinningNumData message, length delimited. Does not implicitly {@link Qot_GetIpoList.WinningNumData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetIpoList.WinningNumData
         * @static
         * @param {Qot_GetIpoList.IWinningNumData} message WinningNumData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WinningNumData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WinningNumData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetIpoList.WinningNumData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetIpoList.WinningNumData} WinningNumData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WinningNumData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetIpoList.WinningNumData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.winningName = reader.string();
                    break;
                case 2:
                    message.winningInfo = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("winningName"))
                throw $util.ProtocolError("missing required 'winningName'", { instance: message });
            if (!message.hasOwnProperty("winningInfo"))
                throw $util.ProtocolError("missing required 'winningInfo'", { instance: message });
            return message;
        };

        /**
         * Decodes a WinningNumData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetIpoList.WinningNumData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetIpoList.WinningNumData} WinningNumData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WinningNumData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WinningNumData message.
         * @function verify
         * @memberof Qot_GetIpoList.WinningNumData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WinningNumData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.winningName))
                return "winningName: string expected";
            if (!$util.isString(message.winningInfo))
                return "winningInfo: string expected";
            return null;
        };

        /**
         * Creates a WinningNumData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetIpoList.WinningNumData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetIpoList.WinningNumData} WinningNumData
         */
        WinningNumData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetIpoList.WinningNumData)
                return object;
            var message = new $root.Qot_GetIpoList.WinningNumData();
            if (object.winningName != null)
                message.winningName = String(object.winningName);
            if (object.winningInfo != null)
                message.winningInfo = String(object.winningInfo);
            return message;
        };

        /**
         * Creates a plain object from a WinningNumData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetIpoList.WinningNumData
         * @static
         * @param {Qot_GetIpoList.WinningNumData} message WinningNumData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WinningNumData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.winningName = "";
                object.winningInfo = "";
            }
            if (message.winningName != null && message.hasOwnProperty("winningName"))
                object.winningName = message.winningName;
            if (message.winningInfo != null && message.hasOwnProperty("winningInfo"))
                object.winningInfo = message.winningInfo;
            return object;
        };

        /**
         * Converts this WinningNumData to JSON.
         * @function toJSON
         * @memberof Qot_GetIpoList.WinningNumData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WinningNumData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WinningNumData;
    })();

    Qot_GetIpoList.HKIpoExData = (function() {

        /**
         * Properties of a HKIpoExData.
         * @memberof Qot_GetIpoList
         * @interface IHKIpoExData
         * @property {number} ipoPriceMin HKIpoExData ipoPriceMin
         * @property {number} ipoPriceMax HKIpoExData ipoPriceMax
         * @property {number} listPrice HKIpoExData listPrice
         * @property {number} lotSize HKIpoExData lotSize
         * @property {number} entrancePrice HKIpoExData entrancePrice
         * @property {boolean} isSubscribeStatus HKIpoExData isSubscribeStatus
         * @property {string|null} [applyEndTime] HKIpoExData applyEndTime
         * @property {number|null} [applyEndTimestamp] HKIpoExData applyEndTimestamp
         */

        /**
         * Constructs a new HKIpoExData.
         * @memberof Qot_GetIpoList
         * @classdesc Represents a HKIpoExData.
         * @implements IHKIpoExData
         * @constructor
         * @param {Qot_GetIpoList.IHKIpoExData=} [properties] Properties to set
         */
        function HKIpoExData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HKIpoExData ipoPriceMin.
         * @member {number} ipoPriceMin
         * @memberof Qot_GetIpoList.HKIpoExData
         * @instance
         */
        HKIpoExData.prototype.ipoPriceMin = 0;

        /**
         * HKIpoExData ipoPriceMax.
         * @member {number} ipoPriceMax
         * @memberof Qot_GetIpoList.HKIpoExData
         * @instance
         */
        HKIpoExData.prototype.ipoPriceMax = 0;

        /**
         * HKIpoExData listPrice.
         * @member {number} listPrice
         * @memberof Qot_GetIpoList.HKIpoExData
         * @instance
         */
        HKIpoExData.prototype.listPrice = 0;

        /**
         * HKIpoExData lotSize.
         * @member {number} lotSize
         * @memberof Qot_GetIpoList.HKIpoExData
         * @instance
         */
        HKIpoExData.prototype.lotSize = 0;

        /**
         * HKIpoExData entrancePrice.
         * @member {number} entrancePrice
         * @memberof Qot_GetIpoList.HKIpoExData
         * @instance
         */
        HKIpoExData.prototype.entrancePrice = 0;

        /**
         * HKIpoExData isSubscribeStatus.
         * @member {boolean} isSubscribeStatus
         * @memberof Qot_GetIpoList.HKIpoExData
         * @instance
         */
        HKIpoExData.prototype.isSubscribeStatus = false;

        /**
         * HKIpoExData applyEndTime.
         * @member {string} applyEndTime
         * @memberof Qot_GetIpoList.HKIpoExData
         * @instance
         */
        HKIpoExData.prototype.applyEndTime = "";

        /**
         * HKIpoExData applyEndTimestamp.
         * @member {number} applyEndTimestamp
         * @memberof Qot_GetIpoList.HKIpoExData
         * @instance
         */
        HKIpoExData.prototype.applyEndTimestamp = 0;

        /**
         * Creates a new HKIpoExData instance using the specified properties.
         * @function create
         * @memberof Qot_GetIpoList.HKIpoExData
         * @static
         * @param {Qot_GetIpoList.IHKIpoExData=} [properties] Properties to set
         * @returns {Qot_GetIpoList.HKIpoExData} HKIpoExData instance
         */
        HKIpoExData.create = function create(properties) {
            return new HKIpoExData(properties);
        };

        /**
         * Encodes the specified HKIpoExData message. Does not implicitly {@link Qot_GetIpoList.HKIpoExData.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetIpoList.HKIpoExData
         * @static
         * @param {Qot_GetIpoList.IHKIpoExData} message HKIpoExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HKIpoExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.ipoPriceMin);
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.ipoPriceMax);
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.listPrice);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.lotSize);
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.entrancePrice);
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isSubscribeStatus);
            if (message.applyEndTime != null && message.hasOwnProperty("applyEndTime"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.applyEndTime);
            if (message.applyEndTimestamp != null && message.hasOwnProperty("applyEndTimestamp"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.applyEndTimestamp);
            return writer;
        };

        /**
         * Encodes the specified HKIpoExData message, length delimited. Does not implicitly {@link Qot_GetIpoList.HKIpoExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetIpoList.HKIpoExData
         * @static
         * @param {Qot_GetIpoList.IHKIpoExData} message HKIpoExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HKIpoExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HKIpoExData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetIpoList.HKIpoExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetIpoList.HKIpoExData} HKIpoExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HKIpoExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetIpoList.HKIpoExData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ipoPriceMin = reader.double();
                    break;
                case 2:
                    message.ipoPriceMax = reader.double();
                    break;
                case 3:
                    message.listPrice = reader.double();
                    break;
                case 4:
                    message.lotSize = reader.int32();
                    break;
                case 5:
                    message.entrancePrice = reader.double();
                    break;
                case 6:
                    message.isSubscribeStatus = reader.bool();
                    break;
                case 7:
                    message.applyEndTime = reader.string();
                    break;
                case 8:
                    message.applyEndTimestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("ipoPriceMin"))
                throw $util.ProtocolError("missing required 'ipoPriceMin'", { instance: message });
            if (!message.hasOwnProperty("ipoPriceMax"))
                throw $util.ProtocolError("missing required 'ipoPriceMax'", { instance: message });
            if (!message.hasOwnProperty("listPrice"))
                throw $util.ProtocolError("missing required 'listPrice'", { instance: message });
            if (!message.hasOwnProperty("lotSize"))
                throw $util.ProtocolError("missing required 'lotSize'", { instance: message });
            if (!message.hasOwnProperty("entrancePrice"))
                throw $util.ProtocolError("missing required 'entrancePrice'", { instance: message });
            if (!message.hasOwnProperty("isSubscribeStatus"))
                throw $util.ProtocolError("missing required 'isSubscribeStatus'", { instance: message });
            return message;
        };

        /**
         * Decodes a HKIpoExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetIpoList.HKIpoExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetIpoList.HKIpoExData} HKIpoExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HKIpoExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HKIpoExData message.
         * @function verify
         * @memberof Qot_GetIpoList.HKIpoExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HKIpoExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.ipoPriceMin !== "number")
                return "ipoPriceMin: number expected";
            if (typeof message.ipoPriceMax !== "number")
                return "ipoPriceMax: number expected";
            if (typeof message.listPrice !== "number")
                return "listPrice: number expected";
            if (!$util.isInteger(message.lotSize))
                return "lotSize: integer expected";
            if (typeof message.entrancePrice !== "number")
                return "entrancePrice: number expected";
            if (typeof message.isSubscribeStatus !== "boolean")
                return "isSubscribeStatus: boolean expected";
            if (message.applyEndTime != null && message.hasOwnProperty("applyEndTime"))
                if (!$util.isString(message.applyEndTime))
                    return "applyEndTime: string expected";
            if (message.applyEndTimestamp != null && message.hasOwnProperty("applyEndTimestamp"))
                if (typeof message.applyEndTimestamp !== "number")
                    return "applyEndTimestamp: number expected";
            return null;
        };

        /**
         * Creates a HKIpoExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetIpoList.HKIpoExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetIpoList.HKIpoExData} HKIpoExData
         */
        HKIpoExData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetIpoList.HKIpoExData)
                return object;
            var message = new $root.Qot_GetIpoList.HKIpoExData();
            if (object.ipoPriceMin != null)
                message.ipoPriceMin = Number(object.ipoPriceMin);
            if (object.ipoPriceMax != null)
                message.ipoPriceMax = Number(object.ipoPriceMax);
            if (object.listPrice != null)
                message.listPrice = Number(object.listPrice);
            if (object.lotSize != null)
                message.lotSize = object.lotSize | 0;
            if (object.entrancePrice != null)
                message.entrancePrice = Number(object.entrancePrice);
            if (object.isSubscribeStatus != null)
                message.isSubscribeStatus = Boolean(object.isSubscribeStatus);
            if (object.applyEndTime != null)
                message.applyEndTime = String(object.applyEndTime);
            if (object.applyEndTimestamp != null)
                message.applyEndTimestamp = Number(object.applyEndTimestamp);
            return message;
        };

        /**
         * Creates a plain object from a HKIpoExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetIpoList.HKIpoExData
         * @static
         * @param {Qot_GetIpoList.HKIpoExData} message HKIpoExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HKIpoExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.ipoPriceMin = 0;
                object.ipoPriceMax = 0;
                object.listPrice = 0;
                object.lotSize = 0;
                object.entrancePrice = 0;
                object.isSubscribeStatus = false;
                object.applyEndTime = "";
                object.applyEndTimestamp = 0;
            }
            if (message.ipoPriceMin != null && message.hasOwnProperty("ipoPriceMin"))
                object.ipoPriceMin = options.json && !isFinite(message.ipoPriceMin) ? String(message.ipoPriceMin) : message.ipoPriceMin;
            if (message.ipoPriceMax != null && message.hasOwnProperty("ipoPriceMax"))
                object.ipoPriceMax = options.json && !isFinite(message.ipoPriceMax) ? String(message.ipoPriceMax) : message.ipoPriceMax;
            if (message.listPrice != null && message.hasOwnProperty("listPrice"))
                object.listPrice = options.json && !isFinite(message.listPrice) ? String(message.listPrice) : message.listPrice;
            if (message.lotSize != null && message.hasOwnProperty("lotSize"))
                object.lotSize = message.lotSize;
            if (message.entrancePrice != null && message.hasOwnProperty("entrancePrice"))
                object.entrancePrice = options.json && !isFinite(message.entrancePrice) ? String(message.entrancePrice) : message.entrancePrice;
            if (message.isSubscribeStatus != null && message.hasOwnProperty("isSubscribeStatus"))
                object.isSubscribeStatus = message.isSubscribeStatus;
            if (message.applyEndTime != null && message.hasOwnProperty("applyEndTime"))
                object.applyEndTime = message.applyEndTime;
            if (message.applyEndTimestamp != null && message.hasOwnProperty("applyEndTimestamp"))
                object.applyEndTimestamp = options.json && !isFinite(message.applyEndTimestamp) ? String(message.applyEndTimestamp) : message.applyEndTimestamp;
            return object;
        };

        /**
         * Converts this HKIpoExData to JSON.
         * @function toJSON
         * @memberof Qot_GetIpoList.HKIpoExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HKIpoExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HKIpoExData;
    })();

    Qot_GetIpoList.USIpoExData = (function() {

        /**
         * Properties of a USIpoExData.
         * @memberof Qot_GetIpoList
         * @interface IUSIpoExData
         * @property {number} ipoPriceMin USIpoExData ipoPriceMin
         * @property {number} ipoPriceMax USIpoExData ipoPriceMax
         * @property {number|Long} issueSize USIpoExData issueSize
         */

        /**
         * Constructs a new USIpoExData.
         * @memberof Qot_GetIpoList
         * @classdesc Represents a USIpoExData.
         * @implements IUSIpoExData
         * @constructor
         * @param {Qot_GetIpoList.IUSIpoExData=} [properties] Properties to set
         */
        function USIpoExData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * USIpoExData ipoPriceMin.
         * @member {number} ipoPriceMin
         * @memberof Qot_GetIpoList.USIpoExData
         * @instance
         */
        USIpoExData.prototype.ipoPriceMin = 0;

        /**
         * USIpoExData ipoPriceMax.
         * @member {number} ipoPriceMax
         * @memberof Qot_GetIpoList.USIpoExData
         * @instance
         */
        USIpoExData.prototype.ipoPriceMax = 0;

        /**
         * USIpoExData issueSize.
         * @member {number|Long} issueSize
         * @memberof Qot_GetIpoList.USIpoExData
         * @instance
         */
        USIpoExData.prototype.issueSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new USIpoExData instance using the specified properties.
         * @function create
         * @memberof Qot_GetIpoList.USIpoExData
         * @static
         * @param {Qot_GetIpoList.IUSIpoExData=} [properties] Properties to set
         * @returns {Qot_GetIpoList.USIpoExData} USIpoExData instance
         */
        USIpoExData.create = function create(properties) {
            return new USIpoExData(properties);
        };

        /**
         * Encodes the specified USIpoExData message. Does not implicitly {@link Qot_GetIpoList.USIpoExData.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetIpoList.USIpoExData
         * @static
         * @param {Qot_GetIpoList.IUSIpoExData} message USIpoExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        USIpoExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.ipoPriceMin);
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.ipoPriceMax);
            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.issueSize);
            return writer;
        };

        /**
         * Encodes the specified USIpoExData message, length delimited. Does not implicitly {@link Qot_GetIpoList.USIpoExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetIpoList.USIpoExData
         * @static
         * @param {Qot_GetIpoList.IUSIpoExData} message USIpoExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        USIpoExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a USIpoExData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetIpoList.USIpoExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetIpoList.USIpoExData} USIpoExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        USIpoExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetIpoList.USIpoExData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ipoPriceMin = reader.double();
                    break;
                case 2:
                    message.ipoPriceMax = reader.double();
                    break;
                case 3:
                    message.issueSize = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("ipoPriceMin"))
                throw $util.ProtocolError("missing required 'ipoPriceMin'", { instance: message });
            if (!message.hasOwnProperty("ipoPriceMax"))
                throw $util.ProtocolError("missing required 'ipoPriceMax'", { instance: message });
            if (!message.hasOwnProperty("issueSize"))
                throw $util.ProtocolError("missing required 'issueSize'", { instance: message });
            return message;
        };

        /**
         * Decodes a USIpoExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetIpoList.USIpoExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetIpoList.USIpoExData} USIpoExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        USIpoExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a USIpoExData message.
         * @function verify
         * @memberof Qot_GetIpoList.USIpoExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        USIpoExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.ipoPriceMin !== "number")
                return "ipoPriceMin: number expected";
            if (typeof message.ipoPriceMax !== "number")
                return "ipoPriceMax: number expected";
            if (!$util.isInteger(message.issueSize) && !(message.issueSize && $util.isInteger(message.issueSize.low) && $util.isInteger(message.issueSize.high)))
                return "issueSize: integer|Long expected";
            return null;
        };

        /**
         * Creates a USIpoExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetIpoList.USIpoExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetIpoList.USIpoExData} USIpoExData
         */
        USIpoExData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetIpoList.USIpoExData)
                return object;
            var message = new $root.Qot_GetIpoList.USIpoExData();
            if (object.ipoPriceMin != null)
                message.ipoPriceMin = Number(object.ipoPriceMin);
            if (object.ipoPriceMax != null)
                message.ipoPriceMax = Number(object.ipoPriceMax);
            if (object.issueSize != null)
                if ($util.Long)
                    (message.issueSize = $util.Long.fromValue(object.issueSize)).unsigned = false;
                else if (typeof object.issueSize === "string")
                    message.issueSize = parseInt(object.issueSize, 10);
                else if (typeof object.issueSize === "number")
                    message.issueSize = object.issueSize;
                else if (typeof object.issueSize === "object")
                    message.issueSize = new $util.LongBits(object.issueSize.low >>> 0, object.issueSize.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a USIpoExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetIpoList.USIpoExData
         * @static
         * @param {Qot_GetIpoList.USIpoExData} message USIpoExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        USIpoExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.ipoPriceMin = 0;
                object.ipoPriceMax = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.issueSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.issueSize = options.longs === String ? "0" : 0;
            }
            if (message.ipoPriceMin != null && message.hasOwnProperty("ipoPriceMin"))
                object.ipoPriceMin = options.json && !isFinite(message.ipoPriceMin) ? String(message.ipoPriceMin) : message.ipoPriceMin;
            if (message.ipoPriceMax != null && message.hasOwnProperty("ipoPriceMax"))
                object.ipoPriceMax = options.json && !isFinite(message.ipoPriceMax) ? String(message.ipoPriceMax) : message.ipoPriceMax;
            if (message.issueSize != null && message.hasOwnProperty("issueSize"))
                if (typeof message.issueSize === "number")
                    object.issueSize = options.longs === String ? String(message.issueSize) : message.issueSize;
                else
                    object.issueSize = options.longs === String ? $util.Long.prototype.toString.call(message.issueSize) : options.longs === Number ? new $util.LongBits(message.issueSize.low >>> 0, message.issueSize.high >>> 0).toNumber() : message.issueSize;
            return object;
        };

        /**
         * Converts this USIpoExData to JSON.
         * @function toJSON
         * @memberof Qot_GetIpoList.USIpoExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        USIpoExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return USIpoExData;
    })();

    Qot_GetIpoList.IpoData = (function() {

        /**
         * Properties of an IpoData.
         * @memberof Qot_GetIpoList
         * @interface IIpoData
         * @property {Qot_GetIpoList.IBasicIpoData} basic IpoData basic
         * @property {Qot_GetIpoList.ICNIpoExData|null} [cnExData] IpoData cnExData
         * @property {Qot_GetIpoList.IHKIpoExData|null} [hkExData] IpoData hkExData
         * @property {Qot_GetIpoList.IUSIpoExData|null} [usExData] IpoData usExData
         */

        /**
         * Constructs a new IpoData.
         * @memberof Qot_GetIpoList
         * @classdesc Represents an IpoData.
         * @implements IIpoData
         * @constructor
         * @param {Qot_GetIpoList.IIpoData=} [properties] Properties to set
         */
        function IpoData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IpoData basic.
         * @member {Qot_GetIpoList.IBasicIpoData} basic
         * @memberof Qot_GetIpoList.IpoData
         * @instance
         */
        IpoData.prototype.basic = null;

        /**
         * IpoData cnExData.
         * @member {Qot_GetIpoList.ICNIpoExData|null|undefined} cnExData
         * @memberof Qot_GetIpoList.IpoData
         * @instance
         */
        IpoData.prototype.cnExData = null;

        /**
         * IpoData hkExData.
         * @member {Qot_GetIpoList.IHKIpoExData|null|undefined} hkExData
         * @memberof Qot_GetIpoList.IpoData
         * @instance
         */
        IpoData.prototype.hkExData = null;

        /**
         * IpoData usExData.
         * @member {Qot_GetIpoList.IUSIpoExData|null|undefined} usExData
         * @memberof Qot_GetIpoList.IpoData
         * @instance
         */
        IpoData.prototype.usExData = null;

        /**
         * Creates a new IpoData instance using the specified properties.
         * @function create
         * @memberof Qot_GetIpoList.IpoData
         * @static
         * @param {Qot_GetIpoList.IIpoData=} [properties] Properties to set
         * @returns {Qot_GetIpoList.IpoData} IpoData instance
         */
        IpoData.create = function create(properties) {
            return new IpoData(properties);
        };

        /**
         * Encodes the specified IpoData message. Does not implicitly {@link Qot_GetIpoList.IpoData.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetIpoList.IpoData
         * @static
         * @param {Qot_GetIpoList.IIpoData} message IpoData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IpoData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetIpoList.BasicIpoData.encode(message.basic, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.cnExData != null && message.hasOwnProperty("cnExData"))
                $root.Qot_GetIpoList.CNIpoExData.encode(message.cnExData, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.hkExData != null && message.hasOwnProperty("hkExData"))
                $root.Qot_GetIpoList.HKIpoExData.encode(message.hkExData, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.usExData != null && message.hasOwnProperty("usExData"))
                $root.Qot_GetIpoList.USIpoExData.encode(message.usExData, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IpoData message, length delimited. Does not implicitly {@link Qot_GetIpoList.IpoData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetIpoList.IpoData
         * @static
         * @param {Qot_GetIpoList.IIpoData} message IpoData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IpoData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IpoData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetIpoList.IpoData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetIpoList.IpoData} IpoData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IpoData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetIpoList.IpoData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.basic = $root.Qot_GetIpoList.BasicIpoData.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.cnExData = $root.Qot_GetIpoList.CNIpoExData.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.hkExData = $root.Qot_GetIpoList.HKIpoExData.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.usExData = $root.Qot_GetIpoList.USIpoExData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("basic"))
                throw $util.ProtocolError("missing required 'basic'", { instance: message });
            return message;
        };

        /**
         * Decodes an IpoData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetIpoList.IpoData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetIpoList.IpoData} IpoData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IpoData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IpoData message.
         * @function verify
         * @memberof Qot_GetIpoList.IpoData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IpoData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetIpoList.BasicIpoData.verify(message.basic);
                if (error)
                    return "basic." + error;
            }
            if (message.cnExData != null && message.hasOwnProperty("cnExData")) {
                var error = $root.Qot_GetIpoList.CNIpoExData.verify(message.cnExData);
                if (error)
                    return "cnExData." + error;
            }
            if (message.hkExData != null && message.hasOwnProperty("hkExData")) {
                var error = $root.Qot_GetIpoList.HKIpoExData.verify(message.hkExData);
                if (error)
                    return "hkExData." + error;
            }
            if (message.usExData != null && message.hasOwnProperty("usExData")) {
                var error = $root.Qot_GetIpoList.USIpoExData.verify(message.usExData);
                if (error)
                    return "usExData." + error;
            }
            return null;
        };

        /**
         * Creates an IpoData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetIpoList.IpoData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetIpoList.IpoData} IpoData
         */
        IpoData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetIpoList.IpoData)
                return object;
            var message = new $root.Qot_GetIpoList.IpoData();
            if (object.basic != null) {
                if (typeof object.basic !== "object")
                    throw TypeError(".Qot_GetIpoList.IpoData.basic: object expected");
                message.basic = $root.Qot_GetIpoList.BasicIpoData.fromObject(object.basic);
            }
            if (object.cnExData != null) {
                if (typeof object.cnExData !== "object")
                    throw TypeError(".Qot_GetIpoList.IpoData.cnExData: object expected");
                message.cnExData = $root.Qot_GetIpoList.CNIpoExData.fromObject(object.cnExData);
            }
            if (object.hkExData != null) {
                if (typeof object.hkExData !== "object")
                    throw TypeError(".Qot_GetIpoList.IpoData.hkExData: object expected");
                message.hkExData = $root.Qot_GetIpoList.HKIpoExData.fromObject(object.hkExData);
            }
            if (object.usExData != null) {
                if (typeof object.usExData !== "object")
                    throw TypeError(".Qot_GetIpoList.IpoData.usExData: object expected");
                message.usExData = $root.Qot_GetIpoList.USIpoExData.fromObject(object.usExData);
            }
            return message;
        };

        /**
         * Creates a plain object from an IpoData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetIpoList.IpoData
         * @static
         * @param {Qot_GetIpoList.IpoData} message IpoData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IpoData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.basic = null;
                object.cnExData = null;
                object.hkExData = null;
                object.usExData = null;
            }
            if (message.basic != null && message.hasOwnProperty("basic"))
                object.basic = $root.Qot_GetIpoList.BasicIpoData.toObject(message.basic, options);
            if (message.cnExData != null && message.hasOwnProperty("cnExData"))
                object.cnExData = $root.Qot_GetIpoList.CNIpoExData.toObject(message.cnExData, options);
            if (message.hkExData != null && message.hasOwnProperty("hkExData"))
                object.hkExData = $root.Qot_GetIpoList.HKIpoExData.toObject(message.hkExData, options);
            if (message.usExData != null && message.hasOwnProperty("usExData"))
                object.usExData = $root.Qot_GetIpoList.USIpoExData.toObject(message.usExData, options);
            return object;
        };

        /**
         * Converts this IpoData to JSON.
         * @function toJSON
         * @memberof Qot_GetIpoList.IpoData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IpoData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IpoData;
    })();

    Qot_GetIpoList.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetIpoList
         * @interface IC2S
         * @property {number} market C2S market
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetIpoList
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetIpoList.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S market.
         * @member {number} market
         * @memberof Qot_GetIpoList.C2S
         * @instance
         */
        C2S.prototype.market = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetIpoList.C2S
         * @static
         * @param {Qot_GetIpoList.IC2S=} [properties] Properties to set
         * @returns {Qot_GetIpoList.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetIpoList.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetIpoList.C2S
         * @static
         * @param {Qot_GetIpoList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.market);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetIpoList.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetIpoList.C2S
         * @static
         * @param {Qot_GetIpoList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetIpoList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetIpoList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetIpoList.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.market = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("market"))
                throw $util.ProtocolError("missing required 'market'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetIpoList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetIpoList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetIpoList.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.market))
                return "market: integer expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetIpoList.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetIpoList.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetIpoList.C2S)
                return object;
            var message = new $root.Qot_GetIpoList.C2S();
            if (object.market != null)
                message.market = object.market | 0;
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetIpoList.C2S
         * @static
         * @param {Qot_GetIpoList.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.market = 0;
            if (message.market != null && message.hasOwnProperty("market"))
                object.market = message.market;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetIpoList.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetIpoList.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetIpoList
         * @interface IS2C
         * @property {Array.<Qot_GetIpoList.IIpoData>|null} [ipoList] S2C ipoList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetIpoList
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetIpoList.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.ipoList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C ipoList.
         * @member {Array.<Qot_GetIpoList.IIpoData>} ipoList
         * @memberof Qot_GetIpoList.S2C
         * @instance
         */
        S2C.prototype.ipoList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetIpoList.S2C
         * @static
         * @param {Qot_GetIpoList.IS2C=} [properties] Properties to set
         * @returns {Qot_GetIpoList.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetIpoList.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetIpoList.S2C
         * @static
         * @param {Qot_GetIpoList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ipoList != null && message.ipoList.length)
                for (var i = 0; i < message.ipoList.length; ++i)
                    $root.Qot_GetIpoList.IpoData.encode(message.ipoList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetIpoList.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetIpoList.S2C
         * @static
         * @param {Qot_GetIpoList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetIpoList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetIpoList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetIpoList.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ipoList && message.ipoList.length))
                        message.ipoList = [];
                    message.ipoList.push($root.Qot_GetIpoList.IpoData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetIpoList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetIpoList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetIpoList.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ipoList != null && message.hasOwnProperty("ipoList")) {
                if (!Array.isArray(message.ipoList))
                    return "ipoList: array expected";
                for (var i = 0; i < message.ipoList.length; ++i) {
                    var error = $root.Qot_GetIpoList.IpoData.verify(message.ipoList[i]);
                    if (error)
                        return "ipoList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetIpoList.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetIpoList.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetIpoList.S2C)
                return object;
            var message = new $root.Qot_GetIpoList.S2C();
            if (object.ipoList) {
                if (!Array.isArray(object.ipoList))
                    throw TypeError(".Qot_GetIpoList.S2C.ipoList: array expected");
                message.ipoList = [];
                for (var i = 0; i < object.ipoList.length; ++i) {
                    if (typeof object.ipoList[i] !== "object")
                        throw TypeError(".Qot_GetIpoList.S2C.ipoList: object expected");
                    message.ipoList[i] = $root.Qot_GetIpoList.IpoData.fromObject(object.ipoList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetIpoList.S2C
         * @static
         * @param {Qot_GetIpoList.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ipoList = [];
            if (message.ipoList && message.ipoList.length) {
                object.ipoList = [];
                for (var j = 0; j < message.ipoList.length; ++j)
                    object.ipoList[j] = $root.Qot_GetIpoList.IpoData.toObject(message.ipoList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetIpoList.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetIpoList.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetIpoList
         * @interface IRequest
         * @property {Qot_GetIpoList.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetIpoList
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetIpoList.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetIpoList.IC2S} c2s
         * @memberof Qot_GetIpoList.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetIpoList.Request
         * @static
         * @param {Qot_GetIpoList.IRequest=} [properties] Properties to set
         * @returns {Qot_GetIpoList.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetIpoList.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetIpoList.Request
         * @static
         * @param {Qot_GetIpoList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetIpoList.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetIpoList.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetIpoList.Request
         * @static
         * @param {Qot_GetIpoList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetIpoList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetIpoList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetIpoList.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetIpoList.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetIpoList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetIpoList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetIpoList.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetIpoList.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetIpoList.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetIpoList.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetIpoList.Request)
                return object;
            var message = new $root.Qot_GetIpoList.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetIpoList.Request.c2s: object expected");
                message.c2s = $root.Qot_GetIpoList.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetIpoList.Request
         * @static
         * @param {Qot_GetIpoList.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetIpoList.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetIpoList.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetIpoList.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetIpoList
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetIpoList.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetIpoList
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetIpoList.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetIpoList.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetIpoList.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetIpoList.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetIpoList.IS2C|null|undefined} s2c
         * @memberof Qot_GetIpoList.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetIpoList.Response
         * @static
         * @param {Qot_GetIpoList.IResponse=} [properties] Properties to set
         * @returns {Qot_GetIpoList.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetIpoList.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetIpoList.Response
         * @static
         * @param {Qot_GetIpoList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetIpoList.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetIpoList.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetIpoList.Response
         * @static
         * @param {Qot_GetIpoList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetIpoList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetIpoList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetIpoList.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetIpoList.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetIpoList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetIpoList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetIpoList.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetIpoList.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetIpoList.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetIpoList.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetIpoList.Response)
                return object;
            var message = new $root.Qot_GetIpoList.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetIpoList.Response.s2c: object expected");
                message.s2c = $root.Qot_GetIpoList.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetIpoList.Response
         * @static
         * @param {Qot_GetIpoList.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetIpoList.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetIpoList.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetIpoList;
})();

$root.Qot_GetKL = (function() {

    /**
     * Namespace Qot_GetKL.
     * @exports Qot_GetKL
     * @namespace
     */
    var Qot_GetKL = {};

    Qot_GetKL.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetKL
         * @interface IC2S
         * @property {number} rehabType C2S rehabType
         * @property {number} klType C2S klType
         * @property {Qot_Common.ISecurity} security C2S security
         * @property {number} reqNum C2S reqNum
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetKL
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetKL.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S rehabType.
         * @member {number} rehabType
         * @memberof Qot_GetKL.C2S
         * @instance
         */
        C2S.prototype.rehabType = 0;

        /**
         * C2S klType.
         * @member {number} klType
         * @memberof Qot_GetKL.C2S
         * @instance
         */
        C2S.prototype.klType = 0;

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetKL.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * C2S reqNum.
         * @member {number} reqNum
         * @memberof Qot_GetKL.C2S
         * @instance
         */
        C2S.prototype.reqNum = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetKL.C2S
         * @static
         * @param {Qot_GetKL.IC2S=} [properties] Properties to set
         * @returns {Qot_GetKL.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetKL.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetKL.C2S
         * @static
         * @param {Qot_GetKL.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rehabType);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.klType);
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.reqNum);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetKL.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetKL.C2S
         * @static
         * @param {Qot_GetKL.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetKL.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetKL.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetKL.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rehabType = reader.int32();
                    break;
                case 2:
                    message.klType = reader.int32();
                    break;
                case 3:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.reqNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("rehabType"))
                throw $util.ProtocolError("missing required 'rehabType'", { instance: message });
            if (!message.hasOwnProperty("klType"))
                throw $util.ProtocolError("missing required 'klType'", { instance: message });
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("reqNum"))
                throw $util.ProtocolError("missing required 'reqNum'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetKL.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetKL.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetKL.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.rehabType))
                return "rehabType: integer expected";
            if (!$util.isInteger(message.klType))
                return "klType: integer expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (!$util.isInteger(message.reqNum))
                return "reqNum: integer expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetKL.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetKL.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetKL.C2S)
                return object;
            var message = new $root.Qot_GetKL.C2S();
            if (object.rehabType != null)
                message.rehabType = object.rehabType | 0;
            if (object.klType != null)
                message.klType = object.klType | 0;
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetKL.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.reqNum != null)
                message.reqNum = object.reqNum | 0;
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetKL.C2S
         * @static
         * @param {Qot_GetKL.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.rehabType = 0;
                object.klType = 0;
                object.security = null;
                object.reqNum = 0;
            }
            if (message.rehabType != null && message.hasOwnProperty("rehabType"))
                object.rehabType = message.rehabType;
            if (message.klType != null && message.hasOwnProperty("klType"))
                object.klType = message.klType;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.reqNum != null && message.hasOwnProperty("reqNum"))
                object.reqNum = message.reqNum;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetKL.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetKL.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetKL
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.IKLine>|null} [klList] S2C klList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetKL
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetKL.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.klList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetKL.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C klList.
         * @member {Array.<Qot_Common.IKLine>} klList
         * @memberof Qot_GetKL.S2C
         * @instance
         */
        S2C.prototype.klList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetKL.S2C
         * @static
         * @param {Qot_GetKL.IS2C=} [properties] Properties to set
         * @returns {Qot_GetKL.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetKL.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetKL.S2C
         * @static
         * @param {Qot_GetKL.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.klList != null && message.klList.length)
                for (var i = 0; i < message.klList.length; ++i)
                    $root.Qot_Common.KLine.encode(message.klList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetKL.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetKL.S2C
         * @static
         * @param {Qot_GetKL.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetKL.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetKL.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetKL.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.klList && message.klList.length))
                        message.klList = [];
                    message.klList.push($root.Qot_Common.KLine.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetKL.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetKL.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetKL.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.klList != null && message.hasOwnProperty("klList")) {
                if (!Array.isArray(message.klList))
                    return "klList: array expected";
                for (var i = 0; i < message.klList.length; ++i) {
                    var error = $root.Qot_Common.KLine.verify(message.klList[i]);
                    if (error)
                        return "klList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetKL.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetKL.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetKL.S2C)
                return object;
            var message = new $root.Qot_GetKL.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetKL.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.klList) {
                if (!Array.isArray(object.klList))
                    throw TypeError(".Qot_GetKL.S2C.klList: array expected");
                message.klList = [];
                for (var i = 0; i < object.klList.length; ++i) {
                    if (typeof object.klList[i] !== "object")
                        throw TypeError(".Qot_GetKL.S2C.klList: object expected");
                    message.klList[i] = $root.Qot_Common.KLine.fromObject(object.klList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetKL.S2C
         * @static
         * @param {Qot_GetKL.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.klList = [];
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.klList && message.klList.length) {
                object.klList = [];
                for (var j = 0; j < message.klList.length; ++j)
                    object.klList[j] = $root.Qot_Common.KLine.toObject(message.klList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetKL.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetKL.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetKL
         * @interface IRequest
         * @property {Qot_GetKL.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetKL
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetKL.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetKL.IC2S} c2s
         * @memberof Qot_GetKL.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetKL.Request
         * @static
         * @param {Qot_GetKL.IRequest=} [properties] Properties to set
         * @returns {Qot_GetKL.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetKL.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetKL.Request
         * @static
         * @param {Qot_GetKL.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetKL.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetKL.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetKL.Request
         * @static
         * @param {Qot_GetKL.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetKL.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetKL.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetKL.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetKL.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetKL.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetKL.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetKL.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetKL.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetKL.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetKL.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetKL.Request)
                return object;
            var message = new $root.Qot_GetKL.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetKL.Request.c2s: object expected");
                message.c2s = $root.Qot_GetKL.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetKL.Request
         * @static
         * @param {Qot_GetKL.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetKL.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetKL.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetKL.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetKL
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetKL.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetKL
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetKL.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetKL.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetKL.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetKL.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetKL.IS2C|null|undefined} s2c
         * @memberof Qot_GetKL.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetKL.Response
         * @static
         * @param {Qot_GetKL.IResponse=} [properties] Properties to set
         * @returns {Qot_GetKL.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetKL.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetKL.Response
         * @static
         * @param {Qot_GetKL.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetKL.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetKL.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetKL.Response
         * @static
         * @param {Qot_GetKL.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetKL.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetKL.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetKL.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetKL.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetKL.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetKL.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetKL.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetKL.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetKL.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetKL.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetKL.Response)
                return object;
            var message = new $root.Qot_GetKL.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetKL.Response.s2c: object expected");
                message.s2c = $root.Qot_GetKL.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetKL.Response
         * @static
         * @param {Qot_GetKL.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetKL.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetKL.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetKL;
})();

$root.Qot_GetOptionChain = (function() {

    /**
     * Namespace Qot_GetOptionChain.
     * @exports Qot_GetOptionChain
     * @namespace
     */
    var Qot_GetOptionChain = {};

    /**
     * OptionCondType enum.
     * @name Qot_GetOptionChain.OptionCondType
     * @enum {string}
     * @property {number} OptionCondType_Unknow=0 OptionCondType_Unknow value
     * @property {number} OptionCondType_WithIn=1 OptionCondType_WithIn value
     * @property {number} OptionCondType_Outside=2 OptionCondType_Outside value
     */
    Qot_GetOptionChain.OptionCondType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OptionCondType_Unknow"] = 0;
        values[valuesById[1] = "OptionCondType_WithIn"] = 1;
        values[valuesById[2] = "OptionCondType_Outside"] = 2;
        return values;
    })();

    Qot_GetOptionChain.DataFilter = (function() {

        /**
         * Properties of a DataFilter.
         * @memberof Qot_GetOptionChain
         * @interface IDataFilter
         * @property {number|null} [impliedVolatilityMin] DataFilter impliedVolatilityMin
         * @property {number|null} [impliedVolatilityMax] DataFilter impliedVolatilityMax
         * @property {number|null} [deltaMin] DataFilter deltaMin
         * @property {number|null} [deltaMax] DataFilter deltaMax
         * @property {number|null} [gammaMin] DataFilter gammaMin
         * @property {number|null} [gammaMax] DataFilter gammaMax
         * @property {number|null} [vegaMin] DataFilter vegaMin
         * @property {number|null} [vegaMax] DataFilter vegaMax
         * @property {number|null} [thetaMin] DataFilter thetaMin
         * @property {number|null} [thetaMax] DataFilter thetaMax
         * @property {number|null} [rhoMin] DataFilter rhoMin
         * @property {number|null} [rhoMax] DataFilter rhoMax
         * @property {number|null} [netOpenInterestMin] DataFilter netOpenInterestMin
         * @property {number|null} [netOpenInterestMax] DataFilter netOpenInterestMax
         * @property {number|null} [openInterestMin] DataFilter openInterestMin
         * @property {number|null} [openInterestMax] DataFilter openInterestMax
         * @property {number|null} [volMin] DataFilter volMin
         * @property {number|null} [volMax] DataFilter volMax
         */

        /**
         * Constructs a new DataFilter.
         * @memberof Qot_GetOptionChain
         * @classdesc Represents a DataFilter.
         * @implements IDataFilter
         * @constructor
         * @param {Qot_GetOptionChain.IDataFilter=} [properties] Properties to set
         */
        function DataFilter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DataFilter impliedVolatilityMin.
         * @member {number} impliedVolatilityMin
         * @memberof Qot_GetOptionChain.DataFilter
         * @instance
         */
        DataFilter.prototype.impliedVolatilityMin = 0;

        /**
         * DataFilter impliedVolatilityMax.
         * @member {number} impliedVolatilityMax
         * @memberof Qot_GetOptionChain.DataFilter
         * @instance
         */
        DataFilter.prototype.impliedVolatilityMax = 0;

        /**
         * DataFilter deltaMin.
         * @member {number} deltaMin
         * @memberof Qot_GetOptionChain.DataFilter
         * @instance
         */
        DataFilter.prototype.deltaMin = 0;

        /**
         * DataFilter deltaMax.
         * @member {number} deltaMax
         * @memberof Qot_GetOptionChain.DataFilter
         * @instance
         */
        DataFilter.prototype.deltaMax = 0;

        /**
         * DataFilter gammaMin.
         * @member {number} gammaMin
         * @memberof Qot_GetOptionChain.DataFilter
         * @instance
         */
        DataFilter.prototype.gammaMin = 0;

        /**
         * DataFilter gammaMax.
         * @member {number} gammaMax
         * @memberof Qot_GetOptionChain.DataFilter
         * @instance
         */
        DataFilter.prototype.gammaMax = 0;

        /**
         * DataFilter vegaMin.
         * @member {number} vegaMin
         * @memberof Qot_GetOptionChain.DataFilter
         * @instance
         */
        DataFilter.prototype.vegaMin = 0;

        /**
         * DataFilter vegaMax.
         * @member {number} vegaMax
         * @memberof Qot_GetOptionChain.DataFilter
         * @instance
         */
        DataFilter.prototype.vegaMax = 0;

        /**
         * DataFilter thetaMin.
         * @member {number} thetaMin
         * @memberof Qot_GetOptionChain.DataFilter
         * @instance
         */
        DataFilter.prototype.thetaMin = 0;

        /**
         * DataFilter thetaMax.
         * @member {number} thetaMax
         * @memberof Qot_GetOptionChain.DataFilter
         * @instance
         */
        DataFilter.prototype.thetaMax = 0;

        /**
         * DataFilter rhoMin.
         * @member {number} rhoMin
         * @memberof Qot_GetOptionChain.DataFilter
         * @instance
         */
        DataFilter.prototype.rhoMin = 0;

        /**
         * DataFilter rhoMax.
         * @member {number} rhoMax
         * @memberof Qot_GetOptionChain.DataFilter
         * @instance
         */
        DataFilter.prototype.rhoMax = 0;

        /**
         * DataFilter netOpenInterestMin.
         * @member {number} netOpenInterestMin
         * @memberof Qot_GetOptionChain.DataFilter
         * @instance
         */
        DataFilter.prototype.netOpenInterestMin = 0;

        /**
         * DataFilter netOpenInterestMax.
         * @member {number} netOpenInterestMax
         * @memberof Qot_GetOptionChain.DataFilter
         * @instance
         */
        DataFilter.prototype.netOpenInterestMax = 0;

        /**
         * DataFilter openInterestMin.
         * @member {number} openInterestMin
         * @memberof Qot_GetOptionChain.DataFilter
         * @instance
         */
        DataFilter.prototype.openInterestMin = 0;

        /**
         * DataFilter openInterestMax.
         * @member {number} openInterestMax
         * @memberof Qot_GetOptionChain.DataFilter
         * @instance
         */
        DataFilter.prototype.openInterestMax = 0;

        /**
         * DataFilter volMin.
         * @member {number} volMin
         * @memberof Qot_GetOptionChain.DataFilter
         * @instance
         */
        DataFilter.prototype.volMin = 0;

        /**
         * DataFilter volMax.
         * @member {number} volMax
         * @memberof Qot_GetOptionChain.DataFilter
         * @instance
         */
        DataFilter.prototype.volMax = 0;

        /**
         * Creates a new DataFilter instance using the specified properties.
         * @function create
         * @memberof Qot_GetOptionChain.DataFilter
         * @static
         * @param {Qot_GetOptionChain.IDataFilter=} [properties] Properties to set
         * @returns {Qot_GetOptionChain.DataFilter} DataFilter instance
         */
        DataFilter.create = function create(properties) {
            return new DataFilter(properties);
        };

        /**
         * Encodes the specified DataFilter message. Does not implicitly {@link Qot_GetOptionChain.DataFilter.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOptionChain.DataFilter
         * @static
         * @param {Qot_GetOptionChain.IDataFilter} message DataFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DataFilter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.impliedVolatilityMin != null && message.hasOwnProperty("impliedVolatilityMin"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.impliedVolatilityMin);
            if (message.impliedVolatilityMax != null && message.hasOwnProperty("impliedVolatilityMax"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.impliedVolatilityMax);
            if (message.deltaMin != null && message.hasOwnProperty("deltaMin"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.deltaMin);
            if (message.deltaMax != null && message.hasOwnProperty("deltaMax"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.deltaMax);
            if (message.gammaMin != null && message.hasOwnProperty("gammaMin"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.gammaMin);
            if (message.gammaMax != null && message.hasOwnProperty("gammaMax"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.gammaMax);
            if (message.vegaMin != null && message.hasOwnProperty("vegaMin"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.vegaMin);
            if (message.vegaMax != null && message.hasOwnProperty("vegaMax"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.vegaMax);
            if (message.thetaMin != null && message.hasOwnProperty("thetaMin"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.thetaMin);
            if (message.thetaMax != null && message.hasOwnProperty("thetaMax"))
                writer.uint32(/* id 10, wireType 1 =*/81).double(message.thetaMax);
            if (message.rhoMin != null && message.hasOwnProperty("rhoMin"))
                writer.uint32(/* id 11, wireType 1 =*/89).double(message.rhoMin);
            if (message.rhoMax != null && message.hasOwnProperty("rhoMax"))
                writer.uint32(/* id 12, wireType 1 =*/97).double(message.rhoMax);
            if (message.netOpenInterestMin != null && message.hasOwnProperty("netOpenInterestMin"))
                writer.uint32(/* id 13, wireType 1 =*/105).double(message.netOpenInterestMin);
            if (message.netOpenInterestMax != null && message.hasOwnProperty("netOpenInterestMax"))
                writer.uint32(/* id 14, wireType 1 =*/113).double(message.netOpenInterestMax);
            if (message.openInterestMin != null && message.hasOwnProperty("openInterestMin"))
                writer.uint32(/* id 15, wireType 1 =*/121).double(message.openInterestMin);
            if (message.openInterestMax != null && message.hasOwnProperty("openInterestMax"))
                writer.uint32(/* id 16, wireType 1 =*/129).double(message.openInterestMax);
            if (message.volMin != null && message.hasOwnProperty("volMin"))
                writer.uint32(/* id 17, wireType 1 =*/137).double(message.volMin);
            if (message.volMax != null && message.hasOwnProperty("volMax"))
                writer.uint32(/* id 18, wireType 1 =*/145).double(message.volMax);
            return writer;
        };

        /**
         * Encodes the specified DataFilter message, length delimited. Does not implicitly {@link Qot_GetOptionChain.DataFilter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOptionChain.DataFilter
         * @static
         * @param {Qot_GetOptionChain.IDataFilter} message DataFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DataFilter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DataFilter message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOptionChain.DataFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOptionChain.DataFilter} DataFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DataFilter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOptionChain.DataFilter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.impliedVolatilityMin = reader.double();
                    break;
                case 2:
                    message.impliedVolatilityMax = reader.double();
                    break;
                case 3:
                    message.deltaMin = reader.double();
                    break;
                case 4:
                    message.deltaMax = reader.double();
                    break;
                case 5:
                    message.gammaMin = reader.double();
                    break;
                case 6:
                    message.gammaMax = reader.double();
                    break;
                case 7:
                    message.vegaMin = reader.double();
                    break;
                case 8:
                    message.vegaMax = reader.double();
                    break;
                case 9:
                    message.thetaMin = reader.double();
                    break;
                case 10:
                    message.thetaMax = reader.double();
                    break;
                case 11:
                    message.rhoMin = reader.double();
                    break;
                case 12:
                    message.rhoMax = reader.double();
                    break;
                case 13:
                    message.netOpenInterestMin = reader.double();
                    break;
                case 14:
                    message.netOpenInterestMax = reader.double();
                    break;
                case 15:
                    message.openInterestMin = reader.double();
                    break;
                case 16:
                    message.openInterestMax = reader.double();
                    break;
                case 17:
                    message.volMin = reader.double();
                    break;
                case 18:
                    message.volMax = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DataFilter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOptionChain.DataFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOptionChain.DataFilter} DataFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DataFilter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DataFilter message.
         * @function verify
         * @memberof Qot_GetOptionChain.DataFilter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DataFilter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.impliedVolatilityMin != null && message.hasOwnProperty("impliedVolatilityMin"))
                if (typeof message.impliedVolatilityMin !== "number")
                    return "impliedVolatilityMin: number expected";
            if (message.impliedVolatilityMax != null && message.hasOwnProperty("impliedVolatilityMax"))
                if (typeof message.impliedVolatilityMax !== "number")
                    return "impliedVolatilityMax: number expected";
            if (message.deltaMin != null && message.hasOwnProperty("deltaMin"))
                if (typeof message.deltaMin !== "number")
                    return "deltaMin: number expected";
            if (message.deltaMax != null && message.hasOwnProperty("deltaMax"))
                if (typeof message.deltaMax !== "number")
                    return "deltaMax: number expected";
            if (message.gammaMin != null && message.hasOwnProperty("gammaMin"))
                if (typeof message.gammaMin !== "number")
                    return "gammaMin: number expected";
            if (message.gammaMax != null && message.hasOwnProperty("gammaMax"))
                if (typeof message.gammaMax !== "number")
                    return "gammaMax: number expected";
            if (message.vegaMin != null && message.hasOwnProperty("vegaMin"))
                if (typeof message.vegaMin !== "number")
                    return "vegaMin: number expected";
            if (message.vegaMax != null && message.hasOwnProperty("vegaMax"))
                if (typeof message.vegaMax !== "number")
                    return "vegaMax: number expected";
            if (message.thetaMin != null && message.hasOwnProperty("thetaMin"))
                if (typeof message.thetaMin !== "number")
                    return "thetaMin: number expected";
            if (message.thetaMax != null && message.hasOwnProperty("thetaMax"))
                if (typeof message.thetaMax !== "number")
                    return "thetaMax: number expected";
            if (message.rhoMin != null && message.hasOwnProperty("rhoMin"))
                if (typeof message.rhoMin !== "number")
                    return "rhoMin: number expected";
            if (message.rhoMax != null && message.hasOwnProperty("rhoMax"))
                if (typeof message.rhoMax !== "number")
                    return "rhoMax: number expected";
            if (message.netOpenInterestMin != null && message.hasOwnProperty("netOpenInterestMin"))
                if (typeof message.netOpenInterestMin !== "number")
                    return "netOpenInterestMin: number expected";
            if (message.netOpenInterestMax != null && message.hasOwnProperty("netOpenInterestMax"))
                if (typeof message.netOpenInterestMax !== "number")
                    return "netOpenInterestMax: number expected";
            if (message.openInterestMin != null && message.hasOwnProperty("openInterestMin"))
                if (typeof message.openInterestMin !== "number")
                    return "openInterestMin: number expected";
            if (message.openInterestMax != null && message.hasOwnProperty("openInterestMax"))
                if (typeof message.openInterestMax !== "number")
                    return "openInterestMax: number expected";
            if (message.volMin != null && message.hasOwnProperty("volMin"))
                if (typeof message.volMin !== "number")
                    return "volMin: number expected";
            if (message.volMax != null && message.hasOwnProperty("volMax"))
                if (typeof message.volMax !== "number")
                    return "volMax: number expected";
            return null;
        };

        /**
         * Creates a DataFilter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOptionChain.DataFilter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOptionChain.DataFilter} DataFilter
         */
        DataFilter.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOptionChain.DataFilter)
                return object;
            var message = new $root.Qot_GetOptionChain.DataFilter();
            if (object.impliedVolatilityMin != null)
                message.impliedVolatilityMin = Number(object.impliedVolatilityMin);
            if (object.impliedVolatilityMax != null)
                message.impliedVolatilityMax = Number(object.impliedVolatilityMax);
            if (object.deltaMin != null)
                message.deltaMin = Number(object.deltaMin);
            if (object.deltaMax != null)
                message.deltaMax = Number(object.deltaMax);
            if (object.gammaMin != null)
                message.gammaMin = Number(object.gammaMin);
            if (object.gammaMax != null)
                message.gammaMax = Number(object.gammaMax);
            if (object.vegaMin != null)
                message.vegaMin = Number(object.vegaMin);
            if (object.vegaMax != null)
                message.vegaMax = Number(object.vegaMax);
            if (object.thetaMin != null)
                message.thetaMin = Number(object.thetaMin);
            if (object.thetaMax != null)
                message.thetaMax = Number(object.thetaMax);
            if (object.rhoMin != null)
                message.rhoMin = Number(object.rhoMin);
            if (object.rhoMax != null)
                message.rhoMax = Number(object.rhoMax);
            if (object.netOpenInterestMin != null)
                message.netOpenInterestMin = Number(object.netOpenInterestMin);
            if (object.netOpenInterestMax != null)
                message.netOpenInterestMax = Number(object.netOpenInterestMax);
            if (object.openInterestMin != null)
                message.openInterestMin = Number(object.openInterestMin);
            if (object.openInterestMax != null)
                message.openInterestMax = Number(object.openInterestMax);
            if (object.volMin != null)
                message.volMin = Number(object.volMin);
            if (object.volMax != null)
                message.volMax = Number(object.volMax);
            return message;
        };

        /**
         * Creates a plain object from a DataFilter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOptionChain.DataFilter
         * @static
         * @param {Qot_GetOptionChain.DataFilter} message DataFilter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DataFilter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.impliedVolatilityMin = 0;
                object.impliedVolatilityMax = 0;
                object.deltaMin = 0;
                object.deltaMax = 0;
                object.gammaMin = 0;
                object.gammaMax = 0;
                object.vegaMin = 0;
                object.vegaMax = 0;
                object.thetaMin = 0;
                object.thetaMax = 0;
                object.rhoMin = 0;
                object.rhoMax = 0;
                object.netOpenInterestMin = 0;
                object.netOpenInterestMax = 0;
                object.openInterestMin = 0;
                object.openInterestMax = 0;
                object.volMin = 0;
                object.volMax = 0;
            }
            if (message.impliedVolatilityMin != null && message.hasOwnProperty("impliedVolatilityMin"))
                object.impliedVolatilityMin = options.json && !isFinite(message.impliedVolatilityMin) ? String(message.impliedVolatilityMin) : message.impliedVolatilityMin;
            if (message.impliedVolatilityMax != null && message.hasOwnProperty("impliedVolatilityMax"))
                object.impliedVolatilityMax = options.json && !isFinite(message.impliedVolatilityMax) ? String(message.impliedVolatilityMax) : message.impliedVolatilityMax;
            if (message.deltaMin != null && message.hasOwnProperty("deltaMin"))
                object.deltaMin = options.json && !isFinite(message.deltaMin) ? String(message.deltaMin) : message.deltaMin;
            if (message.deltaMax != null && message.hasOwnProperty("deltaMax"))
                object.deltaMax = options.json && !isFinite(message.deltaMax) ? String(message.deltaMax) : message.deltaMax;
            if (message.gammaMin != null && message.hasOwnProperty("gammaMin"))
                object.gammaMin = options.json && !isFinite(message.gammaMin) ? String(message.gammaMin) : message.gammaMin;
            if (message.gammaMax != null && message.hasOwnProperty("gammaMax"))
                object.gammaMax = options.json && !isFinite(message.gammaMax) ? String(message.gammaMax) : message.gammaMax;
            if (message.vegaMin != null && message.hasOwnProperty("vegaMin"))
                object.vegaMin = options.json && !isFinite(message.vegaMin) ? String(message.vegaMin) : message.vegaMin;
            if (message.vegaMax != null && message.hasOwnProperty("vegaMax"))
                object.vegaMax = options.json && !isFinite(message.vegaMax) ? String(message.vegaMax) : message.vegaMax;
            if (message.thetaMin != null && message.hasOwnProperty("thetaMin"))
                object.thetaMin = options.json && !isFinite(message.thetaMin) ? String(message.thetaMin) : message.thetaMin;
            if (message.thetaMax != null && message.hasOwnProperty("thetaMax"))
                object.thetaMax = options.json && !isFinite(message.thetaMax) ? String(message.thetaMax) : message.thetaMax;
            if (message.rhoMin != null && message.hasOwnProperty("rhoMin"))
                object.rhoMin = options.json && !isFinite(message.rhoMin) ? String(message.rhoMin) : message.rhoMin;
            if (message.rhoMax != null && message.hasOwnProperty("rhoMax"))
                object.rhoMax = options.json && !isFinite(message.rhoMax) ? String(message.rhoMax) : message.rhoMax;
            if (message.netOpenInterestMin != null && message.hasOwnProperty("netOpenInterestMin"))
                object.netOpenInterestMin = options.json && !isFinite(message.netOpenInterestMin) ? String(message.netOpenInterestMin) : message.netOpenInterestMin;
            if (message.netOpenInterestMax != null && message.hasOwnProperty("netOpenInterestMax"))
                object.netOpenInterestMax = options.json && !isFinite(message.netOpenInterestMax) ? String(message.netOpenInterestMax) : message.netOpenInterestMax;
            if (message.openInterestMin != null && message.hasOwnProperty("openInterestMin"))
                object.openInterestMin = options.json && !isFinite(message.openInterestMin) ? String(message.openInterestMin) : message.openInterestMin;
            if (message.openInterestMax != null && message.hasOwnProperty("openInterestMax"))
                object.openInterestMax = options.json && !isFinite(message.openInterestMax) ? String(message.openInterestMax) : message.openInterestMax;
            if (message.volMin != null && message.hasOwnProperty("volMin"))
                object.volMin = options.json && !isFinite(message.volMin) ? String(message.volMin) : message.volMin;
            if (message.volMax != null && message.hasOwnProperty("volMax"))
                object.volMax = options.json && !isFinite(message.volMax) ? String(message.volMax) : message.volMax;
            return object;
        };

        /**
         * Converts this DataFilter to JSON.
         * @function toJSON
         * @memberof Qot_GetOptionChain.DataFilter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DataFilter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DataFilter;
    })();

    Qot_GetOptionChain.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetOptionChain
         * @interface IC2S
         * @property {Qot_Common.ISecurity} owner C2S owner
         * @property {number|null} [indexOptionType] C2S indexOptionType
         * @property {number|null} [type] C2S type
         * @property {number|null} [condition] C2S condition
         * @property {string} beginTime C2S beginTime
         * @property {string} endTime C2S endTime
         * @property {Qot_GetOptionChain.IDataFilter|null} [dataFilter] C2S dataFilter
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetOptionChain
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetOptionChain.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S owner.
         * @member {Qot_Common.ISecurity} owner
         * @memberof Qot_GetOptionChain.C2S
         * @instance
         */
        C2S.prototype.owner = null;

        /**
         * C2S indexOptionType.
         * @member {number} indexOptionType
         * @memberof Qot_GetOptionChain.C2S
         * @instance
         */
        C2S.prototype.indexOptionType = 0;

        /**
         * C2S type.
         * @member {number} type
         * @memberof Qot_GetOptionChain.C2S
         * @instance
         */
        C2S.prototype.type = 0;

        /**
         * C2S condition.
         * @member {number} condition
         * @memberof Qot_GetOptionChain.C2S
         * @instance
         */
        C2S.prototype.condition = 0;

        /**
         * C2S beginTime.
         * @member {string} beginTime
         * @memberof Qot_GetOptionChain.C2S
         * @instance
         */
        C2S.prototype.beginTime = "";

        /**
         * C2S endTime.
         * @member {string} endTime
         * @memberof Qot_GetOptionChain.C2S
         * @instance
         */
        C2S.prototype.endTime = "";

        /**
         * C2S dataFilter.
         * @member {Qot_GetOptionChain.IDataFilter|null|undefined} dataFilter
         * @memberof Qot_GetOptionChain.C2S
         * @instance
         */
        C2S.prototype.dataFilter = null;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetOptionChain.C2S
         * @static
         * @param {Qot_GetOptionChain.IC2S=} [properties] Properties to set
         * @returns {Qot_GetOptionChain.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetOptionChain.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOptionChain.C2S
         * @static
         * @param {Qot_GetOptionChain.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.owner, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.condition != null && message.hasOwnProperty("condition"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.condition);
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.beginTime);
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.endTime);
            if (message.indexOptionType != null && message.hasOwnProperty("indexOptionType"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.indexOptionType);
            if (message.dataFilter != null && message.hasOwnProperty("dataFilter"))
                $root.Qot_GetOptionChain.DataFilter.encode(message.dataFilter, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetOptionChain.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOptionChain.C2S
         * @static
         * @param {Qot_GetOptionChain.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOptionChain.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOptionChain.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOptionChain.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.indexOptionType = reader.int32();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.condition = reader.int32();
                    break;
                case 4:
                    message.beginTime = reader.string();
                    break;
                case 5:
                    message.endTime = reader.string();
                    break;
                case 7:
                    message.dataFilter = $root.Qot_GetOptionChain.DataFilter.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("owner"))
                throw $util.ProtocolError("missing required 'owner'", { instance: message });
            if (!message.hasOwnProperty("beginTime"))
                throw $util.ProtocolError("missing required 'beginTime'", { instance: message });
            if (!message.hasOwnProperty("endTime"))
                throw $util.ProtocolError("missing required 'endTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOptionChain.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOptionChain.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetOptionChain.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            if (message.indexOptionType != null && message.hasOwnProperty("indexOptionType"))
                if (!$util.isInteger(message.indexOptionType))
                    return "indexOptionType: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.condition != null && message.hasOwnProperty("condition"))
                if (!$util.isInteger(message.condition))
                    return "condition: integer expected";
            if (!$util.isString(message.beginTime))
                return "beginTime: string expected";
            if (!$util.isString(message.endTime))
                return "endTime: string expected";
            if (message.dataFilter != null && message.hasOwnProperty("dataFilter")) {
                var error = $root.Qot_GetOptionChain.DataFilter.verify(message.dataFilter);
                if (error)
                    return "dataFilter." + error;
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOptionChain.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOptionChain.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOptionChain.C2S)
                return object;
            var message = new $root.Qot_GetOptionChain.C2S();
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".Qot_GetOptionChain.C2S.owner: object expected");
                message.owner = $root.Qot_Common.Security.fromObject(object.owner);
            }
            if (object.indexOptionType != null)
                message.indexOptionType = object.indexOptionType | 0;
            if (object.type != null)
                message.type = object.type | 0;
            if (object.condition != null)
                message.condition = object.condition | 0;
            if (object.beginTime != null)
                message.beginTime = String(object.beginTime);
            if (object.endTime != null)
                message.endTime = String(object.endTime);
            if (object.dataFilter != null) {
                if (typeof object.dataFilter !== "object")
                    throw TypeError(".Qot_GetOptionChain.C2S.dataFilter: object expected");
                message.dataFilter = $root.Qot_GetOptionChain.DataFilter.fromObject(object.dataFilter);
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOptionChain.C2S
         * @static
         * @param {Qot_GetOptionChain.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.owner = null;
                object.type = 0;
                object.condition = 0;
                object.beginTime = "";
                object.endTime = "";
                object.indexOptionType = 0;
                object.dataFilter = null;
            }
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.Qot_Common.Security.toObject(message.owner, options);
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.condition != null && message.hasOwnProperty("condition"))
                object.condition = message.condition;
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                object.beginTime = message.beginTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            if (message.indexOptionType != null && message.hasOwnProperty("indexOptionType"))
                object.indexOptionType = message.indexOptionType;
            if (message.dataFilter != null && message.hasOwnProperty("dataFilter"))
                object.dataFilter = $root.Qot_GetOptionChain.DataFilter.toObject(message.dataFilter, options);
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetOptionChain.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetOptionChain.OptionItem = (function() {

        /**
         * Properties of an OptionItem.
         * @memberof Qot_GetOptionChain
         * @interface IOptionItem
         * @property {Qot_Common.ISecurityStaticInfo|null} [call] OptionItem call
         * @property {Qot_Common.ISecurityStaticInfo|null} [put] OptionItem put
         */

        /**
         * Constructs a new OptionItem.
         * @memberof Qot_GetOptionChain
         * @classdesc Represents an OptionItem.
         * @implements IOptionItem
         * @constructor
         * @param {Qot_GetOptionChain.IOptionItem=} [properties] Properties to set
         */
        function OptionItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OptionItem call.
         * @member {Qot_Common.ISecurityStaticInfo|null|undefined} call
         * @memberof Qot_GetOptionChain.OptionItem
         * @instance
         */
        OptionItem.prototype.call = null;

        /**
         * OptionItem put.
         * @member {Qot_Common.ISecurityStaticInfo|null|undefined} put
         * @memberof Qot_GetOptionChain.OptionItem
         * @instance
         */
        OptionItem.prototype.put = null;

        /**
         * Creates a new OptionItem instance using the specified properties.
         * @function create
         * @memberof Qot_GetOptionChain.OptionItem
         * @static
         * @param {Qot_GetOptionChain.IOptionItem=} [properties] Properties to set
         * @returns {Qot_GetOptionChain.OptionItem} OptionItem instance
         */
        OptionItem.create = function create(properties) {
            return new OptionItem(properties);
        };

        /**
         * Encodes the specified OptionItem message. Does not implicitly {@link Qot_GetOptionChain.OptionItem.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOptionChain.OptionItem
         * @static
         * @param {Qot_GetOptionChain.IOptionItem} message OptionItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.call != null && message.hasOwnProperty("call"))
                $root.Qot_Common.SecurityStaticInfo.encode(message.call, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.put != null && message.hasOwnProperty("put"))
                $root.Qot_Common.SecurityStaticInfo.encode(message.put, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified OptionItem message, length delimited. Does not implicitly {@link Qot_GetOptionChain.OptionItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOptionChain.OptionItem
         * @static
         * @param {Qot_GetOptionChain.IOptionItem} message OptionItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OptionItem message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOptionChain.OptionItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOptionChain.OptionItem} OptionItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOptionChain.OptionItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.call = $root.Qot_Common.SecurityStaticInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.put = $root.Qot_Common.SecurityStaticInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OptionItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOptionChain.OptionItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOptionChain.OptionItem} OptionItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OptionItem message.
         * @function verify
         * @memberof Qot_GetOptionChain.OptionItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OptionItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.call != null && message.hasOwnProperty("call")) {
                var error = $root.Qot_Common.SecurityStaticInfo.verify(message.call);
                if (error)
                    return "call." + error;
            }
            if (message.put != null && message.hasOwnProperty("put")) {
                var error = $root.Qot_Common.SecurityStaticInfo.verify(message.put);
                if (error)
                    return "put." + error;
            }
            return null;
        };

        /**
         * Creates an OptionItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOptionChain.OptionItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOptionChain.OptionItem} OptionItem
         */
        OptionItem.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOptionChain.OptionItem)
                return object;
            var message = new $root.Qot_GetOptionChain.OptionItem();
            if (object.call != null) {
                if (typeof object.call !== "object")
                    throw TypeError(".Qot_GetOptionChain.OptionItem.call: object expected");
                message.call = $root.Qot_Common.SecurityStaticInfo.fromObject(object.call);
            }
            if (object.put != null) {
                if (typeof object.put !== "object")
                    throw TypeError(".Qot_GetOptionChain.OptionItem.put: object expected");
                message.put = $root.Qot_Common.SecurityStaticInfo.fromObject(object.put);
            }
            return message;
        };

        /**
         * Creates a plain object from an OptionItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOptionChain.OptionItem
         * @static
         * @param {Qot_GetOptionChain.OptionItem} message OptionItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OptionItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.call = null;
                object.put = null;
            }
            if (message.call != null && message.hasOwnProperty("call"))
                object.call = $root.Qot_Common.SecurityStaticInfo.toObject(message.call, options);
            if (message.put != null && message.hasOwnProperty("put"))
                object.put = $root.Qot_Common.SecurityStaticInfo.toObject(message.put, options);
            return object;
        };

        /**
         * Converts this OptionItem to JSON.
         * @function toJSON
         * @memberof Qot_GetOptionChain.OptionItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OptionItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OptionItem;
    })();

    Qot_GetOptionChain.OptionChain = (function() {

        /**
         * Properties of an OptionChain.
         * @memberof Qot_GetOptionChain
         * @interface IOptionChain
         * @property {string} strikeTime OptionChain strikeTime
         * @property {Array.<Qot_GetOptionChain.IOptionItem>|null} [option] OptionChain option
         * @property {number|null} [strikeTimestamp] OptionChain strikeTimestamp
         */

        /**
         * Constructs a new OptionChain.
         * @memberof Qot_GetOptionChain
         * @classdesc Represents an OptionChain.
         * @implements IOptionChain
         * @constructor
         * @param {Qot_GetOptionChain.IOptionChain=} [properties] Properties to set
         */
        function OptionChain(properties) {
            this.option = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OptionChain strikeTime.
         * @member {string} strikeTime
         * @memberof Qot_GetOptionChain.OptionChain
         * @instance
         */
        OptionChain.prototype.strikeTime = "";

        /**
         * OptionChain option.
         * @member {Array.<Qot_GetOptionChain.IOptionItem>} option
         * @memberof Qot_GetOptionChain.OptionChain
         * @instance
         */
        OptionChain.prototype.option = $util.emptyArray;

        /**
         * OptionChain strikeTimestamp.
         * @member {number} strikeTimestamp
         * @memberof Qot_GetOptionChain.OptionChain
         * @instance
         */
        OptionChain.prototype.strikeTimestamp = 0;

        /**
         * Creates a new OptionChain instance using the specified properties.
         * @function create
         * @memberof Qot_GetOptionChain.OptionChain
         * @static
         * @param {Qot_GetOptionChain.IOptionChain=} [properties] Properties to set
         * @returns {Qot_GetOptionChain.OptionChain} OptionChain instance
         */
        OptionChain.create = function create(properties) {
            return new OptionChain(properties);
        };

        /**
         * Encodes the specified OptionChain message. Does not implicitly {@link Qot_GetOptionChain.OptionChain.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOptionChain.OptionChain
         * @static
         * @param {Qot_GetOptionChain.IOptionChain} message OptionChain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionChain.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.strikeTime);
            if (message.option != null && message.option.length)
                for (var i = 0; i < message.option.length; ++i)
                    $root.Qot_GetOptionChain.OptionItem.encode(message.option[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.strikeTimestamp != null && message.hasOwnProperty("strikeTimestamp"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.strikeTimestamp);
            return writer;
        };

        /**
         * Encodes the specified OptionChain message, length delimited. Does not implicitly {@link Qot_GetOptionChain.OptionChain.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOptionChain.OptionChain
         * @static
         * @param {Qot_GetOptionChain.IOptionChain} message OptionChain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionChain.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OptionChain message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOptionChain.OptionChain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOptionChain.OptionChain} OptionChain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionChain.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOptionChain.OptionChain();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.strikeTime = reader.string();
                    break;
                case 2:
                    if (!(message.option && message.option.length))
                        message.option = [];
                    message.option.push($root.Qot_GetOptionChain.OptionItem.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.strikeTimestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("strikeTime"))
                throw $util.ProtocolError("missing required 'strikeTime'", { instance: message });
            return message;
        };

        /**
         * Decodes an OptionChain message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOptionChain.OptionChain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOptionChain.OptionChain} OptionChain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionChain.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OptionChain message.
         * @function verify
         * @memberof Qot_GetOptionChain.OptionChain
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OptionChain.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.strikeTime))
                return "strikeTime: string expected";
            if (message.option != null && message.hasOwnProperty("option")) {
                if (!Array.isArray(message.option))
                    return "option: array expected";
                for (var i = 0; i < message.option.length; ++i) {
                    var error = $root.Qot_GetOptionChain.OptionItem.verify(message.option[i]);
                    if (error)
                        return "option." + error;
                }
            }
            if (message.strikeTimestamp != null && message.hasOwnProperty("strikeTimestamp"))
                if (typeof message.strikeTimestamp !== "number")
                    return "strikeTimestamp: number expected";
            return null;
        };

        /**
         * Creates an OptionChain message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOptionChain.OptionChain
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOptionChain.OptionChain} OptionChain
         */
        OptionChain.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOptionChain.OptionChain)
                return object;
            var message = new $root.Qot_GetOptionChain.OptionChain();
            if (object.strikeTime != null)
                message.strikeTime = String(object.strikeTime);
            if (object.option) {
                if (!Array.isArray(object.option))
                    throw TypeError(".Qot_GetOptionChain.OptionChain.option: array expected");
                message.option = [];
                for (var i = 0; i < object.option.length; ++i) {
                    if (typeof object.option[i] !== "object")
                        throw TypeError(".Qot_GetOptionChain.OptionChain.option: object expected");
                    message.option[i] = $root.Qot_GetOptionChain.OptionItem.fromObject(object.option[i]);
                }
            }
            if (object.strikeTimestamp != null)
                message.strikeTimestamp = Number(object.strikeTimestamp);
            return message;
        };

        /**
         * Creates a plain object from an OptionChain message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOptionChain.OptionChain
         * @static
         * @param {Qot_GetOptionChain.OptionChain} message OptionChain
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OptionChain.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.option = [];
            if (options.defaults) {
                object.strikeTime = "";
                object.strikeTimestamp = 0;
            }
            if (message.strikeTime != null && message.hasOwnProperty("strikeTime"))
                object.strikeTime = message.strikeTime;
            if (message.option && message.option.length) {
                object.option = [];
                for (var j = 0; j < message.option.length; ++j)
                    object.option[j] = $root.Qot_GetOptionChain.OptionItem.toObject(message.option[j], options);
            }
            if (message.strikeTimestamp != null && message.hasOwnProperty("strikeTimestamp"))
                object.strikeTimestamp = options.json && !isFinite(message.strikeTimestamp) ? String(message.strikeTimestamp) : message.strikeTimestamp;
            return object;
        };

        /**
         * Converts this OptionChain to JSON.
         * @function toJSON
         * @memberof Qot_GetOptionChain.OptionChain
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OptionChain.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OptionChain;
    })();

    Qot_GetOptionChain.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetOptionChain
         * @interface IS2C
         * @property {Array.<Qot_GetOptionChain.IOptionChain>|null} [optionChain] S2C optionChain
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetOptionChain
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetOptionChain.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.optionChain = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C optionChain.
         * @member {Array.<Qot_GetOptionChain.IOptionChain>} optionChain
         * @memberof Qot_GetOptionChain.S2C
         * @instance
         */
        S2C.prototype.optionChain = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetOptionChain.S2C
         * @static
         * @param {Qot_GetOptionChain.IS2C=} [properties] Properties to set
         * @returns {Qot_GetOptionChain.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetOptionChain.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOptionChain.S2C
         * @static
         * @param {Qot_GetOptionChain.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.optionChain != null && message.optionChain.length)
                for (var i = 0; i < message.optionChain.length; ++i)
                    $root.Qot_GetOptionChain.OptionChain.encode(message.optionChain[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetOptionChain.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOptionChain.S2C
         * @static
         * @param {Qot_GetOptionChain.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOptionChain.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOptionChain.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOptionChain.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.optionChain && message.optionChain.length))
                        message.optionChain = [];
                    message.optionChain.push($root.Qot_GetOptionChain.OptionChain.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOptionChain.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOptionChain.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetOptionChain.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.optionChain != null && message.hasOwnProperty("optionChain")) {
                if (!Array.isArray(message.optionChain))
                    return "optionChain: array expected";
                for (var i = 0; i < message.optionChain.length; ++i) {
                    var error = $root.Qot_GetOptionChain.OptionChain.verify(message.optionChain[i]);
                    if (error)
                        return "optionChain." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOptionChain.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOptionChain.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOptionChain.S2C)
                return object;
            var message = new $root.Qot_GetOptionChain.S2C();
            if (object.optionChain) {
                if (!Array.isArray(object.optionChain))
                    throw TypeError(".Qot_GetOptionChain.S2C.optionChain: array expected");
                message.optionChain = [];
                for (var i = 0; i < object.optionChain.length; ++i) {
                    if (typeof object.optionChain[i] !== "object")
                        throw TypeError(".Qot_GetOptionChain.S2C.optionChain: object expected");
                    message.optionChain[i] = $root.Qot_GetOptionChain.OptionChain.fromObject(object.optionChain[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOptionChain.S2C
         * @static
         * @param {Qot_GetOptionChain.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.optionChain = [];
            if (message.optionChain && message.optionChain.length) {
                object.optionChain = [];
                for (var j = 0; j < message.optionChain.length; ++j)
                    object.optionChain[j] = $root.Qot_GetOptionChain.OptionChain.toObject(message.optionChain[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetOptionChain.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetOptionChain.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetOptionChain
         * @interface IRequest
         * @property {Qot_GetOptionChain.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetOptionChain
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetOptionChain.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetOptionChain.IC2S} c2s
         * @memberof Qot_GetOptionChain.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetOptionChain.Request
         * @static
         * @param {Qot_GetOptionChain.IRequest=} [properties] Properties to set
         * @returns {Qot_GetOptionChain.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetOptionChain.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOptionChain.Request
         * @static
         * @param {Qot_GetOptionChain.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetOptionChain.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetOptionChain.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOptionChain.Request
         * @static
         * @param {Qot_GetOptionChain.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOptionChain.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOptionChain.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOptionChain.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetOptionChain.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOptionChain.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOptionChain.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetOptionChain.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetOptionChain.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOptionChain.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOptionChain.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOptionChain.Request)
                return object;
            var message = new $root.Qot_GetOptionChain.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetOptionChain.Request.c2s: object expected");
                message.c2s = $root.Qot_GetOptionChain.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOptionChain.Request
         * @static
         * @param {Qot_GetOptionChain.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetOptionChain.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetOptionChain.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetOptionChain.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetOptionChain
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetOptionChain.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetOptionChain
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetOptionChain.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetOptionChain.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetOptionChain.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetOptionChain.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetOptionChain.IS2C|null|undefined} s2c
         * @memberof Qot_GetOptionChain.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetOptionChain.Response
         * @static
         * @param {Qot_GetOptionChain.IResponse=} [properties] Properties to set
         * @returns {Qot_GetOptionChain.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetOptionChain.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOptionChain.Response
         * @static
         * @param {Qot_GetOptionChain.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetOptionChain.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetOptionChain.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOptionChain.Response
         * @static
         * @param {Qot_GetOptionChain.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOptionChain.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOptionChain.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOptionChain.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetOptionChain.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOptionChain.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOptionChain.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetOptionChain.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetOptionChain.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOptionChain.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOptionChain.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOptionChain.Response)
                return object;
            var message = new $root.Qot_GetOptionChain.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetOptionChain.Response.s2c: object expected");
                message.s2c = $root.Qot_GetOptionChain.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOptionChain.Response
         * @static
         * @param {Qot_GetOptionChain.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetOptionChain.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetOptionChain.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetOptionChain;
})();

$root.Qot_GetOrderBook = (function() {

    /**
     * Namespace Qot_GetOrderBook.
     * @exports Qot_GetOrderBook
     * @namespace
     */
    var Qot_GetOrderBook = {};

    Qot_GetOrderBook.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetOrderBook
         * @interface IC2S
         * @property {Qot_Common.ISecurity} security C2S security
         * @property {number} num C2S num
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetOrderBook
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetOrderBook.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetOrderBook.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * C2S num.
         * @member {number} num
         * @memberof Qot_GetOrderBook.C2S
         * @instance
         */
        C2S.prototype.num = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetOrderBook.C2S
         * @static
         * @param {Qot_GetOrderBook.IC2S=} [properties] Properties to set
         * @returns {Qot_GetOrderBook.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetOrderBook.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOrderBook.C2S
         * @static
         * @param {Qot_GetOrderBook.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetOrderBook.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOrderBook.C2S
         * @static
         * @param {Qot_GetOrderBook.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOrderBook.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOrderBook.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOrderBook.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.num = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("num"))
                throw $util.ProtocolError("missing required 'num'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOrderBook.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOrderBook.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetOrderBook.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (!$util.isInteger(message.num))
                return "num: integer expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOrderBook.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOrderBook.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOrderBook.C2S)
                return object;
            var message = new $root.Qot_GetOrderBook.C2S();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetOrderBook.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.num != null)
                message.num = object.num | 0;
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOrderBook.C2S
         * @static
         * @param {Qot_GetOrderBook.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.security = null;
                object.num = 0;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetOrderBook.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetOrderBook.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetOrderBook
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.IOrderBook>|null} [orderBookAskList] S2C orderBookAskList
         * @property {Array.<Qot_Common.IOrderBook>|null} [orderBookBidList] S2C orderBookBidList
         * @property {string|null} [svrRecvTimeBid] S2C svrRecvTimeBid
         * @property {number|null} [svrRecvTimeBidTimestamp] S2C svrRecvTimeBidTimestamp
         * @property {string|null} [svrRecvTimeAsk] S2C svrRecvTimeAsk
         * @property {number|null} [svrRecvTimeAskTimestamp] S2C svrRecvTimeAskTimestamp
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetOrderBook
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetOrderBook.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.orderBookAskList = [];
            this.orderBookBidList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetOrderBook.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C orderBookAskList.
         * @member {Array.<Qot_Common.IOrderBook>} orderBookAskList
         * @memberof Qot_GetOrderBook.S2C
         * @instance
         */
        S2C.prototype.orderBookAskList = $util.emptyArray;

        /**
         * S2C orderBookBidList.
         * @member {Array.<Qot_Common.IOrderBook>} orderBookBidList
         * @memberof Qot_GetOrderBook.S2C
         * @instance
         */
        S2C.prototype.orderBookBidList = $util.emptyArray;

        /**
         * S2C svrRecvTimeBid.
         * @member {string} svrRecvTimeBid
         * @memberof Qot_GetOrderBook.S2C
         * @instance
         */
        S2C.prototype.svrRecvTimeBid = "";

        /**
         * S2C svrRecvTimeBidTimestamp.
         * @member {number} svrRecvTimeBidTimestamp
         * @memberof Qot_GetOrderBook.S2C
         * @instance
         */
        S2C.prototype.svrRecvTimeBidTimestamp = 0;

        /**
         * S2C svrRecvTimeAsk.
         * @member {string} svrRecvTimeAsk
         * @memberof Qot_GetOrderBook.S2C
         * @instance
         */
        S2C.prototype.svrRecvTimeAsk = "";

        /**
         * S2C svrRecvTimeAskTimestamp.
         * @member {number} svrRecvTimeAskTimestamp
         * @memberof Qot_GetOrderBook.S2C
         * @instance
         */
        S2C.prototype.svrRecvTimeAskTimestamp = 0;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetOrderBook.S2C
         * @static
         * @param {Qot_GetOrderBook.IS2C=} [properties] Properties to set
         * @returns {Qot_GetOrderBook.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetOrderBook.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOrderBook.S2C
         * @static
         * @param {Qot_GetOrderBook.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.orderBookAskList != null && message.orderBookAskList.length)
                for (var i = 0; i < message.orderBookAskList.length; ++i)
                    $root.Qot_Common.OrderBook.encode(message.orderBookAskList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.orderBookBidList != null && message.orderBookBidList.length)
                for (var i = 0; i < message.orderBookBidList.length; ++i)
                    $root.Qot_Common.OrderBook.encode(message.orderBookBidList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.svrRecvTimeBid != null && message.hasOwnProperty("svrRecvTimeBid"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.svrRecvTimeBid);
            if (message.svrRecvTimeBidTimestamp != null && message.hasOwnProperty("svrRecvTimeBidTimestamp"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.svrRecvTimeBidTimestamp);
            if (message.svrRecvTimeAsk != null && message.hasOwnProperty("svrRecvTimeAsk"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.svrRecvTimeAsk);
            if (message.svrRecvTimeAskTimestamp != null && message.hasOwnProperty("svrRecvTimeAskTimestamp"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.svrRecvTimeAskTimestamp);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetOrderBook.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOrderBook.S2C
         * @static
         * @param {Qot_GetOrderBook.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOrderBook.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOrderBook.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOrderBook.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.orderBookAskList && message.orderBookAskList.length))
                        message.orderBookAskList = [];
                    message.orderBookAskList.push($root.Qot_Common.OrderBook.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.orderBookBidList && message.orderBookBidList.length))
                        message.orderBookBidList = [];
                    message.orderBookBidList.push($root.Qot_Common.OrderBook.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.svrRecvTimeBid = reader.string();
                    break;
                case 5:
                    message.svrRecvTimeBidTimestamp = reader.double();
                    break;
                case 6:
                    message.svrRecvTimeAsk = reader.string();
                    break;
                case 7:
                    message.svrRecvTimeAskTimestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOrderBook.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOrderBook.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetOrderBook.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.orderBookAskList != null && message.hasOwnProperty("orderBookAskList")) {
                if (!Array.isArray(message.orderBookAskList))
                    return "orderBookAskList: array expected";
                for (var i = 0; i < message.orderBookAskList.length; ++i) {
                    var error = $root.Qot_Common.OrderBook.verify(message.orderBookAskList[i]);
                    if (error)
                        return "orderBookAskList." + error;
                }
            }
            if (message.orderBookBidList != null && message.hasOwnProperty("orderBookBidList")) {
                if (!Array.isArray(message.orderBookBidList))
                    return "orderBookBidList: array expected";
                for (var i = 0; i < message.orderBookBidList.length; ++i) {
                    var error = $root.Qot_Common.OrderBook.verify(message.orderBookBidList[i]);
                    if (error)
                        return "orderBookBidList." + error;
                }
            }
            if (message.svrRecvTimeBid != null && message.hasOwnProperty("svrRecvTimeBid"))
                if (!$util.isString(message.svrRecvTimeBid))
                    return "svrRecvTimeBid: string expected";
            if (message.svrRecvTimeBidTimestamp != null && message.hasOwnProperty("svrRecvTimeBidTimestamp"))
                if (typeof message.svrRecvTimeBidTimestamp !== "number")
                    return "svrRecvTimeBidTimestamp: number expected";
            if (message.svrRecvTimeAsk != null && message.hasOwnProperty("svrRecvTimeAsk"))
                if (!$util.isString(message.svrRecvTimeAsk))
                    return "svrRecvTimeAsk: string expected";
            if (message.svrRecvTimeAskTimestamp != null && message.hasOwnProperty("svrRecvTimeAskTimestamp"))
                if (typeof message.svrRecvTimeAskTimestamp !== "number")
                    return "svrRecvTimeAskTimestamp: number expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOrderBook.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOrderBook.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOrderBook.S2C)
                return object;
            var message = new $root.Qot_GetOrderBook.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetOrderBook.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.orderBookAskList) {
                if (!Array.isArray(object.orderBookAskList))
                    throw TypeError(".Qot_GetOrderBook.S2C.orderBookAskList: array expected");
                message.orderBookAskList = [];
                for (var i = 0; i < object.orderBookAskList.length; ++i) {
                    if (typeof object.orderBookAskList[i] !== "object")
                        throw TypeError(".Qot_GetOrderBook.S2C.orderBookAskList: object expected");
                    message.orderBookAskList[i] = $root.Qot_Common.OrderBook.fromObject(object.orderBookAskList[i]);
                }
            }
            if (object.orderBookBidList) {
                if (!Array.isArray(object.orderBookBidList))
                    throw TypeError(".Qot_GetOrderBook.S2C.orderBookBidList: array expected");
                message.orderBookBidList = [];
                for (var i = 0; i < object.orderBookBidList.length; ++i) {
                    if (typeof object.orderBookBidList[i] !== "object")
                        throw TypeError(".Qot_GetOrderBook.S2C.orderBookBidList: object expected");
                    message.orderBookBidList[i] = $root.Qot_Common.OrderBook.fromObject(object.orderBookBidList[i]);
                }
            }
            if (object.svrRecvTimeBid != null)
                message.svrRecvTimeBid = String(object.svrRecvTimeBid);
            if (object.svrRecvTimeBidTimestamp != null)
                message.svrRecvTimeBidTimestamp = Number(object.svrRecvTimeBidTimestamp);
            if (object.svrRecvTimeAsk != null)
                message.svrRecvTimeAsk = String(object.svrRecvTimeAsk);
            if (object.svrRecvTimeAskTimestamp != null)
                message.svrRecvTimeAskTimestamp = Number(object.svrRecvTimeAskTimestamp);
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOrderBook.S2C
         * @static
         * @param {Qot_GetOrderBook.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.orderBookAskList = [];
                object.orderBookBidList = [];
            }
            if (options.defaults) {
                object.security = null;
                object.svrRecvTimeBid = "";
                object.svrRecvTimeBidTimestamp = 0;
                object.svrRecvTimeAsk = "";
                object.svrRecvTimeAskTimestamp = 0;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.orderBookAskList && message.orderBookAskList.length) {
                object.orderBookAskList = [];
                for (var j = 0; j < message.orderBookAskList.length; ++j)
                    object.orderBookAskList[j] = $root.Qot_Common.OrderBook.toObject(message.orderBookAskList[j], options);
            }
            if (message.orderBookBidList && message.orderBookBidList.length) {
                object.orderBookBidList = [];
                for (var j = 0; j < message.orderBookBidList.length; ++j)
                    object.orderBookBidList[j] = $root.Qot_Common.OrderBook.toObject(message.orderBookBidList[j], options);
            }
            if (message.svrRecvTimeBid != null && message.hasOwnProperty("svrRecvTimeBid"))
                object.svrRecvTimeBid = message.svrRecvTimeBid;
            if (message.svrRecvTimeBidTimestamp != null && message.hasOwnProperty("svrRecvTimeBidTimestamp"))
                object.svrRecvTimeBidTimestamp = options.json && !isFinite(message.svrRecvTimeBidTimestamp) ? String(message.svrRecvTimeBidTimestamp) : message.svrRecvTimeBidTimestamp;
            if (message.svrRecvTimeAsk != null && message.hasOwnProperty("svrRecvTimeAsk"))
                object.svrRecvTimeAsk = message.svrRecvTimeAsk;
            if (message.svrRecvTimeAskTimestamp != null && message.hasOwnProperty("svrRecvTimeAskTimestamp"))
                object.svrRecvTimeAskTimestamp = options.json && !isFinite(message.svrRecvTimeAskTimestamp) ? String(message.svrRecvTimeAskTimestamp) : message.svrRecvTimeAskTimestamp;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetOrderBook.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetOrderBook.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetOrderBook
         * @interface IRequest
         * @property {Qot_GetOrderBook.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetOrderBook
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetOrderBook.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetOrderBook.IC2S} c2s
         * @memberof Qot_GetOrderBook.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetOrderBook.Request
         * @static
         * @param {Qot_GetOrderBook.IRequest=} [properties] Properties to set
         * @returns {Qot_GetOrderBook.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetOrderBook.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOrderBook.Request
         * @static
         * @param {Qot_GetOrderBook.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetOrderBook.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetOrderBook.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOrderBook.Request
         * @static
         * @param {Qot_GetOrderBook.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOrderBook.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOrderBook.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOrderBook.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetOrderBook.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOrderBook.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOrderBook.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetOrderBook.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetOrderBook.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOrderBook.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOrderBook.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOrderBook.Request)
                return object;
            var message = new $root.Qot_GetOrderBook.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetOrderBook.Request.c2s: object expected");
                message.c2s = $root.Qot_GetOrderBook.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOrderBook.Request
         * @static
         * @param {Qot_GetOrderBook.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetOrderBook.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetOrderBook.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetOrderBook.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetOrderBook
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetOrderBook.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetOrderBook
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetOrderBook.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetOrderBook.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetOrderBook.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetOrderBook.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetOrderBook.IS2C|null|undefined} s2c
         * @memberof Qot_GetOrderBook.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetOrderBook.Response
         * @static
         * @param {Qot_GetOrderBook.IResponse=} [properties] Properties to set
         * @returns {Qot_GetOrderBook.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetOrderBook.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOrderBook.Response
         * @static
         * @param {Qot_GetOrderBook.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetOrderBook.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetOrderBook.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOrderBook.Response
         * @static
         * @param {Qot_GetOrderBook.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOrderBook.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOrderBook.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOrderBook.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetOrderBook.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOrderBook.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOrderBook.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetOrderBook.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetOrderBook.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOrderBook.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOrderBook.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOrderBook.Response)
                return object;
            var message = new $root.Qot_GetOrderBook.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetOrderBook.Response.s2c: object expected");
                message.s2c = $root.Qot_GetOrderBook.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOrderBook.Response
         * @static
         * @param {Qot_GetOrderBook.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetOrderBook.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetOrderBook.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetOrderBook;
})();

$root.Qot_GetOrderDetail = (function() {

    /**
     * Namespace Qot_GetOrderDetail.
     * @exports Qot_GetOrderDetail
     * @namespace
     */
    var Qot_GetOrderDetail = {};

    Qot_GetOrderDetail.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetOrderDetail
         * @interface IC2S
         * @property {Qot_Common.ISecurity} security C2S security
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetOrderDetail
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetOrderDetail.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetOrderDetail.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetOrderDetail.C2S
         * @static
         * @param {Qot_GetOrderDetail.IC2S=} [properties] Properties to set
         * @returns {Qot_GetOrderDetail.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetOrderDetail.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOrderDetail.C2S
         * @static
         * @param {Qot_GetOrderDetail.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetOrderDetail.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOrderDetail.C2S
         * @static
         * @param {Qot_GetOrderDetail.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOrderDetail.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOrderDetail.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOrderDetail.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOrderDetail.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOrderDetail.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetOrderDetail.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOrderDetail.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOrderDetail.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOrderDetail.C2S)
                return object;
            var message = new $root.Qot_GetOrderDetail.C2S();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetOrderDetail.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOrderDetail.C2S
         * @static
         * @param {Qot_GetOrderDetail.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetOrderDetail.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetOrderDetail.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetOrderDetail
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Qot_Common.IOrderDetail} orderDetailAsk S2C orderDetailAsk
         * @property {Qot_Common.IOrderDetail} orderDetailBid S2C orderDetailBid
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetOrderDetail
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetOrderDetail.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetOrderDetail.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C orderDetailAsk.
         * @member {Qot_Common.IOrderDetail} orderDetailAsk
         * @memberof Qot_GetOrderDetail.S2C
         * @instance
         */
        S2C.prototype.orderDetailAsk = null;

        /**
         * S2C orderDetailBid.
         * @member {Qot_Common.IOrderDetail} orderDetailBid
         * @memberof Qot_GetOrderDetail.S2C
         * @instance
         */
        S2C.prototype.orderDetailBid = null;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetOrderDetail.S2C
         * @static
         * @param {Qot_GetOrderDetail.IS2C=} [properties] Properties to set
         * @returns {Qot_GetOrderDetail.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetOrderDetail.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOrderDetail.S2C
         * @static
         * @param {Qot_GetOrderDetail.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            $root.Qot_Common.OrderDetail.encode(message.orderDetailAsk, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            $root.Qot_Common.OrderDetail.encode(message.orderDetailBid, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetOrderDetail.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOrderDetail.S2C
         * @static
         * @param {Qot_GetOrderDetail.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOrderDetail.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOrderDetail.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOrderDetail.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.orderDetailAsk = $root.Qot_Common.OrderDetail.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.orderDetailBid = $root.Qot_Common.OrderDetail.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("orderDetailAsk"))
                throw $util.ProtocolError("missing required 'orderDetailAsk'", { instance: message });
            if (!message.hasOwnProperty("orderDetailBid"))
                throw $util.ProtocolError("missing required 'orderDetailBid'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOrderDetail.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOrderDetail.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetOrderDetail.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            {
                var error = $root.Qot_Common.OrderDetail.verify(message.orderDetailAsk);
                if (error)
                    return "orderDetailAsk." + error;
            }
            {
                var error = $root.Qot_Common.OrderDetail.verify(message.orderDetailBid);
                if (error)
                    return "orderDetailBid." + error;
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOrderDetail.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOrderDetail.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOrderDetail.S2C)
                return object;
            var message = new $root.Qot_GetOrderDetail.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetOrderDetail.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.orderDetailAsk != null) {
                if (typeof object.orderDetailAsk !== "object")
                    throw TypeError(".Qot_GetOrderDetail.S2C.orderDetailAsk: object expected");
                message.orderDetailAsk = $root.Qot_Common.OrderDetail.fromObject(object.orderDetailAsk);
            }
            if (object.orderDetailBid != null) {
                if (typeof object.orderDetailBid !== "object")
                    throw TypeError(".Qot_GetOrderDetail.S2C.orderDetailBid: object expected");
                message.orderDetailBid = $root.Qot_Common.OrderDetail.fromObject(object.orderDetailBid);
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOrderDetail.S2C
         * @static
         * @param {Qot_GetOrderDetail.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.security = null;
                object.orderDetailAsk = null;
                object.orderDetailBid = null;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.orderDetailAsk != null && message.hasOwnProperty("orderDetailAsk"))
                object.orderDetailAsk = $root.Qot_Common.OrderDetail.toObject(message.orderDetailAsk, options);
            if (message.orderDetailBid != null && message.hasOwnProperty("orderDetailBid"))
                object.orderDetailBid = $root.Qot_Common.OrderDetail.toObject(message.orderDetailBid, options);
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetOrderDetail.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetOrderDetail.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetOrderDetail
         * @interface IRequest
         * @property {Qot_GetOrderDetail.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetOrderDetail
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetOrderDetail.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetOrderDetail.IC2S} c2s
         * @memberof Qot_GetOrderDetail.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetOrderDetail.Request
         * @static
         * @param {Qot_GetOrderDetail.IRequest=} [properties] Properties to set
         * @returns {Qot_GetOrderDetail.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetOrderDetail.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOrderDetail.Request
         * @static
         * @param {Qot_GetOrderDetail.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetOrderDetail.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetOrderDetail.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOrderDetail.Request
         * @static
         * @param {Qot_GetOrderDetail.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOrderDetail.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOrderDetail.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOrderDetail.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetOrderDetail.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOrderDetail.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOrderDetail.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetOrderDetail.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetOrderDetail.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOrderDetail.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOrderDetail.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOrderDetail.Request)
                return object;
            var message = new $root.Qot_GetOrderDetail.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetOrderDetail.Request.c2s: object expected");
                message.c2s = $root.Qot_GetOrderDetail.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOrderDetail.Request
         * @static
         * @param {Qot_GetOrderDetail.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetOrderDetail.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetOrderDetail.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetOrderDetail.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetOrderDetail
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetOrderDetail.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetOrderDetail
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetOrderDetail.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetOrderDetail.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetOrderDetail.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetOrderDetail.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetOrderDetail.IS2C|null|undefined} s2c
         * @memberof Qot_GetOrderDetail.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetOrderDetail.Response
         * @static
         * @param {Qot_GetOrderDetail.IResponse=} [properties] Properties to set
         * @returns {Qot_GetOrderDetail.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetOrderDetail.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOrderDetail.Response
         * @static
         * @param {Qot_GetOrderDetail.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetOrderDetail.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetOrderDetail.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOrderDetail.Response
         * @static
         * @param {Qot_GetOrderDetail.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOrderDetail.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOrderDetail.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOrderDetail.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetOrderDetail.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOrderDetail.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOrderDetail.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetOrderDetail.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetOrderDetail.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOrderDetail.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOrderDetail.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOrderDetail.Response)
                return object;
            var message = new $root.Qot_GetOrderDetail.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetOrderDetail.Response.s2c: object expected");
                message.s2c = $root.Qot_GetOrderDetail.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOrderDetail.Response
         * @static
         * @param {Qot_GetOrderDetail.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetOrderDetail.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetOrderDetail.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetOrderDetail;
})();

$root.Qot_GetOwnerPlate = (function() {

    /**
     * Namespace Qot_GetOwnerPlate.
     * @exports Qot_GetOwnerPlate
     * @namespace
     */
    var Qot_GetOwnerPlate = {};

    Qot_GetOwnerPlate.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetOwnerPlate
         * @interface IC2S
         * @property {Array.<Qot_Common.ISecurity>|null} [securityList] C2S securityList
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetOwnerPlate
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetOwnerPlate.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.securityList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S securityList.
         * @member {Array.<Qot_Common.ISecurity>} securityList
         * @memberof Qot_GetOwnerPlate.C2S
         * @instance
         */
        C2S.prototype.securityList = $util.emptyArray;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetOwnerPlate.C2S
         * @static
         * @param {Qot_GetOwnerPlate.IC2S=} [properties] Properties to set
         * @returns {Qot_GetOwnerPlate.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetOwnerPlate.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOwnerPlate.C2S
         * @static
         * @param {Qot_GetOwnerPlate.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.securityList != null && message.securityList.length)
                for (var i = 0; i < message.securityList.length; ++i)
                    $root.Qot_Common.Security.encode(message.securityList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetOwnerPlate.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOwnerPlate.C2S
         * @static
         * @param {Qot_GetOwnerPlate.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOwnerPlate.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOwnerPlate.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOwnerPlate.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.securityList && message.securityList.length))
                        message.securityList = [];
                    message.securityList.push($root.Qot_Common.Security.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOwnerPlate.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOwnerPlate.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetOwnerPlate.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.securityList != null && message.hasOwnProperty("securityList")) {
                if (!Array.isArray(message.securityList))
                    return "securityList: array expected";
                for (var i = 0; i < message.securityList.length; ++i) {
                    var error = $root.Qot_Common.Security.verify(message.securityList[i]);
                    if (error)
                        return "securityList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOwnerPlate.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOwnerPlate.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOwnerPlate.C2S)
                return object;
            var message = new $root.Qot_GetOwnerPlate.C2S();
            if (object.securityList) {
                if (!Array.isArray(object.securityList))
                    throw TypeError(".Qot_GetOwnerPlate.C2S.securityList: array expected");
                message.securityList = [];
                for (var i = 0; i < object.securityList.length; ++i) {
                    if (typeof object.securityList[i] !== "object")
                        throw TypeError(".Qot_GetOwnerPlate.C2S.securityList: object expected");
                    message.securityList[i] = $root.Qot_Common.Security.fromObject(object.securityList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOwnerPlate.C2S
         * @static
         * @param {Qot_GetOwnerPlate.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.securityList = [];
            if (message.securityList && message.securityList.length) {
                object.securityList = [];
                for (var j = 0; j < message.securityList.length; ++j)
                    object.securityList[j] = $root.Qot_Common.Security.toObject(message.securityList[j], options);
            }
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetOwnerPlate.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetOwnerPlate.SecurityOwnerPlate = (function() {

        /**
         * Properties of a SecurityOwnerPlate.
         * @memberof Qot_GetOwnerPlate
         * @interface ISecurityOwnerPlate
         * @property {Qot_Common.ISecurity} security SecurityOwnerPlate security
         * @property {Array.<Qot_Common.IPlateInfo>|null} [plateInfoList] SecurityOwnerPlate plateInfoList
         */

        /**
         * Constructs a new SecurityOwnerPlate.
         * @memberof Qot_GetOwnerPlate
         * @classdesc Represents a SecurityOwnerPlate.
         * @implements ISecurityOwnerPlate
         * @constructor
         * @param {Qot_GetOwnerPlate.ISecurityOwnerPlate=} [properties] Properties to set
         */
        function SecurityOwnerPlate(properties) {
            this.plateInfoList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityOwnerPlate security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetOwnerPlate.SecurityOwnerPlate
         * @instance
         */
        SecurityOwnerPlate.prototype.security = null;

        /**
         * SecurityOwnerPlate plateInfoList.
         * @member {Array.<Qot_Common.IPlateInfo>} plateInfoList
         * @memberof Qot_GetOwnerPlate.SecurityOwnerPlate
         * @instance
         */
        SecurityOwnerPlate.prototype.plateInfoList = $util.emptyArray;

        /**
         * Creates a new SecurityOwnerPlate instance using the specified properties.
         * @function create
         * @memberof Qot_GetOwnerPlate.SecurityOwnerPlate
         * @static
         * @param {Qot_GetOwnerPlate.ISecurityOwnerPlate=} [properties] Properties to set
         * @returns {Qot_GetOwnerPlate.SecurityOwnerPlate} SecurityOwnerPlate instance
         */
        SecurityOwnerPlate.create = function create(properties) {
            return new SecurityOwnerPlate(properties);
        };

        /**
         * Encodes the specified SecurityOwnerPlate message. Does not implicitly {@link Qot_GetOwnerPlate.SecurityOwnerPlate.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOwnerPlate.SecurityOwnerPlate
         * @static
         * @param {Qot_GetOwnerPlate.ISecurityOwnerPlate} message SecurityOwnerPlate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityOwnerPlate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.plateInfoList != null && message.plateInfoList.length)
                for (var i = 0; i < message.plateInfoList.length; ++i)
                    $root.Qot_Common.PlateInfo.encode(message.plateInfoList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SecurityOwnerPlate message, length delimited. Does not implicitly {@link Qot_GetOwnerPlate.SecurityOwnerPlate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOwnerPlate.SecurityOwnerPlate
         * @static
         * @param {Qot_GetOwnerPlate.ISecurityOwnerPlate} message SecurityOwnerPlate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityOwnerPlate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityOwnerPlate message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOwnerPlate.SecurityOwnerPlate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOwnerPlate.SecurityOwnerPlate} SecurityOwnerPlate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityOwnerPlate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOwnerPlate.SecurityOwnerPlate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.plateInfoList && message.plateInfoList.length))
                        message.plateInfoList = [];
                    message.plateInfoList.push($root.Qot_Common.PlateInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a SecurityOwnerPlate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOwnerPlate.SecurityOwnerPlate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOwnerPlate.SecurityOwnerPlate} SecurityOwnerPlate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityOwnerPlate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityOwnerPlate message.
         * @function verify
         * @memberof Qot_GetOwnerPlate.SecurityOwnerPlate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityOwnerPlate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.plateInfoList != null && message.hasOwnProperty("plateInfoList")) {
                if (!Array.isArray(message.plateInfoList))
                    return "plateInfoList: array expected";
                for (var i = 0; i < message.plateInfoList.length; ++i) {
                    var error = $root.Qot_Common.PlateInfo.verify(message.plateInfoList[i]);
                    if (error)
                        return "plateInfoList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SecurityOwnerPlate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOwnerPlate.SecurityOwnerPlate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOwnerPlate.SecurityOwnerPlate} SecurityOwnerPlate
         */
        SecurityOwnerPlate.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOwnerPlate.SecurityOwnerPlate)
                return object;
            var message = new $root.Qot_GetOwnerPlate.SecurityOwnerPlate();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetOwnerPlate.SecurityOwnerPlate.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.plateInfoList) {
                if (!Array.isArray(object.plateInfoList))
                    throw TypeError(".Qot_GetOwnerPlate.SecurityOwnerPlate.plateInfoList: array expected");
                message.plateInfoList = [];
                for (var i = 0; i < object.plateInfoList.length; ++i) {
                    if (typeof object.plateInfoList[i] !== "object")
                        throw TypeError(".Qot_GetOwnerPlate.SecurityOwnerPlate.plateInfoList: object expected");
                    message.plateInfoList[i] = $root.Qot_Common.PlateInfo.fromObject(object.plateInfoList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SecurityOwnerPlate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOwnerPlate.SecurityOwnerPlate
         * @static
         * @param {Qot_GetOwnerPlate.SecurityOwnerPlate} message SecurityOwnerPlate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityOwnerPlate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.plateInfoList = [];
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.plateInfoList && message.plateInfoList.length) {
                object.plateInfoList = [];
                for (var j = 0; j < message.plateInfoList.length; ++j)
                    object.plateInfoList[j] = $root.Qot_Common.PlateInfo.toObject(message.plateInfoList[j], options);
            }
            return object;
        };

        /**
         * Converts this SecurityOwnerPlate to JSON.
         * @function toJSON
         * @memberof Qot_GetOwnerPlate.SecurityOwnerPlate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityOwnerPlate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityOwnerPlate;
    })();

    Qot_GetOwnerPlate.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetOwnerPlate
         * @interface IS2C
         * @property {Array.<Qot_GetOwnerPlate.ISecurityOwnerPlate>|null} [ownerPlateList] S2C ownerPlateList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetOwnerPlate
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetOwnerPlate.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.ownerPlateList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C ownerPlateList.
         * @member {Array.<Qot_GetOwnerPlate.ISecurityOwnerPlate>} ownerPlateList
         * @memberof Qot_GetOwnerPlate.S2C
         * @instance
         */
        S2C.prototype.ownerPlateList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetOwnerPlate.S2C
         * @static
         * @param {Qot_GetOwnerPlate.IS2C=} [properties] Properties to set
         * @returns {Qot_GetOwnerPlate.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetOwnerPlate.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOwnerPlate.S2C
         * @static
         * @param {Qot_GetOwnerPlate.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerPlateList != null && message.ownerPlateList.length)
                for (var i = 0; i < message.ownerPlateList.length; ++i)
                    $root.Qot_GetOwnerPlate.SecurityOwnerPlate.encode(message.ownerPlateList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetOwnerPlate.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOwnerPlate.S2C
         * @static
         * @param {Qot_GetOwnerPlate.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOwnerPlate.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOwnerPlate.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOwnerPlate.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ownerPlateList && message.ownerPlateList.length))
                        message.ownerPlateList = [];
                    message.ownerPlateList.push($root.Qot_GetOwnerPlate.SecurityOwnerPlate.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOwnerPlate.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOwnerPlate.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetOwnerPlate.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerPlateList != null && message.hasOwnProperty("ownerPlateList")) {
                if (!Array.isArray(message.ownerPlateList))
                    return "ownerPlateList: array expected";
                for (var i = 0; i < message.ownerPlateList.length; ++i) {
                    var error = $root.Qot_GetOwnerPlate.SecurityOwnerPlate.verify(message.ownerPlateList[i]);
                    if (error)
                        return "ownerPlateList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOwnerPlate.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOwnerPlate.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOwnerPlate.S2C)
                return object;
            var message = new $root.Qot_GetOwnerPlate.S2C();
            if (object.ownerPlateList) {
                if (!Array.isArray(object.ownerPlateList))
                    throw TypeError(".Qot_GetOwnerPlate.S2C.ownerPlateList: array expected");
                message.ownerPlateList = [];
                for (var i = 0; i < object.ownerPlateList.length; ++i) {
                    if (typeof object.ownerPlateList[i] !== "object")
                        throw TypeError(".Qot_GetOwnerPlate.S2C.ownerPlateList: object expected");
                    message.ownerPlateList[i] = $root.Qot_GetOwnerPlate.SecurityOwnerPlate.fromObject(object.ownerPlateList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOwnerPlate.S2C
         * @static
         * @param {Qot_GetOwnerPlate.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ownerPlateList = [];
            if (message.ownerPlateList && message.ownerPlateList.length) {
                object.ownerPlateList = [];
                for (var j = 0; j < message.ownerPlateList.length; ++j)
                    object.ownerPlateList[j] = $root.Qot_GetOwnerPlate.SecurityOwnerPlate.toObject(message.ownerPlateList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetOwnerPlate.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetOwnerPlate.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetOwnerPlate
         * @interface IRequest
         * @property {Qot_GetOwnerPlate.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetOwnerPlate
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetOwnerPlate.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetOwnerPlate.IC2S} c2s
         * @memberof Qot_GetOwnerPlate.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetOwnerPlate.Request
         * @static
         * @param {Qot_GetOwnerPlate.IRequest=} [properties] Properties to set
         * @returns {Qot_GetOwnerPlate.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetOwnerPlate.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOwnerPlate.Request
         * @static
         * @param {Qot_GetOwnerPlate.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetOwnerPlate.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetOwnerPlate.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOwnerPlate.Request
         * @static
         * @param {Qot_GetOwnerPlate.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOwnerPlate.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOwnerPlate.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOwnerPlate.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetOwnerPlate.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOwnerPlate.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOwnerPlate.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetOwnerPlate.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetOwnerPlate.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOwnerPlate.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOwnerPlate.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOwnerPlate.Request)
                return object;
            var message = new $root.Qot_GetOwnerPlate.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetOwnerPlate.Request.c2s: object expected");
                message.c2s = $root.Qot_GetOwnerPlate.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOwnerPlate.Request
         * @static
         * @param {Qot_GetOwnerPlate.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetOwnerPlate.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetOwnerPlate.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetOwnerPlate.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetOwnerPlate
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetOwnerPlate.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetOwnerPlate
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetOwnerPlate.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetOwnerPlate.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetOwnerPlate.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetOwnerPlate.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetOwnerPlate.IS2C|null|undefined} s2c
         * @memberof Qot_GetOwnerPlate.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetOwnerPlate.Response
         * @static
         * @param {Qot_GetOwnerPlate.IResponse=} [properties] Properties to set
         * @returns {Qot_GetOwnerPlate.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetOwnerPlate.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOwnerPlate.Response
         * @static
         * @param {Qot_GetOwnerPlate.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetOwnerPlate.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetOwnerPlate.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOwnerPlate.Response
         * @static
         * @param {Qot_GetOwnerPlate.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOwnerPlate.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOwnerPlate.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOwnerPlate.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetOwnerPlate.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOwnerPlate.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOwnerPlate.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetOwnerPlate.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetOwnerPlate.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOwnerPlate.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOwnerPlate.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOwnerPlate.Response)
                return object;
            var message = new $root.Qot_GetOwnerPlate.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetOwnerPlate.Response.s2c: object expected");
                message.s2c = $root.Qot_GetOwnerPlate.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOwnerPlate.Response
         * @static
         * @param {Qot_GetOwnerPlate.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetOwnerPlate.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetOwnerPlate.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetOwnerPlate;
})();

$root.Qot_GetPlateSecurity = (function() {

    /**
     * Namespace Qot_GetPlateSecurity.
     * @exports Qot_GetPlateSecurity
     * @namespace
     */
    var Qot_GetPlateSecurity = {};

    Qot_GetPlateSecurity.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetPlateSecurity
         * @interface IC2S
         * @property {Qot_Common.ISecurity} plate C2S plate
         * @property {number|null} [sortField] C2S sortField
         * @property {boolean|null} [ascend] C2S ascend
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetPlateSecurity
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetPlateSecurity.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S plate.
         * @member {Qot_Common.ISecurity} plate
         * @memberof Qot_GetPlateSecurity.C2S
         * @instance
         */
        C2S.prototype.plate = null;

        /**
         * C2S sortField.
         * @member {number} sortField
         * @memberof Qot_GetPlateSecurity.C2S
         * @instance
         */
        C2S.prototype.sortField = 0;

        /**
         * C2S ascend.
         * @member {boolean} ascend
         * @memberof Qot_GetPlateSecurity.C2S
         * @instance
         */
        C2S.prototype.ascend = false;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetPlateSecurity.C2S
         * @static
         * @param {Qot_GetPlateSecurity.IC2S=} [properties] Properties to set
         * @returns {Qot_GetPlateSecurity.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetPlateSecurity.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetPlateSecurity.C2S
         * @static
         * @param {Qot_GetPlateSecurity.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.plate, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sortField != null && message.hasOwnProperty("sortField"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.sortField);
            if (message.ascend != null && message.hasOwnProperty("ascend"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.ascend);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetPlateSecurity.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetPlateSecurity.C2S
         * @static
         * @param {Qot_GetPlateSecurity.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetPlateSecurity.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetPlateSecurity.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetPlateSecurity.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.plate = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.sortField = reader.int32();
                    break;
                case 3:
                    message.ascend = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("plate"))
                throw $util.ProtocolError("missing required 'plate'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetPlateSecurity.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetPlateSecurity.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetPlateSecurity.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.plate);
                if (error)
                    return "plate." + error;
            }
            if (message.sortField != null && message.hasOwnProperty("sortField"))
                if (!$util.isInteger(message.sortField))
                    return "sortField: integer expected";
            if (message.ascend != null && message.hasOwnProperty("ascend"))
                if (typeof message.ascend !== "boolean")
                    return "ascend: boolean expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetPlateSecurity.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetPlateSecurity.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetPlateSecurity.C2S)
                return object;
            var message = new $root.Qot_GetPlateSecurity.C2S();
            if (object.plate != null) {
                if (typeof object.plate !== "object")
                    throw TypeError(".Qot_GetPlateSecurity.C2S.plate: object expected");
                message.plate = $root.Qot_Common.Security.fromObject(object.plate);
            }
            if (object.sortField != null)
                message.sortField = object.sortField | 0;
            if (object.ascend != null)
                message.ascend = Boolean(object.ascend);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetPlateSecurity.C2S
         * @static
         * @param {Qot_GetPlateSecurity.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.plate = null;
                object.sortField = 0;
                object.ascend = false;
            }
            if (message.plate != null && message.hasOwnProperty("plate"))
                object.plate = $root.Qot_Common.Security.toObject(message.plate, options);
            if (message.sortField != null && message.hasOwnProperty("sortField"))
                object.sortField = message.sortField;
            if (message.ascend != null && message.hasOwnProperty("ascend"))
                object.ascend = message.ascend;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetPlateSecurity.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetPlateSecurity.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetPlateSecurity
         * @interface IS2C
         * @property {Array.<Qot_Common.ISecurityStaticInfo>|null} [staticInfoList] S2C staticInfoList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetPlateSecurity
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetPlateSecurity.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.staticInfoList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C staticInfoList.
         * @member {Array.<Qot_Common.ISecurityStaticInfo>} staticInfoList
         * @memberof Qot_GetPlateSecurity.S2C
         * @instance
         */
        S2C.prototype.staticInfoList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetPlateSecurity.S2C
         * @static
         * @param {Qot_GetPlateSecurity.IS2C=} [properties] Properties to set
         * @returns {Qot_GetPlateSecurity.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetPlateSecurity.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetPlateSecurity.S2C
         * @static
         * @param {Qot_GetPlateSecurity.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.staticInfoList != null && message.staticInfoList.length)
                for (var i = 0; i < message.staticInfoList.length; ++i)
                    $root.Qot_Common.SecurityStaticInfo.encode(message.staticInfoList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetPlateSecurity.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetPlateSecurity.S2C
         * @static
         * @param {Qot_GetPlateSecurity.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetPlateSecurity.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetPlateSecurity.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetPlateSecurity.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.staticInfoList && message.staticInfoList.length))
                        message.staticInfoList = [];
                    message.staticInfoList.push($root.Qot_Common.SecurityStaticInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetPlateSecurity.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetPlateSecurity.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetPlateSecurity.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.staticInfoList != null && message.hasOwnProperty("staticInfoList")) {
                if (!Array.isArray(message.staticInfoList))
                    return "staticInfoList: array expected";
                for (var i = 0; i < message.staticInfoList.length; ++i) {
                    var error = $root.Qot_Common.SecurityStaticInfo.verify(message.staticInfoList[i]);
                    if (error)
                        return "staticInfoList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetPlateSecurity.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetPlateSecurity.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetPlateSecurity.S2C)
                return object;
            var message = new $root.Qot_GetPlateSecurity.S2C();
            if (object.staticInfoList) {
                if (!Array.isArray(object.staticInfoList))
                    throw TypeError(".Qot_GetPlateSecurity.S2C.staticInfoList: array expected");
                message.staticInfoList = [];
                for (var i = 0; i < object.staticInfoList.length; ++i) {
                    if (typeof object.staticInfoList[i] !== "object")
                        throw TypeError(".Qot_GetPlateSecurity.S2C.staticInfoList: object expected");
                    message.staticInfoList[i] = $root.Qot_Common.SecurityStaticInfo.fromObject(object.staticInfoList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetPlateSecurity.S2C
         * @static
         * @param {Qot_GetPlateSecurity.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.staticInfoList = [];
            if (message.staticInfoList && message.staticInfoList.length) {
                object.staticInfoList = [];
                for (var j = 0; j < message.staticInfoList.length; ++j)
                    object.staticInfoList[j] = $root.Qot_Common.SecurityStaticInfo.toObject(message.staticInfoList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetPlateSecurity.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetPlateSecurity.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetPlateSecurity
         * @interface IRequest
         * @property {Qot_GetPlateSecurity.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetPlateSecurity
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetPlateSecurity.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetPlateSecurity.IC2S} c2s
         * @memberof Qot_GetPlateSecurity.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetPlateSecurity.Request
         * @static
         * @param {Qot_GetPlateSecurity.IRequest=} [properties] Properties to set
         * @returns {Qot_GetPlateSecurity.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetPlateSecurity.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetPlateSecurity.Request
         * @static
         * @param {Qot_GetPlateSecurity.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetPlateSecurity.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetPlateSecurity.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetPlateSecurity.Request
         * @static
         * @param {Qot_GetPlateSecurity.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetPlateSecurity.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetPlateSecurity.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetPlateSecurity.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetPlateSecurity.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetPlateSecurity.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetPlateSecurity.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetPlateSecurity.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetPlateSecurity.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetPlateSecurity.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetPlateSecurity.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetPlateSecurity.Request)
                return object;
            var message = new $root.Qot_GetPlateSecurity.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetPlateSecurity.Request.c2s: object expected");
                message.c2s = $root.Qot_GetPlateSecurity.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetPlateSecurity.Request
         * @static
         * @param {Qot_GetPlateSecurity.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetPlateSecurity.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetPlateSecurity.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetPlateSecurity.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetPlateSecurity
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetPlateSecurity.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetPlateSecurity
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetPlateSecurity.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetPlateSecurity.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetPlateSecurity.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetPlateSecurity.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetPlateSecurity.IS2C|null|undefined} s2c
         * @memberof Qot_GetPlateSecurity.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetPlateSecurity.Response
         * @static
         * @param {Qot_GetPlateSecurity.IResponse=} [properties] Properties to set
         * @returns {Qot_GetPlateSecurity.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetPlateSecurity.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetPlateSecurity.Response
         * @static
         * @param {Qot_GetPlateSecurity.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetPlateSecurity.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetPlateSecurity.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetPlateSecurity.Response
         * @static
         * @param {Qot_GetPlateSecurity.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetPlateSecurity.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetPlateSecurity.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetPlateSecurity.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetPlateSecurity.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetPlateSecurity.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetPlateSecurity.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetPlateSecurity.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetPlateSecurity.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetPlateSecurity.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetPlateSecurity.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetPlateSecurity.Response)
                return object;
            var message = new $root.Qot_GetPlateSecurity.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetPlateSecurity.Response.s2c: object expected");
                message.s2c = $root.Qot_GetPlateSecurity.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetPlateSecurity.Response
         * @static
         * @param {Qot_GetPlateSecurity.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetPlateSecurity.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetPlateSecurity.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetPlateSecurity;
})();

$root.Qot_GetPlateSet = (function() {

    /**
     * Namespace Qot_GetPlateSet.
     * @exports Qot_GetPlateSet
     * @namespace
     */
    var Qot_GetPlateSet = {};

    Qot_GetPlateSet.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetPlateSet
         * @interface IC2S
         * @property {number} market C2S market
         * @property {number} plateSetType C2S plateSetType
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetPlateSet
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetPlateSet.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S market.
         * @member {number} market
         * @memberof Qot_GetPlateSet.C2S
         * @instance
         */
        C2S.prototype.market = 0;

        /**
         * C2S plateSetType.
         * @member {number} plateSetType
         * @memberof Qot_GetPlateSet.C2S
         * @instance
         */
        C2S.prototype.plateSetType = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetPlateSet.C2S
         * @static
         * @param {Qot_GetPlateSet.IC2S=} [properties] Properties to set
         * @returns {Qot_GetPlateSet.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetPlateSet.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetPlateSet.C2S
         * @static
         * @param {Qot_GetPlateSet.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.market);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.plateSetType);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetPlateSet.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetPlateSet.C2S
         * @static
         * @param {Qot_GetPlateSet.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetPlateSet.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetPlateSet.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetPlateSet.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.market = reader.int32();
                    break;
                case 2:
                    message.plateSetType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("market"))
                throw $util.ProtocolError("missing required 'market'", { instance: message });
            if (!message.hasOwnProperty("plateSetType"))
                throw $util.ProtocolError("missing required 'plateSetType'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetPlateSet.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetPlateSet.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetPlateSet.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.market))
                return "market: integer expected";
            if (!$util.isInteger(message.plateSetType))
                return "plateSetType: integer expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetPlateSet.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetPlateSet.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetPlateSet.C2S)
                return object;
            var message = new $root.Qot_GetPlateSet.C2S();
            if (object.market != null)
                message.market = object.market | 0;
            if (object.plateSetType != null)
                message.plateSetType = object.plateSetType | 0;
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetPlateSet.C2S
         * @static
         * @param {Qot_GetPlateSet.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.market = 0;
                object.plateSetType = 0;
            }
            if (message.market != null && message.hasOwnProperty("market"))
                object.market = message.market;
            if (message.plateSetType != null && message.hasOwnProperty("plateSetType"))
                object.plateSetType = message.plateSetType;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetPlateSet.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetPlateSet.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetPlateSet
         * @interface IS2C
         * @property {Array.<Qot_Common.IPlateInfo>|null} [plateInfoList] S2C plateInfoList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetPlateSet
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetPlateSet.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.plateInfoList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C plateInfoList.
         * @member {Array.<Qot_Common.IPlateInfo>} plateInfoList
         * @memberof Qot_GetPlateSet.S2C
         * @instance
         */
        S2C.prototype.plateInfoList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetPlateSet.S2C
         * @static
         * @param {Qot_GetPlateSet.IS2C=} [properties] Properties to set
         * @returns {Qot_GetPlateSet.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetPlateSet.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetPlateSet.S2C
         * @static
         * @param {Qot_GetPlateSet.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.plateInfoList != null && message.plateInfoList.length)
                for (var i = 0; i < message.plateInfoList.length; ++i)
                    $root.Qot_Common.PlateInfo.encode(message.plateInfoList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetPlateSet.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetPlateSet.S2C
         * @static
         * @param {Qot_GetPlateSet.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetPlateSet.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetPlateSet.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetPlateSet.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.plateInfoList && message.plateInfoList.length))
                        message.plateInfoList = [];
                    message.plateInfoList.push($root.Qot_Common.PlateInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetPlateSet.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetPlateSet.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetPlateSet.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.plateInfoList != null && message.hasOwnProperty("plateInfoList")) {
                if (!Array.isArray(message.plateInfoList))
                    return "plateInfoList: array expected";
                for (var i = 0; i < message.plateInfoList.length; ++i) {
                    var error = $root.Qot_Common.PlateInfo.verify(message.plateInfoList[i]);
                    if (error)
                        return "plateInfoList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetPlateSet.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetPlateSet.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetPlateSet.S2C)
                return object;
            var message = new $root.Qot_GetPlateSet.S2C();
            if (object.plateInfoList) {
                if (!Array.isArray(object.plateInfoList))
                    throw TypeError(".Qot_GetPlateSet.S2C.plateInfoList: array expected");
                message.plateInfoList = [];
                for (var i = 0; i < object.plateInfoList.length; ++i) {
                    if (typeof object.plateInfoList[i] !== "object")
                        throw TypeError(".Qot_GetPlateSet.S2C.plateInfoList: object expected");
                    message.plateInfoList[i] = $root.Qot_Common.PlateInfo.fromObject(object.plateInfoList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetPlateSet.S2C
         * @static
         * @param {Qot_GetPlateSet.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.plateInfoList = [];
            if (message.plateInfoList && message.plateInfoList.length) {
                object.plateInfoList = [];
                for (var j = 0; j < message.plateInfoList.length; ++j)
                    object.plateInfoList[j] = $root.Qot_Common.PlateInfo.toObject(message.plateInfoList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetPlateSet.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetPlateSet.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetPlateSet
         * @interface IRequest
         * @property {Qot_GetPlateSet.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetPlateSet
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetPlateSet.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetPlateSet.IC2S} c2s
         * @memberof Qot_GetPlateSet.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetPlateSet.Request
         * @static
         * @param {Qot_GetPlateSet.IRequest=} [properties] Properties to set
         * @returns {Qot_GetPlateSet.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetPlateSet.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetPlateSet.Request
         * @static
         * @param {Qot_GetPlateSet.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetPlateSet.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetPlateSet.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetPlateSet.Request
         * @static
         * @param {Qot_GetPlateSet.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetPlateSet.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetPlateSet.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetPlateSet.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetPlateSet.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetPlateSet.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetPlateSet.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetPlateSet.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetPlateSet.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetPlateSet.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetPlateSet.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetPlateSet.Request)
                return object;
            var message = new $root.Qot_GetPlateSet.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetPlateSet.Request.c2s: object expected");
                message.c2s = $root.Qot_GetPlateSet.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetPlateSet.Request
         * @static
         * @param {Qot_GetPlateSet.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetPlateSet.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetPlateSet.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetPlateSet.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetPlateSet
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetPlateSet.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetPlateSet
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetPlateSet.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetPlateSet.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetPlateSet.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetPlateSet.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetPlateSet.IS2C|null|undefined} s2c
         * @memberof Qot_GetPlateSet.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetPlateSet.Response
         * @static
         * @param {Qot_GetPlateSet.IResponse=} [properties] Properties to set
         * @returns {Qot_GetPlateSet.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetPlateSet.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetPlateSet.Response
         * @static
         * @param {Qot_GetPlateSet.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetPlateSet.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetPlateSet.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetPlateSet.Response
         * @static
         * @param {Qot_GetPlateSet.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetPlateSet.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetPlateSet.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetPlateSet.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetPlateSet.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetPlateSet.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetPlateSet.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetPlateSet.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetPlateSet.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetPlateSet.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetPlateSet.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetPlateSet.Response)
                return object;
            var message = new $root.Qot_GetPlateSet.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetPlateSet.Response.s2c: object expected");
                message.s2c = $root.Qot_GetPlateSet.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetPlateSet.Response
         * @static
         * @param {Qot_GetPlateSet.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetPlateSet.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetPlateSet.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetPlateSet;
})();

$root.Qot_GetPriceReminder = (function() {

    /**
     * Namespace Qot_GetPriceReminder.
     * @exports Qot_GetPriceReminder
     * @namespace
     */
    var Qot_GetPriceReminder = {};

    Qot_GetPriceReminder.PriceReminderItem = (function() {

        /**
         * Properties of a PriceReminderItem.
         * @memberof Qot_GetPriceReminder
         * @interface IPriceReminderItem
         * @property {number|Long} key PriceReminderItem key
         * @property {number} type PriceReminderItem type
         * @property {number} value PriceReminderItem value
         * @property {string} note PriceReminderItem note
         * @property {number} freq PriceReminderItem freq
         * @property {boolean} isEnable PriceReminderItem isEnable
         */

        /**
         * Constructs a new PriceReminderItem.
         * @memberof Qot_GetPriceReminder
         * @classdesc Represents a PriceReminderItem.
         * @implements IPriceReminderItem
         * @constructor
         * @param {Qot_GetPriceReminder.IPriceReminderItem=} [properties] Properties to set
         */
        function PriceReminderItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PriceReminderItem key.
         * @member {number|Long} key
         * @memberof Qot_GetPriceReminder.PriceReminderItem
         * @instance
         */
        PriceReminderItem.prototype.key = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PriceReminderItem type.
         * @member {number} type
         * @memberof Qot_GetPriceReminder.PriceReminderItem
         * @instance
         */
        PriceReminderItem.prototype.type = 0;

        /**
         * PriceReminderItem value.
         * @member {number} value
         * @memberof Qot_GetPriceReminder.PriceReminderItem
         * @instance
         */
        PriceReminderItem.prototype.value = 0;

        /**
         * PriceReminderItem note.
         * @member {string} note
         * @memberof Qot_GetPriceReminder.PriceReminderItem
         * @instance
         */
        PriceReminderItem.prototype.note = "";

        /**
         * PriceReminderItem freq.
         * @member {number} freq
         * @memberof Qot_GetPriceReminder.PriceReminderItem
         * @instance
         */
        PriceReminderItem.prototype.freq = 0;

        /**
         * PriceReminderItem isEnable.
         * @member {boolean} isEnable
         * @memberof Qot_GetPriceReminder.PriceReminderItem
         * @instance
         */
        PriceReminderItem.prototype.isEnable = false;

        /**
         * Creates a new PriceReminderItem instance using the specified properties.
         * @function create
         * @memberof Qot_GetPriceReminder.PriceReminderItem
         * @static
         * @param {Qot_GetPriceReminder.IPriceReminderItem=} [properties] Properties to set
         * @returns {Qot_GetPriceReminder.PriceReminderItem} PriceReminderItem instance
         */
        PriceReminderItem.create = function create(properties) {
            return new PriceReminderItem(properties);
        };

        /**
         * Encodes the specified PriceReminderItem message. Does not implicitly {@link Qot_GetPriceReminder.PriceReminderItem.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetPriceReminder.PriceReminderItem
         * @static
         * @param {Qot_GetPriceReminder.IPriceReminderItem} message PriceReminderItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PriceReminderItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.key);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.value);
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.note);
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.freq);
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isEnable);
            return writer;
        };

        /**
         * Encodes the specified PriceReminderItem message, length delimited. Does not implicitly {@link Qot_GetPriceReminder.PriceReminderItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetPriceReminder.PriceReminderItem
         * @static
         * @param {Qot_GetPriceReminder.IPriceReminderItem} message PriceReminderItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PriceReminderItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PriceReminderItem message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetPriceReminder.PriceReminderItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetPriceReminder.PriceReminderItem} PriceReminderItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PriceReminderItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetPriceReminder.PriceReminderItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.int64();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.value = reader.double();
                    break;
                case 4:
                    message.note = reader.string();
                    break;
                case 5:
                    message.freq = reader.int32();
                    break;
                case 6:
                    message.isEnable = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("key"))
                throw $util.ProtocolError("missing required 'key'", { instance: message });
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("value"))
                throw $util.ProtocolError("missing required 'value'", { instance: message });
            if (!message.hasOwnProperty("note"))
                throw $util.ProtocolError("missing required 'note'", { instance: message });
            if (!message.hasOwnProperty("freq"))
                throw $util.ProtocolError("missing required 'freq'", { instance: message });
            if (!message.hasOwnProperty("isEnable"))
                throw $util.ProtocolError("missing required 'isEnable'", { instance: message });
            return message;
        };

        /**
         * Decodes a PriceReminderItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetPriceReminder.PriceReminderItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetPriceReminder.PriceReminderItem} PriceReminderItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PriceReminderItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PriceReminderItem message.
         * @function verify
         * @memberof Qot_GetPriceReminder.PriceReminderItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PriceReminderItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.key) && !(message.key && $util.isInteger(message.key.low) && $util.isInteger(message.key.high)))
                return "key: integer|Long expected";
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            if (typeof message.value !== "number")
                return "value: number expected";
            if (!$util.isString(message.note))
                return "note: string expected";
            if (!$util.isInteger(message.freq))
                return "freq: integer expected";
            if (typeof message.isEnable !== "boolean")
                return "isEnable: boolean expected";
            return null;
        };

        /**
         * Creates a PriceReminderItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetPriceReminder.PriceReminderItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetPriceReminder.PriceReminderItem} PriceReminderItem
         */
        PriceReminderItem.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetPriceReminder.PriceReminderItem)
                return object;
            var message = new $root.Qot_GetPriceReminder.PriceReminderItem();
            if (object.key != null)
                if ($util.Long)
                    (message.key = $util.Long.fromValue(object.key)).unsigned = false;
                else if (typeof object.key === "string")
                    message.key = parseInt(object.key, 10);
                else if (typeof object.key === "number")
                    message.key = object.key;
                else if (typeof object.key === "object")
                    message.key = new $util.LongBits(object.key.low >>> 0, object.key.high >>> 0).toNumber();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.value != null)
                message.value = Number(object.value);
            if (object.note != null)
                message.note = String(object.note);
            if (object.freq != null)
                message.freq = object.freq | 0;
            if (object.isEnable != null)
                message.isEnable = Boolean(object.isEnable);
            return message;
        };

        /**
         * Creates a plain object from a PriceReminderItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetPriceReminder.PriceReminderItem
         * @static
         * @param {Qot_GetPriceReminder.PriceReminderItem} message PriceReminderItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PriceReminderItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.key = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.key = options.longs === String ? "0" : 0;
                object.type = 0;
                object.value = 0;
                object.note = "";
                object.freq = 0;
                object.isEnable = false;
            }
            if (message.key != null && message.hasOwnProperty("key"))
                if (typeof message.key === "number")
                    object.key = options.longs === String ? String(message.key) : message.key;
                else
                    object.key = options.longs === String ? $util.Long.prototype.toString.call(message.key) : options.longs === Number ? new $util.LongBits(message.key.low >>> 0, message.key.high >>> 0).toNumber() : message.key;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
            if (message.note != null && message.hasOwnProperty("note"))
                object.note = message.note;
            if (message.freq != null && message.hasOwnProperty("freq"))
                object.freq = message.freq;
            if (message.isEnable != null && message.hasOwnProperty("isEnable"))
                object.isEnable = message.isEnable;
            return object;
        };

        /**
         * Converts this PriceReminderItem to JSON.
         * @function toJSON
         * @memberof Qot_GetPriceReminder.PriceReminderItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PriceReminderItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PriceReminderItem;
    })();

    Qot_GetPriceReminder.PriceReminder = (function() {

        /**
         * Properties of a PriceReminder.
         * @memberof Qot_GetPriceReminder
         * @interface IPriceReminder
         * @property {Qot_Common.ISecurity} security PriceReminder security
         * @property {Array.<Qot_GetPriceReminder.IPriceReminderItem>|null} [itemList] PriceReminder itemList
         */

        /**
         * Constructs a new PriceReminder.
         * @memberof Qot_GetPriceReminder
         * @classdesc Represents a PriceReminder.
         * @implements IPriceReminder
         * @constructor
         * @param {Qot_GetPriceReminder.IPriceReminder=} [properties] Properties to set
         */
        function PriceReminder(properties) {
            this.itemList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PriceReminder security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetPriceReminder.PriceReminder
         * @instance
         */
        PriceReminder.prototype.security = null;

        /**
         * PriceReminder itemList.
         * @member {Array.<Qot_GetPriceReminder.IPriceReminderItem>} itemList
         * @memberof Qot_GetPriceReminder.PriceReminder
         * @instance
         */
        PriceReminder.prototype.itemList = $util.emptyArray;

        /**
         * Creates a new PriceReminder instance using the specified properties.
         * @function create
         * @memberof Qot_GetPriceReminder.PriceReminder
         * @static
         * @param {Qot_GetPriceReminder.IPriceReminder=} [properties] Properties to set
         * @returns {Qot_GetPriceReminder.PriceReminder} PriceReminder instance
         */
        PriceReminder.create = function create(properties) {
            return new PriceReminder(properties);
        };

        /**
         * Encodes the specified PriceReminder message. Does not implicitly {@link Qot_GetPriceReminder.PriceReminder.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetPriceReminder.PriceReminder
         * @static
         * @param {Qot_GetPriceReminder.IPriceReminder} message PriceReminder message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PriceReminder.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.itemList != null && message.itemList.length)
                for (var i = 0; i < message.itemList.length; ++i)
                    $root.Qot_GetPriceReminder.PriceReminderItem.encode(message.itemList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PriceReminder message, length delimited. Does not implicitly {@link Qot_GetPriceReminder.PriceReminder.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetPriceReminder.PriceReminder
         * @static
         * @param {Qot_GetPriceReminder.IPriceReminder} message PriceReminder message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PriceReminder.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PriceReminder message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetPriceReminder.PriceReminder
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetPriceReminder.PriceReminder} PriceReminder
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PriceReminder.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetPriceReminder.PriceReminder();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.itemList && message.itemList.length))
                        message.itemList = [];
                    message.itemList.push($root.Qot_GetPriceReminder.PriceReminderItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a PriceReminder message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetPriceReminder.PriceReminder
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetPriceReminder.PriceReminder} PriceReminder
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PriceReminder.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PriceReminder message.
         * @function verify
         * @memberof Qot_GetPriceReminder.PriceReminder
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PriceReminder.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.itemList != null && message.hasOwnProperty("itemList")) {
                if (!Array.isArray(message.itemList))
                    return "itemList: array expected";
                for (var i = 0; i < message.itemList.length; ++i) {
                    var error = $root.Qot_GetPriceReminder.PriceReminderItem.verify(message.itemList[i]);
                    if (error)
                        return "itemList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PriceReminder message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetPriceReminder.PriceReminder
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetPriceReminder.PriceReminder} PriceReminder
         */
        PriceReminder.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetPriceReminder.PriceReminder)
                return object;
            var message = new $root.Qot_GetPriceReminder.PriceReminder();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetPriceReminder.PriceReminder.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.itemList) {
                if (!Array.isArray(object.itemList))
                    throw TypeError(".Qot_GetPriceReminder.PriceReminder.itemList: array expected");
                message.itemList = [];
                for (var i = 0; i < object.itemList.length; ++i) {
                    if (typeof object.itemList[i] !== "object")
                        throw TypeError(".Qot_GetPriceReminder.PriceReminder.itemList: object expected");
                    message.itemList[i] = $root.Qot_GetPriceReminder.PriceReminderItem.fromObject(object.itemList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PriceReminder message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetPriceReminder.PriceReminder
         * @static
         * @param {Qot_GetPriceReminder.PriceReminder} message PriceReminder
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PriceReminder.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.itemList = [];
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.itemList && message.itemList.length) {
                object.itemList = [];
                for (var j = 0; j < message.itemList.length; ++j)
                    object.itemList[j] = $root.Qot_GetPriceReminder.PriceReminderItem.toObject(message.itemList[j], options);
            }
            return object;
        };

        /**
         * Converts this PriceReminder to JSON.
         * @function toJSON
         * @memberof Qot_GetPriceReminder.PriceReminder
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PriceReminder.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PriceReminder;
    })();

    Qot_GetPriceReminder.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetPriceReminder
         * @interface IC2S
         * @property {Qot_Common.ISecurity|null} [security] C2S security
         * @property {number|null} [market] C2S market
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetPriceReminder
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetPriceReminder.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity|null|undefined} security
         * @memberof Qot_GetPriceReminder.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * C2S market.
         * @member {number} market
         * @memberof Qot_GetPriceReminder.C2S
         * @instance
         */
        C2S.prototype.market = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetPriceReminder.C2S
         * @static
         * @param {Qot_GetPriceReminder.IC2S=} [properties] Properties to set
         * @returns {Qot_GetPriceReminder.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetPriceReminder.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetPriceReminder.C2S
         * @static
         * @param {Qot_GetPriceReminder.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.security != null && message.hasOwnProperty("security"))
                $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.market != null && message.hasOwnProperty("market"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.market);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetPriceReminder.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetPriceReminder.C2S
         * @static
         * @param {Qot_GetPriceReminder.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetPriceReminder.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetPriceReminder.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetPriceReminder.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.market = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetPriceReminder.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetPriceReminder.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetPriceReminder.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.security != null && message.hasOwnProperty("security")) {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.market != null && message.hasOwnProperty("market"))
                if (!$util.isInteger(message.market))
                    return "market: integer expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetPriceReminder.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetPriceReminder.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetPriceReminder.C2S)
                return object;
            var message = new $root.Qot_GetPriceReminder.C2S();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetPriceReminder.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.market != null)
                message.market = object.market | 0;
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetPriceReminder.C2S
         * @static
         * @param {Qot_GetPriceReminder.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.security = null;
                object.market = 0;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.market != null && message.hasOwnProperty("market"))
                object.market = message.market;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetPriceReminder.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetPriceReminder.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetPriceReminder
         * @interface IS2C
         * @property {Array.<Qot_GetPriceReminder.IPriceReminder>|null} [priceReminderList] S2C priceReminderList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetPriceReminder
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetPriceReminder.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.priceReminderList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C priceReminderList.
         * @member {Array.<Qot_GetPriceReminder.IPriceReminder>} priceReminderList
         * @memberof Qot_GetPriceReminder.S2C
         * @instance
         */
        S2C.prototype.priceReminderList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetPriceReminder.S2C
         * @static
         * @param {Qot_GetPriceReminder.IS2C=} [properties] Properties to set
         * @returns {Qot_GetPriceReminder.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetPriceReminder.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetPriceReminder.S2C
         * @static
         * @param {Qot_GetPriceReminder.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.priceReminderList != null && message.priceReminderList.length)
                for (var i = 0; i < message.priceReminderList.length; ++i)
                    $root.Qot_GetPriceReminder.PriceReminder.encode(message.priceReminderList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetPriceReminder.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetPriceReminder.S2C
         * @static
         * @param {Qot_GetPriceReminder.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetPriceReminder.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetPriceReminder.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetPriceReminder.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.priceReminderList && message.priceReminderList.length))
                        message.priceReminderList = [];
                    message.priceReminderList.push($root.Qot_GetPriceReminder.PriceReminder.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetPriceReminder.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetPriceReminder.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetPriceReminder.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.priceReminderList != null && message.hasOwnProperty("priceReminderList")) {
                if (!Array.isArray(message.priceReminderList))
                    return "priceReminderList: array expected";
                for (var i = 0; i < message.priceReminderList.length; ++i) {
                    var error = $root.Qot_GetPriceReminder.PriceReminder.verify(message.priceReminderList[i]);
                    if (error)
                        return "priceReminderList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetPriceReminder.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetPriceReminder.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetPriceReminder.S2C)
                return object;
            var message = new $root.Qot_GetPriceReminder.S2C();
            if (object.priceReminderList) {
                if (!Array.isArray(object.priceReminderList))
                    throw TypeError(".Qot_GetPriceReminder.S2C.priceReminderList: array expected");
                message.priceReminderList = [];
                for (var i = 0; i < object.priceReminderList.length; ++i) {
                    if (typeof object.priceReminderList[i] !== "object")
                        throw TypeError(".Qot_GetPriceReminder.S2C.priceReminderList: object expected");
                    message.priceReminderList[i] = $root.Qot_GetPriceReminder.PriceReminder.fromObject(object.priceReminderList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetPriceReminder.S2C
         * @static
         * @param {Qot_GetPriceReminder.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.priceReminderList = [];
            if (message.priceReminderList && message.priceReminderList.length) {
                object.priceReminderList = [];
                for (var j = 0; j < message.priceReminderList.length; ++j)
                    object.priceReminderList[j] = $root.Qot_GetPriceReminder.PriceReminder.toObject(message.priceReminderList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetPriceReminder.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetPriceReminder.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetPriceReminder
         * @interface IRequest
         * @property {Qot_GetPriceReminder.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetPriceReminder
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetPriceReminder.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetPriceReminder.IC2S} c2s
         * @memberof Qot_GetPriceReminder.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetPriceReminder.Request
         * @static
         * @param {Qot_GetPriceReminder.IRequest=} [properties] Properties to set
         * @returns {Qot_GetPriceReminder.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetPriceReminder.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetPriceReminder.Request
         * @static
         * @param {Qot_GetPriceReminder.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetPriceReminder.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetPriceReminder.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetPriceReminder.Request
         * @static
         * @param {Qot_GetPriceReminder.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetPriceReminder.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetPriceReminder.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetPriceReminder.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetPriceReminder.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetPriceReminder.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetPriceReminder.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetPriceReminder.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetPriceReminder.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetPriceReminder.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetPriceReminder.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetPriceReminder.Request)
                return object;
            var message = new $root.Qot_GetPriceReminder.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetPriceReminder.Request.c2s: object expected");
                message.c2s = $root.Qot_GetPriceReminder.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetPriceReminder.Request
         * @static
         * @param {Qot_GetPriceReminder.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetPriceReminder.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetPriceReminder.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetPriceReminder.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetPriceReminder
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetPriceReminder.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetPriceReminder
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetPriceReminder.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetPriceReminder.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetPriceReminder.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetPriceReminder.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetPriceReminder.IS2C|null|undefined} s2c
         * @memberof Qot_GetPriceReminder.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetPriceReminder.Response
         * @static
         * @param {Qot_GetPriceReminder.IResponse=} [properties] Properties to set
         * @returns {Qot_GetPriceReminder.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetPriceReminder.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetPriceReminder.Response
         * @static
         * @param {Qot_GetPriceReminder.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetPriceReminder.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetPriceReminder.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetPriceReminder.Response
         * @static
         * @param {Qot_GetPriceReminder.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetPriceReminder.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetPriceReminder.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetPriceReminder.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetPriceReminder.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetPriceReminder.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetPriceReminder.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetPriceReminder.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetPriceReminder.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetPriceReminder.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetPriceReminder.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetPriceReminder.Response)
                return object;
            var message = new $root.Qot_GetPriceReminder.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetPriceReminder.Response.s2c: object expected");
                message.s2c = $root.Qot_GetPriceReminder.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetPriceReminder.Response
         * @static
         * @param {Qot_GetPriceReminder.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetPriceReminder.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetPriceReminder.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetPriceReminder;
})();

$root.Qot_GetReference = (function() {

    /**
     * Namespace Qot_GetReference.
     * @exports Qot_GetReference
     * @namespace
     */
    var Qot_GetReference = {};

    /**
     * ReferenceType enum.
     * @name Qot_GetReference.ReferenceType
     * @enum {string}
     * @property {number} ReferenceType_Unknow=0 ReferenceType_Unknow value
     * @property {number} ReferenceType_Warrant=1 ReferenceType_Warrant value
     * @property {number} ReferenceType_Future=2 ReferenceType_Future value
     */
    Qot_GetReference.ReferenceType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ReferenceType_Unknow"] = 0;
        values[valuesById[1] = "ReferenceType_Warrant"] = 1;
        values[valuesById[2] = "ReferenceType_Future"] = 2;
        return values;
    })();

    Qot_GetReference.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetReference
         * @interface IC2S
         * @property {Qot_Common.ISecurity} security C2S security
         * @property {number} referenceType C2S referenceType
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetReference
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetReference.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetReference.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * C2S referenceType.
         * @member {number} referenceType
         * @memberof Qot_GetReference.C2S
         * @instance
         */
        C2S.prototype.referenceType = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetReference.C2S
         * @static
         * @param {Qot_GetReference.IC2S=} [properties] Properties to set
         * @returns {Qot_GetReference.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetReference.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetReference.C2S
         * @static
         * @param {Qot_GetReference.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.referenceType);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetReference.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetReference.C2S
         * @static
         * @param {Qot_GetReference.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetReference.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetReference.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetReference.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.referenceType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("referenceType"))
                throw $util.ProtocolError("missing required 'referenceType'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetReference.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetReference.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetReference.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (!$util.isInteger(message.referenceType))
                return "referenceType: integer expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetReference.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetReference.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetReference.C2S)
                return object;
            var message = new $root.Qot_GetReference.C2S();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetReference.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.referenceType != null)
                message.referenceType = object.referenceType | 0;
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetReference.C2S
         * @static
         * @param {Qot_GetReference.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.security = null;
                object.referenceType = 0;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.referenceType != null && message.hasOwnProperty("referenceType"))
                object.referenceType = message.referenceType;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetReference.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetReference.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetReference
         * @interface IS2C
         * @property {Array.<Qot_Common.ISecurityStaticInfo>|null} [staticInfoList] S2C staticInfoList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetReference
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetReference.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.staticInfoList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C staticInfoList.
         * @member {Array.<Qot_Common.ISecurityStaticInfo>} staticInfoList
         * @memberof Qot_GetReference.S2C
         * @instance
         */
        S2C.prototype.staticInfoList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetReference.S2C
         * @static
         * @param {Qot_GetReference.IS2C=} [properties] Properties to set
         * @returns {Qot_GetReference.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetReference.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetReference.S2C
         * @static
         * @param {Qot_GetReference.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.staticInfoList != null && message.staticInfoList.length)
                for (var i = 0; i < message.staticInfoList.length; ++i)
                    $root.Qot_Common.SecurityStaticInfo.encode(message.staticInfoList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetReference.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetReference.S2C
         * @static
         * @param {Qot_GetReference.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetReference.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetReference.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetReference.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    if (!(message.staticInfoList && message.staticInfoList.length))
                        message.staticInfoList = [];
                    message.staticInfoList.push($root.Qot_Common.SecurityStaticInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetReference.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetReference.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetReference.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.staticInfoList != null && message.hasOwnProperty("staticInfoList")) {
                if (!Array.isArray(message.staticInfoList))
                    return "staticInfoList: array expected";
                for (var i = 0; i < message.staticInfoList.length; ++i) {
                    var error = $root.Qot_Common.SecurityStaticInfo.verify(message.staticInfoList[i]);
                    if (error)
                        return "staticInfoList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetReference.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetReference.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetReference.S2C)
                return object;
            var message = new $root.Qot_GetReference.S2C();
            if (object.staticInfoList) {
                if (!Array.isArray(object.staticInfoList))
                    throw TypeError(".Qot_GetReference.S2C.staticInfoList: array expected");
                message.staticInfoList = [];
                for (var i = 0; i < object.staticInfoList.length; ++i) {
                    if (typeof object.staticInfoList[i] !== "object")
                        throw TypeError(".Qot_GetReference.S2C.staticInfoList: object expected");
                    message.staticInfoList[i] = $root.Qot_Common.SecurityStaticInfo.fromObject(object.staticInfoList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetReference.S2C
         * @static
         * @param {Qot_GetReference.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.staticInfoList = [];
            if (message.staticInfoList && message.staticInfoList.length) {
                object.staticInfoList = [];
                for (var j = 0; j < message.staticInfoList.length; ++j)
                    object.staticInfoList[j] = $root.Qot_Common.SecurityStaticInfo.toObject(message.staticInfoList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetReference.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetReference.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetReference
         * @interface IRequest
         * @property {Qot_GetReference.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetReference
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetReference.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetReference.IC2S} c2s
         * @memberof Qot_GetReference.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetReference.Request
         * @static
         * @param {Qot_GetReference.IRequest=} [properties] Properties to set
         * @returns {Qot_GetReference.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetReference.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetReference.Request
         * @static
         * @param {Qot_GetReference.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetReference.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetReference.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetReference.Request
         * @static
         * @param {Qot_GetReference.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetReference.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetReference.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetReference.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetReference.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetReference.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetReference.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetReference.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetReference.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetReference.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetReference.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetReference.Request)
                return object;
            var message = new $root.Qot_GetReference.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetReference.Request.c2s: object expected");
                message.c2s = $root.Qot_GetReference.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetReference.Request
         * @static
         * @param {Qot_GetReference.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetReference.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetReference.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetReference.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetReference
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetReference.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetReference
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetReference.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetReference.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetReference.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetReference.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetReference.IS2C|null|undefined} s2c
         * @memberof Qot_GetReference.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetReference.Response
         * @static
         * @param {Qot_GetReference.IResponse=} [properties] Properties to set
         * @returns {Qot_GetReference.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetReference.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetReference.Response
         * @static
         * @param {Qot_GetReference.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetReference.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetReference.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetReference.Response
         * @static
         * @param {Qot_GetReference.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetReference.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetReference.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetReference.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetReference.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetReference.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetReference.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetReference.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetReference.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetReference.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetReference.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetReference.Response)
                return object;
            var message = new $root.Qot_GetReference.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetReference.Response.s2c: object expected");
                message.s2c = $root.Qot_GetReference.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetReference.Response
         * @static
         * @param {Qot_GetReference.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetReference.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetReference.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetReference;
})();

$root.Qot_GetRehab = (function() {

    /**
     * Namespace Qot_GetRehab.
     * @exports Qot_GetRehab
     * @namespace
     */
    var Qot_GetRehab = {};

    Qot_GetRehab.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetRehab
         * @interface IC2S
         * @property {Array.<Qot_Common.ISecurity>|null} [securityList] C2S securityList
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetRehab
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetRehab.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.securityList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S securityList.
         * @member {Array.<Qot_Common.ISecurity>} securityList
         * @memberof Qot_GetRehab.C2S
         * @instance
         */
        C2S.prototype.securityList = $util.emptyArray;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetRehab.C2S
         * @static
         * @param {Qot_GetRehab.IC2S=} [properties] Properties to set
         * @returns {Qot_GetRehab.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetRehab.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetRehab.C2S
         * @static
         * @param {Qot_GetRehab.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.securityList != null && message.securityList.length)
                for (var i = 0; i < message.securityList.length; ++i)
                    $root.Qot_Common.Security.encode(message.securityList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetRehab.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetRehab.C2S
         * @static
         * @param {Qot_GetRehab.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetRehab.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetRehab.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetRehab.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.securityList && message.securityList.length))
                        message.securityList = [];
                    message.securityList.push($root.Qot_Common.Security.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetRehab.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetRehab.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetRehab.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.securityList != null && message.hasOwnProperty("securityList")) {
                if (!Array.isArray(message.securityList))
                    return "securityList: array expected";
                for (var i = 0; i < message.securityList.length; ++i) {
                    var error = $root.Qot_Common.Security.verify(message.securityList[i]);
                    if (error)
                        return "securityList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetRehab.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetRehab.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetRehab.C2S)
                return object;
            var message = new $root.Qot_GetRehab.C2S();
            if (object.securityList) {
                if (!Array.isArray(object.securityList))
                    throw TypeError(".Qot_GetRehab.C2S.securityList: array expected");
                message.securityList = [];
                for (var i = 0; i < object.securityList.length; ++i) {
                    if (typeof object.securityList[i] !== "object")
                        throw TypeError(".Qot_GetRehab.C2S.securityList: object expected");
                    message.securityList[i] = $root.Qot_Common.Security.fromObject(object.securityList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetRehab.C2S
         * @static
         * @param {Qot_GetRehab.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.securityList = [];
            if (message.securityList && message.securityList.length) {
                object.securityList = [];
                for (var j = 0; j < message.securityList.length; ++j)
                    object.securityList[j] = $root.Qot_Common.Security.toObject(message.securityList[j], options);
            }
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetRehab.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetRehab.SecurityRehab = (function() {

        /**
         * Properties of a SecurityRehab.
         * @memberof Qot_GetRehab
         * @interface ISecurityRehab
         * @property {Qot_Common.ISecurity} security SecurityRehab security
         * @property {Array.<Qot_Common.IRehab>|null} [rehabList] SecurityRehab rehabList
         */

        /**
         * Constructs a new SecurityRehab.
         * @memberof Qot_GetRehab
         * @classdesc Represents a SecurityRehab.
         * @implements ISecurityRehab
         * @constructor
         * @param {Qot_GetRehab.ISecurityRehab=} [properties] Properties to set
         */
        function SecurityRehab(properties) {
            this.rehabList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityRehab security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetRehab.SecurityRehab
         * @instance
         */
        SecurityRehab.prototype.security = null;

        /**
         * SecurityRehab rehabList.
         * @member {Array.<Qot_Common.IRehab>} rehabList
         * @memberof Qot_GetRehab.SecurityRehab
         * @instance
         */
        SecurityRehab.prototype.rehabList = $util.emptyArray;

        /**
         * Creates a new SecurityRehab instance using the specified properties.
         * @function create
         * @memberof Qot_GetRehab.SecurityRehab
         * @static
         * @param {Qot_GetRehab.ISecurityRehab=} [properties] Properties to set
         * @returns {Qot_GetRehab.SecurityRehab} SecurityRehab instance
         */
        SecurityRehab.create = function create(properties) {
            return new SecurityRehab(properties);
        };

        /**
         * Encodes the specified SecurityRehab message. Does not implicitly {@link Qot_GetRehab.SecurityRehab.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetRehab.SecurityRehab
         * @static
         * @param {Qot_GetRehab.ISecurityRehab} message SecurityRehab message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityRehab.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.rehabList != null && message.rehabList.length)
                for (var i = 0; i < message.rehabList.length; ++i)
                    $root.Qot_Common.Rehab.encode(message.rehabList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SecurityRehab message, length delimited. Does not implicitly {@link Qot_GetRehab.SecurityRehab.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetRehab.SecurityRehab
         * @static
         * @param {Qot_GetRehab.ISecurityRehab} message SecurityRehab message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityRehab.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityRehab message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetRehab.SecurityRehab
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetRehab.SecurityRehab} SecurityRehab
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityRehab.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetRehab.SecurityRehab();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.rehabList && message.rehabList.length))
                        message.rehabList = [];
                    message.rehabList.push($root.Qot_Common.Rehab.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a SecurityRehab message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetRehab.SecurityRehab
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetRehab.SecurityRehab} SecurityRehab
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityRehab.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityRehab message.
         * @function verify
         * @memberof Qot_GetRehab.SecurityRehab
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityRehab.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.rehabList != null && message.hasOwnProperty("rehabList")) {
                if (!Array.isArray(message.rehabList))
                    return "rehabList: array expected";
                for (var i = 0; i < message.rehabList.length; ++i) {
                    var error = $root.Qot_Common.Rehab.verify(message.rehabList[i]);
                    if (error)
                        return "rehabList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SecurityRehab message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetRehab.SecurityRehab
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetRehab.SecurityRehab} SecurityRehab
         */
        SecurityRehab.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetRehab.SecurityRehab)
                return object;
            var message = new $root.Qot_GetRehab.SecurityRehab();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetRehab.SecurityRehab.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.rehabList) {
                if (!Array.isArray(object.rehabList))
                    throw TypeError(".Qot_GetRehab.SecurityRehab.rehabList: array expected");
                message.rehabList = [];
                for (var i = 0; i < object.rehabList.length; ++i) {
                    if (typeof object.rehabList[i] !== "object")
                        throw TypeError(".Qot_GetRehab.SecurityRehab.rehabList: object expected");
                    message.rehabList[i] = $root.Qot_Common.Rehab.fromObject(object.rehabList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SecurityRehab message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetRehab.SecurityRehab
         * @static
         * @param {Qot_GetRehab.SecurityRehab} message SecurityRehab
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityRehab.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.rehabList = [];
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.rehabList && message.rehabList.length) {
                object.rehabList = [];
                for (var j = 0; j < message.rehabList.length; ++j)
                    object.rehabList[j] = $root.Qot_Common.Rehab.toObject(message.rehabList[j], options);
            }
            return object;
        };

        /**
         * Converts this SecurityRehab to JSON.
         * @function toJSON
         * @memberof Qot_GetRehab.SecurityRehab
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityRehab.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityRehab;
    })();

    Qot_GetRehab.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetRehab
         * @interface IS2C
         * @property {Array.<Qot_GetRehab.ISecurityRehab>|null} [securityRehabList] S2C securityRehabList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetRehab
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetRehab.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.securityRehabList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C securityRehabList.
         * @member {Array.<Qot_GetRehab.ISecurityRehab>} securityRehabList
         * @memberof Qot_GetRehab.S2C
         * @instance
         */
        S2C.prototype.securityRehabList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetRehab.S2C
         * @static
         * @param {Qot_GetRehab.IS2C=} [properties] Properties to set
         * @returns {Qot_GetRehab.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetRehab.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetRehab.S2C
         * @static
         * @param {Qot_GetRehab.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.securityRehabList != null && message.securityRehabList.length)
                for (var i = 0; i < message.securityRehabList.length; ++i)
                    $root.Qot_GetRehab.SecurityRehab.encode(message.securityRehabList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetRehab.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetRehab.S2C
         * @static
         * @param {Qot_GetRehab.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetRehab.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetRehab.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetRehab.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.securityRehabList && message.securityRehabList.length))
                        message.securityRehabList = [];
                    message.securityRehabList.push($root.Qot_GetRehab.SecurityRehab.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetRehab.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetRehab.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetRehab.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.securityRehabList != null && message.hasOwnProperty("securityRehabList")) {
                if (!Array.isArray(message.securityRehabList))
                    return "securityRehabList: array expected";
                for (var i = 0; i < message.securityRehabList.length; ++i) {
                    var error = $root.Qot_GetRehab.SecurityRehab.verify(message.securityRehabList[i]);
                    if (error)
                        return "securityRehabList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetRehab.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetRehab.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetRehab.S2C)
                return object;
            var message = new $root.Qot_GetRehab.S2C();
            if (object.securityRehabList) {
                if (!Array.isArray(object.securityRehabList))
                    throw TypeError(".Qot_GetRehab.S2C.securityRehabList: array expected");
                message.securityRehabList = [];
                for (var i = 0; i < object.securityRehabList.length; ++i) {
                    if (typeof object.securityRehabList[i] !== "object")
                        throw TypeError(".Qot_GetRehab.S2C.securityRehabList: object expected");
                    message.securityRehabList[i] = $root.Qot_GetRehab.SecurityRehab.fromObject(object.securityRehabList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetRehab.S2C
         * @static
         * @param {Qot_GetRehab.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.securityRehabList = [];
            if (message.securityRehabList && message.securityRehabList.length) {
                object.securityRehabList = [];
                for (var j = 0; j < message.securityRehabList.length; ++j)
                    object.securityRehabList[j] = $root.Qot_GetRehab.SecurityRehab.toObject(message.securityRehabList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetRehab.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetRehab.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetRehab
         * @interface IRequest
         * @property {Qot_GetRehab.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetRehab
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetRehab.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetRehab.IC2S} c2s
         * @memberof Qot_GetRehab.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetRehab.Request
         * @static
         * @param {Qot_GetRehab.IRequest=} [properties] Properties to set
         * @returns {Qot_GetRehab.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetRehab.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetRehab.Request
         * @static
         * @param {Qot_GetRehab.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetRehab.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetRehab.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetRehab.Request
         * @static
         * @param {Qot_GetRehab.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetRehab.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetRehab.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetRehab.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetRehab.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetRehab.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetRehab.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetRehab.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetRehab.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetRehab.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetRehab.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetRehab.Request)
                return object;
            var message = new $root.Qot_GetRehab.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetRehab.Request.c2s: object expected");
                message.c2s = $root.Qot_GetRehab.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetRehab.Request
         * @static
         * @param {Qot_GetRehab.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetRehab.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetRehab.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetRehab.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetRehab
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetRehab.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetRehab
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetRehab.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetRehab.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetRehab.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetRehab.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetRehab.IS2C|null|undefined} s2c
         * @memberof Qot_GetRehab.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetRehab.Response
         * @static
         * @param {Qot_GetRehab.IResponse=} [properties] Properties to set
         * @returns {Qot_GetRehab.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetRehab.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetRehab.Response
         * @static
         * @param {Qot_GetRehab.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetRehab.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetRehab.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetRehab.Response
         * @static
         * @param {Qot_GetRehab.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetRehab.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetRehab.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetRehab.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetRehab.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetRehab.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetRehab.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetRehab.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetRehab.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetRehab.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetRehab.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetRehab.Response)
                return object;
            var message = new $root.Qot_GetRehab.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetRehab.Response.s2c: object expected");
                message.s2c = $root.Qot_GetRehab.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetRehab.Response
         * @static
         * @param {Qot_GetRehab.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetRehab.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetRehab.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetRehab;
})();

$root.Qot_GetRT = (function() {

    /**
     * Namespace Qot_GetRT.
     * @exports Qot_GetRT
     * @namespace
     */
    var Qot_GetRT = {};

    Qot_GetRT.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetRT
         * @interface IC2S
         * @property {Qot_Common.ISecurity} security C2S security
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetRT
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetRT.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetRT.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetRT.C2S
         * @static
         * @param {Qot_GetRT.IC2S=} [properties] Properties to set
         * @returns {Qot_GetRT.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetRT.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetRT.C2S
         * @static
         * @param {Qot_GetRT.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetRT.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetRT.C2S
         * @static
         * @param {Qot_GetRT.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetRT.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetRT.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetRT.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetRT.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetRT.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetRT.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetRT.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetRT.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetRT.C2S)
                return object;
            var message = new $root.Qot_GetRT.C2S();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetRT.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetRT.C2S
         * @static
         * @param {Qot_GetRT.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetRT.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetRT.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetRT
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.ITimeShare>|null} [rtList] S2C rtList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetRT
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetRT.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.rtList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetRT.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C rtList.
         * @member {Array.<Qot_Common.ITimeShare>} rtList
         * @memberof Qot_GetRT.S2C
         * @instance
         */
        S2C.prototype.rtList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetRT.S2C
         * @static
         * @param {Qot_GetRT.IS2C=} [properties] Properties to set
         * @returns {Qot_GetRT.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetRT.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetRT.S2C
         * @static
         * @param {Qot_GetRT.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.rtList != null && message.rtList.length)
                for (var i = 0; i < message.rtList.length; ++i)
                    $root.Qot_Common.TimeShare.encode(message.rtList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetRT.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetRT.S2C
         * @static
         * @param {Qot_GetRT.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetRT.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetRT.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetRT.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.rtList && message.rtList.length))
                        message.rtList = [];
                    message.rtList.push($root.Qot_Common.TimeShare.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetRT.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetRT.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetRT.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.rtList != null && message.hasOwnProperty("rtList")) {
                if (!Array.isArray(message.rtList))
                    return "rtList: array expected";
                for (var i = 0; i < message.rtList.length; ++i) {
                    var error = $root.Qot_Common.TimeShare.verify(message.rtList[i]);
                    if (error)
                        return "rtList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetRT.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetRT.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetRT.S2C)
                return object;
            var message = new $root.Qot_GetRT.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetRT.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.rtList) {
                if (!Array.isArray(object.rtList))
                    throw TypeError(".Qot_GetRT.S2C.rtList: array expected");
                message.rtList = [];
                for (var i = 0; i < object.rtList.length; ++i) {
                    if (typeof object.rtList[i] !== "object")
                        throw TypeError(".Qot_GetRT.S2C.rtList: object expected");
                    message.rtList[i] = $root.Qot_Common.TimeShare.fromObject(object.rtList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetRT.S2C
         * @static
         * @param {Qot_GetRT.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.rtList = [];
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.rtList && message.rtList.length) {
                object.rtList = [];
                for (var j = 0; j < message.rtList.length; ++j)
                    object.rtList[j] = $root.Qot_Common.TimeShare.toObject(message.rtList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetRT.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetRT.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetRT
         * @interface IRequest
         * @property {Qot_GetRT.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetRT
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetRT.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetRT.IC2S} c2s
         * @memberof Qot_GetRT.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetRT.Request
         * @static
         * @param {Qot_GetRT.IRequest=} [properties] Properties to set
         * @returns {Qot_GetRT.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetRT.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetRT.Request
         * @static
         * @param {Qot_GetRT.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetRT.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetRT.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetRT.Request
         * @static
         * @param {Qot_GetRT.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetRT.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetRT.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetRT.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetRT.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetRT.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetRT.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetRT.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetRT.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetRT.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetRT.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetRT.Request)
                return object;
            var message = new $root.Qot_GetRT.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetRT.Request.c2s: object expected");
                message.c2s = $root.Qot_GetRT.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetRT.Request
         * @static
         * @param {Qot_GetRT.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetRT.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetRT.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetRT.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetRT
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetRT.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetRT
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetRT.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetRT.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetRT.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetRT.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetRT.IS2C|null|undefined} s2c
         * @memberof Qot_GetRT.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetRT.Response
         * @static
         * @param {Qot_GetRT.IResponse=} [properties] Properties to set
         * @returns {Qot_GetRT.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetRT.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetRT.Response
         * @static
         * @param {Qot_GetRT.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetRT.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetRT.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetRT.Response
         * @static
         * @param {Qot_GetRT.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetRT.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetRT.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetRT.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetRT.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetRT.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetRT.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetRT.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetRT.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetRT.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetRT.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetRT.Response)
                return object;
            var message = new $root.Qot_GetRT.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetRT.Response.s2c: object expected");
                message.s2c = $root.Qot_GetRT.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetRT.Response
         * @static
         * @param {Qot_GetRT.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetRT.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetRT.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetRT;
})();

$root.Qot_GetSecuritySnapshot = (function() {

    /**
     * Namespace Qot_GetSecuritySnapshot.
     * @exports Qot_GetSecuritySnapshot
     * @namespace
     */
    var Qot_GetSecuritySnapshot = {};

    Qot_GetSecuritySnapshot.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetSecuritySnapshot
         * @interface IC2S
         * @property {Array.<Qot_Common.ISecurity>|null} [securityList] C2S securityList
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetSecuritySnapshot
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetSecuritySnapshot.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.securityList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S securityList.
         * @member {Array.<Qot_Common.ISecurity>} securityList
         * @memberof Qot_GetSecuritySnapshot.C2S
         * @instance
         */
        C2S.prototype.securityList = $util.emptyArray;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetSecuritySnapshot.C2S
         * @static
         * @param {Qot_GetSecuritySnapshot.IC2S=} [properties] Properties to set
         * @returns {Qot_GetSecuritySnapshot.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetSecuritySnapshot.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSecuritySnapshot.C2S
         * @static
         * @param {Qot_GetSecuritySnapshot.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.securityList != null && message.securityList.length)
                for (var i = 0; i < message.securityList.length; ++i)
                    $root.Qot_Common.Security.encode(message.securityList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetSecuritySnapshot.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSecuritySnapshot.C2S
         * @static
         * @param {Qot_GetSecuritySnapshot.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSecuritySnapshot.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSecuritySnapshot.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSecuritySnapshot.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.securityList && message.securityList.length))
                        message.securityList = [];
                    message.securityList.push($root.Qot_Common.Security.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSecuritySnapshot.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSecuritySnapshot.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetSecuritySnapshot.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.securityList != null && message.hasOwnProperty("securityList")) {
                if (!Array.isArray(message.securityList))
                    return "securityList: array expected";
                for (var i = 0; i < message.securityList.length; ++i) {
                    var error = $root.Qot_Common.Security.verify(message.securityList[i]);
                    if (error)
                        return "securityList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSecuritySnapshot.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSecuritySnapshot.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSecuritySnapshot.C2S)
                return object;
            var message = new $root.Qot_GetSecuritySnapshot.C2S();
            if (object.securityList) {
                if (!Array.isArray(object.securityList))
                    throw TypeError(".Qot_GetSecuritySnapshot.C2S.securityList: array expected");
                message.securityList = [];
                for (var i = 0; i < object.securityList.length; ++i) {
                    if (typeof object.securityList[i] !== "object")
                        throw TypeError(".Qot_GetSecuritySnapshot.C2S.securityList: object expected");
                    message.securityList[i] = $root.Qot_Common.Security.fromObject(object.securityList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSecuritySnapshot.C2S
         * @static
         * @param {Qot_GetSecuritySnapshot.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.securityList = [];
            if (message.securityList && message.securityList.length) {
                object.securityList = [];
                for (var j = 0; j < message.securityList.length; ++j)
                    object.securityList[j] = $root.Qot_Common.Security.toObject(message.securityList[j], options);
            }
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetSecuritySnapshot.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetSecuritySnapshot.EquitySnapshotExData = (function() {

        /**
         * Properties of an EquitySnapshotExData.
         * @memberof Qot_GetSecuritySnapshot
         * @interface IEquitySnapshotExData
         * @property {number|Long} issuedShares EquitySnapshotExData issuedShares
         * @property {number} issuedMarketVal EquitySnapshotExData issuedMarketVal
         * @property {number} netAsset EquitySnapshotExData netAsset
         * @property {number} netProfit EquitySnapshotExData netProfit
         * @property {number} earningsPershare EquitySnapshotExData earningsPershare
         * @property {number|Long} outstandingShares EquitySnapshotExData outstandingShares
         * @property {number} outstandingMarketVal EquitySnapshotExData outstandingMarketVal
         * @property {number} netAssetPershare EquitySnapshotExData netAssetPershare
         * @property {number} eyRate EquitySnapshotExData eyRate
         * @property {number} peRate EquitySnapshotExData peRate
         * @property {number} pbRate EquitySnapshotExData pbRate
         * @property {number} peTTMRate EquitySnapshotExData peTTMRate
         * @property {number|null} [dividendTTM] EquitySnapshotExData dividendTTM
         * @property {number|null} [dividendRatioTTM] EquitySnapshotExData dividendRatioTTM
         * @property {number|null} [dividendLFY] EquitySnapshotExData dividendLFY
         * @property {number|null} [dividendLFYRatio] EquitySnapshotExData dividendLFYRatio
         */

        /**
         * Constructs a new EquitySnapshotExData.
         * @memberof Qot_GetSecuritySnapshot
         * @classdesc Represents an EquitySnapshotExData.
         * @implements IEquitySnapshotExData
         * @constructor
         * @param {Qot_GetSecuritySnapshot.IEquitySnapshotExData=} [properties] Properties to set
         */
        function EquitySnapshotExData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EquitySnapshotExData issuedShares.
         * @member {number|Long} issuedShares
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.issuedShares = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * EquitySnapshotExData issuedMarketVal.
         * @member {number} issuedMarketVal
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.issuedMarketVal = 0;

        /**
         * EquitySnapshotExData netAsset.
         * @member {number} netAsset
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.netAsset = 0;

        /**
         * EquitySnapshotExData netProfit.
         * @member {number} netProfit
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.netProfit = 0;

        /**
         * EquitySnapshotExData earningsPershare.
         * @member {number} earningsPershare
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.earningsPershare = 0;

        /**
         * EquitySnapshotExData outstandingShares.
         * @member {number|Long} outstandingShares
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.outstandingShares = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * EquitySnapshotExData outstandingMarketVal.
         * @member {number} outstandingMarketVal
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.outstandingMarketVal = 0;

        /**
         * EquitySnapshotExData netAssetPershare.
         * @member {number} netAssetPershare
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.netAssetPershare = 0;

        /**
         * EquitySnapshotExData eyRate.
         * @member {number} eyRate
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.eyRate = 0;

        /**
         * EquitySnapshotExData peRate.
         * @member {number} peRate
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.peRate = 0;

        /**
         * EquitySnapshotExData pbRate.
         * @member {number} pbRate
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.pbRate = 0;

        /**
         * EquitySnapshotExData peTTMRate.
         * @member {number} peTTMRate
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.peTTMRate = 0;

        /**
         * EquitySnapshotExData dividendTTM.
         * @member {number} dividendTTM
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.dividendTTM = 0;

        /**
         * EquitySnapshotExData dividendRatioTTM.
         * @member {number} dividendRatioTTM
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.dividendRatioTTM = 0;

        /**
         * EquitySnapshotExData dividendLFY.
         * @member {number} dividendLFY
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.dividendLFY = 0;

        /**
         * EquitySnapshotExData dividendLFYRatio.
         * @member {number} dividendLFYRatio
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.dividendLFYRatio = 0;

        /**
         * Creates a new EquitySnapshotExData instance using the specified properties.
         * @function create
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IEquitySnapshotExData=} [properties] Properties to set
         * @returns {Qot_GetSecuritySnapshot.EquitySnapshotExData} EquitySnapshotExData instance
         */
        EquitySnapshotExData.create = function create(properties) {
            return new EquitySnapshotExData(properties);
        };

        /**
         * Encodes the specified EquitySnapshotExData message. Does not implicitly {@link Qot_GetSecuritySnapshot.EquitySnapshotExData.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IEquitySnapshotExData} message EquitySnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquitySnapshotExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.issuedShares);
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.issuedMarketVal);
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.netAsset);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.netProfit);
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.earningsPershare);
            writer.uint32(/* id 6, wireType 0 =*/48).int64(message.outstandingShares);
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.outstandingMarketVal);
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.netAssetPershare);
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.eyRate);
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.peRate);
            writer.uint32(/* id 11, wireType 1 =*/89).double(message.pbRate);
            writer.uint32(/* id 12, wireType 1 =*/97).double(message.peTTMRate);
            if (message.dividendTTM != null && message.hasOwnProperty("dividendTTM"))
                writer.uint32(/* id 13, wireType 1 =*/105).double(message.dividendTTM);
            if (message.dividendRatioTTM != null && message.hasOwnProperty("dividendRatioTTM"))
                writer.uint32(/* id 14, wireType 1 =*/113).double(message.dividendRatioTTM);
            if (message.dividendLFY != null && message.hasOwnProperty("dividendLFY"))
                writer.uint32(/* id 15, wireType 1 =*/121).double(message.dividendLFY);
            if (message.dividendLFYRatio != null && message.hasOwnProperty("dividendLFYRatio"))
                writer.uint32(/* id 16, wireType 1 =*/129).double(message.dividendLFYRatio);
            return writer;
        };

        /**
         * Encodes the specified EquitySnapshotExData message, length delimited. Does not implicitly {@link Qot_GetSecuritySnapshot.EquitySnapshotExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IEquitySnapshotExData} message EquitySnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquitySnapshotExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EquitySnapshotExData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSecuritySnapshot.EquitySnapshotExData} EquitySnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquitySnapshotExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSecuritySnapshot.EquitySnapshotExData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.issuedShares = reader.int64();
                    break;
                case 2:
                    message.issuedMarketVal = reader.double();
                    break;
                case 3:
                    message.netAsset = reader.double();
                    break;
                case 4:
                    message.netProfit = reader.double();
                    break;
                case 5:
                    message.earningsPershare = reader.double();
                    break;
                case 6:
                    message.outstandingShares = reader.int64();
                    break;
                case 7:
                    message.outstandingMarketVal = reader.double();
                    break;
                case 8:
                    message.netAssetPershare = reader.double();
                    break;
                case 9:
                    message.eyRate = reader.double();
                    break;
                case 10:
                    message.peRate = reader.double();
                    break;
                case 11:
                    message.pbRate = reader.double();
                    break;
                case 12:
                    message.peTTMRate = reader.double();
                    break;
                case 13:
                    message.dividendTTM = reader.double();
                    break;
                case 14:
                    message.dividendRatioTTM = reader.double();
                    break;
                case 15:
                    message.dividendLFY = reader.double();
                    break;
                case 16:
                    message.dividendLFYRatio = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("issuedShares"))
                throw $util.ProtocolError("missing required 'issuedShares'", { instance: message });
            if (!message.hasOwnProperty("issuedMarketVal"))
                throw $util.ProtocolError("missing required 'issuedMarketVal'", { instance: message });
            if (!message.hasOwnProperty("netAsset"))
                throw $util.ProtocolError("missing required 'netAsset'", { instance: message });
            if (!message.hasOwnProperty("netProfit"))
                throw $util.ProtocolError("missing required 'netProfit'", { instance: message });
            if (!message.hasOwnProperty("earningsPershare"))
                throw $util.ProtocolError("missing required 'earningsPershare'", { instance: message });
            if (!message.hasOwnProperty("outstandingShares"))
                throw $util.ProtocolError("missing required 'outstandingShares'", { instance: message });
            if (!message.hasOwnProperty("outstandingMarketVal"))
                throw $util.ProtocolError("missing required 'outstandingMarketVal'", { instance: message });
            if (!message.hasOwnProperty("netAssetPershare"))
                throw $util.ProtocolError("missing required 'netAssetPershare'", { instance: message });
            if (!message.hasOwnProperty("eyRate"))
                throw $util.ProtocolError("missing required 'eyRate'", { instance: message });
            if (!message.hasOwnProperty("peRate"))
                throw $util.ProtocolError("missing required 'peRate'", { instance: message });
            if (!message.hasOwnProperty("pbRate"))
                throw $util.ProtocolError("missing required 'pbRate'", { instance: message });
            if (!message.hasOwnProperty("peTTMRate"))
                throw $util.ProtocolError("missing required 'peTTMRate'", { instance: message });
            return message;
        };

        /**
         * Decodes an EquitySnapshotExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSecuritySnapshot.EquitySnapshotExData} EquitySnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquitySnapshotExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EquitySnapshotExData message.
         * @function verify
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EquitySnapshotExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.issuedShares) && !(message.issuedShares && $util.isInteger(message.issuedShares.low) && $util.isInteger(message.issuedShares.high)))
                return "issuedShares: integer|Long expected";
            if (typeof message.issuedMarketVal !== "number")
                return "issuedMarketVal: number expected";
            if (typeof message.netAsset !== "number")
                return "netAsset: number expected";
            if (typeof message.netProfit !== "number")
                return "netProfit: number expected";
            if (typeof message.earningsPershare !== "number")
                return "earningsPershare: number expected";
            if (!$util.isInteger(message.outstandingShares) && !(message.outstandingShares && $util.isInteger(message.outstandingShares.low) && $util.isInteger(message.outstandingShares.high)))
                return "outstandingShares: integer|Long expected";
            if (typeof message.outstandingMarketVal !== "number")
                return "outstandingMarketVal: number expected";
            if (typeof message.netAssetPershare !== "number")
                return "netAssetPershare: number expected";
            if (typeof message.eyRate !== "number")
                return "eyRate: number expected";
            if (typeof message.peRate !== "number")
                return "peRate: number expected";
            if (typeof message.pbRate !== "number")
                return "pbRate: number expected";
            if (typeof message.peTTMRate !== "number")
                return "peTTMRate: number expected";
            if (message.dividendTTM != null && message.hasOwnProperty("dividendTTM"))
                if (typeof message.dividendTTM !== "number")
                    return "dividendTTM: number expected";
            if (message.dividendRatioTTM != null && message.hasOwnProperty("dividendRatioTTM"))
                if (typeof message.dividendRatioTTM !== "number")
                    return "dividendRatioTTM: number expected";
            if (message.dividendLFY != null && message.hasOwnProperty("dividendLFY"))
                if (typeof message.dividendLFY !== "number")
                    return "dividendLFY: number expected";
            if (message.dividendLFYRatio != null && message.hasOwnProperty("dividendLFYRatio"))
                if (typeof message.dividendLFYRatio !== "number")
                    return "dividendLFYRatio: number expected";
            return null;
        };

        /**
         * Creates an EquitySnapshotExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSecuritySnapshot.EquitySnapshotExData} EquitySnapshotExData
         */
        EquitySnapshotExData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSecuritySnapshot.EquitySnapshotExData)
                return object;
            var message = new $root.Qot_GetSecuritySnapshot.EquitySnapshotExData();
            if (object.issuedShares != null)
                if ($util.Long)
                    (message.issuedShares = $util.Long.fromValue(object.issuedShares)).unsigned = false;
                else if (typeof object.issuedShares === "string")
                    message.issuedShares = parseInt(object.issuedShares, 10);
                else if (typeof object.issuedShares === "number")
                    message.issuedShares = object.issuedShares;
                else if (typeof object.issuedShares === "object")
                    message.issuedShares = new $util.LongBits(object.issuedShares.low >>> 0, object.issuedShares.high >>> 0).toNumber();
            if (object.issuedMarketVal != null)
                message.issuedMarketVal = Number(object.issuedMarketVal);
            if (object.netAsset != null)
                message.netAsset = Number(object.netAsset);
            if (object.netProfit != null)
                message.netProfit = Number(object.netProfit);
            if (object.earningsPershare != null)
                message.earningsPershare = Number(object.earningsPershare);
            if (object.outstandingShares != null)
                if ($util.Long)
                    (message.outstandingShares = $util.Long.fromValue(object.outstandingShares)).unsigned = false;
                else if (typeof object.outstandingShares === "string")
                    message.outstandingShares = parseInt(object.outstandingShares, 10);
                else if (typeof object.outstandingShares === "number")
                    message.outstandingShares = object.outstandingShares;
                else if (typeof object.outstandingShares === "object")
                    message.outstandingShares = new $util.LongBits(object.outstandingShares.low >>> 0, object.outstandingShares.high >>> 0).toNumber();
            if (object.outstandingMarketVal != null)
                message.outstandingMarketVal = Number(object.outstandingMarketVal);
            if (object.netAssetPershare != null)
                message.netAssetPershare = Number(object.netAssetPershare);
            if (object.eyRate != null)
                message.eyRate = Number(object.eyRate);
            if (object.peRate != null)
                message.peRate = Number(object.peRate);
            if (object.pbRate != null)
                message.pbRate = Number(object.pbRate);
            if (object.peTTMRate != null)
                message.peTTMRate = Number(object.peTTMRate);
            if (object.dividendTTM != null)
                message.dividendTTM = Number(object.dividendTTM);
            if (object.dividendRatioTTM != null)
                message.dividendRatioTTM = Number(object.dividendRatioTTM);
            if (object.dividendLFY != null)
                message.dividendLFY = Number(object.dividendLFY);
            if (object.dividendLFYRatio != null)
                message.dividendLFYRatio = Number(object.dividendLFYRatio);
            return message;
        };

        /**
         * Creates a plain object from an EquitySnapshotExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.EquitySnapshotExData} message EquitySnapshotExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EquitySnapshotExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.issuedShares = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.issuedShares = options.longs === String ? "0" : 0;
                object.issuedMarketVal = 0;
                object.netAsset = 0;
                object.netProfit = 0;
                object.earningsPershare = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.outstandingShares = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.outstandingShares = options.longs === String ? "0" : 0;
                object.outstandingMarketVal = 0;
                object.netAssetPershare = 0;
                object.eyRate = 0;
                object.peRate = 0;
                object.pbRate = 0;
                object.peTTMRate = 0;
                object.dividendTTM = 0;
                object.dividendRatioTTM = 0;
                object.dividendLFY = 0;
                object.dividendLFYRatio = 0;
            }
            if (message.issuedShares != null && message.hasOwnProperty("issuedShares"))
                if (typeof message.issuedShares === "number")
                    object.issuedShares = options.longs === String ? String(message.issuedShares) : message.issuedShares;
                else
                    object.issuedShares = options.longs === String ? $util.Long.prototype.toString.call(message.issuedShares) : options.longs === Number ? new $util.LongBits(message.issuedShares.low >>> 0, message.issuedShares.high >>> 0).toNumber() : message.issuedShares;
            if (message.issuedMarketVal != null && message.hasOwnProperty("issuedMarketVal"))
                object.issuedMarketVal = options.json && !isFinite(message.issuedMarketVal) ? String(message.issuedMarketVal) : message.issuedMarketVal;
            if (message.netAsset != null && message.hasOwnProperty("netAsset"))
                object.netAsset = options.json && !isFinite(message.netAsset) ? String(message.netAsset) : message.netAsset;
            if (message.netProfit != null && message.hasOwnProperty("netProfit"))
                object.netProfit = options.json && !isFinite(message.netProfit) ? String(message.netProfit) : message.netProfit;
            if (message.earningsPershare != null && message.hasOwnProperty("earningsPershare"))
                object.earningsPershare = options.json && !isFinite(message.earningsPershare) ? String(message.earningsPershare) : message.earningsPershare;
            if (message.outstandingShares != null && message.hasOwnProperty("outstandingShares"))
                if (typeof message.outstandingShares === "number")
                    object.outstandingShares = options.longs === String ? String(message.outstandingShares) : message.outstandingShares;
                else
                    object.outstandingShares = options.longs === String ? $util.Long.prototype.toString.call(message.outstandingShares) : options.longs === Number ? new $util.LongBits(message.outstandingShares.low >>> 0, message.outstandingShares.high >>> 0).toNumber() : message.outstandingShares;
            if (message.outstandingMarketVal != null && message.hasOwnProperty("outstandingMarketVal"))
                object.outstandingMarketVal = options.json && !isFinite(message.outstandingMarketVal) ? String(message.outstandingMarketVal) : message.outstandingMarketVal;
            if (message.netAssetPershare != null && message.hasOwnProperty("netAssetPershare"))
                object.netAssetPershare = options.json && !isFinite(message.netAssetPershare) ? String(message.netAssetPershare) : message.netAssetPershare;
            if (message.eyRate != null && message.hasOwnProperty("eyRate"))
                object.eyRate = options.json && !isFinite(message.eyRate) ? String(message.eyRate) : message.eyRate;
            if (message.peRate != null && message.hasOwnProperty("peRate"))
                object.peRate = options.json && !isFinite(message.peRate) ? String(message.peRate) : message.peRate;
            if (message.pbRate != null && message.hasOwnProperty("pbRate"))
                object.pbRate = options.json && !isFinite(message.pbRate) ? String(message.pbRate) : message.pbRate;
            if (message.peTTMRate != null && message.hasOwnProperty("peTTMRate"))
                object.peTTMRate = options.json && !isFinite(message.peTTMRate) ? String(message.peTTMRate) : message.peTTMRate;
            if (message.dividendTTM != null && message.hasOwnProperty("dividendTTM"))
                object.dividendTTM = options.json && !isFinite(message.dividendTTM) ? String(message.dividendTTM) : message.dividendTTM;
            if (message.dividendRatioTTM != null && message.hasOwnProperty("dividendRatioTTM"))
                object.dividendRatioTTM = options.json && !isFinite(message.dividendRatioTTM) ? String(message.dividendRatioTTM) : message.dividendRatioTTM;
            if (message.dividendLFY != null && message.hasOwnProperty("dividendLFY"))
                object.dividendLFY = options.json && !isFinite(message.dividendLFY) ? String(message.dividendLFY) : message.dividendLFY;
            if (message.dividendLFYRatio != null && message.hasOwnProperty("dividendLFYRatio"))
                object.dividendLFYRatio = options.json && !isFinite(message.dividendLFYRatio) ? String(message.dividendLFYRatio) : message.dividendLFYRatio;
            return object;
        };

        /**
         * Converts this EquitySnapshotExData to JSON.
         * @function toJSON
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EquitySnapshotExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EquitySnapshotExData;
    })();

    Qot_GetSecuritySnapshot.WarrantSnapshotExData = (function() {

        /**
         * Properties of a WarrantSnapshotExData.
         * @memberof Qot_GetSecuritySnapshot
         * @interface IWarrantSnapshotExData
         * @property {number} conversionRate WarrantSnapshotExData conversionRate
         * @property {number} warrantType WarrantSnapshotExData warrantType
         * @property {number} strikePrice WarrantSnapshotExData strikePrice
         * @property {string} maturityTime WarrantSnapshotExData maturityTime
         * @property {string} endTradeTime WarrantSnapshotExData endTradeTime
         * @property {Qot_Common.ISecurity} owner WarrantSnapshotExData owner
         * @property {number} recoveryPrice WarrantSnapshotExData recoveryPrice
         * @property {number|Long} streetVolumn WarrantSnapshotExData streetVolumn
         * @property {number|Long} issueVolumn WarrantSnapshotExData issueVolumn
         * @property {number} streetRate WarrantSnapshotExData streetRate
         * @property {number} delta WarrantSnapshotExData delta
         * @property {number} impliedVolatility WarrantSnapshotExData impliedVolatility
         * @property {number} premium WarrantSnapshotExData premium
         * @property {number|null} [maturityTimestamp] WarrantSnapshotExData maturityTimestamp
         * @property {number|null} [endTradeTimestamp] WarrantSnapshotExData endTradeTimestamp
         * @property {number|null} [leverage] WarrantSnapshotExData leverage
         * @property {number|null} [ipop] WarrantSnapshotExData ipop
         * @property {number|null} [breakEvenPoint] WarrantSnapshotExData breakEvenPoint
         * @property {number|null} [conversionPrice] WarrantSnapshotExData conversionPrice
         * @property {number|null} [priceRecoveryRatio] WarrantSnapshotExData priceRecoveryRatio
         * @property {number|null} [score] WarrantSnapshotExData score
         * @property {number|null} [upperStrikePrice] WarrantSnapshotExData upperStrikePrice
         * @property {number|null} [lowerStrikePrice] WarrantSnapshotExData lowerStrikePrice
         * @property {number|null} [inLinePriceStatus] WarrantSnapshotExData inLinePriceStatus
         * @property {string|null} [issuerCode] WarrantSnapshotExData issuerCode
         */

        /**
         * Constructs a new WarrantSnapshotExData.
         * @memberof Qot_GetSecuritySnapshot
         * @classdesc Represents a WarrantSnapshotExData.
         * @implements IWarrantSnapshotExData
         * @constructor
         * @param {Qot_GetSecuritySnapshot.IWarrantSnapshotExData=} [properties] Properties to set
         */
        function WarrantSnapshotExData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WarrantSnapshotExData conversionRate.
         * @member {number} conversionRate
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.conversionRate = 0;

        /**
         * WarrantSnapshotExData warrantType.
         * @member {number} warrantType
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.warrantType = 0;

        /**
         * WarrantSnapshotExData strikePrice.
         * @member {number} strikePrice
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.strikePrice = 0;

        /**
         * WarrantSnapshotExData maturityTime.
         * @member {string} maturityTime
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.maturityTime = "";

        /**
         * WarrantSnapshotExData endTradeTime.
         * @member {string} endTradeTime
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.endTradeTime = "";

        /**
         * WarrantSnapshotExData owner.
         * @member {Qot_Common.ISecurity} owner
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.owner = null;

        /**
         * WarrantSnapshotExData recoveryPrice.
         * @member {number} recoveryPrice
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.recoveryPrice = 0;

        /**
         * WarrantSnapshotExData streetVolumn.
         * @member {number|Long} streetVolumn
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.streetVolumn = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * WarrantSnapshotExData issueVolumn.
         * @member {number|Long} issueVolumn
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.issueVolumn = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * WarrantSnapshotExData streetRate.
         * @member {number} streetRate
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.streetRate = 0;

        /**
         * WarrantSnapshotExData delta.
         * @member {number} delta
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.delta = 0;

        /**
         * WarrantSnapshotExData impliedVolatility.
         * @member {number} impliedVolatility
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.impliedVolatility = 0;

        /**
         * WarrantSnapshotExData premium.
         * @member {number} premium
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.premium = 0;

        /**
         * WarrantSnapshotExData maturityTimestamp.
         * @member {number} maturityTimestamp
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.maturityTimestamp = 0;

        /**
         * WarrantSnapshotExData endTradeTimestamp.
         * @member {number} endTradeTimestamp
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.endTradeTimestamp = 0;

        /**
         * WarrantSnapshotExData leverage.
         * @member {number} leverage
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.leverage = 0;

        /**
         * WarrantSnapshotExData ipop.
         * @member {number} ipop
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.ipop = 0;

        /**
         * WarrantSnapshotExData breakEvenPoint.
         * @member {number} breakEvenPoint
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.breakEvenPoint = 0;

        /**
         * WarrantSnapshotExData conversionPrice.
         * @member {number} conversionPrice
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.conversionPrice = 0;

        /**
         * WarrantSnapshotExData priceRecoveryRatio.
         * @member {number} priceRecoveryRatio
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.priceRecoveryRatio = 0;

        /**
         * WarrantSnapshotExData score.
         * @member {number} score
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.score = 0;

        /**
         * WarrantSnapshotExData upperStrikePrice.
         * @member {number} upperStrikePrice
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.upperStrikePrice = 0;

        /**
         * WarrantSnapshotExData lowerStrikePrice.
         * @member {number} lowerStrikePrice
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.lowerStrikePrice = 0;

        /**
         * WarrantSnapshotExData inLinePriceStatus.
         * @member {number} inLinePriceStatus
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.inLinePriceStatus = 0;

        /**
         * WarrantSnapshotExData issuerCode.
         * @member {string} issuerCode
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.issuerCode = "";

        /**
         * Creates a new WarrantSnapshotExData instance using the specified properties.
         * @function create
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IWarrantSnapshotExData=} [properties] Properties to set
         * @returns {Qot_GetSecuritySnapshot.WarrantSnapshotExData} WarrantSnapshotExData instance
         */
        WarrantSnapshotExData.create = function create(properties) {
            return new WarrantSnapshotExData(properties);
        };

        /**
         * Encodes the specified WarrantSnapshotExData message. Does not implicitly {@link Qot_GetSecuritySnapshot.WarrantSnapshotExData.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IWarrantSnapshotExData} message WarrantSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarrantSnapshotExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.conversionRate);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.warrantType);
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.strikePrice);
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.maturityTime);
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.endTradeTime);
            $root.Qot_Common.Security.encode(message.owner, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.recoveryPrice);
            writer.uint32(/* id 8, wireType 0 =*/64).int64(message.streetVolumn);
            writer.uint32(/* id 9, wireType 0 =*/72).int64(message.issueVolumn);
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.streetRate);
            writer.uint32(/* id 11, wireType 1 =*/89).double(message.delta);
            writer.uint32(/* id 12, wireType 1 =*/97).double(message.impliedVolatility);
            writer.uint32(/* id 13, wireType 1 =*/105).double(message.premium);
            if (message.maturityTimestamp != null && message.hasOwnProperty("maturityTimestamp"))
                writer.uint32(/* id 14, wireType 1 =*/113).double(message.maturityTimestamp);
            if (message.endTradeTimestamp != null && message.hasOwnProperty("endTradeTimestamp"))
                writer.uint32(/* id 15, wireType 1 =*/121).double(message.endTradeTimestamp);
            if (message.leverage != null && message.hasOwnProperty("leverage"))
                writer.uint32(/* id 16, wireType 1 =*/129).double(message.leverage);
            if (message.ipop != null && message.hasOwnProperty("ipop"))
                writer.uint32(/* id 17, wireType 1 =*/137).double(message.ipop);
            if (message.breakEvenPoint != null && message.hasOwnProperty("breakEvenPoint"))
                writer.uint32(/* id 18, wireType 1 =*/145).double(message.breakEvenPoint);
            if (message.conversionPrice != null && message.hasOwnProperty("conversionPrice"))
                writer.uint32(/* id 19, wireType 1 =*/153).double(message.conversionPrice);
            if (message.priceRecoveryRatio != null && message.hasOwnProperty("priceRecoveryRatio"))
                writer.uint32(/* id 20, wireType 1 =*/161).double(message.priceRecoveryRatio);
            if (message.score != null && message.hasOwnProperty("score"))
                writer.uint32(/* id 21, wireType 1 =*/169).double(message.score);
            if (message.upperStrikePrice != null && message.hasOwnProperty("upperStrikePrice"))
                writer.uint32(/* id 22, wireType 1 =*/177).double(message.upperStrikePrice);
            if (message.lowerStrikePrice != null && message.hasOwnProperty("lowerStrikePrice"))
                writer.uint32(/* id 23, wireType 1 =*/185).double(message.lowerStrikePrice);
            if (message.inLinePriceStatus != null && message.hasOwnProperty("inLinePriceStatus"))
                writer.uint32(/* id 24, wireType 0 =*/192).int32(message.inLinePriceStatus);
            if (message.issuerCode != null && message.hasOwnProperty("issuerCode"))
                writer.uint32(/* id 25, wireType 2 =*/202).string(message.issuerCode);
            return writer;
        };

        /**
         * Encodes the specified WarrantSnapshotExData message, length delimited. Does not implicitly {@link Qot_GetSecuritySnapshot.WarrantSnapshotExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IWarrantSnapshotExData} message WarrantSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarrantSnapshotExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WarrantSnapshotExData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSecuritySnapshot.WarrantSnapshotExData} WarrantSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarrantSnapshotExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSecuritySnapshot.WarrantSnapshotExData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.conversionRate = reader.double();
                    break;
                case 2:
                    message.warrantType = reader.int32();
                    break;
                case 3:
                    message.strikePrice = reader.double();
                    break;
                case 4:
                    message.maturityTime = reader.string();
                    break;
                case 5:
                    message.endTradeTime = reader.string();
                    break;
                case 6:
                    message.owner = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.recoveryPrice = reader.double();
                    break;
                case 8:
                    message.streetVolumn = reader.int64();
                    break;
                case 9:
                    message.issueVolumn = reader.int64();
                    break;
                case 10:
                    message.streetRate = reader.double();
                    break;
                case 11:
                    message.delta = reader.double();
                    break;
                case 12:
                    message.impliedVolatility = reader.double();
                    break;
                case 13:
                    message.premium = reader.double();
                    break;
                case 14:
                    message.maturityTimestamp = reader.double();
                    break;
                case 15:
                    message.endTradeTimestamp = reader.double();
                    break;
                case 16:
                    message.leverage = reader.double();
                    break;
                case 17:
                    message.ipop = reader.double();
                    break;
                case 18:
                    message.breakEvenPoint = reader.double();
                    break;
                case 19:
                    message.conversionPrice = reader.double();
                    break;
                case 20:
                    message.priceRecoveryRatio = reader.double();
                    break;
                case 21:
                    message.score = reader.double();
                    break;
                case 22:
                    message.upperStrikePrice = reader.double();
                    break;
                case 23:
                    message.lowerStrikePrice = reader.double();
                    break;
                case 24:
                    message.inLinePriceStatus = reader.int32();
                    break;
                case 25:
                    message.issuerCode = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("conversionRate"))
                throw $util.ProtocolError("missing required 'conversionRate'", { instance: message });
            if (!message.hasOwnProperty("warrantType"))
                throw $util.ProtocolError("missing required 'warrantType'", { instance: message });
            if (!message.hasOwnProperty("strikePrice"))
                throw $util.ProtocolError("missing required 'strikePrice'", { instance: message });
            if (!message.hasOwnProperty("maturityTime"))
                throw $util.ProtocolError("missing required 'maturityTime'", { instance: message });
            if (!message.hasOwnProperty("endTradeTime"))
                throw $util.ProtocolError("missing required 'endTradeTime'", { instance: message });
            if (!message.hasOwnProperty("owner"))
                throw $util.ProtocolError("missing required 'owner'", { instance: message });
            if (!message.hasOwnProperty("recoveryPrice"))
                throw $util.ProtocolError("missing required 'recoveryPrice'", { instance: message });
            if (!message.hasOwnProperty("streetVolumn"))
                throw $util.ProtocolError("missing required 'streetVolumn'", { instance: message });
            if (!message.hasOwnProperty("issueVolumn"))
                throw $util.ProtocolError("missing required 'issueVolumn'", { instance: message });
            if (!message.hasOwnProperty("streetRate"))
                throw $util.ProtocolError("missing required 'streetRate'", { instance: message });
            if (!message.hasOwnProperty("delta"))
                throw $util.ProtocolError("missing required 'delta'", { instance: message });
            if (!message.hasOwnProperty("impliedVolatility"))
                throw $util.ProtocolError("missing required 'impliedVolatility'", { instance: message });
            if (!message.hasOwnProperty("premium"))
                throw $util.ProtocolError("missing required 'premium'", { instance: message });
            return message;
        };

        /**
         * Decodes a WarrantSnapshotExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSecuritySnapshot.WarrantSnapshotExData} WarrantSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarrantSnapshotExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WarrantSnapshotExData message.
         * @function verify
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WarrantSnapshotExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.conversionRate !== "number")
                return "conversionRate: number expected";
            if (!$util.isInteger(message.warrantType))
                return "warrantType: integer expected";
            if (typeof message.strikePrice !== "number")
                return "strikePrice: number expected";
            if (!$util.isString(message.maturityTime))
                return "maturityTime: string expected";
            if (!$util.isString(message.endTradeTime))
                return "endTradeTime: string expected";
            {
                var error = $root.Qot_Common.Security.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            if (typeof message.recoveryPrice !== "number")
                return "recoveryPrice: number expected";
            if (!$util.isInteger(message.streetVolumn) && !(message.streetVolumn && $util.isInteger(message.streetVolumn.low) && $util.isInteger(message.streetVolumn.high)))
                return "streetVolumn: integer|Long expected";
            if (!$util.isInteger(message.issueVolumn) && !(message.issueVolumn && $util.isInteger(message.issueVolumn.low) && $util.isInteger(message.issueVolumn.high)))
                return "issueVolumn: integer|Long expected";
            if (typeof message.streetRate !== "number")
                return "streetRate: number expected";
            if (typeof message.delta !== "number")
                return "delta: number expected";
            if (typeof message.impliedVolatility !== "number")
                return "impliedVolatility: number expected";
            if (typeof message.premium !== "number")
                return "premium: number expected";
            if (message.maturityTimestamp != null && message.hasOwnProperty("maturityTimestamp"))
                if (typeof message.maturityTimestamp !== "number")
                    return "maturityTimestamp: number expected";
            if (message.endTradeTimestamp != null && message.hasOwnProperty("endTradeTimestamp"))
                if (typeof message.endTradeTimestamp !== "number")
                    return "endTradeTimestamp: number expected";
            if (message.leverage != null && message.hasOwnProperty("leverage"))
                if (typeof message.leverage !== "number")
                    return "leverage: number expected";
            if (message.ipop != null && message.hasOwnProperty("ipop"))
                if (typeof message.ipop !== "number")
                    return "ipop: number expected";
            if (message.breakEvenPoint != null && message.hasOwnProperty("breakEvenPoint"))
                if (typeof message.breakEvenPoint !== "number")
                    return "breakEvenPoint: number expected";
            if (message.conversionPrice != null && message.hasOwnProperty("conversionPrice"))
                if (typeof message.conversionPrice !== "number")
                    return "conversionPrice: number expected";
            if (message.priceRecoveryRatio != null && message.hasOwnProperty("priceRecoveryRatio"))
                if (typeof message.priceRecoveryRatio !== "number")
                    return "priceRecoveryRatio: number expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (typeof message.score !== "number")
                    return "score: number expected";
            if (message.upperStrikePrice != null && message.hasOwnProperty("upperStrikePrice"))
                if (typeof message.upperStrikePrice !== "number")
                    return "upperStrikePrice: number expected";
            if (message.lowerStrikePrice != null && message.hasOwnProperty("lowerStrikePrice"))
                if (typeof message.lowerStrikePrice !== "number")
                    return "lowerStrikePrice: number expected";
            if (message.inLinePriceStatus != null && message.hasOwnProperty("inLinePriceStatus"))
                if (!$util.isInteger(message.inLinePriceStatus))
                    return "inLinePriceStatus: integer expected";
            if (message.issuerCode != null && message.hasOwnProperty("issuerCode"))
                if (!$util.isString(message.issuerCode))
                    return "issuerCode: string expected";
            return null;
        };

        /**
         * Creates a WarrantSnapshotExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSecuritySnapshot.WarrantSnapshotExData} WarrantSnapshotExData
         */
        WarrantSnapshotExData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSecuritySnapshot.WarrantSnapshotExData)
                return object;
            var message = new $root.Qot_GetSecuritySnapshot.WarrantSnapshotExData();
            if (object.conversionRate != null)
                message.conversionRate = Number(object.conversionRate);
            if (object.warrantType != null)
                message.warrantType = object.warrantType | 0;
            if (object.strikePrice != null)
                message.strikePrice = Number(object.strikePrice);
            if (object.maturityTime != null)
                message.maturityTime = String(object.maturityTime);
            if (object.endTradeTime != null)
                message.endTradeTime = String(object.endTradeTime);
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".Qot_GetSecuritySnapshot.WarrantSnapshotExData.owner: object expected");
                message.owner = $root.Qot_Common.Security.fromObject(object.owner);
            }
            if (object.recoveryPrice != null)
                message.recoveryPrice = Number(object.recoveryPrice);
            if (object.streetVolumn != null)
                if ($util.Long)
                    (message.streetVolumn = $util.Long.fromValue(object.streetVolumn)).unsigned = false;
                else if (typeof object.streetVolumn === "string")
                    message.streetVolumn = parseInt(object.streetVolumn, 10);
                else if (typeof object.streetVolumn === "number")
                    message.streetVolumn = object.streetVolumn;
                else if (typeof object.streetVolumn === "object")
                    message.streetVolumn = new $util.LongBits(object.streetVolumn.low >>> 0, object.streetVolumn.high >>> 0).toNumber();
            if (object.issueVolumn != null)
                if ($util.Long)
                    (message.issueVolumn = $util.Long.fromValue(object.issueVolumn)).unsigned = false;
                else if (typeof object.issueVolumn === "string")
                    message.issueVolumn = parseInt(object.issueVolumn, 10);
                else if (typeof object.issueVolumn === "number")
                    message.issueVolumn = object.issueVolumn;
                else if (typeof object.issueVolumn === "object")
                    message.issueVolumn = new $util.LongBits(object.issueVolumn.low >>> 0, object.issueVolumn.high >>> 0).toNumber();
            if (object.streetRate != null)
                message.streetRate = Number(object.streetRate);
            if (object.delta != null)
                message.delta = Number(object.delta);
            if (object.impliedVolatility != null)
                message.impliedVolatility = Number(object.impliedVolatility);
            if (object.premium != null)
                message.premium = Number(object.premium);
            if (object.maturityTimestamp != null)
                message.maturityTimestamp = Number(object.maturityTimestamp);
            if (object.endTradeTimestamp != null)
                message.endTradeTimestamp = Number(object.endTradeTimestamp);
            if (object.leverage != null)
                message.leverage = Number(object.leverage);
            if (object.ipop != null)
                message.ipop = Number(object.ipop);
            if (object.breakEvenPoint != null)
                message.breakEvenPoint = Number(object.breakEvenPoint);
            if (object.conversionPrice != null)
                message.conversionPrice = Number(object.conversionPrice);
            if (object.priceRecoveryRatio != null)
                message.priceRecoveryRatio = Number(object.priceRecoveryRatio);
            if (object.score != null)
                message.score = Number(object.score);
            if (object.upperStrikePrice != null)
                message.upperStrikePrice = Number(object.upperStrikePrice);
            if (object.lowerStrikePrice != null)
                message.lowerStrikePrice = Number(object.lowerStrikePrice);
            if (object.inLinePriceStatus != null)
                message.inLinePriceStatus = object.inLinePriceStatus | 0;
            if (object.issuerCode != null)
                message.issuerCode = String(object.issuerCode);
            return message;
        };

        /**
         * Creates a plain object from a WarrantSnapshotExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.WarrantSnapshotExData} message WarrantSnapshotExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WarrantSnapshotExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.conversionRate = 0;
                object.warrantType = 0;
                object.strikePrice = 0;
                object.maturityTime = "";
                object.endTradeTime = "";
                object.owner = null;
                object.recoveryPrice = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.streetVolumn = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.streetVolumn = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.issueVolumn = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.issueVolumn = options.longs === String ? "0" : 0;
                object.streetRate = 0;
                object.delta = 0;
                object.impliedVolatility = 0;
                object.premium = 0;
                object.maturityTimestamp = 0;
                object.endTradeTimestamp = 0;
                object.leverage = 0;
                object.ipop = 0;
                object.breakEvenPoint = 0;
                object.conversionPrice = 0;
                object.priceRecoveryRatio = 0;
                object.score = 0;
                object.upperStrikePrice = 0;
                object.lowerStrikePrice = 0;
                object.inLinePriceStatus = 0;
                object.issuerCode = "";
            }
            if (message.conversionRate != null && message.hasOwnProperty("conversionRate"))
                object.conversionRate = options.json && !isFinite(message.conversionRate) ? String(message.conversionRate) : message.conversionRate;
            if (message.warrantType != null && message.hasOwnProperty("warrantType"))
                object.warrantType = message.warrantType;
            if (message.strikePrice != null && message.hasOwnProperty("strikePrice"))
                object.strikePrice = options.json && !isFinite(message.strikePrice) ? String(message.strikePrice) : message.strikePrice;
            if (message.maturityTime != null && message.hasOwnProperty("maturityTime"))
                object.maturityTime = message.maturityTime;
            if (message.endTradeTime != null && message.hasOwnProperty("endTradeTime"))
                object.endTradeTime = message.endTradeTime;
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.Qot_Common.Security.toObject(message.owner, options);
            if (message.recoveryPrice != null && message.hasOwnProperty("recoveryPrice"))
                object.recoveryPrice = options.json && !isFinite(message.recoveryPrice) ? String(message.recoveryPrice) : message.recoveryPrice;
            if (message.streetVolumn != null && message.hasOwnProperty("streetVolumn"))
                if (typeof message.streetVolumn === "number")
                    object.streetVolumn = options.longs === String ? String(message.streetVolumn) : message.streetVolumn;
                else
                    object.streetVolumn = options.longs === String ? $util.Long.prototype.toString.call(message.streetVolumn) : options.longs === Number ? new $util.LongBits(message.streetVolumn.low >>> 0, message.streetVolumn.high >>> 0).toNumber() : message.streetVolumn;
            if (message.issueVolumn != null && message.hasOwnProperty("issueVolumn"))
                if (typeof message.issueVolumn === "number")
                    object.issueVolumn = options.longs === String ? String(message.issueVolumn) : message.issueVolumn;
                else
                    object.issueVolumn = options.longs === String ? $util.Long.prototype.toString.call(message.issueVolumn) : options.longs === Number ? new $util.LongBits(message.issueVolumn.low >>> 0, message.issueVolumn.high >>> 0).toNumber() : message.issueVolumn;
            if (message.streetRate != null && message.hasOwnProperty("streetRate"))
                object.streetRate = options.json && !isFinite(message.streetRate) ? String(message.streetRate) : message.streetRate;
            if (message.delta != null && message.hasOwnProperty("delta"))
                object.delta = options.json && !isFinite(message.delta) ? String(message.delta) : message.delta;
            if (message.impliedVolatility != null && message.hasOwnProperty("impliedVolatility"))
                object.impliedVolatility = options.json && !isFinite(message.impliedVolatility) ? String(message.impliedVolatility) : message.impliedVolatility;
            if (message.premium != null && message.hasOwnProperty("premium"))
                object.premium = options.json && !isFinite(message.premium) ? String(message.premium) : message.premium;
            if (message.maturityTimestamp != null && message.hasOwnProperty("maturityTimestamp"))
                object.maturityTimestamp = options.json && !isFinite(message.maturityTimestamp) ? String(message.maturityTimestamp) : message.maturityTimestamp;
            if (message.endTradeTimestamp != null && message.hasOwnProperty("endTradeTimestamp"))
                object.endTradeTimestamp = options.json && !isFinite(message.endTradeTimestamp) ? String(message.endTradeTimestamp) : message.endTradeTimestamp;
            if (message.leverage != null && message.hasOwnProperty("leverage"))
                object.leverage = options.json && !isFinite(message.leverage) ? String(message.leverage) : message.leverage;
            if (message.ipop != null && message.hasOwnProperty("ipop"))
                object.ipop = options.json && !isFinite(message.ipop) ? String(message.ipop) : message.ipop;
            if (message.breakEvenPoint != null && message.hasOwnProperty("breakEvenPoint"))
                object.breakEvenPoint = options.json && !isFinite(message.breakEvenPoint) ? String(message.breakEvenPoint) : message.breakEvenPoint;
            if (message.conversionPrice != null && message.hasOwnProperty("conversionPrice"))
                object.conversionPrice = options.json && !isFinite(message.conversionPrice) ? String(message.conversionPrice) : message.conversionPrice;
            if (message.priceRecoveryRatio != null && message.hasOwnProperty("priceRecoveryRatio"))
                object.priceRecoveryRatio = options.json && !isFinite(message.priceRecoveryRatio) ? String(message.priceRecoveryRatio) : message.priceRecoveryRatio;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = options.json && !isFinite(message.score) ? String(message.score) : message.score;
            if (message.upperStrikePrice != null && message.hasOwnProperty("upperStrikePrice"))
                object.upperStrikePrice = options.json && !isFinite(message.upperStrikePrice) ? String(message.upperStrikePrice) : message.upperStrikePrice;
            if (message.lowerStrikePrice != null && message.hasOwnProperty("lowerStrikePrice"))
                object.lowerStrikePrice = options.json && !isFinite(message.lowerStrikePrice) ? String(message.lowerStrikePrice) : message.lowerStrikePrice;
            if (message.inLinePriceStatus != null && message.hasOwnProperty("inLinePriceStatus"))
                object.inLinePriceStatus = message.inLinePriceStatus;
            if (message.issuerCode != null && message.hasOwnProperty("issuerCode"))
                object.issuerCode = message.issuerCode;
            return object;
        };

        /**
         * Converts this WarrantSnapshotExData to JSON.
         * @function toJSON
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WarrantSnapshotExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WarrantSnapshotExData;
    })();

    Qot_GetSecuritySnapshot.OptionSnapshotExData = (function() {

        /**
         * Properties of an OptionSnapshotExData.
         * @memberof Qot_GetSecuritySnapshot
         * @interface IOptionSnapshotExData
         * @property {number} type OptionSnapshotExData type
         * @property {Qot_Common.ISecurity} owner OptionSnapshotExData owner
         * @property {string} strikeTime OptionSnapshotExData strikeTime
         * @property {number} strikePrice OptionSnapshotExData strikePrice
         * @property {number} contractSize OptionSnapshotExData contractSize
         * @property {number} openInterest OptionSnapshotExData openInterest
         * @property {number} impliedVolatility OptionSnapshotExData impliedVolatility
         * @property {number} premium OptionSnapshotExData premium
         * @property {number} delta OptionSnapshotExData delta
         * @property {number} gamma OptionSnapshotExData gamma
         * @property {number} vega OptionSnapshotExData vega
         * @property {number} theta OptionSnapshotExData theta
         * @property {number} rho OptionSnapshotExData rho
         * @property {number|null} [strikeTimestamp] OptionSnapshotExData strikeTimestamp
         * @property {number|null} [indexOptionType] OptionSnapshotExData indexOptionType
         * @property {number|null} [netOpenInterest] OptionSnapshotExData netOpenInterest
         * @property {number|null} [expiryDateDistance] OptionSnapshotExData expiryDateDistance
         * @property {number|null} [contractNominalValue] OptionSnapshotExData contractNominalValue
         * @property {number|null} [ownerLotMultiplier] OptionSnapshotExData ownerLotMultiplier
         * @property {number|null} [optionAreaType] OptionSnapshotExData optionAreaType
         * @property {number|null} [contractMultiplier] OptionSnapshotExData contractMultiplier
         */

        /**
         * Constructs a new OptionSnapshotExData.
         * @memberof Qot_GetSecuritySnapshot
         * @classdesc Represents an OptionSnapshotExData.
         * @implements IOptionSnapshotExData
         * @constructor
         * @param {Qot_GetSecuritySnapshot.IOptionSnapshotExData=} [properties] Properties to set
         */
        function OptionSnapshotExData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OptionSnapshotExData type.
         * @member {number} type
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.type = 0;

        /**
         * OptionSnapshotExData owner.
         * @member {Qot_Common.ISecurity} owner
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.owner = null;

        /**
         * OptionSnapshotExData strikeTime.
         * @member {string} strikeTime
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.strikeTime = "";

        /**
         * OptionSnapshotExData strikePrice.
         * @member {number} strikePrice
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.strikePrice = 0;

        /**
         * OptionSnapshotExData contractSize.
         * @member {number} contractSize
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.contractSize = 0;

        /**
         * OptionSnapshotExData openInterest.
         * @member {number} openInterest
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.openInterest = 0;

        /**
         * OptionSnapshotExData impliedVolatility.
         * @member {number} impliedVolatility
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.impliedVolatility = 0;

        /**
         * OptionSnapshotExData premium.
         * @member {number} premium
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.premium = 0;

        /**
         * OptionSnapshotExData delta.
         * @member {number} delta
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.delta = 0;

        /**
         * OptionSnapshotExData gamma.
         * @member {number} gamma
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.gamma = 0;

        /**
         * OptionSnapshotExData vega.
         * @member {number} vega
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.vega = 0;

        /**
         * OptionSnapshotExData theta.
         * @member {number} theta
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.theta = 0;

        /**
         * OptionSnapshotExData rho.
         * @member {number} rho
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.rho = 0;

        /**
         * OptionSnapshotExData strikeTimestamp.
         * @member {number} strikeTimestamp
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.strikeTimestamp = 0;

        /**
         * OptionSnapshotExData indexOptionType.
         * @member {number} indexOptionType
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.indexOptionType = 0;

        /**
         * OptionSnapshotExData netOpenInterest.
         * @member {number} netOpenInterest
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.netOpenInterest = 0;

        /**
         * OptionSnapshotExData expiryDateDistance.
         * @member {number} expiryDateDistance
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.expiryDateDistance = 0;

        /**
         * OptionSnapshotExData contractNominalValue.
         * @member {number} contractNominalValue
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.contractNominalValue = 0;

        /**
         * OptionSnapshotExData ownerLotMultiplier.
         * @member {number} ownerLotMultiplier
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.ownerLotMultiplier = 0;

        /**
         * OptionSnapshotExData optionAreaType.
         * @member {number} optionAreaType
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.optionAreaType = 0;

        /**
         * OptionSnapshotExData contractMultiplier.
         * @member {number} contractMultiplier
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.contractMultiplier = 0;

        /**
         * Creates a new OptionSnapshotExData instance using the specified properties.
         * @function create
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IOptionSnapshotExData=} [properties] Properties to set
         * @returns {Qot_GetSecuritySnapshot.OptionSnapshotExData} OptionSnapshotExData instance
         */
        OptionSnapshotExData.create = function create(properties) {
            return new OptionSnapshotExData(properties);
        };

        /**
         * Encodes the specified OptionSnapshotExData message. Does not implicitly {@link Qot_GetSecuritySnapshot.OptionSnapshotExData.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IOptionSnapshotExData} message OptionSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionSnapshotExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            $root.Qot_Common.Security.encode(message.owner, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.strikeTime);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.strikePrice);
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.contractSize);
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.openInterest);
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.impliedVolatility);
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.premium);
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.delta);
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.gamma);
            writer.uint32(/* id 11, wireType 1 =*/89).double(message.vega);
            writer.uint32(/* id 12, wireType 1 =*/97).double(message.theta);
            writer.uint32(/* id 13, wireType 1 =*/105).double(message.rho);
            if (message.strikeTimestamp != null && message.hasOwnProperty("strikeTimestamp"))
                writer.uint32(/* id 14, wireType 1 =*/113).double(message.strikeTimestamp);
            if (message.indexOptionType != null && message.hasOwnProperty("indexOptionType"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.indexOptionType);
            if (message.netOpenInterest != null && message.hasOwnProperty("netOpenInterest"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.netOpenInterest);
            if (message.expiryDateDistance != null && message.hasOwnProperty("expiryDateDistance"))
                writer.uint32(/* id 17, wireType 0 =*/136).int32(message.expiryDateDistance);
            if (message.contractNominalValue != null && message.hasOwnProperty("contractNominalValue"))
                writer.uint32(/* id 18, wireType 1 =*/145).double(message.contractNominalValue);
            if (message.ownerLotMultiplier != null && message.hasOwnProperty("ownerLotMultiplier"))
                writer.uint32(/* id 19, wireType 1 =*/153).double(message.ownerLotMultiplier);
            if (message.optionAreaType != null && message.hasOwnProperty("optionAreaType"))
                writer.uint32(/* id 20, wireType 0 =*/160).int32(message.optionAreaType);
            if (message.contractMultiplier != null && message.hasOwnProperty("contractMultiplier"))
                writer.uint32(/* id 21, wireType 1 =*/169).double(message.contractMultiplier);
            return writer;
        };

        /**
         * Encodes the specified OptionSnapshotExData message, length delimited. Does not implicitly {@link Qot_GetSecuritySnapshot.OptionSnapshotExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IOptionSnapshotExData} message OptionSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionSnapshotExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OptionSnapshotExData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSecuritySnapshot.OptionSnapshotExData} OptionSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionSnapshotExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSecuritySnapshot.OptionSnapshotExData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.owner = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.strikeTime = reader.string();
                    break;
                case 4:
                    message.strikePrice = reader.double();
                    break;
                case 5:
                    message.contractSize = reader.int32();
                    break;
                case 6:
                    message.openInterest = reader.int32();
                    break;
                case 7:
                    message.impliedVolatility = reader.double();
                    break;
                case 8:
                    message.premium = reader.double();
                    break;
                case 9:
                    message.delta = reader.double();
                    break;
                case 10:
                    message.gamma = reader.double();
                    break;
                case 11:
                    message.vega = reader.double();
                    break;
                case 12:
                    message.theta = reader.double();
                    break;
                case 13:
                    message.rho = reader.double();
                    break;
                case 14:
                    message.strikeTimestamp = reader.double();
                    break;
                case 15:
                    message.indexOptionType = reader.int32();
                    break;
                case 16:
                    message.netOpenInterest = reader.int32();
                    break;
                case 17:
                    message.expiryDateDistance = reader.int32();
                    break;
                case 18:
                    message.contractNominalValue = reader.double();
                    break;
                case 19:
                    message.ownerLotMultiplier = reader.double();
                    break;
                case 20:
                    message.optionAreaType = reader.int32();
                    break;
                case 21:
                    message.contractMultiplier = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("owner"))
                throw $util.ProtocolError("missing required 'owner'", { instance: message });
            if (!message.hasOwnProperty("strikeTime"))
                throw $util.ProtocolError("missing required 'strikeTime'", { instance: message });
            if (!message.hasOwnProperty("strikePrice"))
                throw $util.ProtocolError("missing required 'strikePrice'", { instance: message });
            if (!message.hasOwnProperty("contractSize"))
                throw $util.ProtocolError("missing required 'contractSize'", { instance: message });
            if (!message.hasOwnProperty("openInterest"))
                throw $util.ProtocolError("missing required 'openInterest'", { instance: message });
            if (!message.hasOwnProperty("impliedVolatility"))
                throw $util.ProtocolError("missing required 'impliedVolatility'", { instance: message });
            if (!message.hasOwnProperty("premium"))
                throw $util.ProtocolError("missing required 'premium'", { instance: message });
            if (!message.hasOwnProperty("delta"))
                throw $util.ProtocolError("missing required 'delta'", { instance: message });
            if (!message.hasOwnProperty("gamma"))
                throw $util.ProtocolError("missing required 'gamma'", { instance: message });
            if (!message.hasOwnProperty("vega"))
                throw $util.ProtocolError("missing required 'vega'", { instance: message });
            if (!message.hasOwnProperty("theta"))
                throw $util.ProtocolError("missing required 'theta'", { instance: message });
            if (!message.hasOwnProperty("rho"))
                throw $util.ProtocolError("missing required 'rho'", { instance: message });
            return message;
        };

        /**
         * Decodes an OptionSnapshotExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSecuritySnapshot.OptionSnapshotExData} OptionSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionSnapshotExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OptionSnapshotExData message.
         * @function verify
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OptionSnapshotExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            {
                var error = $root.Qot_Common.Security.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            if (!$util.isString(message.strikeTime))
                return "strikeTime: string expected";
            if (typeof message.strikePrice !== "number")
                return "strikePrice: number expected";
            if (!$util.isInteger(message.contractSize))
                return "contractSize: integer expected";
            if (!$util.isInteger(message.openInterest))
                return "openInterest: integer expected";
            if (typeof message.impliedVolatility !== "number")
                return "impliedVolatility: number expected";
            if (typeof message.premium !== "number")
                return "premium: number expected";
            if (typeof message.delta !== "number")
                return "delta: number expected";
            if (typeof message.gamma !== "number")
                return "gamma: number expected";
            if (typeof message.vega !== "number")
                return "vega: number expected";
            if (typeof message.theta !== "number")
                return "theta: number expected";
            if (typeof message.rho !== "number")
                return "rho: number expected";
            if (message.strikeTimestamp != null && message.hasOwnProperty("strikeTimestamp"))
                if (typeof message.strikeTimestamp !== "number")
                    return "strikeTimestamp: number expected";
            if (message.indexOptionType != null && message.hasOwnProperty("indexOptionType"))
                if (!$util.isInteger(message.indexOptionType))
                    return "indexOptionType: integer expected";
            if (message.netOpenInterest != null && message.hasOwnProperty("netOpenInterest"))
                if (!$util.isInteger(message.netOpenInterest))
                    return "netOpenInterest: integer expected";
            if (message.expiryDateDistance != null && message.hasOwnProperty("expiryDateDistance"))
                if (!$util.isInteger(message.expiryDateDistance))
                    return "expiryDateDistance: integer expected";
            if (message.contractNominalValue != null && message.hasOwnProperty("contractNominalValue"))
                if (typeof message.contractNominalValue !== "number")
                    return "contractNominalValue: number expected";
            if (message.ownerLotMultiplier != null && message.hasOwnProperty("ownerLotMultiplier"))
                if (typeof message.ownerLotMultiplier !== "number")
                    return "ownerLotMultiplier: number expected";
            if (message.optionAreaType != null && message.hasOwnProperty("optionAreaType"))
                if (!$util.isInteger(message.optionAreaType))
                    return "optionAreaType: integer expected";
            if (message.contractMultiplier != null && message.hasOwnProperty("contractMultiplier"))
                if (typeof message.contractMultiplier !== "number")
                    return "contractMultiplier: number expected";
            return null;
        };

        /**
         * Creates an OptionSnapshotExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSecuritySnapshot.OptionSnapshotExData} OptionSnapshotExData
         */
        OptionSnapshotExData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSecuritySnapshot.OptionSnapshotExData)
                return object;
            var message = new $root.Qot_GetSecuritySnapshot.OptionSnapshotExData();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".Qot_GetSecuritySnapshot.OptionSnapshotExData.owner: object expected");
                message.owner = $root.Qot_Common.Security.fromObject(object.owner);
            }
            if (object.strikeTime != null)
                message.strikeTime = String(object.strikeTime);
            if (object.strikePrice != null)
                message.strikePrice = Number(object.strikePrice);
            if (object.contractSize != null)
                message.contractSize = object.contractSize | 0;
            if (object.openInterest != null)
                message.openInterest = object.openInterest | 0;
            if (object.impliedVolatility != null)
                message.impliedVolatility = Number(object.impliedVolatility);
            if (object.premium != null)
                message.premium = Number(object.premium);
            if (object.delta != null)
                message.delta = Number(object.delta);
            if (object.gamma != null)
                message.gamma = Number(object.gamma);
            if (object.vega != null)
                message.vega = Number(object.vega);
            if (object.theta != null)
                message.theta = Number(object.theta);
            if (object.rho != null)
                message.rho = Number(object.rho);
            if (object.strikeTimestamp != null)
                message.strikeTimestamp = Number(object.strikeTimestamp);
            if (object.indexOptionType != null)
                message.indexOptionType = object.indexOptionType | 0;
            if (object.netOpenInterest != null)
                message.netOpenInterest = object.netOpenInterest | 0;
            if (object.expiryDateDistance != null)
                message.expiryDateDistance = object.expiryDateDistance | 0;
            if (object.contractNominalValue != null)
                message.contractNominalValue = Number(object.contractNominalValue);
            if (object.ownerLotMultiplier != null)
                message.ownerLotMultiplier = Number(object.ownerLotMultiplier);
            if (object.optionAreaType != null)
                message.optionAreaType = object.optionAreaType | 0;
            if (object.contractMultiplier != null)
                message.contractMultiplier = Number(object.contractMultiplier);
            return message;
        };

        /**
         * Creates a plain object from an OptionSnapshotExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.OptionSnapshotExData} message OptionSnapshotExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OptionSnapshotExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.owner = null;
                object.strikeTime = "";
                object.strikePrice = 0;
                object.contractSize = 0;
                object.openInterest = 0;
                object.impliedVolatility = 0;
                object.premium = 0;
                object.delta = 0;
                object.gamma = 0;
                object.vega = 0;
                object.theta = 0;
                object.rho = 0;
                object.strikeTimestamp = 0;
                object.indexOptionType = 0;
                object.netOpenInterest = 0;
                object.expiryDateDistance = 0;
                object.contractNominalValue = 0;
                object.ownerLotMultiplier = 0;
                object.optionAreaType = 0;
                object.contractMultiplier = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.Qot_Common.Security.toObject(message.owner, options);
            if (message.strikeTime != null && message.hasOwnProperty("strikeTime"))
                object.strikeTime = message.strikeTime;
            if (message.strikePrice != null && message.hasOwnProperty("strikePrice"))
                object.strikePrice = options.json && !isFinite(message.strikePrice) ? String(message.strikePrice) : message.strikePrice;
            if (message.contractSize != null && message.hasOwnProperty("contractSize"))
                object.contractSize = message.contractSize;
            if (message.openInterest != null && message.hasOwnProperty("openInterest"))
                object.openInterest = message.openInterest;
            if (message.impliedVolatility != null && message.hasOwnProperty("impliedVolatility"))
                object.impliedVolatility = options.json && !isFinite(message.impliedVolatility) ? String(message.impliedVolatility) : message.impliedVolatility;
            if (message.premium != null && message.hasOwnProperty("premium"))
                object.premium = options.json && !isFinite(message.premium) ? String(message.premium) : message.premium;
            if (message.delta != null && message.hasOwnProperty("delta"))
                object.delta = options.json && !isFinite(message.delta) ? String(message.delta) : message.delta;
            if (message.gamma != null && message.hasOwnProperty("gamma"))
                object.gamma = options.json && !isFinite(message.gamma) ? String(message.gamma) : message.gamma;
            if (message.vega != null && message.hasOwnProperty("vega"))
                object.vega = options.json && !isFinite(message.vega) ? String(message.vega) : message.vega;
            if (message.theta != null && message.hasOwnProperty("theta"))
                object.theta = options.json && !isFinite(message.theta) ? String(message.theta) : message.theta;
            if (message.rho != null && message.hasOwnProperty("rho"))
                object.rho = options.json && !isFinite(message.rho) ? String(message.rho) : message.rho;
            if (message.strikeTimestamp != null && message.hasOwnProperty("strikeTimestamp"))
                object.strikeTimestamp = options.json && !isFinite(message.strikeTimestamp) ? String(message.strikeTimestamp) : message.strikeTimestamp;
            if (message.indexOptionType != null && message.hasOwnProperty("indexOptionType"))
                object.indexOptionType = message.indexOptionType;
            if (message.netOpenInterest != null && message.hasOwnProperty("netOpenInterest"))
                object.netOpenInterest = message.netOpenInterest;
            if (message.expiryDateDistance != null && message.hasOwnProperty("expiryDateDistance"))
                object.expiryDateDistance = message.expiryDateDistance;
            if (message.contractNominalValue != null && message.hasOwnProperty("contractNominalValue"))
                object.contractNominalValue = options.json && !isFinite(message.contractNominalValue) ? String(message.contractNominalValue) : message.contractNominalValue;
            if (message.ownerLotMultiplier != null && message.hasOwnProperty("ownerLotMultiplier"))
                object.ownerLotMultiplier = options.json && !isFinite(message.ownerLotMultiplier) ? String(message.ownerLotMultiplier) : message.ownerLotMultiplier;
            if (message.optionAreaType != null && message.hasOwnProperty("optionAreaType"))
                object.optionAreaType = message.optionAreaType;
            if (message.contractMultiplier != null && message.hasOwnProperty("contractMultiplier"))
                object.contractMultiplier = options.json && !isFinite(message.contractMultiplier) ? String(message.contractMultiplier) : message.contractMultiplier;
            return object;
        };

        /**
         * Converts this OptionSnapshotExData to JSON.
         * @function toJSON
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OptionSnapshotExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OptionSnapshotExData;
    })();

    Qot_GetSecuritySnapshot.IndexSnapshotExData = (function() {

        /**
         * Properties of an IndexSnapshotExData.
         * @memberof Qot_GetSecuritySnapshot
         * @interface IIndexSnapshotExData
         * @property {number} raiseCount IndexSnapshotExData raiseCount
         * @property {number} fallCount IndexSnapshotExData fallCount
         * @property {number} equalCount IndexSnapshotExData equalCount
         */

        /**
         * Constructs a new IndexSnapshotExData.
         * @memberof Qot_GetSecuritySnapshot
         * @classdesc Represents an IndexSnapshotExData.
         * @implements IIndexSnapshotExData
         * @constructor
         * @param {Qot_GetSecuritySnapshot.IIndexSnapshotExData=} [properties] Properties to set
         */
        function IndexSnapshotExData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IndexSnapshotExData raiseCount.
         * @member {number} raiseCount
         * @memberof Qot_GetSecuritySnapshot.IndexSnapshotExData
         * @instance
         */
        IndexSnapshotExData.prototype.raiseCount = 0;

        /**
         * IndexSnapshotExData fallCount.
         * @member {number} fallCount
         * @memberof Qot_GetSecuritySnapshot.IndexSnapshotExData
         * @instance
         */
        IndexSnapshotExData.prototype.fallCount = 0;

        /**
         * IndexSnapshotExData equalCount.
         * @member {number} equalCount
         * @memberof Qot_GetSecuritySnapshot.IndexSnapshotExData
         * @instance
         */
        IndexSnapshotExData.prototype.equalCount = 0;

        /**
         * Creates a new IndexSnapshotExData instance using the specified properties.
         * @function create
         * @memberof Qot_GetSecuritySnapshot.IndexSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IIndexSnapshotExData=} [properties] Properties to set
         * @returns {Qot_GetSecuritySnapshot.IndexSnapshotExData} IndexSnapshotExData instance
         */
        IndexSnapshotExData.create = function create(properties) {
            return new IndexSnapshotExData(properties);
        };

        /**
         * Encodes the specified IndexSnapshotExData message. Does not implicitly {@link Qot_GetSecuritySnapshot.IndexSnapshotExData.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSecuritySnapshot.IndexSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IIndexSnapshotExData} message IndexSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IndexSnapshotExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.raiseCount);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fallCount);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.equalCount);
            return writer;
        };

        /**
         * Encodes the specified IndexSnapshotExData message, length delimited. Does not implicitly {@link Qot_GetSecuritySnapshot.IndexSnapshotExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSecuritySnapshot.IndexSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IIndexSnapshotExData} message IndexSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IndexSnapshotExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IndexSnapshotExData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSecuritySnapshot.IndexSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSecuritySnapshot.IndexSnapshotExData} IndexSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IndexSnapshotExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSecuritySnapshot.IndexSnapshotExData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.raiseCount = reader.int32();
                    break;
                case 2:
                    message.fallCount = reader.int32();
                    break;
                case 3:
                    message.equalCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("raiseCount"))
                throw $util.ProtocolError("missing required 'raiseCount'", { instance: message });
            if (!message.hasOwnProperty("fallCount"))
                throw $util.ProtocolError("missing required 'fallCount'", { instance: message });
            if (!message.hasOwnProperty("equalCount"))
                throw $util.ProtocolError("missing required 'equalCount'", { instance: message });
            return message;
        };

        /**
         * Decodes an IndexSnapshotExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSecuritySnapshot.IndexSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSecuritySnapshot.IndexSnapshotExData} IndexSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IndexSnapshotExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IndexSnapshotExData message.
         * @function verify
         * @memberof Qot_GetSecuritySnapshot.IndexSnapshotExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IndexSnapshotExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.raiseCount))
                return "raiseCount: integer expected";
            if (!$util.isInteger(message.fallCount))
                return "fallCount: integer expected";
            if (!$util.isInteger(message.equalCount))
                return "equalCount: integer expected";
            return null;
        };

        /**
         * Creates an IndexSnapshotExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSecuritySnapshot.IndexSnapshotExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSecuritySnapshot.IndexSnapshotExData} IndexSnapshotExData
         */
        IndexSnapshotExData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSecuritySnapshot.IndexSnapshotExData)
                return object;
            var message = new $root.Qot_GetSecuritySnapshot.IndexSnapshotExData();
            if (object.raiseCount != null)
                message.raiseCount = object.raiseCount | 0;
            if (object.fallCount != null)
                message.fallCount = object.fallCount | 0;
            if (object.equalCount != null)
                message.equalCount = object.equalCount | 0;
            return message;
        };

        /**
         * Creates a plain object from an IndexSnapshotExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSecuritySnapshot.IndexSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IndexSnapshotExData} message IndexSnapshotExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IndexSnapshotExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.raiseCount = 0;
                object.fallCount = 0;
                object.equalCount = 0;
            }
            if (message.raiseCount != null && message.hasOwnProperty("raiseCount"))
                object.raiseCount = message.raiseCount;
            if (message.fallCount != null && message.hasOwnProperty("fallCount"))
                object.fallCount = message.fallCount;
            if (message.equalCount != null && message.hasOwnProperty("equalCount"))
                object.equalCount = message.equalCount;
            return object;
        };

        /**
         * Converts this IndexSnapshotExData to JSON.
         * @function toJSON
         * @memberof Qot_GetSecuritySnapshot.IndexSnapshotExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IndexSnapshotExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IndexSnapshotExData;
    })();

    Qot_GetSecuritySnapshot.PlateSnapshotExData = (function() {

        /**
         * Properties of a PlateSnapshotExData.
         * @memberof Qot_GetSecuritySnapshot
         * @interface IPlateSnapshotExData
         * @property {number} raiseCount PlateSnapshotExData raiseCount
         * @property {number} fallCount PlateSnapshotExData fallCount
         * @property {number} equalCount PlateSnapshotExData equalCount
         */

        /**
         * Constructs a new PlateSnapshotExData.
         * @memberof Qot_GetSecuritySnapshot
         * @classdesc Represents a PlateSnapshotExData.
         * @implements IPlateSnapshotExData
         * @constructor
         * @param {Qot_GetSecuritySnapshot.IPlateSnapshotExData=} [properties] Properties to set
         */
        function PlateSnapshotExData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlateSnapshotExData raiseCount.
         * @member {number} raiseCount
         * @memberof Qot_GetSecuritySnapshot.PlateSnapshotExData
         * @instance
         */
        PlateSnapshotExData.prototype.raiseCount = 0;

        /**
         * PlateSnapshotExData fallCount.
         * @member {number} fallCount
         * @memberof Qot_GetSecuritySnapshot.PlateSnapshotExData
         * @instance
         */
        PlateSnapshotExData.prototype.fallCount = 0;

        /**
         * PlateSnapshotExData equalCount.
         * @member {number} equalCount
         * @memberof Qot_GetSecuritySnapshot.PlateSnapshotExData
         * @instance
         */
        PlateSnapshotExData.prototype.equalCount = 0;

        /**
         * Creates a new PlateSnapshotExData instance using the specified properties.
         * @function create
         * @memberof Qot_GetSecuritySnapshot.PlateSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IPlateSnapshotExData=} [properties] Properties to set
         * @returns {Qot_GetSecuritySnapshot.PlateSnapshotExData} PlateSnapshotExData instance
         */
        PlateSnapshotExData.create = function create(properties) {
            return new PlateSnapshotExData(properties);
        };

        /**
         * Encodes the specified PlateSnapshotExData message. Does not implicitly {@link Qot_GetSecuritySnapshot.PlateSnapshotExData.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSecuritySnapshot.PlateSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IPlateSnapshotExData} message PlateSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlateSnapshotExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.raiseCount);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fallCount);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.equalCount);
            return writer;
        };

        /**
         * Encodes the specified PlateSnapshotExData message, length delimited. Does not implicitly {@link Qot_GetSecuritySnapshot.PlateSnapshotExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSecuritySnapshot.PlateSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IPlateSnapshotExData} message PlateSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlateSnapshotExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlateSnapshotExData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSecuritySnapshot.PlateSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSecuritySnapshot.PlateSnapshotExData} PlateSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlateSnapshotExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSecuritySnapshot.PlateSnapshotExData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.raiseCount = reader.int32();
                    break;
                case 2:
                    message.fallCount = reader.int32();
                    break;
                case 3:
                    message.equalCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("raiseCount"))
                throw $util.ProtocolError("missing required 'raiseCount'", { instance: message });
            if (!message.hasOwnProperty("fallCount"))
                throw $util.ProtocolError("missing required 'fallCount'", { instance: message });
            if (!message.hasOwnProperty("equalCount"))
                throw $util.ProtocolError("missing required 'equalCount'", { instance: message });
            return message;
        };

        /**
         * Decodes a PlateSnapshotExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSecuritySnapshot.PlateSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSecuritySnapshot.PlateSnapshotExData} PlateSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlateSnapshotExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlateSnapshotExData message.
         * @function verify
         * @memberof Qot_GetSecuritySnapshot.PlateSnapshotExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlateSnapshotExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.raiseCount))
                return "raiseCount: integer expected";
            if (!$util.isInteger(message.fallCount))
                return "fallCount: integer expected";
            if (!$util.isInteger(message.equalCount))
                return "equalCount: integer expected";
            return null;
        };

        /**
         * Creates a PlateSnapshotExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSecuritySnapshot.PlateSnapshotExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSecuritySnapshot.PlateSnapshotExData} PlateSnapshotExData
         */
        PlateSnapshotExData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSecuritySnapshot.PlateSnapshotExData)
                return object;
            var message = new $root.Qot_GetSecuritySnapshot.PlateSnapshotExData();
            if (object.raiseCount != null)
                message.raiseCount = object.raiseCount | 0;
            if (object.fallCount != null)
                message.fallCount = object.fallCount | 0;
            if (object.equalCount != null)
                message.equalCount = object.equalCount | 0;
            return message;
        };

        /**
         * Creates a plain object from a PlateSnapshotExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSecuritySnapshot.PlateSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.PlateSnapshotExData} message PlateSnapshotExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlateSnapshotExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.raiseCount = 0;
                object.fallCount = 0;
                object.equalCount = 0;
            }
            if (message.raiseCount != null && message.hasOwnProperty("raiseCount"))
                object.raiseCount = message.raiseCount;
            if (message.fallCount != null && message.hasOwnProperty("fallCount"))
                object.fallCount = message.fallCount;
            if (message.equalCount != null && message.hasOwnProperty("equalCount"))
                object.equalCount = message.equalCount;
            return object;
        };

        /**
         * Converts this PlateSnapshotExData to JSON.
         * @function toJSON
         * @memberof Qot_GetSecuritySnapshot.PlateSnapshotExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlateSnapshotExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlateSnapshotExData;
    })();

    Qot_GetSecuritySnapshot.FutureSnapshotExData = (function() {

        /**
         * Properties of a FutureSnapshotExData.
         * @memberof Qot_GetSecuritySnapshot
         * @interface IFutureSnapshotExData
         * @property {number} lastSettlePrice FutureSnapshotExData lastSettlePrice
         * @property {number} position FutureSnapshotExData position
         * @property {number} positionChange FutureSnapshotExData positionChange
         * @property {string} lastTradeTime FutureSnapshotExData lastTradeTime
         * @property {number|null} [lastTradeTimestamp] FutureSnapshotExData lastTradeTimestamp
         * @property {boolean} isMainContract FutureSnapshotExData isMainContract
         */

        /**
         * Constructs a new FutureSnapshotExData.
         * @memberof Qot_GetSecuritySnapshot
         * @classdesc Represents a FutureSnapshotExData.
         * @implements IFutureSnapshotExData
         * @constructor
         * @param {Qot_GetSecuritySnapshot.IFutureSnapshotExData=} [properties] Properties to set
         */
        function FutureSnapshotExData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FutureSnapshotExData lastSettlePrice.
         * @member {number} lastSettlePrice
         * @memberof Qot_GetSecuritySnapshot.FutureSnapshotExData
         * @instance
         */
        FutureSnapshotExData.prototype.lastSettlePrice = 0;

        /**
         * FutureSnapshotExData position.
         * @member {number} position
         * @memberof Qot_GetSecuritySnapshot.FutureSnapshotExData
         * @instance
         */
        FutureSnapshotExData.prototype.position = 0;

        /**
         * FutureSnapshotExData positionChange.
         * @member {number} positionChange
         * @memberof Qot_GetSecuritySnapshot.FutureSnapshotExData
         * @instance
         */
        FutureSnapshotExData.prototype.positionChange = 0;

        /**
         * FutureSnapshotExData lastTradeTime.
         * @member {string} lastTradeTime
         * @memberof Qot_GetSecuritySnapshot.FutureSnapshotExData
         * @instance
         */
        FutureSnapshotExData.prototype.lastTradeTime = "";

        /**
         * FutureSnapshotExData lastTradeTimestamp.
         * @member {number} lastTradeTimestamp
         * @memberof Qot_GetSecuritySnapshot.FutureSnapshotExData
         * @instance
         */
        FutureSnapshotExData.prototype.lastTradeTimestamp = 0;

        /**
         * FutureSnapshotExData isMainContract.
         * @member {boolean} isMainContract
         * @memberof Qot_GetSecuritySnapshot.FutureSnapshotExData
         * @instance
         */
        FutureSnapshotExData.prototype.isMainContract = false;

        /**
         * Creates a new FutureSnapshotExData instance using the specified properties.
         * @function create
         * @memberof Qot_GetSecuritySnapshot.FutureSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IFutureSnapshotExData=} [properties] Properties to set
         * @returns {Qot_GetSecuritySnapshot.FutureSnapshotExData} FutureSnapshotExData instance
         */
        FutureSnapshotExData.create = function create(properties) {
            return new FutureSnapshotExData(properties);
        };

        /**
         * Encodes the specified FutureSnapshotExData message. Does not implicitly {@link Qot_GetSecuritySnapshot.FutureSnapshotExData.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSecuritySnapshot.FutureSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IFutureSnapshotExData} message FutureSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FutureSnapshotExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.lastSettlePrice);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.position);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.positionChange);
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.lastTradeTime);
            if (message.lastTradeTimestamp != null && message.hasOwnProperty("lastTradeTimestamp"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.lastTradeTimestamp);
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isMainContract);
            return writer;
        };

        /**
         * Encodes the specified FutureSnapshotExData message, length delimited. Does not implicitly {@link Qot_GetSecuritySnapshot.FutureSnapshotExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSecuritySnapshot.FutureSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IFutureSnapshotExData} message FutureSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FutureSnapshotExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FutureSnapshotExData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSecuritySnapshot.FutureSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSecuritySnapshot.FutureSnapshotExData} FutureSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FutureSnapshotExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSecuritySnapshot.FutureSnapshotExData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lastSettlePrice = reader.double();
                    break;
                case 2:
                    message.position = reader.int32();
                    break;
                case 3:
                    message.positionChange = reader.int32();
                    break;
                case 4:
                    message.lastTradeTime = reader.string();
                    break;
                case 5:
                    message.lastTradeTimestamp = reader.double();
                    break;
                case 6:
                    message.isMainContract = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("lastSettlePrice"))
                throw $util.ProtocolError("missing required 'lastSettlePrice'", { instance: message });
            if (!message.hasOwnProperty("position"))
                throw $util.ProtocolError("missing required 'position'", { instance: message });
            if (!message.hasOwnProperty("positionChange"))
                throw $util.ProtocolError("missing required 'positionChange'", { instance: message });
            if (!message.hasOwnProperty("lastTradeTime"))
                throw $util.ProtocolError("missing required 'lastTradeTime'", { instance: message });
            if (!message.hasOwnProperty("isMainContract"))
                throw $util.ProtocolError("missing required 'isMainContract'", { instance: message });
            return message;
        };

        /**
         * Decodes a FutureSnapshotExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSecuritySnapshot.FutureSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSecuritySnapshot.FutureSnapshotExData} FutureSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FutureSnapshotExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FutureSnapshotExData message.
         * @function verify
         * @memberof Qot_GetSecuritySnapshot.FutureSnapshotExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FutureSnapshotExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.lastSettlePrice !== "number")
                return "lastSettlePrice: number expected";
            if (!$util.isInteger(message.position))
                return "position: integer expected";
            if (!$util.isInteger(message.positionChange))
                return "positionChange: integer expected";
            if (!$util.isString(message.lastTradeTime))
                return "lastTradeTime: string expected";
            if (message.lastTradeTimestamp != null && message.hasOwnProperty("lastTradeTimestamp"))
                if (typeof message.lastTradeTimestamp !== "number")
                    return "lastTradeTimestamp: number expected";
            if (typeof message.isMainContract !== "boolean")
                return "isMainContract: boolean expected";
            return null;
        };

        /**
         * Creates a FutureSnapshotExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSecuritySnapshot.FutureSnapshotExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSecuritySnapshot.FutureSnapshotExData} FutureSnapshotExData
         */
        FutureSnapshotExData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSecuritySnapshot.FutureSnapshotExData)
                return object;
            var message = new $root.Qot_GetSecuritySnapshot.FutureSnapshotExData();
            if (object.lastSettlePrice != null)
                message.lastSettlePrice = Number(object.lastSettlePrice);
            if (object.position != null)
                message.position = object.position | 0;
            if (object.positionChange != null)
                message.positionChange = object.positionChange | 0;
            if (object.lastTradeTime != null)
                message.lastTradeTime = String(object.lastTradeTime);
            if (object.lastTradeTimestamp != null)
                message.lastTradeTimestamp = Number(object.lastTradeTimestamp);
            if (object.isMainContract != null)
                message.isMainContract = Boolean(object.isMainContract);
            return message;
        };

        /**
         * Creates a plain object from a FutureSnapshotExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSecuritySnapshot.FutureSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.FutureSnapshotExData} message FutureSnapshotExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FutureSnapshotExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.lastSettlePrice = 0;
                object.position = 0;
                object.positionChange = 0;
                object.lastTradeTime = "";
                object.lastTradeTimestamp = 0;
                object.isMainContract = false;
            }
            if (message.lastSettlePrice != null && message.hasOwnProperty("lastSettlePrice"))
                object.lastSettlePrice = options.json && !isFinite(message.lastSettlePrice) ? String(message.lastSettlePrice) : message.lastSettlePrice;
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = message.position;
            if (message.positionChange != null && message.hasOwnProperty("positionChange"))
                object.positionChange = message.positionChange;
            if (message.lastTradeTime != null && message.hasOwnProperty("lastTradeTime"))
                object.lastTradeTime = message.lastTradeTime;
            if (message.lastTradeTimestamp != null && message.hasOwnProperty("lastTradeTimestamp"))
                object.lastTradeTimestamp = options.json && !isFinite(message.lastTradeTimestamp) ? String(message.lastTradeTimestamp) : message.lastTradeTimestamp;
            if (message.isMainContract != null && message.hasOwnProperty("isMainContract"))
                object.isMainContract = message.isMainContract;
            return object;
        };

        /**
         * Converts this FutureSnapshotExData to JSON.
         * @function toJSON
         * @memberof Qot_GetSecuritySnapshot.FutureSnapshotExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FutureSnapshotExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FutureSnapshotExData;
    })();

    Qot_GetSecuritySnapshot.SnapshotBasicData = (function() {

        /**
         * Properties of a SnapshotBasicData.
         * @memberof Qot_GetSecuritySnapshot
         * @interface ISnapshotBasicData
         * @property {Qot_Common.ISecurity} security SnapshotBasicData security
         * @property {number} type SnapshotBasicData type
         * @property {boolean} isSuspend SnapshotBasicData isSuspend
         * @property {string} listTime SnapshotBasicData listTime
         * @property {number} lotSize SnapshotBasicData lotSize
         * @property {number} priceSpread SnapshotBasicData priceSpread
         * @property {string} updateTime SnapshotBasicData updateTime
         * @property {number} highPrice SnapshotBasicData highPrice
         * @property {number} openPrice SnapshotBasicData openPrice
         * @property {number} lowPrice SnapshotBasicData lowPrice
         * @property {number} lastClosePrice SnapshotBasicData lastClosePrice
         * @property {number} curPrice SnapshotBasicData curPrice
         * @property {number|Long} volume SnapshotBasicData volume
         * @property {number} turnover SnapshotBasicData turnover
         * @property {number} turnoverRate SnapshotBasicData turnoverRate
         * @property {number|null} [listTimestamp] SnapshotBasicData listTimestamp
         * @property {number|null} [updateTimestamp] SnapshotBasicData updateTimestamp
         * @property {number|null} [askPrice] SnapshotBasicData askPrice
         * @property {number|null} [bidPrice] SnapshotBasicData bidPrice
         * @property {number|Long|null} [askVol] SnapshotBasicData askVol
         * @property {number|Long|null} [bidVol] SnapshotBasicData bidVol
         * @property {boolean|null} [enableMargin] SnapshotBasicData enableMargin
         * @property {number|null} [mortgageRatio] SnapshotBasicData mortgageRatio
         * @property {number|null} [longMarginInitialRatio] SnapshotBasicData longMarginInitialRatio
         * @property {boolean|null} [enableShortSell] SnapshotBasicData enableShortSell
         * @property {number|null} [shortSellRate] SnapshotBasicData shortSellRate
         * @property {number|Long|null} [shortAvailableVolume] SnapshotBasicData shortAvailableVolume
         * @property {number|null} [shortMarginInitialRatio] SnapshotBasicData shortMarginInitialRatio
         * @property {number|null} [amplitude] SnapshotBasicData amplitude
         * @property {number|null} [avgPrice] SnapshotBasicData avgPrice
         * @property {number|null} [bidAskRatio] SnapshotBasicData bidAskRatio
         * @property {number|null} [volumeRatio] SnapshotBasicData volumeRatio
         * @property {number|null} [highest52WeeksPrice] SnapshotBasicData highest52WeeksPrice
         * @property {number|null} [lowest52WeeksPrice] SnapshotBasicData lowest52WeeksPrice
         * @property {number|null} [highestHistoryPrice] SnapshotBasicData highestHistoryPrice
         * @property {number|null} [lowestHistoryPrice] SnapshotBasicData lowestHistoryPrice
         * @property {Qot_Common.IPreAfterMarketData|null} [preMarket] SnapshotBasicData preMarket
         * @property {Qot_Common.IPreAfterMarketData|null} [afterMarket] SnapshotBasicData afterMarket
         * @property {number|null} [secStatus] SnapshotBasicData secStatus
         * @property {number|null} [closePrice5Minute] SnapshotBasicData closePrice5Minute
         */

        /**
         * Constructs a new SnapshotBasicData.
         * @memberof Qot_GetSecuritySnapshot
         * @classdesc Represents a SnapshotBasicData.
         * @implements ISnapshotBasicData
         * @constructor
         * @param {Qot_GetSecuritySnapshot.ISnapshotBasicData=} [properties] Properties to set
         */
        function SnapshotBasicData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SnapshotBasicData security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.security = null;

        /**
         * SnapshotBasicData type.
         * @member {number} type
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.type = 0;

        /**
         * SnapshotBasicData isSuspend.
         * @member {boolean} isSuspend
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.isSuspend = false;

        /**
         * SnapshotBasicData listTime.
         * @member {string} listTime
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.listTime = "";

        /**
         * SnapshotBasicData lotSize.
         * @member {number} lotSize
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.lotSize = 0;

        /**
         * SnapshotBasicData priceSpread.
         * @member {number} priceSpread
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.priceSpread = 0;

        /**
         * SnapshotBasicData updateTime.
         * @member {string} updateTime
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.updateTime = "";

        /**
         * SnapshotBasicData highPrice.
         * @member {number} highPrice
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.highPrice = 0;

        /**
         * SnapshotBasicData openPrice.
         * @member {number} openPrice
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.openPrice = 0;

        /**
         * SnapshotBasicData lowPrice.
         * @member {number} lowPrice
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.lowPrice = 0;

        /**
         * SnapshotBasicData lastClosePrice.
         * @member {number} lastClosePrice
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.lastClosePrice = 0;

        /**
         * SnapshotBasicData curPrice.
         * @member {number} curPrice
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.curPrice = 0;

        /**
         * SnapshotBasicData volume.
         * @member {number|Long} volume
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.volume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SnapshotBasicData turnover.
         * @member {number} turnover
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.turnover = 0;

        /**
         * SnapshotBasicData turnoverRate.
         * @member {number} turnoverRate
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.turnoverRate = 0;

        /**
         * SnapshotBasicData listTimestamp.
         * @member {number} listTimestamp
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.listTimestamp = 0;

        /**
         * SnapshotBasicData updateTimestamp.
         * @member {number} updateTimestamp
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.updateTimestamp = 0;

        /**
         * SnapshotBasicData askPrice.
         * @member {number} askPrice
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.askPrice = 0;

        /**
         * SnapshotBasicData bidPrice.
         * @member {number} bidPrice
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.bidPrice = 0;

        /**
         * SnapshotBasicData askVol.
         * @member {number|Long} askVol
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.askVol = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SnapshotBasicData bidVol.
         * @member {number|Long} bidVol
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.bidVol = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SnapshotBasicData enableMargin.
         * @member {boolean} enableMargin
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.enableMargin = false;

        /**
         * SnapshotBasicData mortgageRatio.
         * @member {number} mortgageRatio
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.mortgageRatio = 0;

        /**
         * SnapshotBasicData longMarginInitialRatio.
         * @member {number} longMarginInitialRatio
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.longMarginInitialRatio = 0;

        /**
         * SnapshotBasicData enableShortSell.
         * @member {boolean} enableShortSell
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.enableShortSell = false;

        /**
         * SnapshotBasicData shortSellRate.
         * @member {number} shortSellRate
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.shortSellRate = 0;

        /**
         * SnapshotBasicData shortAvailableVolume.
         * @member {number|Long} shortAvailableVolume
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.shortAvailableVolume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SnapshotBasicData shortMarginInitialRatio.
         * @member {number} shortMarginInitialRatio
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.shortMarginInitialRatio = 0;

        /**
         * SnapshotBasicData amplitude.
         * @member {number} amplitude
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.amplitude = 0;

        /**
         * SnapshotBasicData avgPrice.
         * @member {number} avgPrice
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.avgPrice = 0;

        /**
         * SnapshotBasicData bidAskRatio.
         * @member {number} bidAskRatio
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.bidAskRatio = 0;

        /**
         * SnapshotBasicData volumeRatio.
         * @member {number} volumeRatio
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.volumeRatio = 0;

        /**
         * SnapshotBasicData highest52WeeksPrice.
         * @member {number} highest52WeeksPrice
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.highest52WeeksPrice = 0;

        /**
         * SnapshotBasicData lowest52WeeksPrice.
         * @member {number} lowest52WeeksPrice
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.lowest52WeeksPrice = 0;

        /**
         * SnapshotBasicData highestHistoryPrice.
         * @member {number} highestHistoryPrice
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.highestHistoryPrice = 0;

        /**
         * SnapshotBasicData lowestHistoryPrice.
         * @member {number} lowestHistoryPrice
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.lowestHistoryPrice = 0;

        /**
         * SnapshotBasicData preMarket.
         * @member {Qot_Common.IPreAfterMarketData|null|undefined} preMarket
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.preMarket = null;

        /**
         * SnapshotBasicData afterMarket.
         * @member {Qot_Common.IPreAfterMarketData|null|undefined} afterMarket
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.afterMarket = null;

        /**
         * SnapshotBasicData secStatus.
         * @member {number} secStatus
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.secStatus = 0;

        /**
         * SnapshotBasicData closePrice5Minute.
         * @member {number} closePrice5Minute
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.closePrice5Minute = 0;

        /**
         * Creates a new SnapshotBasicData instance using the specified properties.
         * @function create
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @static
         * @param {Qot_GetSecuritySnapshot.ISnapshotBasicData=} [properties] Properties to set
         * @returns {Qot_GetSecuritySnapshot.SnapshotBasicData} SnapshotBasicData instance
         */
        SnapshotBasicData.create = function create(properties) {
            return new SnapshotBasicData(properties);
        };

        /**
         * Encodes the specified SnapshotBasicData message. Does not implicitly {@link Qot_GetSecuritySnapshot.SnapshotBasicData.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @static
         * @param {Qot_GetSecuritySnapshot.ISnapshotBasicData} message SnapshotBasicData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SnapshotBasicData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isSuspend);
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.listTime);
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.lotSize);
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.priceSpread);
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.updateTime);
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.highPrice);
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.openPrice);
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.lowPrice);
            writer.uint32(/* id 11, wireType 1 =*/89).double(message.lastClosePrice);
            writer.uint32(/* id 12, wireType 1 =*/97).double(message.curPrice);
            writer.uint32(/* id 13, wireType 0 =*/104).int64(message.volume);
            writer.uint32(/* id 14, wireType 1 =*/113).double(message.turnover);
            writer.uint32(/* id 15, wireType 1 =*/121).double(message.turnoverRate);
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                writer.uint32(/* id 16, wireType 1 =*/129).double(message.listTimestamp);
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                writer.uint32(/* id 17, wireType 1 =*/137).double(message.updateTimestamp);
            if (message.askPrice != null && message.hasOwnProperty("askPrice"))
                writer.uint32(/* id 18, wireType 1 =*/145).double(message.askPrice);
            if (message.bidPrice != null && message.hasOwnProperty("bidPrice"))
                writer.uint32(/* id 19, wireType 1 =*/153).double(message.bidPrice);
            if (message.askVol != null && message.hasOwnProperty("askVol"))
                writer.uint32(/* id 20, wireType 0 =*/160).int64(message.askVol);
            if (message.bidVol != null && message.hasOwnProperty("bidVol"))
                writer.uint32(/* id 21, wireType 0 =*/168).int64(message.bidVol);
            if (message.enableMargin != null && message.hasOwnProperty("enableMargin"))
                writer.uint32(/* id 22, wireType 0 =*/176).bool(message.enableMargin);
            if (message.mortgageRatio != null && message.hasOwnProperty("mortgageRatio"))
                writer.uint32(/* id 23, wireType 1 =*/185).double(message.mortgageRatio);
            if (message.longMarginInitialRatio != null && message.hasOwnProperty("longMarginInitialRatio"))
                writer.uint32(/* id 24, wireType 1 =*/193).double(message.longMarginInitialRatio);
            if (message.enableShortSell != null && message.hasOwnProperty("enableShortSell"))
                writer.uint32(/* id 25, wireType 0 =*/200).bool(message.enableShortSell);
            if (message.shortSellRate != null && message.hasOwnProperty("shortSellRate"))
                writer.uint32(/* id 26, wireType 1 =*/209).double(message.shortSellRate);
            if (message.shortAvailableVolume != null && message.hasOwnProperty("shortAvailableVolume"))
                writer.uint32(/* id 27, wireType 0 =*/216).int64(message.shortAvailableVolume);
            if (message.shortMarginInitialRatio != null && message.hasOwnProperty("shortMarginInitialRatio"))
                writer.uint32(/* id 28, wireType 1 =*/225).double(message.shortMarginInitialRatio);
            if (message.amplitude != null && message.hasOwnProperty("amplitude"))
                writer.uint32(/* id 29, wireType 1 =*/233).double(message.amplitude);
            if (message.avgPrice != null && message.hasOwnProperty("avgPrice"))
                writer.uint32(/* id 30, wireType 1 =*/241).double(message.avgPrice);
            if (message.bidAskRatio != null && message.hasOwnProperty("bidAskRatio"))
                writer.uint32(/* id 31, wireType 1 =*/249).double(message.bidAskRatio);
            if (message.volumeRatio != null && message.hasOwnProperty("volumeRatio"))
                writer.uint32(/* id 32, wireType 1 =*/257).double(message.volumeRatio);
            if (message.highest52WeeksPrice != null && message.hasOwnProperty("highest52WeeksPrice"))
                writer.uint32(/* id 33, wireType 1 =*/265).double(message.highest52WeeksPrice);
            if (message.lowest52WeeksPrice != null && message.hasOwnProperty("lowest52WeeksPrice"))
                writer.uint32(/* id 34, wireType 1 =*/273).double(message.lowest52WeeksPrice);
            if (message.highestHistoryPrice != null && message.hasOwnProperty("highestHistoryPrice"))
                writer.uint32(/* id 35, wireType 1 =*/281).double(message.highestHistoryPrice);
            if (message.lowestHistoryPrice != null && message.hasOwnProperty("lowestHistoryPrice"))
                writer.uint32(/* id 36, wireType 1 =*/289).double(message.lowestHistoryPrice);
            if (message.preMarket != null && message.hasOwnProperty("preMarket"))
                $root.Qot_Common.PreAfterMarketData.encode(message.preMarket, writer.uint32(/* id 37, wireType 2 =*/298).fork()).ldelim();
            if (message.afterMarket != null && message.hasOwnProperty("afterMarket"))
                $root.Qot_Common.PreAfterMarketData.encode(message.afterMarket, writer.uint32(/* id 38, wireType 2 =*/306).fork()).ldelim();
            if (message.secStatus != null && message.hasOwnProperty("secStatus"))
                writer.uint32(/* id 39, wireType 0 =*/312).int32(message.secStatus);
            if (message.closePrice5Minute != null && message.hasOwnProperty("closePrice5Minute"))
                writer.uint32(/* id 40, wireType 1 =*/321).double(message.closePrice5Minute);
            return writer;
        };

        /**
         * Encodes the specified SnapshotBasicData message, length delimited. Does not implicitly {@link Qot_GetSecuritySnapshot.SnapshotBasicData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @static
         * @param {Qot_GetSecuritySnapshot.ISnapshotBasicData} message SnapshotBasicData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SnapshotBasicData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SnapshotBasicData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSecuritySnapshot.SnapshotBasicData} SnapshotBasicData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SnapshotBasicData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSecuritySnapshot.SnapshotBasicData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.isSuspend = reader.bool();
                    break;
                case 4:
                    message.listTime = reader.string();
                    break;
                case 5:
                    message.lotSize = reader.int32();
                    break;
                case 6:
                    message.priceSpread = reader.double();
                    break;
                case 7:
                    message.updateTime = reader.string();
                    break;
                case 8:
                    message.highPrice = reader.double();
                    break;
                case 9:
                    message.openPrice = reader.double();
                    break;
                case 10:
                    message.lowPrice = reader.double();
                    break;
                case 11:
                    message.lastClosePrice = reader.double();
                    break;
                case 12:
                    message.curPrice = reader.double();
                    break;
                case 13:
                    message.volume = reader.int64();
                    break;
                case 14:
                    message.turnover = reader.double();
                    break;
                case 15:
                    message.turnoverRate = reader.double();
                    break;
                case 16:
                    message.listTimestamp = reader.double();
                    break;
                case 17:
                    message.updateTimestamp = reader.double();
                    break;
                case 18:
                    message.askPrice = reader.double();
                    break;
                case 19:
                    message.bidPrice = reader.double();
                    break;
                case 20:
                    message.askVol = reader.int64();
                    break;
                case 21:
                    message.bidVol = reader.int64();
                    break;
                case 22:
                    message.enableMargin = reader.bool();
                    break;
                case 23:
                    message.mortgageRatio = reader.double();
                    break;
                case 24:
                    message.longMarginInitialRatio = reader.double();
                    break;
                case 25:
                    message.enableShortSell = reader.bool();
                    break;
                case 26:
                    message.shortSellRate = reader.double();
                    break;
                case 27:
                    message.shortAvailableVolume = reader.int64();
                    break;
                case 28:
                    message.shortMarginInitialRatio = reader.double();
                    break;
                case 29:
                    message.amplitude = reader.double();
                    break;
                case 30:
                    message.avgPrice = reader.double();
                    break;
                case 31:
                    message.bidAskRatio = reader.double();
                    break;
                case 32:
                    message.volumeRatio = reader.double();
                    break;
                case 33:
                    message.highest52WeeksPrice = reader.double();
                    break;
                case 34:
                    message.lowest52WeeksPrice = reader.double();
                    break;
                case 35:
                    message.highestHistoryPrice = reader.double();
                    break;
                case 36:
                    message.lowestHistoryPrice = reader.double();
                    break;
                case 37:
                    message.preMarket = $root.Qot_Common.PreAfterMarketData.decode(reader, reader.uint32());
                    break;
                case 38:
                    message.afterMarket = $root.Qot_Common.PreAfterMarketData.decode(reader, reader.uint32());
                    break;
                case 39:
                    message.secStatus = reader.int32();
                    break;
                case 40:
                    message.closePrice5Minute = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("isSuspend"))
                throw $util.ProtocolError("missing required 'isSuspend'", { instance: message });
            if (!message.hasOwnProperty("listTime"))
                throw $util.ProtocolError("missing required 'listTime'", { instance: message });
            if (!message.hasOwnProperty("lotSize"))
                throw $util.ProtocolError("missing required 'lotSize'", { instance: message });
            if (!message.hasOwnProperty("priceSpread"))
                throw $util.ProtocolError("missing required 'priceSpread'", { instance: message });
            if (!message.hasOwnProperty("updateTime"))
                throw $util.ProtocolError("missing required 'updateTime'", { instance: message });
            if (!message.hasOwnProperty("highPrice"))
                throw $util.ProtocolError("missing required 'highPrice'", { instance: message });
            if (!message.hasOwnProperty("openPrice"))
                throw $util.ProtocolError("missing required 'openPrice'", { instance: message });
            if (!message.hasOwnProperty("lowPrice"))
                throw $util.ProtocolError("missing required 'lowPrice'", { instance: message });
            if (!message.hasOwnProperty("lastClosePrice"))
                throw $util.ProtocolError("missing required 'lastClosePrice'", { instance: message });
            if (!message.hasOwnProperty("curPrice"))
                throw $util.ProtocolError("missing required 'curPrice'", { instance: message });
            if (!message.hasOwnProperty("volume"))
                throw $util.ProtocolError("missing required 'volume'", { instance: message });
            if (!message.hasOwnProperty("turnover"))
                throw $util.ProtocolError("missing required 'turnover'", { instance: message });
            if (!message.hasOwnProperty("turnoverRate"))
                throw $util.ProtocolError("missing required 'turnoverRate'", { instance: message });
            return message;
        };

        /**
         * Decodes a SnapshotBasicData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSecuritySnapshot.SnapshotBasicData} SnapshotBasicData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SnapshotBasicData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SnapshotBasicData message.
         * @function verify
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SnapshotBasicData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            if (typeof message.isSuspend !== "boolean")
                return "isSuspend: boolean expected";
            if (!$util.isString(message.listTime))
                return "listTime: string expected";
            if (!$util.isInteger(message.lotSize))
                return "lotSize: integer expected";
            if (typeof message.priceSpread !== "number")
                return "priceSpread: number expected";
            if (!$util.isString(message.updateTime))
                return "updateTime: string expected";
            if (typeof message.highPrice !== "number")
                return "highPrice: number expected";
            if (typeof message.openPrice !== "number")
                return "openPrice: number expected";
            if (typeof message.lowPrice !== "number")
                return "lowPrice: number expected";
            if (typeof message.lastClosePrice !== "number")
                return "lastClosePrice: number expected";
            if (typeof message.curPrice !== "number")
                return "curPrice: number expected";
            if (!$util.isInteger(message.volume) && !(message.volume && $util.isInteger(message.volume.low) && $util.isInteger(message.volume.high)))
                return "volume: integer|Long expected";
            if (typeof message.turnover !== "number")
                return "turnover: number expected";
            if (typeof message.turnoverRate !== "number")
                return "turnoverRate: number expected";
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                if (typeof message.listTimestamp !== "number")
                    return "listTimestamp: number expected";
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                if (typeof message.updateTimestamp !== "number")
                    return "updateTimestamp: number expected";
            if (message.askPrice != null && message.hasOwnProperty("askPrice"))
                if (typeof message.askPrice !== "number")
                    return "askPrice: number expected";
            if (message.bidPrice != null && message.hasOwnProperty("bidPrice"))
                if (typeof message.bidPrice !== "number")
                    return "bidPrice: number expected";
            if (message.askVol != null && message.hasOwnProperty("askVol"))
                if (!$util.isInteger(message.askVol) && !(message.askVol && $util.isInteger(message.askVol.low) && $util.isInteger(message.askVol.high)))
                    return "askVol: integer|Long expected";
            if (message.bidVol != null && message.hasOwnProperty("bidVol"))
                if (!$util.isInteger(message.bidVol) && !(message.bidVol && $util.isInteger(message.bidVol.low) && $util.isInteger(message.bidVol.high)))
                    return "bidVol: integer|Long expected";
            if (message.enableMargin != null && message.hasOwnProperty("enableMargin"))
                if (typeof message.enableMargin !== "boolean")
                    return "enableMargin: boolean expected";
            if (message.mortgageRatio != null && message.hasOwnProperty("mortgageRatio"))
                if (typeof message.mortgageRatio !== "number")
                    return "mortgageRatio: number expected";
            if (message.longMarginInitialRatio != null && message.hasOwnProperty("longMarginInitialRatio"))
                if (typeof message.longMarginInitialRatio !== "number")
                    return "longMarginInitialRatio: number expected";
            if (message.enableShortSell != null && message.hasOwnProperty("enableShortSell"))
                if (typeof message.enableShortSell !== "boolean")
                    return "enableShortSell: boolean expected";
            if (message.shortSellRate != null && message.hasOwnProperty("shortSellRate"))
                if (typeof message.shortSellRate !== "number")
                    return "shortSellRate: number expected";
            if (message.shortAvailableVolume != null && message.hasOwnProperty("shortAvailableVolume"))
                if (!$util.isInteger(message.shortAvailableVolume) && !(message.shortAvailableVolume && $util.isInteger(message.shortAvailableVolume.low) && $util.isInteger(message.shortAvailableVolume.high)))
                    return "shortAvailableVolume: integer|Long expected";
            if (message.shortMarginInitialRatio != null && message.hasOwnProperty("shortMarginInitialRatio"))
                if (typeof message.shortMarginInitialRatio !== "number")
                    return "shortMarginInitialRatio: number expected";
            if (message.amplitude != null && message.hasOwnProperty("amplitude"))
                if (typeof message.amplitude !== "number")
                    return "amplitude: number expected";
            if (message.avgPrice != null && message.hasOwnProperty("avgPrice"))
                if (typeof message.avgPrice !== "number")
                    return "avgPrice: number expected";
            if (message.bidAskRatio != null && message.hasOwnProperty("bidAskRatio"))
                if (typeof message.bidAskRatio !== "number")
                    return "bidAskRatio: number expected";
            if (message.volumeRatio != null && message.hasOwnProperty("volumeRatio"))
                if (typeof message.volumeRatio !== "number")
                    return "volumeRatio: number expected";
            if (message.highest52WeeksPrice != null && message.hasOwnProperty("highest52WeeksPrice"))
                if (typeof message.highest52WeeksPrice !== "number")
                    return "highest52WeeksPrice: number expected";
            if (message.lowest52WeeksPrice != null && message.hasOwnProperty("lowest52WeeksPrice"))
                if (typeof message.lowest52WeeksPrice !== "number")
                    return "lowest52WeeksPrice: number expected";
            if (message.highestHistoryPrice != null && message.hasOwnProperty("highestHistoryPrice"))
                if (typeof message.highestHistoryPrice !== "number")
                    return "highestHistoryPrice: number expected";
            if (message.lowestHistoryPrice != null && message.hasOwnProperty("lowestHistoryPrice"))
                if (typeof message.lowestHistoryPrice !== "number")
                    return "lowestHistoryPrice: number expected";
            if (message.preMarket != null && message.hasOwnProperty("preMarket")) {
                var error = $root.Qot_Common.PreAfterMarketData.verify(message.preMarket);
                if (error)
                    return "preMarket." + error;
            }
            if (message.afterMarket != null && message.hasOwnProperty("afterMarket")) {
                var error = $root.Qot_Common.PreAfterMarketData.verify(message.afterMarket);
                if (error)
                    return "afterMarket." + error;
            }
            if (message.secStatus != null && message.hasOwnProperty("secStatus"))
                if (!$util.isInteger(message.secStatus))
                    return "secStatus: integer expected";
            if (message.closePrice5Minute != null && message.hasOwnProperty("closePrice5Minute"))
                if (typeof message.closePrice5Minute !== "number")
                    return "closePrice5Minute: number expected";
            return null;
        };

        /**
         * Creates a SnapshotBasicData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSecuritySnapshot.SnapshotBasicData} SnapshotBasicData
         */
        SnapshotBasicData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSecuritySnapshot.SnapshotBasicData)
                return object;
            var message = new $root.Qot_GetSecuritySnapshot.SnapshotBasicData();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetSecuritySnapshot.SnapshotBasicData.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.type != null)
                message.type = object.type | 0;
            if (object.isSuspend != null)
                message.isSuspend = Boolean(object.isSuspend);
            if (object.listTime != null)
                message.listTime = String(object.listTime);
            if (object.lotSize != null)
                message.lotSize = object.lotSize | 0;
            if (object.priceSpread != null)
                message.priceSpread = Number(object.priceSpread);
            if (object.updateTime != null)
                message.updateTime = String(object.updateTime);
            if (object.highPrice != null)
                message.highPrice = Number(object.highPrice);
            if (object.openPrice != null)
                message.openPrice = Number(object.openPrice);
            if (object.lowPrice != null)
                message.lowPrice = Number(object.lowPrice);
            if (object.lastClosePrice != null)
                message.lastClosePrice = Number(object.lastClosePrice);
            if (object.curPrice != null)
                message.curPrice = Number(object.curPrice);
            if (object.volume != null)
                if ($util.Long)
                    (message.volume = $util.Long.fromValue(object.volume)).unsigned = false;
                else if (typeof object.volume === "string")
                    message.volume = parseInt(object.volume, 10);
                else if (typeof object.volume === "number")
                    message.volume = object.volume;
                else if (typeof object.volume === "object")
                    message.volume = new $util.LongBits(object.volume.low >>> 0, object.volume.high >>> 0).toNumber();
            if (object.turnover != null)
                message.turnover = Number(object.turnover);
            if (object.turnoverRate != null)
                message.turnoverRate = Number(object.turnoverRate);
            if (object.listTimestamp != null)
                message.listTimestamp = Number(object.listTimestamp);
            if (object.updateTimestamp != null)
                message.updateTimestamp = Number(object.updateTimestamp);
            if (object.askPrice != null)
                message.askPrice = Number(object.askPrice);
            if (object.bidPrice != null)
                message.bidPrice = Number(object.bidPrice);
            if (object.askVol != null)
                if ($util.Long)
                    (message.askVol = $util.Long.fromValue(object.askVol)).unsigned = false;
                else if (typeof object.askVol === "string")
                    message.askVol = parseInt(object.askVol, 10);
                else if (typeof object.askVol === "number")
                    message.askVol = object.askVol;
                else if (typeof object.askVol === "object")
                    message.askVol = new $util.LongBits(object.askVol.low >>> 0, object.askVol.high >>> 0).toNumber();
            if (object.bidVol != null)
                if ($util.Long)
                    (message.bidVol = $util.Long.fromValue(object.bidVol)).unsigned = false;
                else if (typeof object.bidVol === "string")
                    message.bidVol = parseInt(object.bidVol, 10);
                else if (typeof object.bidVol === "number")
                    message.bidVol = object.bidVol;
                else if (typeof object.bidVol === "object")
                    message.bidVol = new $util.LongBits(object.bidVol.low >>> 0, object.bidVol.high >>> 0).toNumber();
            if (object.enableMargin != null)
                message.enableMargin = Boolean(object.enableMargin);
            if (object.mortgageRatio != null)
                message.mortgageRatio = Number(object.mortgageRatio);
            if (object.longMarginInitialRatio != null)
                message.longMarginInitialRatio = Number(object.longMarginInitialRatio);
            if (object.enableShortSell != null)
                message.enableShortSell = Boolean(object.enableShortSell);
            if (object.shortSellRate != null)
                message.shortSellRate = Number(object.shortSellRate);
            if (object.shortAvailableVolume != null)
                if ($util.Long)
                    (message.shortAvailableVolume = $util.Long.fromValue(object.shortAvailableVolume)).unsigned = false;
                else if (typeof object.shortAvailableVolume === "string")
                    message.shortAvailableVolume = parseInt(object.shortAvailableVolume, 10);
                else if (typeof object.shortAvailableVolume === "number")
                    message.shortAvailableVolume = object.shortAvailableVolume;
                else if (typeof object.shortAvailableVolume === "object")
                    message.shortAvailableVolume = new $util.LongBits(object.shortAvailableVolume.low >>> 0, object.shortAvailableVolume.high >>> 0).toNumber();
            if (object.shortMarginInitialRatio != null)
                message.shortMarginInitialRatio = Number(object.shortMarginInitialRatio);
            if (object.amplitude != null)
                message.amplitude = Number(object.amplitude);
            if (object.avgPrice != null)
                message.avgPrice = Number(object.avgPrice);
            if (object.bidAskRatio != null)
                message.bidAskRatio = Number(object.bidAskRatio);
            if (object.volumeRatio != null)
                message.volumeRatio = Number(object.volumeRatio);
            if (object.highest52WeeksPrice != null)
                message.highest52WeeksPrice = Number(object.highest52WeeksPrice);
            if (object.lowest52WeeksPrice != null)
                message.lowest52WeeksPrice = Number(object.lowest52WeeksPrice);
            if (object.highestHistoryPrice != null)
                message.highestHistoryPrice = Number(object.highestHistoryPrice);
            if (object.lowestHistoryPrice != null)
                message.lowestHistoryPrice = Number(object.lowestHistoryPrice);
            if (object.preMarket != null) {
                if (typeof object.preMarket !== "object")
                    throw TypeError(".Qot_GetSecuritySnapshot.SnapshotBasicData.preMarket: object expected");
                message.preMarket = $root.Qot_Common.PreAfterMarketData.fromObject(object.preMarket);
            }
            if (object.afterMarket != null) {
                if (typeof object.afterMarket !== "object")
                    throw TypeError(".Qot_GetSecuritySnapshot.SnapshotBasicData.afterMarket: object expected");
                message.afterMarket = $root.Qot_Common.PreAfterMarketData.fromObject(object.afterMarket);
            }
            if (object.secStatus != null)
                message.secStatus = object.secStatus | 0;
            if (object.closePrice5Minute != null)
                message.closePrice5Minute = Number(object.closePrice5Minute);
            return message;
        };

        /**
         * Creates a plain object from a SnapshotBasicData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @static
         * @param {Qot_GetSecuritySnapshot.SnapshotBasicData} message SnapshotBasicData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SnapshotBasicData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.security = null;
                object.type = 0;
                object.isSuspend = false;
                object.listTime = "";
                object.lotSize = 0;
                object.priceSpread = 0;
                object.updateTime = "";
                object.highPrice = 0;
                object.openPrice = 0;
                object.lowPrice = 0;
                object.lastClosePrice = 0;
                object.curPrice = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.volume = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.volume = options.longs === String ? "0" : 0;
                object.turnover = 0;
                object.turnoverRate = 0;
                object.listTimestamp = 0;
                object.updateTimestamp = 0;
                object.askPrice = 0;
                object.bidPrice = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.askVol = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.askVol = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.bidVol = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bidVol = options.longs === String ? "0" : 0;
                object.enableMargin = false;
                object.mortgageRatio = 0;
                object.longMarginInitialRatio = 0;
                object.enableShortSell = false;
                object.shortSellRate = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.shortAvailableVolume = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.shortAvailableVolume = options.longs === String ? "0" : 0;
                object.shortMarginInitialRatio = 0;
                object.amplitude = 0;
                object.avgPrice = 0;
                object.bidAskRatio = 0;
                object.volumeRatio = 0;
                object.highest52WeeksPrice = 0;
                object.lowest52WeeksPrice = 0;
                object.highestHistoryPrice = 0;
                object.lowestHistoryPrice = 0;
                object.preMarket = null;
                object.afterMarket = null;
                object.secStatus = 0;
                object.closePrice5Minute = 0;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.isSuspend != null && message.hasOwnProperty("isSuspend"))
                object.isSuspend = message.isSuspend;
            if (message.listTime != null && message.hasOwnProperty("listTime"))
                object.listTime = message.listTime;
            if (message.lotSize != null && message.hasOwnProperty("lotSize"))
                object.lotSize = message.lotSize;
            if (message.priceSpread != null && message.hasOwnProperty("priceSpread"))
                object.priceSpread = options.json && !isFinite(message.priceSpread) ? String(message.priceSpread) : message.priceSpread;
            if (message.updateTime != null && message.hasOwnProperty("updateTime"))
                object.updateTime = message.updateTime;
            if (message.highPrice != null && message.hasOwnProperty("highPrice"))
                object.highPrice = options.json && !isFinite(message.highPrice) ? String(message.highPrice) : message.highPrice;
            if (message.openPrice != null && message.hasOwnProperty("openPrice"))
                object.openPrice = options.json && !isFinite(message.openPrice) ? String(message.openPrice) : message.openPrice;
            if (message.lowPrice != null && message.hasOwnProperty("lowPrice"))
                object.lowPrice = options.json && !isFinite(message.lowPrice) ? String(message.lowPrice) : message.lowPrice;
            if (message.lastClosePrice != null && message.hasOwnProperty("lastClosePrice"))
                object.lastClosePrice = options.json && !isFinite(message.lastClosePrice) ? String(message.lastClosePrice) : message.lastClosePrice;
            if (message.curPrice != null && message.hasOwnProperty("curPrice"))
                object.curPrice = options.json && !isFinite(message.curPrice) ? String(message.curPrice) : message.curPrice;
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (typeof message.volume === "number")
                    object.volume = options.longs === String ? String(message.volume) : message.volume;
                else
                    object.volume = options.longs === String ? $util.Long.prototype.toString.call(message.volume) : options.longs === Number ? new $util.LongBits(message.volume.low >>> 0, message.volume.high >>> 0).toNumber() : message.volume;
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                object.turnover = options.json && !isFinite(message.turnover) ? String(message.turnover) : message.turnover;
            if (message.turnoverRate != null && message.hasOwnProperty("turnoverRate"))
                object.turnoverRate = options.json && !isFinite(message.turnoverRate) ? String(message.turnoverRate) : message.turnoverRate;
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                object.listTimestamp = options.json && !isFinite(message.listTimestamp) ? String(message.listTimestamp) : message.listTimestamp;
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                object.updateTimestamp = options.json && !isFinite(message.updateTimestamp) ? String(message.updateTimestamp) : message.updateTimestamp;
            if (message.askPrice != null && message.hasOwnProperty("askPrice"))
                object.askPrice = options.json && !isFinite(message.askPrice) ? String(message.askPrice) : message.askPrice;
            if (message.bidPrice != null && message.hasOwnProperty("bidPrice"))
                object.bidPrice = options.json && !isFinite(message.bidPrice) ? String(message.bidPrice) : message.bidPrice;
            if (message.askVol != null && message.hasOwnProperty("askVol"))
                if (typeof message.askVol === "number")
                    object.askVol = options.longs === String ? String(message.askVol) : message.askVol;
                else
                    object.askVol = options.longs === String ? $util.Long.prototype.toString.call(message.askVol) : options.longs === Number ? new $util.LongBits(message.askVol.low >>> 0, message.askVol.high >>> 0).toNumber() : message.askVol;
            if (message.bidVol != null && message.hasOwnProperty("bidVol"))
                if (typeof message.bidVol === "number")
                    object.bidVol = options.longs === String ? String(message.bidVol) : message.bidVol;
                else
                    object.bidVol = options.longs === String ? $util.Long.prototype.toString.call(message.bidVol) : options.longs === Number ? new $util.LongBits(message.bidVol.low >>> 0, message.bidVol.high >>> 0).toNumber() : message.bidVol;
            if (message.enableMargin != null && message.hasOwnProperty("enableMargin"))
                object.enableMargin = message.enableMargin;
            if (message.mortgageRatio != null && message.hasOwnProperty("mortgageRatio"))
                object.mortgageRatio = options.json && !isFinite(message.mortgageRatio) ? String(message.mortgageRatio) : message.mortgageRatio;
            if (message.longMarginInitialRatio != null && message.hasOwnProperty("longMarginInitialRatio"))
                object.longMarginInitialRatio = options.json && !isFinite(message.longMarginInitialRatio) ? String(message.longMarginInitialRatio) : message.longMarginInitialRatio;
            if (message.enableShortSell != null && message.hasOwnProperty("enableShortSell"))
                object.enableShortSell = message.enableShortSell;
            if (message.shortSellRate != null && message.hasOwnProperty("shortSellRate"))
                object.shortSellRate = options.json && !isFinite(message.shortSellRate) ? String(message.shortSellRate) : message.shortSellRate;
            if (message.shortAvailableVolume != null && message.hasOwnProperty("shortAvailableVolume"))
                if (typeof message.shortAvailableVolume === "number")
                    object.shortAvailableVolume = options.longs === String ? String(message.shortAvailableVolume) : message.shortAvailableVolume;
                else
                    object.shortAvailableVolume = options.longs === String ? $util.Long.prototype.toString.call(message.shortAvailableVolume) : options.longs === Number ? new $util.LongBits(message.shortAvailableVolume.low >>> 0, message.shortAvailableVolume.high >>> 0).toNumber() : message.shortAvailableVolume;
            if (message.shortMarginInitialRatio != null && message.hasOwnProperty("shortMarginInitialRatio"))
                object.shortMarginInitialRatio = options.json && !isFinite(message.shortMarginInitialRatio) ? String(message.shortMarginInitialRatio) : message.shortMarginInitialRatio;
            if (message.amplitude != null && message.hasOwnProperty("amplitude"))
                object.amplitude = options.json && !isFinite(message.amplitude) ? String(message.amplitude) : message.amplitude;
            if (message.avgPrice != null && message.hasOwnProperty("avgPrice"))
                object.avgPrice = options.json && !isFinite(message.avgPrice) ? String(message.avgPrice) : message.avgPrice;
            if (message.bidAskRatio != null && message.hasOwnProperty("bidAskRatio"))
                object.bidAskRatio = options.json && !isFinite(message.bidAskRatio) ? String(message.bidAskRatio) : message.bidAskRatio;
            if (message.volumeRatio != null && message.hasOwnProperty("volumeRatio"))
                object.volumeRatio = options.json && !isFinite(message.volumeRatio) ? String(message.volumeRatio) : message.volumeRatio;
            if (message.highest52WeeksPrice != null && message.hasOwnProperty("highest52WeeksPrice"))
                object.highest52WeeksPrice = options.json && !isFinite(message.highest52WeeksPrice) ? String(message.highest52WeeksPrice) : message.highest52WeeksPrice;
            if (message.lowest52WeeksPrice != null && message.hasOwnProperty("lowest52WeeksPrice"))
                object.lowest52WeeksPrice = options.json && !isFinite(message.lowest52WeeksPrice) ? String(message.lowest52WeeksPrice) : message.lowest52WeeksPrice;
            if (message.highestHistoryPrice != null && message.hasOwnProperty("highestHistoryPrice"))
                object.highestHistoryPrice = options.json && !isFinite(message.highestHistoryPrice) ? String(message.highestHistoryPrice) : message.highestHistoryPrice;
            if (message.lowestHistoryPrice != null && message.hasOwnProperty("lowestHistoryPrice"))
                object.lowestHistoryPrice = options.json && !isFinite(message.lowestHistoryPrice) ? String(message.lowestHistoryPrice) : message.lowestHistoryPrice;
            if (message.preMarket != null && message.hasOwnProperty("preMarket"))
                object.preMarket = $root.Qot_Common.PreAfterMarketData.toObject(message.preMarket, options);
            if (message.afterMarket != null && message.hasOwnProperty("afterMarket"))
                object.afterMarket = $root.Qot_Common.PreAfterMarketData.toObject(message.afterMarket, options);
            if (message.secStatus != null && message.hasOwnProperty("secStatus"))
                object.secStatus = message.secStatus;
            if (message.closePrice5Minute != null && message.hasOwnProperty("closePrice5Minute"))
                object.closePrice5Minute = options.json && !isFinite(message.closePrice5Minute) ? String(message.closePrice5Minute) : message.closePrice5Minute;
            return object;
        };

        /**
         * Converts this SnapshotBasicData to JSON.
         * @function toJSON
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SnapshotBasicData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SnapshotBasicData;
    })();

    Qot_GetSecuritySnapshot.Snapshot = (function() {

        /**
         * Properties of a Snapshot.
         * @memberof Qot_GetSecuritySnapshot
         * @interface ISnapshot
         * @property {Qot_GetSecuritySnapshot.ISnapshotBasicData} basic Snapshot basic
         * @property {Qot_GetSecuritySnapshot.IEquitySnapshotExData|null} [equityExData] Snapshot equityExData
         * @property {Qot_GetSecuritySnapshot.IWarrantSnapshotExData|null} [warrantExData] Snapshot warrantExData
         * @property {Qot_GetSecuritySnapshot.IOptionSnapshotExData|null} [optionExData] Snapshot optionExData
         * @property {Qot_GetSecuritySnapshot.IIndexSnapshotExData|null} [indexExData] Snapshot indexExData
         * @property {Qot_GetSecuritySnapshot.IPlateSnapshotExData|null} [plateExData] Snapshot plateExData
         * @property {Qot_GetSecuritySnapshot.IFutureSnapshotExData|null} [futureExData] Snapshot futureExData
         */

        /**
         * Constructs a new Snapshot.
         * @memberof Qot_GetSecuritySnapshot
         * @classdesc Represents a Snapshot.
         * @implements ISnapshot
         * @constructor
         * @param {Qot_GetSecuritySnapshot.ISnapshot=} [properties] Properties to set
         */
        function Snapshot(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Snapshot basic.
         * @member {Qot_GetSecuritySnapshot.ISnapshotBasicData} basic
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @instance
         */
        Snapshot.prototype.basic = null;

        /**
         * Snapshot equityExData.
         * @member {Qot_GetSecuritySnapshot.IEquitySnapshotExData|null|undefined} equityExData
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @instance
         */
        Snapshot.prototype.equityExData = null;

        /**
         * Snapshot warrantExData.
         * @member {Qot_GetSecuritySnapshot.IWarrantSnapshotExData|null|undefined} warrantExData
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @instance
         */
        Snapshot.prototype.warrantExData = null;

        /**
         * Snapshot optionExData.
         * @member {Qot_GetSecuritySnapshot.IOptionSnapshotExData|null|undefined} optionExData
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @instance
         */
        Snapshot.prototype.optionExData = null;

        /**
         * Snapshot indexExData.
         * @member {Qot_GetSecuritySnapshot.IIndexSnapshotExData|null|undefined} indexExData
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @instance
         */
        Snapshot.prototype.indexExData = null;

        /**
         * Snapshot plateExData.
         * @member {Qot_GetSecuritySnapshot.IPlateSnapshotExData|null|undefined} plateExData
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @instance
         */
        Snapshot.prototype.plateExData = null;

        /**
         * Snapshot futureExData.
         * @member {Qot_GetSecuritySnapshot.IFutureSnapshotExData|null|undefined} futureExData
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @instance
         */
        Snapshot.prototype.futureExData = null;

        /**
         * Creates a new Snapshot instance using the specified properties.
         * @function create
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @static
         * @param {Qot_GetSecuritySnapshot.ISnapshot=} [properties] Properties to set
         * @returns {Qot_GetSecuritySnapshot.Snapshot} Snapshot instance
         */
        Snapshot.create = function create(properties) {
            return new Snapshot(properties);
        };

        /**
         * Encodes the specified Snapshot message. Does not implicitly {@link Qot_GetSecuritySnapshot.Snapshot.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @static
         * @param {Qot_GetSecuritySnapshot.ISnapshot} message Snapshot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Snapshot.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetSecuritySnapshot.SnapshotBasicData.encode(message.basic, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.equityExData != null && message.hasOwnProperty("equityExData"))
                $root.Qot_GetSecuritySnapshot.EquitySnapshotExData.encode(message.equityExData, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.warrantExData != null && message.hasOwnProperty("warrantExData"))
                $root.Qot_GetSecuritySnapshot.WarrantSnapshotExData.encode(message.warrantExData, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.optionExData != null && message.hasOwnProperty("optionExData"))
                $root.Qot_GetSecuritySnapshot.OptionSnapshotExData.encode(message.optionExData, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.indexExData != null && message.hasOwnProperty("indexExData"))
                $root.Qot_GetSecuritySnapshot.IndexSnapshotExData.encode(message.indexExData, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.plateExData != null && message.hasOwnProperty("plateExData"))
                $root.Qot_GetSecuritySnapshot.PlateSnapshotExData.encode(message.plateExData, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.futureExData != null && message.hasOwnProperty("futureExData"))
                $root.Qot_GetSecuritySnapshot.FutureSnapshotExData.encode(message.futureExData, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Snapshot message, length delimited. Does not implicitly {@link Qot_GetSecuritySnapshot.Snapshot.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @static
         * @param {Qot_GetSecuritySnapshot.ISnapshot} message Snapshot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Snapshot.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Snapshot message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSecuritySnapshot.Snapshot} Snapshot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Snapshot.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSecuritySnapshot.Snapshot();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.basic = $root.Qot_GetSecuritySnapshot.SnapshotBasicData.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.equityExData = $root.Qot_GetSecuritySnapshot.EquitySnapshotExData.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.warrantExData = $root.Qot_GetSecuritySnapshot.WarrantSnapshotExData.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.optionExData = $root.Qot_GetSecuritySnapshot.OptionSnapshotExData.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.indexExData = $root.Qot_GetSecuritySnapshot.IndexSnapshotExData.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.plateExData = $root.Qot_GetSecuritySnapshot.PlateSnapshotExData.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.futureExData = $root.Qot_GetSecuritySnapshot.FutureSnapshotExData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("basic"))
                throw $util.ProtocolError("missing required 'basic'", { instance: message });
            return message;
        };

        /**
         * Decodes a Snapshot message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSecuritySnapshot.Snapshot} Snapshot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Snapshot.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Snapshot message.
         * @function verify
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Snapshot.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetSecuritySnapshot.SnapshotBasicData.verify(message.basic);
                if (error)
                    return "basic." + error;
            }
            if (message.equityExData != null && message.hasOwnProperty("equityExData")) {
                var error = $root.Qot_GetSecuritySnapshot.EquitySnapshotExData.verify(message.equityExData);
                if (error)
                    return "equityExData." + error;
            }
            if (message.warrantExData != null && message.hasOwnProperty("warrantExData")) {
                var error = $root.Qot_GetSecuritySnapshot.WarrantSnapshotExData.verify(message.warrantExData);
                if (error)
                    return "warrantExData." + error;
            }
            if (message.optionExData != null && message.hasOwnProperty("optionExData")) {
                var error = $root.Qot_GetSecuritySnapshot.OptionSnapshotExData.verify(message.optionExData);
                if (error)
                    return "optionExData." + error;
            }
            if (message.indexExData != null && message.hasOwnProperty("indexExData")) {
                var error = $root.Qot_GetSecuritySnapshot.IndexSnapshotExData.verify(message.indexExData);
                if (error)
                    return "indexExData." + error;
            }
            if (message.plateExData != null && message.hasOwnProperty("plateExData")) {
                var error = $root.Qot_GetSecuritySnapshot.PlateSnapshotExData.verify(message.plateExData);
                if (error)
                    return "plateExData." + error;
            }
            if (message.futureExData != null && message.hasOwnProperty("futureExData")) {
                var error = $root.Qot_GetSecuritySnapshot.FutureSnapshotExData.verify(message.futureExData);
                if (error)
                    return "futureExData." + error;
            }
            return null;
        };

        /**
         * Creates a Snapshot message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSecuritySnapshot.Snapshot} Snapshot
         */
        Snapshot.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSecuritySnapshot.Snapshot)
                return object;
            var message = new $root.Qot_GetSecuritySnapshot.Snapshot();
            if (object.basic != null) {
                if (typeof object.basic !== "object")
                    throw TypeError(".Qot_GetSecuritySnapshot.Snapshot.basic: object expected");
                message.basic = $root.Qot_GetSecuritySnapshot.SnapshotBasicData.fromObject(object.basic);
            }
            if (object.equityExData != null) {
                if (typeof object.equityExData !== "object")
                    throw TypeError(".Qot_GetSecuritySnapshot.Snapshot.equityExData: object expected");
                message.equityExData = $root.Qot_GetSecuritySnapshot.EquitySnapshotExData.fromObject(object.equityExData);
            }
            if (object.warrantExData != null) {
                if (typeof object.warrantExData !== "object")
                    throw TypeError(".Qot_GetSecuritySnapshot.Snapshot.warrantExData: object expected");
                message.warrantExData = $root.Qot_GetSecuritySnapshot.WarrantSnapshotExData.fromObject(object.warrantExData);
            }
            if (object.optionExData != null) {
                if (typeof object.optionExData !== "object")
                    throw TypeError(".Qot_GetSecuritySnapshot.Snapshot.optionExData: object expected");
                message.optionExData = $root.Qot_GetSecuritySnapshot.OptionSnapshotExData.fromObject(object.optionExData);
            }
            if (object.indexExData != null) {
                if (typeof object.indexExData !== "object")
                    throw TypeError(".Qot_GetSecuritySnapshot.Snapshot.indexExData: object expected");
                message.indexExData = $root.Qot_GetSecuritySnapshot.IndexSnapshotExData.fromObject(object.indexExData);
            }
            if (object.plateExData != null) {
                if (typeof object.plateExData !== "object")
                    throw TypeError(".Qot_GetSecuritySnapshot.Snapshot.plateExData: object expected");
                message.plateExData = $root.Qot_GetSecuritySnapshot.PlateSnapshotExData.fromObject(object.plateExData);
            }
            if (object.futureExData != null) {
                if (typeof object.futureExData !== "object")
                    throw TypeError(".Qot_GetSecuritySnapshot.Snapshot.futureExData: object expected");
                message.futureExData = $root.Qot_GetSecuritySnapshot.FutureSnapshotExData.fromObject(object.futureExData);
            }
            return message;
        };

        /**
         * Creates a plain object from a Snapshot message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @static
         * @param {Qot_GetSecuritySnapshot.Snapshot} message Snapshot
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Snapshot.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.basic = null;
                object.equityExData = null;
                object.warrantExData = null;
                object.optionExData = null;
                object.indexExData = null;
                object.plateExData = null;
                object.futureExData = null;
            }
            if (message.basic != null && message.hasOwnProperty("basic"))
                object.basic = $root.Qot_GetSecuritySnapshot.SnapshotBasicData.toObject(message.basic, options);
            if (message.equityExData != null && message.hasOwnProperty("equityExData"))
                object.equityExData = $root.Qot_GetSecuritySnapshot.EquitySnapshotExData.toObject(message.equityExData, options);
            if (message.warrantExData != null && message.hasOwnProperty("warrantExData"))
                object.warrantExData = $root.Qot_GetSecuritySnapshot.WarrantSnapshotExData.toObject(message.warrantExData, options);
            if (message.optionExData != null && message.hasOwnProperty("optionExData"))
                object.optionExData = $root.Qot_GetSecuritySnapshot.OptionSnapshotExData.toObject(message.optionExData, options);
            if (message.indexExData != null && message.hasOwnProperty("indexExData"))
                object.indexExData = $root.Qot_GetSecuritySnapshot.IndexSnapshotExData.toObject(message.indexExData, options);
            if (message.plateExData != null && message.hasOwnProperty("plateExData"))
                object.plateExData = $root.Qot_GetSecuritySnapshot.PlateSnapshotExData.toObject(message.plateExData, options);
            if (message.futureExData != null && message.hasOwnProperty("futureExData"))
                object.futureExData = $root.Qot_GetSecuritySnapshot.FutureSnapshotExData.toObject(message.futureExData, options);
            return object;
        };

        /**
         * Converts this Snapshot to JSON.
         * @function toJSON
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Snapshot.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Snapshot;
    })();

    Qot_GetSecuritySnapshot.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetSecuritySnapshot
         * @interface IS2C
         * @property {Array.<Qot_GetSecuritySnapshot.ISnapshot>|null} [snapshotList] S2C snapshotList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetSecuritySnapshot
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetSecuritySnapshot.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.snapshotList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C snapshotList.
         * @member {Array.<Qot_GetSecuritySnapshot.ISnapshot>} snapshotList
         * @memberof Qot_GetSecuritySnapshot.S2C
         * @instance
         */
        S2C.prototype.snapshotList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetSecuritySnapshot.S2C
         * @static
         * @param {Qot_GetSecuritySnapshot.IS2C=} [properties] Properties to set
         * @returns {Qot_GetSecuritySnapshot.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetSecuritySnapshot.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSecuritySnapshot.S2C
         * @static
         * @param {Qot_GetSecuritySnapshot.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.snapshotList != null && message.snapshotList.length)
                for (var i = 0; i < message.snapshotList.length; ++i)
                    $root.Qot_GetSecuritySnapshot.Snapshot.encode(message.snapshotList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetSecuritySnapshot.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSecuritySnapshot.S2C
         * @static
         * @param {Qot_GetSecuritySnapshot.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSecuritySnapshot.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSecuritySnapshot.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSecuritySnapshot.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.snapshotList && message.snapshotList.length))
                        message.snapshotList = [];
                    message.snapshotList.push($root.Qot_GetSecuritySnapshot.Snapshot.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSecuritySnapshot.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSecuritySnapshot.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetSecuritySnapshot.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.snapshotList != null && message.hasOwnProperty("snapshotList")) {
                if (!Array.isArray(message.snapshotList))
                    return "snapshotList: array expected";
                for (var i = 0; i < message.snapshotList.length; ++i) {
                    var error = $root.Qot_GetSecuritySnapshot.Snapshot.verify(message.snapshotList[i]);
                    if (error)
                        return "snapshotList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSecuritySnapshot.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSecuritySnapshot.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSecuritySnapshot.S2C)
                return object;
            var message = new $root.Qot_GetSecuritySnapshot.S2C();
            if (object.snapshotList) {
                if (!Array.isArray(object.snapshotList))
                    throw TypeError(".Qot_GetSecuritySnapshot.S2C.snapshotList: array expected");
                message.snapshotList = [];
                for (var i = 0; i < object.snapshotList.length; ++i) {
                    if (typeof object.snapshotList[i] !== "object")
                        throw TypeError(".Qot_GetSecuritySnapshot.S2C.snapshotList: object expected");
                    message.snapshotList[i] = $root.Qot_GetSecuritySnapshot.Snapshot.fromObject(object.snapshotList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSecuritySnapshot.S2C
         * @static
         * @param {Qot_GetSecuritySnapshot.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.snapshotList = [];
            if (message.snapshotList && message.snapshotList.length) {
                object.snapshotList = [];
                for (var j = 0; j < message.snapshotList.length; ++j)
                    object.snapshotList[j] = $root.Qot_GetSecuritySnapshot.Snapshot.toObject(message.snapshotList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetSecuritySnapshot.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetSecuritySnapshot.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetSecuritySnapshot
         * @interface IRequest
         * @property {Qot_GetSecuritySnapshot.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetSecuritySnapshot
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetSecuritySnapshot.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetSecuritySnapshot.IC2S} c2s
         * @memberof Qot_GetSecuritySnapshot.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetSecuritySnapshot.Request
         * @static
         * @param {Qot_GetSecuritySnapshot.IRequest=} [properties] Properties to set
         * @returns {Qot_GetSecuritySnapshot.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetSecuritySnapshot.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSecuritySnapshot.Request
         * @static
         * @param {Qot_GetSecuritySnapshot.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetSecuritySnapshot.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetSecuritySnapshot.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSecuritySnapshot.Request
         * @static
         * @param {Qot_GetSecuritySnapshot.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSecuritySnapshot.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSecuritySnapshot.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSecuritySnapshot.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetSecuritySnapshot.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSecuritySnapshot.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSecuritySnapshot.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetSecuritySnapshot.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetSecuritySnapshot.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSecuritySnapshot.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSecuritySnapshot.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSecuritySnapshot.Request)
                return object;
            var message = new $root.Qot_GetSecuritySnapshot.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetSecuritySnapshot.Request.c2s: object expected");
                message.c2s = $root.Qot_GetSecuritySnapshot.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSecuritySnapshot.Request
         * @static
         * @param {Qot_GetSecuritySnapshot.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetSecuritySnapshot.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetSecuritySnapshot.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetSecuritySnapshot.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetSecuritySnapshot
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetSecuritySnapshot.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetSecuritySnapshot
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetSecuritySnapshot.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetSecuritySnapshot.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetSecuritySnapshot.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetSecuritySnapshot.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetSecuritySnapshot.IS2C|null|undefined} s2c
         * @memberof Qot_GetSecuritySnapshot.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetSecuritySnapshot.Response
         * @static
         * @param {Qot_GetSecuritySnapshot.IResponse=} [properties] Properties to set
         * @returns {Qot_GetSecuritySnapshot.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetSecuritySnapshot.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSecuritySnapshot.Response
         * @static
         * @param {Qot_GetSecuritySnapshot.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetSecuritySnapshot.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetSecuritySnapshot.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSecuritySnapshot.Response
         * @static
         * @param {Qot_GetSecuritySnapshot.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSecuritySnapshot.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSecuritySnapshot.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSecuritySnapshot.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetSecuritySnapshot.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSecuritySnapshot.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSecuritySnapshot.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetSecuritySnapshot.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetSecuritySnapshot.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSecuritySnapshot.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSecuritySnapshot.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSecuritySnapshot.Response)
                return object;
            var message = new $root.Qot_GetSecuritySnapshot.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetSecuritySnapshot.Response.s2c: object expected");
                message.s2c = $root.Qot_GetSecuritySnapshot.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSecuritySnapshot.Response
         * @static
         * @param {Qot_GetSecuritySnapshot.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetSecuritySnapshot.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetSecuritySnapshot.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetSecuritySnapshot;
})();

$root.Qot_GetStaticInfo = (function() {

    /**
     * Namespace Qot_GetStaticInfo.
     * @exports Qot_GetStaticInfo
     * @namespace
     */
    var Qot_GetStaticInfo = {};

    Qot_GetStaticInfo.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetStaticInfo
         * @interface IC2S
         * @property {number|null} [market] C2S market
         * @property {number|null} [secType] C2S secType
         * @property {Array.<Qot_Common.ISecurity>|null} [securityList] C2S securityList
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetStaticInfo
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetStaticInfo.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.securityList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S market.
         * @member {number} market
         * @memberof Qot_GetStaticInfo.C2S
         * @instance
         */
        C2S.prototype.market = 0;

        /**
         * C2S secType.
         * @member {number} secType
         * @memberof Qot_GetStaticInfo.C2S
         * @instance
         */
        C2S.prototype.secType = 0;

        /**
         * C2S securityList.
         * @member {Array.<Qot_Common.ISecurity>} securityList
         * @memberof Qot_GetStaticInfo.C2S
         * @instance
         */
        C2S.prototype.securityList = $util.emptyArray;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetStaticInfo.C2S
         * @static
         * @param {Qot_GetStaticInfo.IC2S=} [properties] Properties to set
         * @returns {Qot_GetStaticInfo.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetStaticInfo.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetStaticInfo.C2S
         * @static
         * @param {Qot_GetStaticInfo.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.market != null && message.hasOwnProperty("market"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.market);
            if (message.secType != null && message.hasOwnProperty("secType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.secType);
            if (message.securityList != null && message.securityList.length)
                for (var i = 0; i < message.securityList.length; ++i)
                    $root.Qot_Common.Security.encode(message.securityList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetStaticInfo.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetStaticInfo.C2S
         * @static
         * @param {Qot_GetStaticInfo.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetStaticInfo.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetStaticInfo.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetStaticInfo.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.market = reader.int32();
                    break;
                case 2:
                    message.secType = reader.int32();
                    break;
                case 3:
                    if (!(message.securityList && message.securityList.length))
                        message.securityList = [];
                    message.securityList.push($root.Qot_Common.Security.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetStaticInfo.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetStaticInfo.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetStaticInfo.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.market != null && message.hasOwnProperty("market"))
                if (!$util.isInteger(message.market))
                    return "market: integer expected";
            if (message.secType != null && message.hasOwnProperty("secType"))
                if (!$util.isInteger(message.secType))
                    return "secType: integer expected";
            if (message.securityList != null && message.hasOwnProperty("securityList")) {
                if (!Array.isArray(message.securityList))
                    return "securityList: array expected";
                for (var i = 0; i < message.securityList.length; ++i) {
                    var error = $root.Qot_Common.Security.verify(message.securityList[i]);
                    if (error)
                        return "securityList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetStaticInfo.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetStaticInfo.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetStaticInfo.C2S)
                return object;
            var message = new $root.Qot_GetStaticInfo.C2S();
            if (object.market != null)
                message.market = object.market | 0;
            if (object.secType != null)
                message.secType = object.secType | 0;
            if (object.securityList) {
                if (!Array.isArray(object.securityList))
                    throw TypeError(".Qot_GetStaticInfo.C2S.securityList: array expected");
                message.securityList = [];
                for (var i = 0; i < object.securityList.length; ++i) {
                    if (typeof object.securityList[i] !== "object")
                        throw TypeError(".Qot_GetStaticInfo.C2S.securityList: object expected");
                    message.securityList[i] = $root.Qot_Common.Security.fromObject(object.securityList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetStaticInfo.C2S
         * @static
         * @param {Qot_GetStaticInfo.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.securityList = [];
            if (options.defaults) {
                object.market = 0;
                object.secType = 0;
            }
            if (message.market != null && message.hasOwnProperty("market"))
                object.market = message.market;
            if (message.secType != null && message.hasOwnProperty("secType"))
                object.secType = message.secType;
            if (message.securityList && message.securityList.length) {
                object.securityList = [];
                for (var j = 0; j < message.securityList.length; ++j)
                    object.securityList[j] = $root.Qot_Common.Security.toObject(message.securityList[j], options);
            }
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetStaticInfo.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetStaticInfo.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetStaticInfo
         * @interface IS2C
         * @property {Array.<Qot_Common.ISecurityStaticInfo>|null} [staticInfoList] S2C staticInfoList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetStaticInfo
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetStaticInfo.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.staticInfoList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C staticInfoList.
         * @member {Array.<Qot_Common.ISecurityStaticInfo>} staticInfoList
         * @memberof Qot_GetStaticInfo.S2C
         * @instance
         */
        S2C.prototype.staticInfoList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetStaticInfo.S2C
         * @static
         * @param {Qot_GetStaticInfo.IS2C=} [properties] Properties to set
         * @returns {Qot_GetStaticInfo.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetStaticInfo.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetStaticInfo.S2C
         * @static
         * @param {Qot_GetStaticInfo.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.staticInfoList != null && message.staticInfoList.length)
                for (var i = 0; i < message.staticInfoList.length; ++i)
                    $root.Qot_Common.SecurityStaticInfo.encode(message.staticInfoList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetStaticInfo.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetStaticInfo.S2C
         * @static
         * @param {Qot_GetStaticInfo.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetStaticInfo.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetStaticInfo.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetStaticInfo.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.staticInfoList && message.staticInfoList.length))
                        message.staticInfoList = [];
                    message.staticInfoList.push($root.Qot_Common.SecurityStaticInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetStaticInfo.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetStaticInfo.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetStaticInfo.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.staticInfoList != null && message.hasOwnProperty("staticInfoList")) {
                if (!Array.isArray(message.staticInfoList))
                    return "staticInfoList: array expected";
                for (var i = 0; i < message.staticInfoList.length; ++i) {
                    var error = $root.Qot_Common.SecurityStaticInfo.verify(message.staticInfoList[i]);
                    if (error)
                        return "staticInfoList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetStaticInfo.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetStaticInfo.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetStaticInfo.S2C)
                return object;
            var message = new $root.Qot_GetStaticInfo.S2C();
            if (object.staticInfoList) {
                if (!Array.isArray(object.staticInfoList))
                    throw TypeError(".Qot_GetStaticInfo.S2C.staticInfoList: array expected");
                message.staticInfoList = [];
                for (var i = 0; i < object.staticInfoList.length; ++i) {
                    if (typeof object.staticInfoList[i] !== "object")
                        throw TypeError(".Qot_GetStaticInfo.S2C.staticInfoList: object expected");
                    message.staticInfoList[i] = $root.Qot_Common.SecurityStaticInfo.fromObject(object.staticInfoList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetStaticInfo.S2C
         * @static
         * @param {Qot_GetStaticInfo.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.staticInfoList = [];
            if (message.staticInfoList && message.staticInfoList.length) {
                object.staticInfoList = [];
                for (var j = 0; j < message.staticInfoList.length; ++j)
                    object.staticInfoList[j] = $root.Qot_Common.SecurityStaticInfo.toObject(message.staticInfoList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetStaticInfo.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetStaticInfo.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetStaticInfo
         * @interface IRequest
         * @property {Qot_GetStaticInfo.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetStaticInfo
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetStaticInfo.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetStaticInfo.IC2S} c2s
         * @memberof Qot_GetStaticInfo.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetStaticInfo.Request
         * @static
         * @param {Qot_GetStaticInfo.IRequest=} [properties] Properties to set
         * @returns {Qot_GetStaticInfo.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetStaticInfo.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetStaticInfo.Request
         * @static
         * @param {Qot_GetStaticInfo.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetStaticInfo.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetStaticInfo.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetStaticInfo.Request
         * @static
         * @param {Qot_GetStaticInfo.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetStaticInfo.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetStaticInfo.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetStaticInfo.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetStaticInfo.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetStaticInfo.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetStaticInfo.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetStaticInfo.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetStaticInfo.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetStaticInfo.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetStaticInfo.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetStaticInfo.Request)
                return object;
            var message = new $root.Qot_GetStaticInfo.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetStaticInfo.Request.c2s: object expected");
                message.c2s = $root.Qot_GetStaticInfo.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetStaticInfo.Request
         * @static
         * @param {Qot_GetStaticInfo.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetStaticInfo.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetStaticInfo.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetStaticInfo.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetStaticInfo
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetStaticInfo.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetStaticInfo
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetStaticInfo.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetStaticInfo.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetStaticInfo.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetStaticInfo.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetStaticInfo.IS2C|null|undefined} s2c
         * @memberof Qot_GetStaticInfo.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetStaticInfo.Response
         * @static
         * @param {Qot_GetStaticInfo.IResponse=} [properties] Properties to set
         * @returns {Qot_GetStaticInfo.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetStaticInfo.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetStaticInfo.Response
         * @static
         * @param {Qot_GetStaticInfo.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetStaticInfo.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetStaticInfo.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetStaticInfo.Response
         * @static
         * @param {Qot_GetStaticInfo.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetStaticInfo.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetStaticInfo.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetStaticInfo.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetStaticInfo.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetStaticInfo.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetStaticInfo.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetStaticInfo.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetStaticInfo.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetStaticInfo.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetStaticInfo.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetStaticInfo.Response)
                return object;
            var message = new $root.Qot_GetStaticInfo.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetStaticInfo.Response.s2c: object expected");
                message.s2c = $root.Qot_GetStaticInfo.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetStaticInfo.Response
         * @static
         * @param {Qot_GetStaticInfo.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetStaticInfo.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetStaticInfo.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetStaticInfo;
})();

$root.Qot_GetSubInfo = (function() {

    /**
     * Namespace Qot_GetSubInfo.
     * @exports Qot_GetSubInfo
     * @namespace
     */
    var Qot_GetSubInfo = {};

    Qot_GetSubInfo.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetSubInfo
         * @interface IC2S
         * @property {boolean|null} [isReqAllConn] C2S isReqAllConn
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetSubInfo
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetSubInfo.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S isReqAllConn.
         * @member {boolean} isReqAllConn
         * @memberof Qot_GetSubInfo.C2S
         * @instance
         */
        C2S.prototype.isReqAllConn = false;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetSubInfo.C2S
         * @static
         * @param {Qot_GetSubInfo.IC2S=} [properties] Properties to set
         * @returns {Qot_GetSubInfo.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetSubInfo.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSubInfo.C2S
         * @static
         * @param {Qot_GetSubInfo.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isReqAllConn != null && message.hasOwnProperty("isReqAllConn"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isReqAllConn);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetSubInfo.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSubInfo.C2S
         * @static
         * @param {Qot_GetSubInfo.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSubInfo.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSubInfo.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSubInfo.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isReqAllConn = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSubInfo.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSubInfo.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetSubInfo.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isReqAllConn != null && message.hasOwnProperty("isReqAllConn"))
                if (typeof message.isReqAllConn !== "boolean")
                    return "isReqAllConn: boolean expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSubInfo.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSubInfo.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSubInfo.C2S)
                return object;
            var message = new $root.Qot_GetSubInfo.C2S();
            if (object.isReqAllConn != null)
                message.isReqAllConn = Boolean(object.isReqAllConn);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSubInfo.C2S
         * @static
         * @param {Qot_GetSubInfo.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.isReqAllConn = false;
            if (message.isReqAllConn != null && message.hasOwnProperty("isReqAllConn"))
                object.isReqAllConn = message.isReqAllConn;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetSubInfo.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetSubInfo.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetSubInfo
         * @interface IS2C
         * @property {Array.<Qot_Common.IConnSubInfo>|null} [connSubInfoList] S2C connSubInfoList
         * @property {number} totalUsedQuota S2C totalUsedQuota
         * @property {number} remainQuota S2C remainQuota
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetSubInfo
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetSubInfo.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.connSubInfoList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C connSubInfoList.
         * @member {Array.<Qot_Common.IConnSubInfo>} connSubInfoList
         * @memberof Qot_GetSubInfo.S2C
         * @instance
         */
        S2C.prototype.connSubInfoList = $util.emptyArray;

        /**
         * S2C totalUsedQuota.
         * @member {number} totalUsedQuota
         * @memberof Qot_GetSubInfo.S2C
         * @instance
         */
        S2C.prototype.totalUsedQuota = 0;

        /**
         * S2C remainQuota.
         * @member {number} remainQuota
         * @memberof Qot_GetSubInfo.S2C
         * @instance
         */
        S2C.prototype.remainQuota = 0;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetSubInfo.S2C
         * @static
         * @param {Qot_GetSubInfo.IS2C=} [properties] Properties to set
         * @returns {Qot_GetSubInfo.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetSubInfo.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSubInfo.S2C
         * @static
         * @param {Qot_GetSubInfo.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.connSubInfoList != null && message.connSubInfoList.length)
                for (var i = 0; i < message.connSubInfoList.length; ++i)
                    $root.Qot_Common.ConnSubInfo.encode(message.connSubInfoList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.totalUsedQuota);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.remainQuota);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetSubInfo.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSubInfo.S2C
         * @static
         * @param {Qot_GetSubInfo.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSubInfo.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSubInfo.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSubInfo.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.connSubInfoList && message.connSubInfoList.length))
                        message.connSubInfoList = [];
                    message.connSubInfoList.push($root.Qot_Common.ConnSubInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.totalUsedQuota = reader.int32();
                    break;
                case 3:
                    message.remainQuota = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("totalUsedQuota"))
                throw $util.ProtocolError("missing required 'totalUsedQuota'", { instance: message });
            if (!message.hasOwnProperty("remainQuota"))
                throw $util.ProtocolError("missing required 'remainQuota'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSubInfo.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSubInfo.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetSubInfo.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.connSubInfoList != null && message.hasOwnProperty("connSubInfoList")) {
                if (!Array.isArray(message.connSubInfoList))
                    return "connSubInfoList: array expected";
                for (var i = 0; i < message.connSubInfoList.length; ++i) {
                    var error = $root.Qot_Common.ConnSubInfo.verify(message.connSubInfoList[i]);
                    if (error)
                        return "connSubInfoList." + error;
                }
            }
            if (!$util.isInteger(message.totalUsedQuota))
                return "totalUsedQuota: integer expected";
            if (!$util.isInteger(message.remainQuota))
                return "remainQuota: integer expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSubInfo.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSubInfo.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSubInfo.S2C)
                return object;
            var message = new $root.Qot_GetSubInfo.S2C();
            if (object.connSubInfoList) {
                if (!Array.isArray(object.connSubInfoList))
                    throw TypeError(".Qot_GetSubInfo.S2C.connSubInfoList: array expected");
                message.connSubInfoList = [];
                for (var i = 0; i < object.connSubInfoList.length; ++i) {
                    if (typeof object.connSubInfoList[i] !== "object")
                        throw TypeError(".Qot_GetSubInfo.S2C.connSubInfoList: object expected");
                    message.connSubInfoList[i] = $root.Qot_Common.ConnSubInfo.fromObject(object.connSubInfoList[i]);
                }
            }
            if (object.totalUsedQuota != null)
                message.totalUsedQuota = object.totalUsedQuota | 0;
            if (object.remainQuota != null)
                message.remainQuota = object.remainQuota | 0;
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSubInfo.S2C
         * @static
         * @param {Qot_GetSubInfo.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.connSubInfoList = [];
            if (options.defaults) {
                object.totalUsedQuota = 0;
                object.remainQuota = 0;
            }
            if (message.connSubInfoList && message.connSubInfoList.length) {
                object.connSubInfoList = [];
                for (var j = 0; j < message.connSubInfoList.length; ++j)
                    object.connSubInfoList[j] = $root.Qot_Common.ConnSubInfo.toObject(message.connSubInfoList[j], options);
            }
            if (message.totalUsedQuota != null && message.hasOwnProperty("totalUsedQuota"))
                object.totalUsedQuota = message.totalUsedQuota;
            if (message.remainQuota != null && message.hasOwnProperty("remainQuota"))
                object.remainQuota = message.remainQuota;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetSubInfo.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetSubInfo.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetSubInfo
         * @interface IRequest
         * @property {Qot_GetSubInfo.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetSubInfo
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetSubInfo.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetSubInfo.IC2S} c2s
         * @memberof Qot_GetSubInfo.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetSubInfo.Request
         * @static
         * @param {Qot_GetSubInfo.IRequest=} [properties] Properties to set
         * @returns {Qot_GetSubInfo.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetSubInfo.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSubInfo.Request
         * @static
         * @param {Qot_GetSubInfo.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetSubInfo.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetSubInfo.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSubInfo.Request
         * @static
         * @param {Qot_GetSubInfo.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSubInfo.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSubInfo.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSubInfo.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetSubInfo.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSubInfo.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSubInfo.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetSubInfo.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetSubInfo.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSubInfo.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSubInfo.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSubInfo.Request)
                return object;
            var message = new $root.Qot_GetSubInfo.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetSubInfo.Request.c2s: object expected");
                message.c2s = $root.Qot_GetSubInfo.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSubInfo.Request
         * @static
         * @param {Qot_GetSubInfo.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetSubInfo.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetSubInfo.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetSubInfo.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetSubInfo
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetSubInfo.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetSubInfo
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetSubInfo.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetSubInfo.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetSubInfo.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetSubInfo.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetSubInfo.IS2C|null|undefined} s2c
         * @memberof Qot_GetSubInfo.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetSubInfo.Response
         * @static
         * @param {Qot_GetSubInfo.IResponse=} [properties] Properties to set
         * @returns {Qot_GetSubInfo.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetSubInfo.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSubInfo.Response
         * @static
         * @param {Qot_GetSubInfo.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetSubInfo.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetSubInfo.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSubInfo.Response
         * @static
         * @param {Qot_GetSubInfo.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSubInfo.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSubInfo.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSubInfo.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetSubInfo.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSubInfo.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSubInfo.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetSubInfo.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetSubInfo.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSubInfo.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSubInfo.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSubInfo.Response)
                return object;
            var message = new $root.Qot_GetSubInfo.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetSubInfo.Response.s2c: object expected");
                message.s2c = $root.Qot_GetSubInfo.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSubInfo.Response
         * @static
         * @param {Qot_GetSubInfo.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetSubInfo.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetSubInfo.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetSubInfo;
})();

$root.Qot_GetSuspend = (function() {

    /**
     * Namespace Qot_GetSuspend.
     * @exports Qot_GetSuspend
     * @namespace
     */
    var Qot_GetSuspend = {};

    Qot_GetSuspend.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetSuspend
         * @interface IC2S
         * @property {Array.<Qot_Common.ISecurity>|null} [securityList] C2S securityList
         * @property {string} beginTime C2S beginTime
         * @property {string} endTime C2S endTime
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetSuspend
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetSuspend.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.securityList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S securityList.
         * @member {Array.<Qot_Common.ISecurity>} securityList
         * @memberof Qot_GetSuspend.C2S
         * @instance
         */
        C2S.prototype.securityList = $util.emptyArray;

        /**
         * C2S beginTime.
         * @member {string} beginTime
         * @memberof Qot_GetSuspend.C2S
         * @instance
         */
        C2S.prototype.beginTime = "";

        /**
         * C2S endTime.
         * @member {string} endTime
         * @memberof Qot_GetSuspend.C2S
         * @instance
         */
        C2S.prototype.endTime = "";

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetSuspend.C2S
         * @static
         * @param {Qot_GetSuspend.IC2S=} [properties] Properties to set
         * @returns {Qot_GetSuspend.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetSuspend.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSuspend.C2S
         * @static
         * @param {Qot_GetSuspend.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.securityList != null && message.securityList.length)
                for (var i = 0; i < message.securityList.length; ++i)
                    $root.Qot_Common.Security.encode(message.securityList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.beginTime);
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.endTime);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetSuspend.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSuspend.C2S
         * @static
         * @param {Qot_GetSuspend.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSuspend.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSuspend.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSuspend.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.securityList && message.securityList.length))
                        message.securityList = [];
                    message.securityList.push($root.Qot_Common.Security.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.beginTime = reader.string();
                    break;
                case 3:
                    message.endTime = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("beginTime"))
                throw $util.ProtocolError("missing required 'beginTime'", { instance: message });
            if (!message.hasOwnProperty("endTime"))
                throw $util.ProtocolError("missing required 'endTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSuspend.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSuspend.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetSuspend.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.securityList != null && message.hasOwnProperty("securityList")) {
                if (!Array.isArray(message.securityList))
                    return "securityList: array expected";
                for (var i = 0; i < message.securityList.length; ++i) {
                    var error = $root.Qot_Common.Security.verify(message.securityList[i]);
                    if (error)
                        return "securityList." + error;
                }
            }
            if (!$util.isString(message.beginTime))
                return "beginTime: string expected";
            if (!$util.isString(message.endTime))
                return "endTime: string expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSuspend.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSuspend.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSuspend.C2S)
                return object;
            var message = new $root.Qot_GetSuspend.C2S();
            if (object.securityList) {
                if (!Array.isArray(object.securityList))
                    throw TypeError(".Qot_GetSuspend.C2S.securityList: array expected");
                message.securityList = [];
                for (var i = 0; i < object.securityList.length; ++i) {
                    if (typeof object.securityList[i] !== "object")
                        throw TypeError(".Qot_GetSuspend.C2S.securityList: object expected");
                    message.securityList[i] = $root.Qot_Common.Security.fromObject(object.securityList[i]);
                }
            }
            if (object.beginTime != null)
                message.beginTime = String(object.beginTime);
            if (object.endTime != null)
                message.endTime = String(object.endTime);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSuspend.C2S
         * @static
         * @param {Qot_GetSuspend.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.securityList = [];
            if (options.defaults) {
                object.beginTime = "";
                object.endTime = "";
            }
            if (message.securityList && message.securityList.length) {
                object.securityList = [];
                for (var j = 0; j < message.securityList.length; ++j)
                    object.securityList[j] = $root.Qot_Common.Security.toObject(message.securityList[j], options);
            }
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                object.beginTime = message.beginTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetSuspend.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetSuspend.Suspend = (function() {

        /**
         * Properties of a Suspend.
         * @memberof Qot_GetSuspend
         * @interface ISuspend
         * @property {string} time Suspend time
         * @property {number|null} [timestamp] Suspend timestamp
         */

        /**
         * Constructs a new Suspend.
         * @memberof Qot_GetSuspend
         * @classdesc Represents a Suspend.
         * @implements ISuspend
         * @constructor
         * @param {Qot_GetSuspend.ISuspend=} [properties] Properties to set
         */
        function Suspend(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Suspend time.
         * @member {string} time
         * @memberof Qot_GetSuspend.Suspend
         * @instance
         */
        Suspend.prototype.time = "";

        /**
         * Suspend timestamp.
         * @member {number} timestamp
         * @memberof Qot_GetSuspend.Suspend
         * @instance
         */
        Suspend.prototype.timestamp = 0;

        /**
         * Creates a new Suspend instance using the specified properties.
         * @function create
         * @memberof Qot_GetSuspend.Suspend
         * @static
         * @param {Qot_GetSuspend.ISuspend=} [properties] Properties to set
         * @returns {Qot_GetSuspend.Suspend} Suspend instance
         */
        Suspend.create = function create(properties) {
            return new Suspend(properties);
        };

        /**
         * Encodes the specified Suspend message. Does not implicitly {@link Qot_GetSuspend.Suspend.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSuspend.Suspend
         * @static
         * @param {Qot_GetSuspend.ISuspend} message Suspend message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Suspend.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.time);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified Suspend message, length delimited. Does not implicitly {@link Qot_GetSuspend.Suspend.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSuspend.Suspend
         * @static
         * @param {Qot_GetSuspend.ISuspend} message Suspend message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Suspend.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Suspend message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSuspend.Suspend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSuspend.Suspend} Suspend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Suspend.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSuspend.Suspend();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.string();
                    break;
                case 2:
                    message.timestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("time"))
                throw $util.ProtocolError("missing required 'time'", { instance: message });
            return message;
        };

        /**
         * Decodes a Suspend message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSuspend.Suspend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSuspend.Suspend} Suspend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Suspend.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Suspend message.
         * @function verify
         * @memberof Qot_GetSuspend.Suspend
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Suspend.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.time))
                return "time: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp !== "number")
                    return "timestamp: number expected";
            return null;
        };

        /**
         * Creates a Suspend message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSuspend.Suspend
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSuspend.Suspend} Suspend
         */
        Suspend.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSuspend.Suspend)
                return object;
            var message = new $root.Qot_GetSuspend.Suspend();
            if (object.time != null)
                message.time = String(object.time);
            if (object.timestamp != null)
                message.timestamp = Number(object.timestamp);
            return message;
        };

        /**
         * Creates a plain object from a Suspend message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSuspend.Suspend
         * @static
         * @param {Qot_GetSuspend.Suspend} message Suspend
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Suspend.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.time = "";
                object.timestamp = 0;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            return object;
        };

        /**
         * Converts this Suspend to JSON.
         * @function toJSON
         * @memberof Qot_GetSuspend.Suspend
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Suspend.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Suspend;
    })();

    Qot_GetSuspend.SecuritySuspend = (function() {

        /**
         * Properties of a SecuritySuspend.
         * @memberof Qot_GetSuspend
         * @interface ISecuritySuspend
         * @property {Qot_Common.ISecurity} security SecuritySuspend security
         * @property {Array.<Qot_GetSuspend.ISuspend>|null} [suspendList] SecuritySuspend suspendList
         */

        /**
         * Constructs a new SecuritySuspend.
         * @memberof Qot_GetSuspend
         * @classdesc Represents a SecuritySuspend.
         * @implements ISecuritySuspend
         * @constructor
         * @param {Qot_GetSuspend.ISecuritySuspend=} [properties] Properties to set
         */
        function SecuritySuspend(properties) {
            this.suspendList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecuritySuspend security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetSuspend.SecuritySuspend
         * @instance
         */
        SecuritySuspend.prototype.security = null;

        /**
         * SecuritySuspend suspendList.
         * @member {Array.<Qot_GetSuspend.ISuspend>} suspendList
         * @memberof Qot_GetSuspend.SecuritySuspend
         * @instance
         */
        SecuritySuspend.prototype.suspendList = $util.emptyArray;

        /**
         * Creates a new SecuritySuspend instance using the specified properties.
         * @function create
         * @memberof Qot_GetSuspend.SecuritySuspend
         * @static
         * @param {Qot_GetSuspend.ISecuritySuspend=} [properties] Properties to set
         * @returns {Qot_GetSuspend.SecuritySuspend} SecuritySuspend instance
         */
        SecuritySuspend.create = function create(properties) {
            return new SecuritySuspend(properties);
        };

        /**
         * Encodes the specified SecuritySuspend message. Does not implicitly {@link Qot_GetSuspend.SecuritySuspend.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSuspend.SecuritySuspend
         * @static
         * @param {Qot_GetSuspend.ISecuritySuspend} message SecuritySuspend message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecuritySuspend.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.suspendList != null && message.suspendList.length)
                for (var i = 0; i < message.suspendList.length; ++i)
                    $root.Qot_GetSuspend.Suspend.encode(message.suspendList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SecuritySuspend message, length delimited. Does not implicitly {@link Qot_GetSuspend.SecuritySuspend.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSuspend.SecuritySuspend
         * @static
         * @param {Qot_GetSuspend.ISecuritySuspend} message SecuritySuspend message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecuritySuspend.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecuritySuspend message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSuspend.SecuritySuspend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSuspend.SecuritySuspend} SecuritySuspend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecuritySuspend.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSuspend.SecuritySuspend();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.suspendList && message.suspendList.length))
                        message.suspendList = [];
                    message.suspendList.push($root.Qot_GetSuspend.Suspend.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a SecuritySuspend message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSuspend.SecuritySuspend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSuspend.SecuritySuspend} SecuritySuspend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecuritySuspend.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecuritySuspend message.
         * @function verify
         * @memberof Qot_GetSuspend.SecuritySuspend
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecuritySuspend.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.suspendList != null && message.hasOwnProperty("suspendList")) {
                if (!Array.isArray(message.suspendList))
                    return "suspendList: array expected";
                for (var i = 0; i < message.suspendList.length; ++i) {
                    var error = $root.Qot_GetSuspend.Suspend.verify(message.suspendList[i]);
                    if (error)
                        return "suspendList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SecuritySuspend message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSuspend.SecuritySuspend
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSuspend.SecuritySuspend} SecuritySuspend
         */
        SecuritySuspend.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSuspend.SecuritySuspend)
                return object;
            var message = new $root.Qot_GetSuspend.SecuritySuspend();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetSuspend.SecuritySuspend.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.suspendList) {
                if (!Array.isArray(object.suspendList))
                    throw TypeError(".Qot_GetSuspend.SecuritySuspend.suspendList: array expected");
                message.suspendList = [];
                for (var i = 0; i < object.suspendList.length; ++i) {
                    if (typeof object.suspendList[i] !== "object")
                        throw TypeError(".Qot_GetSuspend.SecuritySuspend.suspendList: object expected");
                    message.suspendList[i] = $root.Qot_GetSuspend.Suspend.fromObject(object.suspendList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SecuritySuspend message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSuspend.SecuritySuspend
         * @static
         * @param {Qot_GetSuspend.SecuritySuspend} message SecuritySuspend
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecuritySuspend.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.suspendList = [];
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.suspendList && message.suspendList.length) {
                object.suspendList = [];
                for (var j = 0; j < message.suspendList.length; ++j)
                    object.suspendList[j] = $root.Qot_GetSuspend.Suspend.toObject(message.suspendList[j], options);
            }
            return object;
        };

        /**
         * Converts this SecuritySuspend to JSON.
         * @function toJSON
         * @memberof Qot_GetSuspend.SecuritySuspend
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecuritySuspend.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecuritySuspend;
    })();

    Qot_GetSuspend.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetSuspend
         * @interface IS2C
         * @property {Array.<Qot_GetSuspend.ISecuritySuspend>|null} [SecuritySuspendList] S2C SecuritySuspendList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetSuspend
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetSuspend.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.SecuritySuspendList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C SecuritySuspendList.
         * @member {Array.<Qot_GetSuspend.ISecuritySuspend>} SecuritySuspendList
         * @memberof Qot_GetSuspend.S2C
         * @instance
         */
        S2C.prototype.SecuritySuspendList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetSuspend.S2C
         * @static
         * @param {Qot_GetSuspend.IS2C=} [properties] Properties to set
         * @returns {Qot_GetSuspend.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetSuspend.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSuspend.S2C
         * @static
         * @param {Qot_GetSuspend.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.SecuritySuspendList != null && message.SecuritySuspendList.length)
                for (var i = 0; i < message.SecuritySuspendList.length; ++i)
                    $root.Qot_GetSuspend.SecuritySuspend.encode(message.SecuritySuspendList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetSuspend.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSuspend.S2C
         * @static
         * @param {Qot_GetSuspend.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSuspend.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSuspend.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSuspend.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.SecuritySuspendList && message.SecuritySuspendList.length))
                        message.SecuritySuspendList = [];
                    message.SecuritySuspendList.push($root.Qot_GetSuspend.SecuritySuspend.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSuspend.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSuspend.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetSuspend.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.SecuritySuspendList != null && message.hasOwnProperty("SecuritySuspendList")) {
                if (!Array.isArray(message.SecuritySuspendList))
                    return "SecuritySuspendList: array expected";
                for (var i = 0; i < message.SecuritySuspendList.length; ++i) {
                    var error = $root.Qot_GetSuspend.SecuritySuspend.verify(message.SecuritySuspendList[i]);
                    if (error)
                        return "SecuritySuspendList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSuspend.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSuspend.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSuspend.S2C)
                return object;
            var message = new $root.Qot_GetSuspend.S2C();
            if (object.SecuritySuspendList) {
                if (!Array.isArray(object.SecuritySuspendList))
                    throw TypeError(".Qot_GetSuspend.S2C.SecuritySuspendList: array expected");
                message.SecuritySuspendList = [];
                for (var i = 0; i < object.SecuritySuspendList.length; ++i) {
                    if (typeof object.SecuritySuspendList[i] !== "object")
                        throw TypeError(".Qot_GetSuspend.S2C.SecuritySuspendList: object expected");
                    message.SecuritySuspendList[i] = $root.Qot_GetSuspend.SecuritySuspend.fromObject(object.SecuritySuspendList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSuspend.S2C
         * @static
         * @param {Qot_GetSuspend.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.SecuritySuspendList = [];
            if (message.SecuritySuspendList && message.SecuritySuspendList.length) {
                object.SecuritySuspendList = [];
                for (var j = 0; j < message.SecuritySuspendList.length; ++j)
                    object.SecuritySuspendList[j] = $root.Qot_GetSuspend.SecuritySuspend.toObject(message.SecuritySuspendList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetSuspend.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetSuspend.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetSuspend
         * @interface IRequest
         * @property {Qot_GetSuspend.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetSuspend
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetSuspend.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetSuspend.IC2S} c2s
         * @memberof Qot_GetSuspend.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetSuspend.Request
         * @static
         * @param {Qot_GetSuspend.IRequest=} [properties] Properties to set
         * @returns {Qot_GetSuspend.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetSuspend.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSuspend.Request
         * @static
         * @param {Qot_GetSuspend.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetSuspend.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetSuspend.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSuspend.Request
         * @static
         * @param {Qot_GetSuspend.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSuspend.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSuspend.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSuspend.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetSuspend.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSuspend.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSuspend.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetSuspend.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetSuspend.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSuspend.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSuspend.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSuspend.Request)
                return object;
            var message = new $root.Qot_GetSuspend.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetSuspend.Request.c2s: object expected");
                message.c2s = $root.Qot_GetSuspend.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSuspend.Request
         * @static
         * @param {Qot_GetSuspend.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetSuspend.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetSuspend.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetSuspend.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetSuspend
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetSuspend.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetSuspend
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetSuspend.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetSuspend.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetSuspend.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetSuspend.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetSuspend.IS2C|null|undefined} s2c
         * @memberof Qot_GetSuspend.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetSuspend.Response
         * @static
         * @param {Qot_GetSuspend.IResponse=} [properties] Properties to set
         * @returns {Qot_GetSuspend.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetSuspend.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSuspend.Response
         * @static
         * @param {Qot_GetSuspend.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetSuspend.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetSuspend.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSuspend.Response
         * @static
         * @param {Qot_GetSuspend.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSuspend.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSuspend.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSuspend.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetSuspend.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSuspend.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSuspend.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetSuspend.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetSuspend.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSuspend.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSuspend.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSuspend.Response)
                return object;
            var message = new $root.Qot_GetSuspend.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetSuspend.Response.s2c: object expected");
                message.s2c = $root.Qot_GetSuspend.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSuspend.Response
         * @static
         * @param {Qot_GetSuspend.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetSuspend.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetSuspend.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetSuspend;
})();

$root.Qot_GetTicker = (function() {

    /**
     * Namespace Qot_GetTicker.
     * @exports Qot_GetTicker
     * @namespace
     */
    var Qot_GetTicker = {};

    Qot_GetTicker.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetTicker
         * @interface IC2S
         * @property {Qot_Common.ISecurity} security C2S security
         * @property {number} maxRetNum C2S maxRetNum
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetTicker
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetTicker.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetTicker.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * C2S maxRetNum.
         * @member {number} maxRetNum
         * @memberof Qot_GetTicker.C2S
         * @instance
         */
        C2S.prototype.maxRetNum = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetTicker.C2S
         * @static
         * @param {Qot_GetTicker.IC2S=} [properties] Properties to set
         * @returns {Qot_GetTicker.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetTicker.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetTicker.C2S
         * @static
         * @param {Qot_GetTicker.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.maxRetNum);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetTicker.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetTicker.C2S
         * @static
         * @param {Qot_GetTicker.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetTicker.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetTicker.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetTicker.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.maxRetNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("maxRetNum"))
                throw $util.ProtocolError("missing required 'maxRetNum'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetTicker.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetTicker.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetTicker.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (!$util.isInteger(message.maxRetNum))
                return "maxRetNum: integer expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetTicker.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetTicker.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetTicker.C2S)
                return object;
            var message = new $root.Qot_GetTicker.C2S();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetTicker.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.maxRetNum != null)
                message.maxRetNum = object.maxRetNum | 0;
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetTicker.C2S
         * @static
         * @param {Qot_GetTicker.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.security = null;
                object.maxRetNum = 0;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.maxRetNum != null && message.hasOwnProperty("maxRetNum"))
                object.maxRetNum = message.maxRetNum;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetTicker.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetTicker.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetTicker
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.ITicker>|null} [tickerList] S2C tickerList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetTicker
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetTicker.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.tickerList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetTicker.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C tickerList.
         * @member {Array.<Qot_Common.ITicker>} tickerList
         * @memberof Qot_GetTicker.S2C
         * @instance
         */
        S2C.prototype.tickerList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetTicker.S2C
         * @static
         * @param {Qot_GetTicker.IS2C=} [properties] Properties to set
         * @returns {Qot_GetTicker.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetTicker.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetTicker.S2C
         * @static
         * @param {Qot_GetTicker.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.tickerList != null && message.tickerList.length)
                for (var i = 0; i < message.tickerList.length; ++i)
                    $root.Qot_Common.Ticker.encode(message.tickerList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetTicker.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetTicker.S2C
         * @static
         * @param {Qot_GetTicker.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetTicker.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetTicker.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetTicker.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.tickerList && message.tickerList.length))
                        message.tickerList = [];
                    message.tickerList.push($root.Qot_Common.Ticker.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetTicker.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetTicker.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetTicker.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.tickerList != null && message.hasOwnProperty("tickerList")) {
                if (!Array.isArray(message.tickerList))
                    return "tickerList: array expected";
                for (var i = 0; i < message.tickerList.length; ++i) {
                    var error = $root.Qot_Common.Ticker.verify(message.tickerList[i]);
                    if (error)
                        return "tickerList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetTicker.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetTicker.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetTicker.S2C)
                return object;
            var message = new $root.Qot_GetTicker.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetTicker.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.tickerList) {
                if (!Array.isArray(object.tickerList))
                    throw TypeError(".Qot_GetTicker.S2C.tickerList: array expected");
                message.tickerList = [];
                for (var i = 0; i < object.tickerList.length; ++i) {
                    if (typeof object.tickerList[i] !== "object")
                        throw TypeError(".Qot_GetTicker.S2C.tickerList: object expected");
                    message.tickerList[i] = $root.Qot_Common.Ticker.fromObject(object.tickerList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetTicker.S2C
         * @static
         * @param {Qot_GetTicker.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tickerList = [];
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.tickerList && message.tickerList.length) {
                object.tickerList = [];
                for (var j = 0; j < message.tickerList.length; ++j)
                    object.tickerList[j] = $root.Qot_Common.Ticker.toObject(message.tickerList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetTicker.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetTicker.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetTicker
         * @interface IRequest
         * @property {Qot_GetTicker.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetTicker
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetTicker.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetTicker.IC2S} c2s
         * @memberof Qot_GetTicker.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetTicker.Request
         * @static
         * @param {Qot_GetTicker.IRequest=} [properties] Properties to set
         * @returns {Qot_GetTicker.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetTicker.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetTicker.Request
         * @static
         * @param {Qot_GetTicker.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetTicker.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetTicker.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetTicker.Request
         * @static
         * @param {Qot_GetTicker.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetTicker.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetTicker.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetTicker.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetTicker.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetTicker.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetTicker.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetTicker.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetTicker.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetTicker.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetTicker.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetTicker.Request)
                return object;
            var message = new $root.Qot_GetTicker.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetTicker.Request.c2s: object expected");
                message.c2s = $root.Qot_GetTicker.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetTicker.Request
         * @static
         * @param {Qot_GetTicker.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetTicker.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetTicker.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetTicker.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetTicker
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetTicker.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetTicker
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetTicker.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetTicker.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetTicker.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetTicker.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetTicker.IS2C|null|undefined} s2c
         * @memberof Qot_GetTicker.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetTicker.Response
         * @static
         * @param {Qot_GetTicker.IResponse=} [properties] Properties to set
         * @returns {Qot_GetTicker.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetTicker.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetTicker.Response
         * @static
         * @param {Qot_GetTicker.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetTicker.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetTicker.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetTicker.Response
         * @static
         * @param {Qot_GetTicker.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetTicker.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetTicker.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetTicker.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetTicker.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetTicker.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetTicker.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetTicker.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetTicker.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetTicker.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetTicker.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetTicker.Response)
                return object;
            var message = new $root.Qot_GetTicker.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetTicker.Response.s2c: object expected");
                message.s2c = $root.Qot_GetTicker.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetTicker.Response
         * @static
         * @param {Qot_GetTicker.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetTicker.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetTicker.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetTicker;
})();

$root.Qot_GetTradeDate = (function() {

    /**
     * Namespace Qot_GetTradeDate.
     * @exports Qot_GetTradeDate
     * @namespace
     */
    var Qot_GetTradeDate = {};

    Qot_GetTradeDate.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetTradeDate
         * @interface IC2S
         * @property {number} market C2S market
         * @property {string} beginTime C2S beginTime
         * @property {string} endTime C2S endTime
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetTradeDate
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetTradeDate.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S market.
         * @member {number} market
         * @memberof Qot_GetTradeDate.C2S
         * @instance
         */
        C2S.prototype.market = 0;

        /**
         * C2S beginTime.
         * @member {string} beginTime
         * @memberof Qot_GetTradeDate.C2S
         * @instance
         */
        C2S.prototype.beginTime = "";

        /**
         * C2S endTime.
         * @member {string} endTime
         * @memberof Qot_GetTradeDate.C2S
         * @instance
         */
        C2S.prototype.endTime = "";

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetTradeDate.C2S
         * @static
         * @param {Qot_GetTradeDate.IC2S=} [properties] Properties to set
         * @returns {Qot_GetTradeDate.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetTradeDate.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetTradeDate.C2S
         * @static
         * @param {Qot_GetTradeDate.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.market);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.beginTime);
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.endTime);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetTradeDate.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetTradeDate.C2S
         * @static
         * @param {Qot_GetTradeDate.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetTradeDate.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetTradeDate.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetTradeDate.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.market = reader.int32();
                    break;
                case 2:
                    message.beginTime = reader.string();
                    break;
                case 3:
                    message.endTime = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("market"))
                throw $util.ProtocolError("missing required 'market'", { instance: message });
            if (!message.hasOwnProperty("beginTime"))
                throw $util.ProtocolError("missing required 'beginTime'", { instance: message });
            if (!message.hasOwnProperty("endTime"))
                throw $util.ProtocolError("missing required 'endTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetTradeDate.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetTradeDate.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetTradeDate.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.market))
                return "market: integer expected";
            if (!$util.isString(message.beginTime))
                return "beginTime: string expected";
            if (!$util.isString(message.endTime))
                return "endTime: string expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetTradeDate.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetTradeDate.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetTradeDate.C2S)
                return object;
            var message = new $root.Qot_GetTradeDate.C2S();
            if (object.market != null)
                message.market = object.market | 0;
            if (object.beginTime != null)
                message.beginTime = String(object.beginTime);
            if (object.endTime != null)
                message.endTime = String(object.endTime);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetTradeDate.C2S
         * @static
         * @param {Qot_GetTradeDate.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.market = 0;
                object.beginTime = "";
                object.endTime = "";
            }
            if (message.market != null && message.hasOwnProperty("market"))
                object.market = message.market;
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                object.beginTime = message.beginTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetTradeDate.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetTradeDate.TradeDate = (function() {

        /**
         * Properties of a TradeDate.
         * @memberof Qot_GetTradeDate
         * @interface ITradeDate
         * @property {string} time TradeDate time
         * @property {number|null} [timestamp] TradeDate timestamp
         * @property {number|null} [tradeDateType] TradeDate tradeDateType
         */

        /**
         * Constructs a new TradeDate.
         * @memberof Qot_GetTradeDate
         * @classdesc Represents a TradeDate.
         * @implements ITradeDate
         * @constructor
         * @param {Qot_GetTradeDate.ITradeDate=} [properties] Properties to set
         */
        function TradeDate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TradeDate time.
         * @member {string} time
         * @memberof Qot_GetTradeDate.TradeDate
         * @instance
         */
        TradeDate.prototype.time = "";

        /**
         * TradeDate timestamp.
         * @member {number} timestamp
         * @memberof Qot_GetTradeDate.TradeDate
         * @instance
         */
        TradeDate.prototype.timestamp = 0;

        /**
         * TradeDate tradeDateType.
         * @member {number} tradeDateType
         * @memberof Qot_GetTradeDate.TradeDate
         * @instance
         */
        TradeDate.prototype.tradeDateType = 0;

        /**
         * Creates a new TradeDate instance using the specified properties.
         * @function create
         * @memberof Qot_GetTradeDate.TradeDate
         * @static
         * @param {Qot_GetTradeDate.ITradeDate=} [properties] Properties to set
         * @returns {Qot_GetTradeDate.TradeDate} TradeDate instance
         */
        TradeDate.create = function create(properties) {
            return new TradeDate(properties);
        };

        /**
         * Encodes the specified TradeDate message. Does not implicitly {@link Qot_GetTradeDate.TradeDate.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetTradeDate.TradeDate
         * @static
         * @param {Qot_GetTradeDate.ITradeDate} message TradeDate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeDate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.time);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.timestamp);
            if (message.tradeDateType != null && message.hasOwnProperty("tradeDateType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.tradeDateType);
            return writer;
        };

        /**
         * Encodes the specified TradeDate message, length delimited. Does not implicitly {@link Qot_GetTradeDate.TradeDate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetTradeDate.TradeDate
         * @static
         * @param {Qot_GetTradeDate.ITradeDate} message TradeDate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeDate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TradeDate message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetTradeDate.TradeDate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetTradeDate.TradeDate} TradeDate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeDate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetTradeDate.TradeDate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.string();
                    break;
                case 2:
                    message.timestamp = reader.double();
                    break;
                case 3:
                    message.tradeDateType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("time"))
                throw $util.ProtocolError("missing required 'time'", { instance: message });
            return message;
        };

        /**
         * Decodes a TradeDate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetTradeDate.TradeDate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetTradeDate.TradeDate} TradeDate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeDate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TradeDate message.
         * @function verify
         * @memberof Qot_GetTradeDate.TradeDate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TradeDate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.time))
                return "time: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp !== "number")
                    return "timestamp: number expected";
            if (message.tradeDateType != null && message.hasOwnProperty("tradeDateType"))
                if (!$util.isInteger(message.tradeDateType))
                    return "tradeDateType: integer expected";
            return null;
        };

        /**
         * Creates a TradeDate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetTradeDate.TradeDate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetTradeDate.TradeDate} TradeDate
         */
        TradeDate.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetTradeDate.TradeDate)
                return object;
            var message = new $root.Qot_GetTradeDate.TradeDate();
            if (object.time != null)
                message.time = String(object.time);
            if (object.timestamp != null)
                message.timestamp = Number(object.timestamp);
            if (object.tradeDateType != null)
                message.tradeDateType = object.tradeDateType | 0;
            return message;
        };

        /**
         * Creates a plain object from a TradeDate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetTradeDate.TradeDate
         * @static
         * @param {Qot_GetTradeDate.TradeDate} message TradeDate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TradeDate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.time = "";
                object.timestamp = 0;
                object.tradeDateType = 0;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            if (message.tradeDateType != null && message.hasOwnProperty("tradeDateType"))
                object.tradeDateType = message.tradeDateType;
            return object;
        };

        /**
         * Converts this TradeDate to JSON.
         * @function toJSON
         * @memberof Qot_GetTradeDate.TradeDate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TradeDate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TradeDate;
    })();

    Qot_GetTradeDate.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetTradeDate
         * @interface IS2C
         * @property {Array.<Qot_GetTradeDate.ITradeDate>|null} [tradeDateList] S2C tradeDateList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetTradeDate
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetTradeDate.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.tradeDateList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C tradeDateList.
         * @member {Array.<Qot_GetTradeDate.ITradeDate>} tradeDateList
         * @memberof Qot_GetTradeDate.S2C
         * @instance
         */
        S2C.prototype.tradeDateList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetTradeDate.S2C
         * @static
         * @param {Qot_GetTradeDate.IS2C=} [properties] Properties to set
         * @returns {Qot_GetTradeDate.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetTradeDate.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetTradeDate.S2C
         * @static
         * @param {Qot_GetTradeDate.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tradeDateList != null && message.tradeDateList.length)
                for (var i = 0; i < message.tradeDateList.length; ++i)
                    $root.Qot_GetTradeDate.TradeDate.encode(message.tradeDateList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetTradeDate.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetTradeDate.S2C
         * @static
         * @param {Qot_GetTradeDate.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetTradeDate.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetTradeDate.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetTradeDate.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.tradeDateList && message.tradeDateList.length))
                        message.tradeDateList = [];
                    message.tradeDateList.push($root.Qot_GetTradeDate.TradeDate.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetTradeDate.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetTradeDate.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetTradeDate.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tradeDateList != null && message.hasOwnProperty("tradeDateList")) {
                if (!Array.isArray(message.tradeDateList))
                    return "tradeDateList: array expected";
                for (var i = 0; i < message.tradeDateList.length; ++i) {
                    var error = $root.Qot_GetTradeDate.TradeDate.verify(message.tradeDateList[i]);
                    if (error)
                        return "tradeDateList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetTradeDate.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetTradeDate.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetTradeDate.S2C)
                return object;
            var message = new $root.Qot_GetTradeDate.S2C();
            if (object.tradeDateList) {
                if (!Array.isArray(object.tradeDateList))
                    throw TypeError(".Qot_GetTradeDate.S2C.tradeDateList: array expected");
                message.tradeDateList = [];
                for (var i = 0; i < object.tradeDateList.length; ++i) {
                    if (typeof object.tradeDateList[i] !== "object")
                        throw TypeError(".Qot_GetTradeDate.S2C.tradeDateList: object expected");
                    message.tradeDateList[i] = $root.Qot_GetTradeDate.TradeDate.fromObject(object.tradeDateList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetTradeDate.S2C
         * @static
         * @param {Qot_GetTradeDate.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tradeDateList = [];
            if (message.tradeDateList && message.tradeDateList.length) {
                object.tradeDateList = [];
                for (var j = 0; j < message.tradeDateList.length; ++j)
                    object.tradeDateList[j] = $root.Qot_GetTradeDate.TradeDate.toObject(message.tradeDateList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetTradeDate.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetTradeDate.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetTradeDate
         * @interface IRequest
         * @property {Qot_GetTradeDate.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetTradeDate
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetTradeDate.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetTradeDate.IC2S} c2s
         * @memberof Qot_GetTradeDate.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetTradeDate.Request
         * @static
         * @param {Qot_GetTradeDate.IRequest=} [properties] Properties to set
         * @returns {Qot_GetTradeDate.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetTradeDate.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetTradeDate.Request
         * @static
         * @param {Qot_GetTradeDate.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetTradeDate.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetTradeDate.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetTradeDate.Request
         * @static
         * @param {Qot_GetTradeDate.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetTradeDate.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetTradeDate.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetTradeDate.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetTradeDate.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetTradeDate.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetTradeDate.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetTradeDate.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetTradeDate.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetTradeDate.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetTradeDate.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetTradeDate.Request)
                return object;
            var message = new $root.Qot_GetTradeDate.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetTradeDate.Request.c2s: object expected");
                message.c2s = $root.Qot_GetTradeDate.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetTradeDate.Request
         * @static
         * @param {Qot_GetTradeDate.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetTradeDate.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetTradeDate.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetTradeDate.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetTradeDate
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetTradeDate.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetTradeDate
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetTradeDate.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetTradeDate.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetTradeDate.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetTradeDate.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetTradeDate.IS2C|null|undefined} s2c
         * @memberof Qot_GetTradeDate.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetTradeDate.Response
         * @static
         * @param {Qot_GetTradeDate.IResponse=} [properties] Properties to set
         * @returns {Qot_GetTradeDate.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetTradeDate.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetTradeDate.Response
         * @static
         * @param {Qot_GetTradeDate.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetTradeDate.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetTradeDate.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetTradeDate.Response
         * @static
         * @param {Qot_GetTradeDate.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetTradeDate.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetTradeDate.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetTradeDate.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetTradeDate.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetTradeDate.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetTradeDate.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetTradeDate.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetTradeDate.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetTradeDate.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetTradeDate.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetTradeDate.Response)
                return object;
            var message = new $root.Qot_GetTradeDate.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetTradeDate.Response.s2c: object expected");
                message.s2c = $root.Qot_GetTradeDate.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetTradeDate.Response
         * @static
         * @param {Qot_GetTradeDate.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetTradeDate.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetTradeDate.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetTradeDate;
})();

$root.Qot_GetUserSecurityGroup = (function() {

    /**
     * Namespace Qot_GetUserSecurityGroup.
     * @exports Qot_GetUserSecurityGroup
     * @namespace
     */
    var Qot_GetUserSecurityGroup = {};

    /**
     * GroupType enum.
     * @name Qot_GetUserSecurityGroup.GroupType
     * @enum {string}
     * @property {number} GroupType_Unknown=0 GroupType_Unknown value
     * @property {number} GroupType_Custom=1 GroupType_Custom value
     * @property {number} GroupType_System=2 GroupType_System value
     * @property {number} GroupType_All=3 GroupType_All value
     */
    Qot_GetUserSecurityGroup.GroupType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "GroupType_Unknown"] = 0;
        values[valuesById[1] = "GroupType_Custom"] = 1;
        values[valuesById[2] = "GroupType_System"] = 2;
        values[valuesById[3] = "GroupType_All"] = 3;
        return values;
    })();

    Qot_GetUserSecurityGroup.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetUserSecurityGroup
         * @interface IC2S
         * @property {number} groupType C2S groupType
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetUserSecurityGroup
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetUserSecurityGroup.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S groupType.
         * @member {number} groupType
         * @memberof Qot_GetUserSecurityGroup.C2S
         * @instance
         */
        C2S.prototype.groupType = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetUserSecurityGroup.C2S
         * @static
         * @param {Qot_GetUserSecurityGroup.IC2S=} [properties] Properties to set
         * @returns {Qot_GetUserSecurityGroup.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetUserSecurityGroup.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetUserSecurityGroup.C2S
         * @static
         * @param {Qot_GetUserSecurityGroup.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.groupType);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetUserSecurityGroup.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetUserSecurityGroup.C2S
         * @static
         * @param {Qot_GetUserSecurityGroup.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetUserSecurityGroup.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetUserSecurityGroup.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetUserSecurityGroup.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.groupType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("groupType"))
                throw $util.ProtocolError("missing required 'groupType'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetUserSecurityGroup.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetUserSecurityGroup.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetUserSecurityGroup.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.groupType))
                return "groupType: integer expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetUserSecurityGroup.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetUserSecurityGroup.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetUserSecurityGroup.C2S)
                return object;
            var message = new $root.Qot_GetUserSecurityGroup.C2S();
            if (object.groupType != null)
                message.groupType = object.groupType | 0;
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetUserSecurityGroup.C2S
         * @static
         * @param {Qot_GetUserSecurityGroup.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.groupType = 0;
            if (message.groupType != null && message.hasOwnProperty("groupType"))
                object.groupType = message.groupType;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetUserSecurityGroup.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetUserSecurityGroup.GroupData = (function() {

        /**
         * Properties of a GroupData.
         * @memberof Qot_GetUserSecurityGroup
         * @interface IGroupData
         * @property {string} groupName GroupData groupName
         * @property {number} groupType GroupData groupType
         */

        /**
         * Constructs a new GroupData.
         * @memberof Qot_GetUserSecurityGroup
         * @classdesc Represents a GroupData.
         * @implements IGroupData
         * @constructor
         * @param {Qot_GetUserSecurityGroup.IGroupData=} [properties] Properties to set
         */
        function GroupData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupData groupName.
         * @member {string} groupName
         * @memberof Qot_GetUserSecurityGroup.GroupData
         * @instance
         */
        GroupData.prototype.groupName = "";

        /**
         * GroupData groupType.
         * @member {number} groupType
         * @memberof Qot_GetUserSecurityGroup.GroupData
         * @instance
         */
        GroupData.prototype.groupType = 0;

        /**
         * Creates a new GroupData instance using the specified properties.
         * @function create
         * @memberof Qot_GetUserSecurityGroup.GroupData
         * @static
         * @param {Qot_GetUserSecurityGroup.IGroupData=} [properties] Properties to set
         * @returns {Qot_GetUserSecurityGroup.GroupData} GroupData instance
         */
        GroupData.create = function create(properties) {
            return new GroupData(properties);
        };

        /**
         * Encodes the specified GroupData message. Does not implicitly {@link Qot_GetUserSecurityGroup.GroupData.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetUserSecurityGroup.GroupData
         * @static
         * @param {Qot_GetUserSecurityGroup.IGroupData} message GroupData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupName);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.groupType);
            return writer;
        };

        /**
         * Encodes the specified GroupData message, length delimited. Does not implicitly {@link Qot_GetUserSecurityGroup.GroupData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetUserSecurityGroup.GroupData
         * @static
         * @param {Qot_GetUserSecurityGroup.IGroupData} message GroupData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetUserSecurityGroup.GroupData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetUserSecurityGroup.GroupData} GroupData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetUserSecurityGroup.GroupData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.groupName = reader.string();
                    break;
                case 2:
                    message.groupType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("groupName"))
                throw $util.ProtocolError("missing required 'groupName'", { instance: message });
            if (!message.hasOwnProperty("groupType"))
                throw $util.ProtocolError("missing required 'groupType'", { instance: message });
            return message;
        };

        /**
         * Decodes a GroupData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetUserSecurityGroup.GroupData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetUserSecurityGroup.GroupData} GroupData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupData message.
         * @function verify
         * @memberof Qot_GetUserSecurityGroup.GroupData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.groupName))
                return "groupName: string expected";
            if (!$util.isInteger(message.groupType))
                return "groupType: integer expected";
            return null;
        };

        /**
         * Creates a GroupData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetUserSecurityGroup.GroupData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetUserSecurityGroup.GroupData} GroupData
         */
        GroupData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetUserSecurityGroup.GroupData)
                return object;
            var message = new $root.Qot_GetUserSecurityGroup.GroupData();
            if (object.groupName != null)
                message.groupName = String(object.groupName);
            if (object.groupType != null)
                message.groupType = object.groupType | 0;
            return message;
        };

        /**
         * Creates a plain object from a GroupData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetUserSecurityGroup.GroupData
         * @static
         * @param {Qot_GetUserSecurityGroup.GroupData} message GroupData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.groupName = "";
                object.groupType = 0;
            }
            if (message.groupName != null && message.hasOwnProperty("groupName"))
                object.groupName = message.groupName;
            if (message.groupType != null && message.hasOwnProperty("groupType"))
                object.groupType = message.groupType;
            return object;
        };

        /**
         * Converts this GroupData to JSON.
         * @function toJSON
         * @memberof Qot_GetUserSecurityGroup.GroupData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GroupData;
    })();

    Qot_GetUserSecurityGroup.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetUserSecurityGroup
         * @interface IS2C
         * @property {Array.<Qot_GetUserSecurityGroup.IGroupData>|null} [groupList] S2C groupList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetUserSecurityGroup
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetUserSecurityGroup.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.groupList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C groupList.
         * @member {Array.<Qot_GetUserSecurityGroup.IGroupData>} groupList
         * @memberof Qot_GetUserSecurityGroup.S2C
         * @instance
         */
        S2C.prototype.groupList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetUserSecurityGroup.S2C
         * @static
         * @param {Qot_GetUserSecurityGroup.IS2C=} [properties] Properties to set
         * @returns {Qot_GetUserSecurityGroup.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetUserSecurityGroup.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetUserSecurityGroup.S2C
         * @static
         * @param {Qot_GetUserSecurityGroup.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.groupList != null && message.groupList.length)
                for (var i = 0; i < message.groupList.length; ++i)
                    $root.Qot_GetUserSecurityGroup.GroupData.encode(message.groupList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetUserSecurityGroup.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetUserSecurityGroup.S2C
         * @static
         * @param {Qot_GetUserSecurityGroup.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetUserSecurityGroup.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetUserSecurityGroup.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetUserSecurityGroup.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.groupList && message.groupList.length))
                        message.groupList = [];
                    message.groupList.push($root.Qot_GetUserSecurityGroup.GroupData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetUserSecurityGroup.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetUserSecurityGroup.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetUserSecurityGroup.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.groupList != null && message.hasOwnProperty("groupList")) {
                if (!Array.isArray(message.groupList))
                    return "groupList: array expected";
                for (var i = 0; i < message.groupList.length; ++i) {
                    var error = $root.Qot_GetUserSecurityGroup.GroupData.verify(message.groupList[i]);
                    if (error)
                        return "groupList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetUserSecurityGroup.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetUserSecurityGroup.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetUserSecurityGroup.S2C)
                return object;
            var message = new $root.Qot_GetUserSecurityGroup.S2C();
            if (object.groupList) {
                if (!Array.isArray(object.groupList))
                    throw TypeError(".Qot_GetUserSecurityGroup.S2C.groupList: array expected");
                message.groupList = [];
                for (var i = 0; i < object.groupList.length; ++i) {
                    if (typeof object.groupList[i] !== "object")
                        throw TypeError(".Qot_GetUserSecurityGroup.S2C.groupList: object expected");
                    message.groupList[i] = $root.Qot_GetUserSecurityGroup.GroupData.fromObject(object.groupList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetUserSecurityGroup.S2C
         * @static
         * @param {Qot_GetUserSecurityGroup.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.groupList = [];
            if (message.groupList && message.groupList.length) {
                object.groupList = [];
                for (var j = 0; j < message.groupList.length; ++j)
                    object.groupList[j] = $root.Qot_GetUserSecurityGroup.GroupData.toObject(message.groupList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetUserSecurityGroup.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetUserSecurityGroup.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetUserSecurityGroup
         * @interface IRequest
         * @property {Qot_GetUserSecurityGroup.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetUserSecurityGroup
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetUserSecurityGroup.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetUserSecurityGroup.IC2S} c2s
         * @memberof Qot_GetUserSecurityGroup.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetUserSecurityGroup.Request
         * @static
         * @param {Qot_GetUserSecurityGroup.IRequest=} [properties] Properties to set
         * @returns {Qot_GetUserSecurityGroup.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetUserSecurityGroup.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetUserSecurityGroup.Request
         * @static
         * @param {Qot_GetUserSecurityGroup.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetUserSecurityGroup.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetUserSecurityGroup.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetUserSecurityGroup.Request
         * @static
         * @param {Qot_GetUserSecurityGroup.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetUserSecurityGroup.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetUserSecurityGroup.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetUserSecurityGroup.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetUserSecurityGroup.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetUserSecurityGroup.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetUserSecurityGroup.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetUserSecurityGroup.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetUserSecurityGroup.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetUserSecurityGroup.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetUserSecurityGroup.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetUserSecurityGroup.Request)
                return object;
            var message = new $root.Qot_GetUserSecurityGroup.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetUserSecurityGroup.Request.c2s: object expected");
                message.c2s = $root.Qot_GetUserSecurityGroup.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetUserSecurityGroup.Request
         * @static
         * @param {Qot_GetUserSecurityGroup.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetUserSecurityGroup.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetUserSecurityGroup.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetUserSecurityGroup.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetUserSecurityGroup
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetUserSecurityGroup.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetUserSecurityGroup
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetUserSecurityGroup.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetUserSecurityGroup.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetUserSecurityGroup.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetUserSecurityGroup.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetUserSecurityGroup.IS2C|null|undefined} s2c
         * @memberof Qot_GetUserSecurityGroup.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetUserSecurityGroup.Response
         * @static
         * @param {Qot_GetUserSecurityGroup.IResponse=} [properties] Properties to set
         * @returns {Qot_GetUserSecurityGroup.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetUserSecurityGroup.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetUserSecurityGroup.Response
         * @static
         * @param {Qot_GetUserSecurityGroup.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetUserSecurityGroup.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetUserSecurityGroup.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetUserSecurityGroup.Response
         * @static
         * @param {Qot_GetUserSecurityGroup.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetUserSecurityGroup.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetUserSecurityGroup.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetUserSecurityGroup.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetUserSecurityGroup.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetUserSecurityGroup.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetUserSecurityGroup.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetUserSecurityGroup.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetUserSecurityGroup.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetUserSecurityGroup.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetUserSecurityGroup.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetUserSecurityGroup.Response)
                return object;
            var message = new $root.Qot_GetUserSecurityGroup.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetUserSecurityGroup.Response.s2c: object expected");
                message.s2c = $root.Qot_GetUserSecurityGroup.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetUserSecurityGroup.Response
         * @static
         * @param {Qot_GetUserSecurityGroup.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetUserSecurityGroup.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetUserSecurityGroup.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetUserSecurityGroup;
})();

$root.Qot_GetUserSecurity = (function() {

    /**
     * Namespace Qot_GetUserSecurity.
     * @exports Qot_GetUserSecurity
     * @namespace
     */
    var Qot_GetUserSecurity = {};

    Qot_GetUserSecurity.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetUserSecurity
         * @interface IC2S
         * @property {string} groupName C2S groupName
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetUserSecurity
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetUserSecurity.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S groupName.
         * @member {string} groupName
         * @memberof Qot_GetUserSecurity.C2S
         * @instance
         */
        C2S.prototype.groupName = "";

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetUserSecurity.C2S
         * @static
         * @param {Qot_GetUserSecurity.IC2S=} [properties] Properties to set
         * @returns {Qot_GetUserSecurity.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetUserSecurity.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetUserSecurity.C2S
         * @static
         * @param {Qot_GetUserSecurity.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupName);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetUserSecurity.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetUserSecurity.C2S
         * @static
         * @param {Qot_GetUserSecurity.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetUserSecurity.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetUserSecurity.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetUserSecurity.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.groupName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("groupName"))
                throw $util.ProtocolError("missing required 'groupName'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetUserSecurity.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetUserSecurity.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetUserSecurity.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.groupName))
                return "groupName: string expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetUserSecurity.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetUserSecurity.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetUserSecurity.C2S)
                return object;
            var message = new $root.Qot_GetUserSecurity.C2S();
            if (object.groupName != null)
                message.groupName = String(object.groupName);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetUserSecurity.C2S
         * @static
         * @param {Qot_GetUserSecurity.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.groupName = "";
            if (message.groupName != null && message.hasOwnProperty("groupName"))
                object.groupName = message.groupName;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetUserSecurity.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetUserSecurity.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetUserSecurity
         * @interface IS2C
         * @property {Array.<Qot_Common.ISecurityStaticInfo>|null} [staticInfoList] S2C staticInfoList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetUserSecurity
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetUserSecurity.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.staticInfoList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C staticInfoList.
         * @member {Array.<Qot_Common.ISecurityStaticInfo>} staticInfoList
         * @memberof Qot_GetUserSecurity.S2C
         * @instance
         */
        S2C.prototype.staticInfoList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetUserSecurity.S2C
         * @static
         * @param {Qot_GetUserSecurity.IS2C=} [properties] Properties to set
         * @returns {Qot_GetUserSecurity.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetUserSecurity.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetUserSecurity.S2C
         * @static
         * @param {Qot_GetUserSecurity.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.staticInfoList != null && message.staticInfoList.length)
                for (var i = 0; i < message.staticInfoList.length; ++i)
                    $root.Qot_Common.SecurityStaticInfo.encode(message.staticInfoList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetUserSecurity.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetUserSecurity.S2C
         * @static
         * @param {Qot_GetUserSecurity.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetUserSecurity.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetUserSecurity.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetUserSecurity.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.staticInfoList && message.staticInfoList.length))
                        message.staticInfoList = [];
                    message.staticInfoList.push($root.Qot_Common.SecurityStaticInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetUserSecurity.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetUserSecurity.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetUserSecurity.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.staticInfoList != null && message.hasOwnProperty("staticInfoList")) {
                if (!Array.isArray(message.staticInfoList))
                    return "staticInfoList: array expected";
                for (var i = 0; i < message.staticInfoList.length; ++i) {
                    var error = $root.Qot_Common.SecurityStaticInfo.verify(message.staticInfoList[i]);
                    if (error)
                        return "staticInfoList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetUserSecurity.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetUserSecurity.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetUserSecurity.S2C)
                return object;
            var message = new $root.Qot_GetUserSecurity.S2C();
            if (object.staticInfoList) {
                if (!Array.isArray(object.staticInfoList))
                    throw TypeError(".Qot_GetUserSecurity.S2C.staticInfoList: array expected");
                message.staticInfoList = [];
                for (var i = 0; i < object.staticInfoList.length; ++i) {
                    if (typeof object.staticInfoList[i] !== "object")
                        throw TypeError(".Qot_GetUserSecurity.S2C.staticInfoList: object expected");
                    message.staticInfoList[i] = $root.Qot_Common.SecurityStaticInfo.fromObject(object.staticInfoList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetUserSecurity.S2C
         * @static
         * @param {Qot_GetUserSecurity.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.staticInfoList = [];
            if (message.staticInfoList && message.staticInfoList.length) {
                object.staticInfoList = [];
                for (var j = 0; j < message.staticInfoList.length; ++j)
                    object.staticInfoList[j] = $root.Qot_Common.SecurityStaticInfo.toObject(message.staticInfoList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetUserSecurity.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetUserSecurity.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetUserSecurity
         * @interface IRequest
         * @property {Qot_GetUserSecurity.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetUserSecurity
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetUserSecurity.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetUserSecurity.IC2S} c2s
         * @memberof Qot_GetUserSecurity.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetUserSecurity.Request
         * @static
         * @param {Qot_GetUserSecurity.IRequest=} [properties] Properties to set
         * @returns {Qot_GetUserSecurity.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetUserSecurity.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetUserSecurity.Request
         * @static
         * @param {Qot_GetUserSecurity.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetUserSecurity.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetUserSecurity.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetUserSecurity.Request
         * @static
         * @param {Qot_GetUserSecurity.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetUserSecurity.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetUserSecurity.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetUserSecurity.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetUserSecurity.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetUserSecurity.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetUserSecurity.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetUserSecurity.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetUserSecurity.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetUserSecurity.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetUserSecurity.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetUserSecurity.Request)
                return object;
            var message = new $root.Qot_GetUserSecurity.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetUserSecurity.Request.c2s: object expected");
                message.c2s = $root.Qot_GetUserSecurity.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetUserSecurity.Request
         * @static
         * @param {Qot_GetUserSecurity.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetUserSecurity.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetUserSecurity.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetUserSecurity.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetUserSecurity
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetUserSecurity.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetUserSecurity
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetUserSecurity.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetUserSecurity.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetUserSecurity.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetUserSecurity.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetUserSecurity.IS2C|null|undefined} s2c
         * @memberof Qot_GetUserSecurity.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetUserSecurity.Response
         * @static
         * @param {Qot_GetUserSecurity.IResponse=} [properties] Properties to set
         * @returns {Qot_GetUserSecurity.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetUserSecurity.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetUserSecurity.Response
         * @static
         * @param {Qot_GetUserSecurity.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetUserSecurity.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetUserSecurity.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetUserSecurity.Response
         * @static
         * @param {Qot_GetUserSecurity.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetUserSecurity.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetUserSecurity.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetUserSecurity.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetUserSecurity.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetUserSecurity.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetUserSecurity.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetUserSecurity.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetUserSecurity.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetUserSecurity.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetUserSecurity.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetUserSecurity.Response)
                return object;
            var message = new $root.Qot_GetUserSecurity.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetUserSecurity.Response.s2c: object expected");
                message.s2c = $root.Qot_GetUserSecurity.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetUserSecurity.Response
         * @static
         * @param {Qot_GetUserSecurity.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetUserSecurity.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetUserSecurity.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetUserSecurity;
})();

$root.Qot_GetWarrant = (function() {

    /**
     * Namespace Qot_GetWarrant.
     * @exports Qot_GetWarrant
     * @namespace
     */
    var Qot_GetWarrant = {};

    Qot_GetWarrant.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetWarrant
         * @interface IC2S
         * @property {number} begin C2S begin
         * @property {number} num C2S num
         * @property {number} sortField C2S sortField
         * @property {boolean} ascend C2S ascend
         * @property {Qot_Common.ISecurity|null} [owner] C2S owner
         * @property {Array.<number>|null} [typeList] C2S typeList
         * @property {Array.<number>|null} [issuerList] C2S issuerList
         * @property {string|null} [maturityTimeMin] C2S maturityTimeMin
         * @property {string|null} [maturityTimeMax] C2S maturityTimeMax
         * @property {number|null} [ipoPeriod] C2S ipoPeriod
         * @property {number|null} [priceType] C2S priceType
         * @property {number|null} [status] C2S status
         * @property {number|null} [curPriceMin] C2S curPriceMin
         * @property {number|null} [curPriceMax] C2S curPriceMax
         * @property {number|null} [strikePriceMin] C2S strikePriceMin
         * @property {number|null} [strikePriceMax] C2S strikePriceMax
         * @property {number|null} [streetMin] C2S streetMin
         * @property {number|null} [streetMax] C2S streetMax
         * @property {number|null} [conversionMin] C2S conversionMin
         * @property {number|null} [conversionMax] C2S conversionMax
         * @property {number|Long|null} [volMin] C2S volMin
         * @property {number|Long|null} [volMax] C2S volMax
         * @property {number|null} [premiumMin] C2S premiumMin
         * @property {number|null} [premiumMax] C2S premiumMax
         * @property {number|null} [leverageRatioMin] C2S leverageRatioMin
         * @property {number|null} [leverageRatioMax] C2S leverageRatioMax
         * @property {number|null} [deltaMin] C2S deltaMin
         * @property {number|null} [deltaMax] C2S deltaMax
         * @property {number|null} [impliedMin] C2S impliedMin
         * @property {number|null} [impliedMax] C2S impliedMax
         * @property {number|null} [recoveryPriceMin] C2S recoveryPriceMin
         * @property {number|null} [recoveryPriceMax] C2S recoveryPriceMax
         * @property {number|null} [priceRecoveryRatioMin] C2S priceRecoveryRatioMin
         * @property {number|null} [priceRecoveryRatioMax] C2S priceRecoveryRatioMax
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetWarrant
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetWarrant.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.typeList = [];
            this.issuerList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S begin.
         * @member {number} begin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.begin = 0;

        /**
         * C2S num.
         * @member {number} num
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.num = 0;

        /**
         * C2S sortField.
         * @member {number} sortField
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.sortField = 0;

        /**
         * C2S ascend.
         * @member {boolean} ascend
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.ascend = false;

        /**
         * C2S owner.
         * @member {Qot_Common.ISecurity|null|undefined} owner
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.owner = null;

        /**
         * C2S typeList.
         * @member {Array.<number>} typeList
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.typeList = $util.emptyArray;

        /**
         * C2S issuerList.
         * @member {Array.<number>} issuerList
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.issuerList = $util.emptyArray;

        /**
         * C2S maturityTimeMin.
         * @member {string} maturityTimeMin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.maturityTimeMin = "";

        /**
         * C2S maturityTimeMax.
         * @member {string} maturityTimeMax
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.maturityTimeMax = "";

        /**
         * C2S ipoPeriod.
         * @member {number} ipoPeriod
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.ipoPeriod = 0;

        /**
         * C2S priceType.
         * @member {number} priceType
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.priceType = 0;

        /**
         * C2S status.
         * @member {number} status
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.status = 0;

        /**
         * C2S curPriceMin.
         * @member {number} curPriceMin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.curPriceMin = 0;

        /**
         * C2S curPriceMax.
         * @member {number} curPriceMax
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.curPriceMax = 0;

        /**
         * C2S strikePriceMin.
         * @member {number} strikePriceMin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.strikePriceMin = 0;

        /**
         * C2S strikePriceMax.
         * @member {number} strikePriceMax
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.strikePriceMax = 0;

        /**
         * C2S streetMin.
         * @member {number} streetMin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.streetMin = 0;

        /**
         * C2S streetMax.
         * @member {number} streetMax
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.streetMax = 0;

        /**
         * C2S conversionMin.
         * @member {number} conversionMin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.conversionMin = 0;

        /**
         * C2S conversionMax.
         * @member {number} conversionMax
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.conversionMax = 0;

        /**
         * C2S volMin.
         * @member {number|Long} volMin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.volMin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * C2S volMax.
         * @member {number|Long} volMax
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.volMax = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * C2S premiumMin.
         * @member {number} premiumMin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.premiumMin = 0;

        /**
         * C2S premiumMax.
         * @member {number} premiumMax
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.premiumMax = 0;

        /**
         * C2S leverageRatioMin.
         * @member {number} leverageRatioMin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.leverageRatioMin = 0;

        /**
         * C2S leverageRatioMax.
         * @member {number} leverageRatioMax
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.leverageRatioMax = 0;

        /**
         * C2S deltaMin.
         * @member {number} deltaMin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.deltaMin = 0;

        /**
         * C2S deltaMax.
         * @member {number} deltaMax
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.deltaMax = 0;

        /**
         * C2S impliedMin.
         * @member {number} impliedMin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.impliedMin = 0;

        /**
         * C2S impliedMax.
         * @member {number} impliedMax
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.impliedMax = 0;

        /**
         * C2S recoveryPriceMin.
         * @member {number} recoveryPriceMin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.recoveryPriceMin = 0;

        /**
         * C2S recoveryPriceMax.
         * @member {number} recoveryPriceMax
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.recoveryPriceMax = 0;

        /**
         * C2S priceRecoveryRatioMin.
         * @member {number} priceRecoveryRatioMin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.priceRecoveryRatioMin = 0;

        /**
         * C2S priceRecoveryRatioMax.
         * @member {number} priceRecoveryRatioMax
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.priceRecoveryRatioMax = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetWarrant.C2S
         * @static
         * @param {Qot_GetWarrant.IC2S=} [properties] Properties to set
         * @returns {Qot_GetWarrant.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetWarrant.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetWarrant.C2S
         * @static
         * @param {Qot_GetWarrant.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.begin);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.sortField);
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.ascend);
            if (message.owner != null && message.hasOwnProperty("owner"))
                $root.Qot_Common.Security.encode(message.owner, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.typeList != null && message.typeList.length)
                for (var i = 0; i < message.typeList.length; ++i)
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.typeList[i]);
            if (message.issuerList != null && message.issuerList.length)
                for (var i = 0; i < message.issuerList.length; ++i)
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.issuerList[i]);
            if (message.maturityTimeMin != null && message.hasOwnProperty("maturityTimeMin"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.maturityTimeMin);
            if (message.maturityTimeMax != null && message.hasOwnProperty("maturityTimeMax"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.maturityTimeMax);
            if (message.ipoPeriod != null && message.hasOwnProperty("ipoPeriod"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.ipoPeriod);
            if (message.priceType != null && message.hasOwnProperty("priceType"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.priceType);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.status);
            if (message.curPriceMin != null && message.hasOwnProperty("curPriceMin"))
                writer.uint32(/* id 13, wireType 1 =*/105).double(message.curPriceMin);
            if (message.curPriceMax != null && message.hasOwnProperty("curPriceMax"))
                writer.uint32(/* id 14, wireType 1 =*/113).double(message.curPriceMax);
            if (message.strikePriceMin != null && message.hasOwnProperty("strikePriceMin"))
                writer.uint32(/* id 15, wireType 1 =*/121).double(message.strikePriceMin);
            if (message.strikePriceMax != null && message.hasOwnProperty("strikePriceMax"))
                writer.uint32(/* id 16, wireType 1 =*/129).double(message.strikePriceMax);
            if (message.streetMin != null && message.hasOwnProperty("streetMin"))
                writer.uint32(/* id 17, wireType 1 =*/137).double(message.streetMin);
            if (message.streetMax != null && message.hasOwnProperty("streetMax"))
                writer.uint32(/* id 18, wireType 1 =*/145).double(message.streetMax);
            if (message.conversionMin != null && message.hasOwnProperty("conversionMin"))
                writer.uint32(/* id 19, wireType 1 =*/153).double(message.conversionMin);
            if (message.conversionMax != null && message.hasOwnProperty("conversionMax"))
                writer.uint32(/* id 20, wireType 1 =*/161).double(message.conversionMax);
            if (message.volMin != null && message.hasOwnProperty("volMin"))
                writer.uint32(/* id 21, wireType 0 =*/168).uint64(message.volMin);
            if (message.volMax != null && message.hasOwnProperty("volMax"))
                writer.uint32(/* id 22, wireType 0 =*/176).uint64(message.volMax);
            if (message.premiumMin != null && message.hasOwnProperty("premiumMin"))
                writer.uint32(/* id 23, wireType 1 =*/185).double(message.premiumMin);
            if (message.premiumMax != null && message.hasOwnProperty("premiumMax"))
                writer.uint32(/* id 24, wireType 1 =*/193).double(message.premiumMax);
            if (message.leverageRatioMin != null && message.hasOwnProperty("leverageRatioMin"))
                writer.uint32(/* id 25, wireType 1 =*/201).double(message.leverageRatioMin);
            if (message.leverageRatioMax != null && message.hasOwnProperty("leverageRatioMax"))
                writer.uint32(/* id 26, wireType 1 =*/209).double(message.leverageRatioMax);
            if (message.deltaMin != null && message.hasOwnProperty("deltaMin"))
                writer.uint32(/* id 27, wireType 1 =*/217).double(message.deltaMin);
            if (message.deltaMax != null && message.hasOwnProperty("deltaMax"))
                writer.uint32(/* id 28, wireType 1 =*/225).double(message.deltaMax);
            if (message.impliedMin != null && message.hasOwnProperty("impliedMin"))
                writer.uint32(/* id 29, wireType 1 =*/233).double(message.impliedMin);
            if (message.impliedMax != null && message.hasOwnProperty("impliedMax"))
                writer.uint32(/* id 30, wireType 1 =*/241).double(message.impliedMax);
            if (message.recoveryPriceMin != null && message.hasOwnProperty("recoveryPriceMin"))
                writer.uint32(/* id 31, wireType 1 =*/249).double(message.recoveryPriceMin);
            if (message.recoveryPriceMax != null && message.hasOwnProperty("recoveryPriceMax"))
                writer.uint32(/* id 32, wireType 1 =*/257).double(message.recoveryPriceMax);
            if (message.priceRecoveryRatioMin != null && message.hasOwnProperty("priceRecoveryRatioMin"))
                writer.uint32(/* id 33, wireType 1 =*/265).double(message.priceRecoveryRatioMin);
            if (message.priceRecoveryRatioMax != null && message.hasOwnProperty("priceRecoveryRatioMax"))
                writer.uint32(/* id 34, wireType 1 =*/273).double(message.priceRecoveryRatioMax);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetWarrant.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetWarrant.C2S
         * @static
         * @param {Qot_GetWarrant.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetWarrant.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetWarrant.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetWarrant.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.begin = reader.int32();
                    break;
                case 2:
                    message.num = reader.int32();
                    break;
                case 3:
                    message.sortField = reader.int32();
                    break;
                case 4:
                    message.ascend = reader.bool();
                    break;
                case 5:
                    message.owner = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 6:
                    if (!(message.typeList && message.typeList.length))
                        message.typeList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.typeList.push(reader.int32());
                    } else
                        message.typeList.push(reader.int32());
                    break;
                case 7:
                    if (!(message.issuerList && message.issuerList.length))
                        message.issuerList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.issuerList.push(reader.int32());
                    } else
                        message.issuerList.push(reader.int32());
                    break;
                case 8:
                    message.maturityTimeMin = reader.string();
                    break;
                case 9:
                    message.maturityTimeMax = reader.string();
                    break;
                case 10:
                    message.ipoPeriod = reader.int32();
                    break;
                case 11:
                    message.priceType = reader.int32();
                    break;
                case 12:
                    message.status = reader.int32();
                    break;
                case 13:
                    message.curPriceMin = reader.double();
                    break;
                case 14:
                    message.curPriceMax = reader.double();
                    break;
                case 15:
                    message.strikePriceMin = reader.double();
                    break;
                case 16:
                    message.strikePriceMax = reader.double();
                    break;
                case 17:
                    message.streetMin = reader.double();
                    break;
                case 18:
                    message.streetMax = reader.double();
                    break;
                case 19:
                    message.conversionMin = reader.double();
                    break;
                case 20:
                    message.conversionMax = reader.double();
                    break;
                case 21:
                    message.volMin = reader.uint64();
                    break;
                case 22:
                    message.volMax = reader.uint64();
                    break;
                case 23:
                    message.premiumMin = reader.double();
                    break;
                case 24:
                    message.premiumMax = reader.double();
                    break;
                case 25:
                    message.leverageRatioMin = reader.double();
                    break;
                case 26:
                    message.leverageRatioMax = reader.double();
                    break;
                case 27:
                    message.deltaMin = reader.double();
                    break;
                case 28:
                    message.deltaMax = reader.double();
                    break;
                case 29:
                    message.impliedMin = reader.double();
                    break;
                case 30:
                    message.impliedMax = reader.double();
                    break;
                case 31:
                    message.recoveryPriceMin = reader.double();
                    break;
                case 32:
                    message.recoveryPriceMax = reader.double();
                    break;
                case 33:
                    message.priceRecoveryRatioMin = reader.double();
                    break;
                case 34:
                    message.priceRecoveryRatioMax = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("begin"))
                throw $util.ProtocolError("missing required 'begin'", { instance: message });
            if (!message.hasOwnProperty("num"))
                throw $util.ProtocolError("missing required 'num'", { instance: message });
            if (!message.hasOwnProperty("sortField"))
                throw $util.ProtocolError("missing required 'sortField'", { instance: message });
            if (!message.hasOwnProperty("ascend"))
                throw $util.ProtocolError("missing required 'ascend'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetWarrant.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetWarrant.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetWarrant.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.begin))
                return "begin: integer expected";
            if (!$util.isInteger(message.num))
                return "num: integer expected";
            if (!$util.isInteger(message.sortField))
                return "sortField: integer expected";
            if (typeof message.ascend !== "boolean")
                return "ascend: boolean expected";
            if (message.owner != null && message.hasOwnProperty("owner")) {
                var error = $root.Qot_Common.Security.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            if (message.typeList != null && message.hasOwnProperty("typeList")) {
                if (!Array.isArray(message.typeList))
                    return "typeList: array expected";
                for (var i = 0; i < message.typeList.length; ++i)
                    if (!$util.isInteger(message.typeList[i]))
                        return "typeList: integer[] expected";
            }
            if (message.issuerList != null && message.hasOwnProperty("issuerList")) {
                if (!Array.isArray(message.issuerList))
                    return "issuerList: array expected";
                for (var i = 0; i < message.issuerList.length; ++i)
                    if (!$util.isInteger(message.issuerList[i]))
                        return "issuerList: integer[] expected";
            }
            if (message.maturityTimeMin != null && message.hasOwnProperty("maturityTimeMin"))
                if (!$util.isString(message.maturityTimeMin))
                    return "maturityTimeMin: string expected";
            if (message.maturityTimeMax != null && message.hasOwnProperty("maturityTimeMax"))
                if (!$util.isString(message.maturityTimeMax))
                    return "maturityTimeMax: string expected";
            if (message.ipoPeriod != null && message.hasOwnProperty("ipoPeriod"))
                if (!$util.isInteger(message.ipoPeriod))
                    return "ipoPeriod: integer expected";
            if (message.priceType != null && message.hasOwnProperty("priceType"))
                if (!$util.isInteger(message.priceType))
                    return "priceType: integer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isInteger(message.status))
                    return "status: integer expected";
            if (message.curPriceMin != null && message.hasOwnProperty("curPriceMin"))
                if (typeof message.curPriceMin !== "number")
                    return "curPriceMin: number expected";
            if (message.curPriceMax != null && message.hasOwnProperty("curPriceMax"))
                if (typeof message.curPriceMax !== "number")
                    return "curPriceMax: number expected";
            if (message.strikePriceMin != null && message.hasOwnProperty("strikePriceMin"))
                if (typeof message.strikePriceMin !== "number")
                    return "strikePriceMin: number expected";
            if (message.strikePriceMax != null && message.hasOwnProperty("strikePriceMax"))
                if (typeof message.strikePriceMax !== "number")
                    return "strikePriceMax: number expected";
            if (message.streetMin != null && message.hasOwnProperty("streetMin"))
                if (typeof message.streetMin !== "number")
                    return "streetMin: number expected";
            if (message.streetMax != null && message.hasOwnProperty("streetMax"))
                if (typeof message.streetMax !== "number")
                    return "streetMax: number expected";
            if (message.conversionMin != null && message.hasOwnProperty("conversionMin"))
                if (typeof message.conversionMin !== "number")
                    return "conversionMin: number expected";
            if (message.conversionMax != null && message.hasOwnProperty("conversionMax"))
                if (typeof message.conversionMax !== "number")
                    return "conversionMax: number expected";
            if (message.volMin != null && message.hasOwnProperty("volMin"))
                if (!$util.isInteger(message.volMin) && !(message.volMin && $util.isInteger(message.volMin.low) && $util.isInteger(message.volMin.high)))
                    return "volMin: integer|Long expected";
            if (message.volMax != null && message.hasOwnProperty("volMax"))
                if (!$util.isInteger(message.volMax) && !(message.volMax && $util.isInteger(message.volMax.low) && $util.isInteger(message.volMax.high)))
                    return "volMax: integer|Long expected";
            if (message.premiumMin != null && message.hasOwnProperty("premiumMin"))
                if (typeof message.premiumMin !== "number")
                    return "premiumMin: number expected";
            if (message.premiumMax != null && message.hasOwnProperty("premiumMax"))
                if (typeof message.premiumMax !== "number")
                    return "premiumMax: number expected";
            if (message.leverageRatioMin != null && message.hasOwnProperty("leverageRatioMin"))
                if (typeof message.leverageRatioMin !== "number")
                    return "leverageRatioMin: number expected";
            if (message.leverageRatioMax != null && message.hasOwnProperty("leverageRatioMax"))
                if (typeof message.leverageRatioMax !== "number")
                    return "leverageRatioMax: number expected";
            if (message.deltaMin != null && message.hasOwnProperty("deltaMin"))
                if (typeof message.deltaMin !== "number")
                    return "deltaMin: number expected";
            if (message.deltaMax != null && message.hasOwnProperty("deltaMax"))
                if (typeof message.deltaMax !== "number")
                    return "deltaMax: number expected";
            if (message.impliedMin != null && message.hasOwnProperty("impliedMin"))
                if (typeof message.impliedMin !== "number")
                    return "impliedMin: number expected";
            if (message.impliedMax != null && message.hasOwnProperty("impliedMax"))
                if (typeof message.impliedMax !== "number")
                    return "impliedMax: number expected";
            if (message.recoveryPriceMin != null && message.hasOwnProperty("recoveryPriceMin"))
                if (typeof message.recoveryPriceMin !== "number")
                    return "recoveryPriceMin: number expected";
            if (message.recoveryPriceMax != null && message.hasOwnProperty("recoveryPriceMax"))
                if (typeof message.recoveryPriceMax !== "number")
                    return "recoveryPriceMax: number expected";
            if (message.priceRecoveryRatioMin != null && message.hasOwnProperty("priceRecoveryRatioMin"))
                if (typeof message.priceRecoveryRatioMin !== "number")
                    return "priceRecoveryRatioMin: number expected";
            if (message.priceRecoveryRatioMax != null && message.hasOwnProperty("priceRecoveryRatioMax"))
                if (typeof message.priceRecoveryRatioMax !== "number")
                    return "priceRecoveryRatioMax: number expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetWarrant.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetWarrant.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetWarrant.C2S)
                return object;
            var message = new $root.Qot_GetWarrant.C2S();
            if (object.begin != null)
                message.begin = object.begin | 0;
            if (object.num != null)
                message.num = object.num | 0;
            if (object.sortField != null)
                message.sortField = object.sortField | 0;
            if (object.ascend != null)
                message.ascend = Boolean(object.ascend);
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".Qot_GetWarrant.C2S.owner: object expected");
                message.owner = $root.Qot_Common.Security.fromObject(object.owner);
            }
            if (object.typeList) {
                if (!Array.isArray(object.typeList))
                    throw TypeError(".Qot_GetWarrant.C2S.typeList: array expected");
                message.typeList = [];
                for (var i = 0; i < object.typeList.length; ++i)
                    message.typeList[i] = object.typeList[i] | 0;
            }
            if (object.issuerList) {
                if (!Array.isArray(object.issuerList))
                    throw TypeError(".Qot_GetWarrant.C2S.issuerList: array expected");
                message.issuerList = [];
                for (var i = 0; i < object.issuerList.length; ++i)
                    message.issuerList[i] = object.issuerList[i] | 0;
            }
            if (object.maturityTimeMin != null)
                message.maturityTimeMin = String(object.maturityTimeMin);
            if (object.maturityTimeMax != null)
                message.maturityTimeMax = String(object.maturityTimeMax);
            if (object.ipoPeriod != null)
                message.ipoPeriod = object.ipoPeriod | 0;
            if (object.priceType != null)
                message.priceType = object.priceType | 0;
            if (object.status != null)
                message.status = object.status | 0;
            if (object.curPriceMin != null)
                message.curPriceMin = Number(object.curPriceMin);
            if (object.curPriceMax != null)
                message.curPriceMax = Number(object.curPriceMax);
            if (object.strikePriceMin != null)
                message.strikePriceMin = Number(object.strikePriceMin);
            if (object.strikePriceMax != null)
                message.strikePriceMax = Number(object.strikePriceMax);
            if (object.streetMin != null)
                message.streetMin = Number(object.streetMin);
            if (object.streetMax != null)
                message.streetMax = Number(object.streetMax);
            if (object.conversionMin != null)
                message.conversionMin = Number(object.conversionMin);
            if (object.conversionMax != null)
                message.conversionMax = Number(object.conversionMax);
            if (object.volMin != null)
                if ($util.Long)
                    (message.volMin = $util.Long.fromValue(object.volMin)).unsigned = true;
                else if (typeof object.volMin === "string")
                    message.volMin = parseInt(object.volMin, 10);
                else if (typeof object.volMin === "number")
                    message.volMin = object.volMin;
                else if (typeof object.volMin === "object")
                    message.volMin = new $util.LongBits(object.volMin.low >>> 0, object.volMin.high >>> 0).toNumber(true);
            if (object.volMax != null)
                if ($util.Long)
                    (message.volMax = $util.Long.fromValue(object.volMax)).unsigned = true;
                else if (typeof object.volMax === "string")
                    message.volMax = parseInt(object.volMax, 10);
                else if (typeof object.volMax === "number")
                    message.volMax = object.volMax;
                else if (typeof object.volMax === "object")
                    message.volMax = new $util.LongBits(object.volMax.low >>> 0, object.volMax.high >>> 0).toNumber(true);
            if (object.premiumMin != null)
                message.premiumMin = Number(object.premiumMin);
            if (object.premiumMax != null)
                message.premiumMax = Number(object.premiumMax);
            if (object.leverageRatioMin != null)
                message.leverageRatioMin = Number(object.leverageRatioMin);
            if (object.leverageRatioMax != null)
                message.leverageRatioMax = Number(object.leverageRatioMax);
            if (object.deltaMin != null)
                message.deltaMin = Number(object.deltaMin);
            if (object.deltaMax != null)
                message.deltaMax = Number(object.deltaMax);
            if (object.impliedMin != null)
                message.impliedMin = Number(object.impliedMin);
            if (object.impliedMax != null)
                message.impliedMax = Number(object.impliedMax);
            if (object.recoveryPriceMin != null)
                message.recoveryPriceMin = Number(object.recoveryPriceMin);
            if (object.recoveryPriceMax != null)
                message.recoveryPriceMax = Number(object.recoveryPriceMax);
            if (object.priceRecoveryRatioMin != null)
                message.priceRecoveryRatioMin = Number(object.priceRecoveryRatioMin);
            if (object.priceRecoveryRatioMax != null)
                message.priceRecoveryRatioMax = Number(object.priceRecoveryRatioMax);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetWarrant.C2S
         * @static
         * @param {Qot_GetWarrant.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.typeList = [];
                object.issuerList = [];
            }
            if (options.defaults) {
                object.begin = 0;
                object.num = 0;
                object.sortField = 0;
                object.ascend = false;
                object.owner = null;
                object.maturityTimeMin = "";
                object.maturityTimeMax = "";
                object.ipoPeriod = 0;
                object.priceType = 0;
                object.status = 0;
                object.curPriceMin = 0;
                object.curPriceMax = 0;
                object.strikePriceMin = 0;
                object.strikePriceMax = 0;
                object.streetMin = 0;
                object.streetMax = 0;
                object.conversionMin = 0;
                object.conversionMax = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.volMin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.volMin = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.volMax = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.volMax = options.longs === String ? "0" : 0;
                object.premiumMin = 0;
                object.premiumMax = 0;
                object.leverageRatioMin = 0;
                object.leverageRatioMax = 0;
                object.deltaMin = 0;
                object.deltaMax = 0;
                object.impliedMin = 0;
                object.impliedMax = 0;
                object.recoveryPriceMin = 0;
                object.recoveryPriceMax = 0;
                object.priceRecoveryRatioMin = 0;
                object.priceRecoveryRatioMax = 0;
            }
            if (message.begin != null && message.hasOwnProperty("begin"))
                object.begin = message.begin;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.sortField != null && message.hasOwnProperty("sortField"))
                object.sortField = message.sortField;
            if (message.ascend != null && message.hasOwnProperty("ascend"))
                object.ascend = message.ascend;
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.Qot_Common.Security.toObject(message.owner, options);
            if (message.typeList && message.typeList.length) {
                object.typeList = [];
                for (var j = 0; j < message.typeList.length; ++j)
                    object.typeList[j] = message.typeList[j];
            }
            if (message.issuerList && message.issuerList.length) {
                object.issuerList = [];
                for (var j = 0; j < message.issuerList.length; ++j)
                    object.issuerList[j] = message.issuerList[j];
            }
            if (message.maturityTimeMin != null && message.hasOwnProperty("maturityTimeMin"))
                object.maturityTimeMin = message.maturityTimeMin;
            if (message.maturityTimeMax != null && message.hasOwnProperty("maturityTimeMax"))
                object.maturityTimeMax = message.maturityTimeMax;
            if (message.ipoPeriod != null && message.hasOwnProperty("ipoPeriod"))
                object.ipoPeriod = message.ipoPeriod;
            if (message.priceType != null && message.hasOwnProperty("priceType"))
                object.priceType = message.priceType;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.curPriceMin != null && message.hasOwnProperty("curPriceMin"))
                object.curPriceMin = options.json && !isFinite(message.curPriceMin) ? String(message.curPriceMin) : message.curPriceMin;
            if (message.curPriceMax != null && message.hasOwnProperty("curPriceMax"))
                object.curPriceMax = options.json && !isFinite(message.curPriceMax) ? String(message.curPriceMax) : message.curPriceMax;
            if (message.strikePriceMin != null && message.hasOwnProperty("strikePriceMin"))
                object.strikePriceMin = options.json && !isFinite(message.strikePriceMin) ? String(message.strikePriceMin) : message.strikePriceMin;
            if (message.strikePriceMax != null && message.hasOwnProperty("strikePriceMax"))
                object.strikePriceMax = options.json && !isFinite(message.strikePriceMax) ? String(message.strikePriceMax) : message.strikePriceMax;
            if (message.streetMin != null && message.hasOwnProperty("streetMin"))
                object.streetMin = options.json && !isFinite(message.streetMin) ? String(message.streetMin) : message.streetMin;
            if (message.streetMax != null && message.hasOwnProperty("streetMax"))
                object.streetMax = options.json && !isFinite(message.streetMax) ? String(message.streetMax) : message.streetMax;
            if (message.conversionMin != null && message.hasOwnProperty("conversionMin"))
                object.conversionMin = options.json && !isFinite(message.conversionMin) ? String(message.conversionMin) : message.conversionMin;
            if (message.conversionMax != null && message.hasOwnProperty("conversionMax"))
                object.conversionMax = options.json && !isFinite(message.conversionMax) ? String(message.conversionMax) : message.conversionMax;
            if (message.volMin != null && message.hasOwnProperty("volMin"))
                if (typeof message.volMin === "number")
                    object.volMin = options.longs === String ? String(message.volMin) : message.volMin;
                else
                    object.volMin = options.longs === String ? $util.Long.prototype.toString.call(message.volMin) : options.longs === Number ? new $util.LongBits(message.volMin.low >>> 0, message.volMin.high >>> 0).toNumber(true) : message.volMin;
            if (message.volMax != null && message.hasOwnProperty("volMax"))
                if (typeof message.volMax === "number")
                    object.volMax = options.longs === String ? String(message.volMax) : message.volMax;
                else
                    object.volMax = options.longs === String ? $util.Long.prototype.toString.call(message.volMax) : options.longs === Number ? new $util.LongBits(message.volMax.low >>> 0, message.volMax.high >>> 0).toNumber(true) : message.volMax;
            if (message.premiumMin != null && message.hasOwnProperty("premiumMin"))
                object.premiumMin = options.json && !isFinite(message.premiumMin) ? String(message.premiumMin) : message.premiumMin;
            if (message.premiumMax != null && message.hasOwnProperty("premiumMax"))
                object.premiumMax = options.json && !isFinite(message.premiumMax) ? String(message.premiumMax) : message.premiumMax;
            if (message.leverageRatioMin != null && message.hasOwnProperty("leverageRatioMin"))
                object.leverageRatioMin = options.json && !isFinite(message.leverageRatioMin) ? String(message.leverageRatioMin) : message.leverageRatioMin;
            if (message.leverageRatioMax != null && message.hasOwnProperty("leverageRatioMax"))
                object.leverageRatioMax = options.json && !isFinite(message.leverageRatioMax) ? String(message.leverageRatioMax) : message.leverageRatioMax;
            if (message.deltaMin != null && message.hasOwnProperty("deltaMin"))
                object.deltaMin = options.json && !isFinite(message.deltaMin) ? String(message.deltaMin) : message.deltaMin;
            if (message.deltaMax != null && message.hasOwnProperty("deltaMax"))
                object.deltaMax = options.json && !isFinite(message.deltaMax) ? String(message.deltaMax) : message.deltaMax;
            if (message.impliedMin != null && message.hasOwnProperty("impliedMin"))
                object.impliedMin = options.json && !isFinite(message.impliedMin) ? String(message.impliedMin) : message.impliedMin;
            if (message.impliedMax != null && message.hasOwnProperty("impliedMax"))
                object.impliedMax = options.json && !isFinite(message.impliedMax) ? String(message.impliedMax) : message.impliedMax;
            if (message.recoveryPriceMin != null && message.hasOwnProperty("recoveryPriceMin"))
                object.recoveryPriceMin = options.json && !isFinite(message.recoveryPriceMin) ? String(message.recoveryPriceMin) : message.recoveryPriceMin;
            if (message.recoveryPriceMax != null && message.hasOwnProperty("recoveryPriceMax"))
                object.recoveryPriceMax = options.json && !isFinite(message.recoveryPriceMax) ? String(message.recoveryPriceMax) : message.recoveryPriceMax;
            if (message.priceRecoveryRatioMin != null && message.hasOwnProperty("priceRecoveryRatioMin"))
                object.priceRecoveryRatioMin = options.json && !isFinite(message.priceRecoveryRatioMin) ? String(message.priceRecoveryRatioMin) : message.priceRecoveryRatioMin;
            if (message.priceRecoveryRatioMax != null && message.hasOwnProperty("priceRecoveryRatioMax"))
                object.priceRecoveryRatioMax = options.json && !isFinite(message.priceRecoveryRatioMax) ? String(message.priceRecoveryRatioMax) : message.priceRecoveryRatioMax;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetWarrant.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetWarrant.WarrantData = (function() {

        /**
         * Properties of a WarrantData.
         * @memberof Qot_GetWarrant
         * @interface IWarrantData
         * @property {Qot_Common.ISecurity} stock WarrantData stock
         * @property {Qot_Common.ISecurity} owner WarrantData owner
         * @property {number} type WarrantData type
         * @property {number} issuer WarrantData issuer
         * @property {string} maturityTime WarrantData maturityTime
         * @property {number|null} [maturityTimestamp] WarrantData maturityTimestamp
         * @property {string} listTime WarrantData listTime
         * @property {number|null} [listTimestamp] WarrantData listTimestamp
         * @property {string} lastTradeTime WarrantData lastTradeTime
         * @property {number|null} [lastTradeTimestamp] WarrantData lastTradeTimestamp
         * @property {number|null} [recoveryPrice] WarrantData recoveryPrice
         * @property {number} conversionRatio WarrantData conversionRatio
         * @property {number} lotSize WarrantData lotSize
         * @property {number} strikePrice WarrantData strikePrice
         * @property {number} lastClosePrice WarrantData lastClosePrice
         * @property {string} name WarrantData name
         * @property {number} curPrice WarrantData curPrice
         * @property {number} priceChangeVal WarrantData priceChangeVal
         * @property {number} changeRate WarrantData changeRate
         * @property {number} status WarrantData status
         * @property {number} bidPrice WarrantData bidPrice
         * @property {number} askPrice WarrantData askPrice
         * @property {number|Long} bidVol WarrantData bidVol
         * @property {number|Long} askVol WarrantData askVol
         * @property {number|Long} volume WarrantData volume
         * @property {number} turnover WarrantData turnover
         * @property {number} score WarrantData score
         * @property {number} premium WarrantData premium
         * @property {number} breakEvenPoint WarrantData breakEvenPoint
         * @property {number} leverage WarrantData leverage
         * @property {number} ipop WarrantData ipop
         * @property {number|null} [priceRecoveryRatio] WarrantData priceRecoveryRatio
         * @property {number} conversionPrice WarrantData conversionPrice
         * @property {number} streetRate WarrantData streetRate
         * @property {number|Long} streetVol WarrantData streetVol
         * @property {number} amplitude WarrantData amplitude
         * @property {number|Long} issueSize WarrantData issueSize
         * @property {number} highPrice WarrantData highPrice
         * @property {number} lowPrice WarrantData lowPrice
         * @property {number|null} [impliedVolatility] WarrantData impliedVolatility
         * @property {number|null} [delta] WarrantData delta
         * @property {number} effectiveLeverage WarrantData effectiveLeverage
         * @property {number|null} [upperStrikePrice] WarrantData upperStrikePrice
         * @property {number|null} [lowerStrikePrice] WarrantData lowerStrikePrice
         * @property {number|null} [inLinePriceStatus] WarrantData inLinePriceStatus
         */

        /**
         * Constructs a new WarrantData.
         * @memberof Qot_GetWarrant
         * @classdesc Represents a WarrantData.
         * @implements IWarrantData
         * @constructor
         * @param {Qot_GetWarrant.IWarrantData=} [properties] Properties to set
         */
        function WarrantData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WarrantData stock.
         * @member {Qot_Common.ISecurity} stock
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.stock = null;

        /**
         * WarrantData owner.
         * @member {Qot_Common.ISecurity} owner
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.owner = null;

        /**
         * WarrantData type.
         * @member {number} type
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.type = 0;

        /**
         * WarrantData issuer.
         * @member {number} issuer
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.issuer = 0;

        /**
         * WarrantData maturityTime.
         * @member {string} maturityTime
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.maturityTime = "";

        /**
         * WarrantData maturityTimestamp.
         * @member {number} maturityTimestamp
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.maturityTimestamp = 0;

        /**
         * WarrantData listTime.
         * @member {string} listTime
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.listTime = "";

        /**
         * WarrantData listTimestamp.
         * @member {number} listTimestamp
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.listTimestamp = 0;

        /**
         * WarrantData lastTradeTime.
         * @member {string} lastTradeTime
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.lastTradeTime = "";

        /**
         * WarrantData lastTradeTimestamp.
         * @member {number} lastTradeTimestamp
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.lastTradeTimestamp = 0;

        /**
         * WarrantData recoveryPrice.
         * @member {number} recoveryPrice
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.recoveryPrice = 0;

        /**
         * WarrantData conversionRatio.
         * @member {number} conversionRatio
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.conversionRatio = 0;

        /**
         * WarrantData lotSize.
         * @member {number} lotSize
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.lotSize = 0;

        /**
         * WarrantData strikePrice.
         * @member {number} strikePrice
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.strikePrice = 0;

        /**
         * WarrantData lastClosePrice.
         * @member {number} lastClosePrice
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.lastClosePrice = 0;

        /**
         * WarrantData name.
         * @member {string} name
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.name = "";

        /**
         * WarrantData curPrice.
         * @member {number} curPrice
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.curPrice = 0;

        /**
         * WarrantData priceChangeVal.
         * @member {number} priceChangeVal
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.priceChangeVal = 0;

        /**
         * WarrantData changeRate.
         * @member {number} changeRate
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.changeRate = 0;

        /**
         * WarrantData status.
         * @member {number} status
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.status = 0;

        /**
         * WarrantData bidPrice.
         * @member {number} bidPrice
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.bidPrice = 0;

        /**
         * WarrantData askPrice.
         * @member {number} askPrice
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.askPrice = 0;

        /**
         * WarrantData bidVol.
         * @member {number|Long} bidVol
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.bidVol = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * WarrantData askVol.
         * @member {number|Long} askVol
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.askVol = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * WarrantData volume.
         * @member {number|Long} volume
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.volume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * WarrantData turnover.
         * @member {number} turnover
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.turnover = 0;

        /**
         * WarrantData score.
         * @member {number} score
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.score = 0;

        /**
         * WarrantData premium.
         * @member {number} premium
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.premium = 0;

        /**
         * WarrantData breakEvenPoint.
         * @member {number} breakEvenPoint
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.breakEvenPoint = 0;

        /**
         * WarrantData leverage.
         * @member {number} leverage
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.leverage = 0;

        /**
         * WarrantData ipop.
         * @member {number} ipop
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.ipop = 0;

        /**
         * WarrantData priceRecoveryRatio.
         * @member {number} priceRecoveryRatio
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.priceRecoveryRatio = 0;

        /**
         * WarrantData conversionPrice.
         * @member {number} conversionPrice
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.conversionPrice = 0;

        /**
         * WarrantData streetRate.
         * @member {number} streetRate
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.streetRate = 0;

        /**
         * WarrantData streetVol.
         * @member {number|Long} streetVol
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.streetVol = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * WarrantData amplitude.
         * @member {number} amplitude
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.amplitude = 0;

        /**
         * WarrantData issueSize.
         * @member {number|Long} issueSize
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.issueSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * WarrantData highPrice.
         * @member {number} highPrice
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.highPrice = 0;

        /**
         * WarrantData lowPrice.
         * @member {number} lowPrice
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.lowPrice = 0;

        /**
         * WarrantData impliedVolatility.
         * @member {number} impliedVolatility
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.impliedVolatility = 0;

        /**
         * WarrantData delta.
         * @member {number} delta
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.delta = 0;

        /**
         * WarrantData effectiveLeverage.
         * @member {number} effectiveLeverage
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.effectiveLeverage = 0;

        /**
         * WarrantData upperStrikePrice.
         * @member {number} upperStrikePrice
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.upperStrikePrice = 0;

        /**
         * WarrantData lowerStrikePrice.
         * @member {number} lowerStrikePrice
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.lowerStrikePrice = 0;

        /**
         * WarrantData inLinePriceStatus.
         * @member {number} inLinePriceStatus
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.inLinePriceStatus = 0;

        /**
         * Creates a new WarrantData instance using the specified properties.
         * @function create
         * @memberof Qot_GetWarrant.WarrantData
         * @static
         * @param {Qot_GetWarrant.IWarrantData=} [properties] Properties to set
         * @returns {Qot_GetWarrant.WarrantData} WarrantData instance
         */
        WarrantData.create = function create(properties) {
            return new WarrantData(properties);
        };

        /**
         * Encodes the specified WarrantData message. Does not implicitly {@link Qot_GetWarrant.WarrantData.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetWarrant.WarrantData
         * @static
         * @param {Qot_GetWarrant.IWarrantData} message WarrantData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarrantData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.stock, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            $root.Qot_Common.Security.encode(message.owner, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.issuer);
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.maturityTime);
            if (message.maturityTimestamp != null && message.hasOwnProperty("maturityTimestamp"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.maturityTimestamp);
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.listTime);
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.listTimestamp);
            writer.uint32(/* id 9, wireType 2 =*/74).string(message.lastTradeTime);
            if (message.lastTradeTimestamp != null && message.hasOwnProperty("lastTradeTimestamp"))
                writer.uint32(/* id 10, wireType 1 =*/81).double(message.lastTradeTimestamp);
            if (message.recoveryPrice != null && message.hasOwnProperty("recoveryPrice"))
                writer.uint32(/* id 11, wireType 1 =*/89).double(message.recoveryPrice);
            writer.uint32(/* id 12, wireType 1 =*/97).double(message.conversionRatio);
            writer.uint32(/* id 13, wireType 0 =*/104).int32(message.lotSize);
            writer.uint32(/* id 14, wireType 1 =*/113).double(message.strikePrice);
            writer.uint32(/* id 15, wireType 1 =*/121).double(message.lastClosePrice);
            writer.uint32(/* id 16, wireType 2 =*/130).string(message.name);
            writer.uint32(/* id 17, wireType 1 =*/137).double(message.curPrice);
            writer.uint32(/* id 18, wireType 1 =*/145).double(message.priceChangeVal);
            writer.uint32(/* id 19, wireType 1 =*/153).double(message.changeRate);
            writer.uint32(/* id 20, wireType 0 =*/160).int32(message.status);
            writer.uint32(/* id 21, wireType 1 =*/169).double(message.bidPrice);
            writer.uint32(/* id 22, wireType 1 =*/177).double(message.askPrice);
            writer.uint32(/* id 23, wireType 0 =*/184).int64(message.bidVol);
            writer.uint32(/* id 24, wireType 0 =*/192).int64(message.askVol);
            writer.uint32(/* id 25, wireType 0 =*/200).int64(message.volume);
            writer.uint32(/* id 26, wireType 1 =*/209).double(message.turnover);
            writer.uint32(/* id 27, wireType 1 =*/217).double(message.score);
            writer.uint32(/* id 28, wireType 1 =*/225).double(message.premium);
            writer.uint32(/* id 29, wireType 1 =*/233).double(message.breakEvenPoint);
            writer.uint32(/* id 30, wireType 1 =*/241).double(message.leverage);
            writer.uint32(/* id 31, wireType 1 =*/249).double(message.ipop);
            if (message.priceRecoveryRatio != null && message.hasOwnProperty("priceRecoveryRatio"))
                writer.uint32(/* id 32, wireType 1 =*/257).double(message.priceRecoveryRatio);
            writer.uint32(/* id 33, wireType 1 =*/265).double(message.conversionPrice);
            writer.uint32(/* id 34, wireType 1 =*/273).double(message.streetRate);
            writer.uint32(/* id 35, wireType 0 =*/280).int64(message.streetVol);
            writer.uint32(/* id 36, wireType 1 =*/289).double(message.amplitude);
            writer.uint32(/* id 37, wireType 0 =*/296).int64(message.issueSize);
            writer.uint32(/* id 39, wireType 1 =*/313).double(message.highPrice);
            writer.uint32(/* id 40, wireType 1 =*/321).double(message.lowPrice);
            if (message.impliedVolatility != null && message.hasOwnProperty("impliedVolatility"))
                writer.uint32(/* id 41, wireType 1 =*/329).double(message.impliedVolatility);
            if (message.delta != null && message.hasOwnProperty("delta"))
                writer.uint32(/* id 42, wireType 1 =*/337).double(message.delta);
            writer.uint32(/* id 43, wireType 1 =*/345).double(message.effectiveLeverage);
            if (message.upperStrikePrice != null && message.hasOwnProperty("upperStrikePrice"))
                writer.uint32(/* id 44, wireType 1 =*/353).double(message.upperStrikePrice);
            if (message.lowerStrikePrice != null && message.hasOwnProperty("lowerStrikePrice"))
                writer.uint32(/* id 45, wireType 1 =*/361).double(message.lowerStrikePrice);
            if (message.inLinePriceStatus != null && message.hasOwnProperty("inLinePriceStatus"))
                writer.uint32(/* id 46, wireType 0 =*/368).int32(message.inLinePriceStatus);
            return writer;
        };

        /**
         * Encodes the specified WarrantData message, length delimited. Does not implicitly {@link Qot_GetWarrant.WarrantData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetWarrant.WarrantData
         * @static
         * @param {Qot_GetWarrant.IWarrantData} message WarrantData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarrantData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WarrantData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetWarrant.WarrantData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetWarrant.WarrantData} WarrantData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarrantData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetWarrant.WarrantData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stock = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.owner = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.type = reader.int32();
                    break;
                case 4:
                    message.issuer = reader.int32();
                    break;
                case 5:
                    message.maturityTime = reader.string();
                    break;
                case 6:
                    message.maturityTimestamp = reader.double();
                    break;
                case 7:
                    message.listTime = reader.string();
                    break;
                case 8:
                    message.listTimestamp = reader.double();
                    break;
                case 9:
                    message.lastTradeTime = reader.string();
                    break;
                case 10:
                    message.lastTradeTimestamp = reader.double();
                    break;
                case 11:
                    message.recoveryPrice = reader.double();
                    break;
                case 12:
                    message.conversionRatio = reader.double();
                    break;
                case 13:
                    message.lotSize = reader.int32();
                    break;
                case 14:
                    message.strikePrice = reader.double();
                    break;
                case 15:
                    message.lastClosePrice = reader.double();
                    break;
                case 16:
                    message.name = reader.string();
                    break;
                case 17:
                    message.curPrice = reader.double();
                    break;
                case 18:
                    message.priceChangeVal = reader.double();
                    break;
                case 19:
                    message.changeRate = reader.double();
                    break;
                case 20:
                    message.status = reader.int32();
                    break;
                case 21:
                    message.bidPrice = reader.double();
                    break;
                case 22:
                    message.askPrice = reader.double();
                    break;
                case 23:
                    message.bidVol = reader.int64();
                    break;
                case 24:
                    message.askVol = reader.int64();
                    break;
                case 25:
                    message.volume = reader.int64();
                    break;
                case 26:
                    message.turnover = reader.double();
                    break;
                case 27:
                    message.score = reader.double();
                    break;
                case 28:
                    message.premium = reader.double();
                    break;
                case 29:
                    message.breakEvenPoint = reader.double();
                    break;
                case 30:
                    message.leverage = reader.double();
                    break;
                case 31:
                    message.ipop = reader.double();
                    break;
                case 32:
                    message.priceRecoveryRatio = reader.double();
                    break;
                case 33:
                    message.conversionPrice = reader.double();
                    break;
                case 34:
                    message.streetRate = reader.double();
                    break;
                case 35:
                    message.streetVol = reader.int64();
                    break;
                case 36:
                    message.amplitude = reader.double();
                    break;
                case 37:
                    message.issueSize = reader.int64();
                    break;
                case 39:
                    message.highPrice = reader.double();
                    break;
                case 40:
                    message.lowPrice = reader.double();
                    break;
                case 41:
                    message.impliedVolatility = reader.double();
                    break;
                case 42:
                    message.delta = reader.double();
                    break;
                case 43:
                    message.effectiveLeverage = reader.double();
                    break;
                case 44:
                    message.upperStrikePrice = reader.double();
                    break;
                case 45:
                    message.lowerStrikePrice = reader.double();
                    break;
                case 46:
                    message.inLinePriceStatus = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("stock"))
                throw $util.ProtocolError("missing required 'stock'", { instance: message });
            if (!message.hasOwnProperty("owner"))
                throw $util.ProtocolError("missing required 'owner'", { instance: message });
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("issuer"))
                throw $util.ProtocolError("missing required 'issuer'", { instance: message });
            if (!message.hasOwnProperty("maturityTime"))
                throw $util.ProtocolError("missing required 'maturityTime'", { instance: message });
            if (!message.hasOwnProperty("listTime"))
                throw $util.ProtocolError("missing required 'listTime'", { instance: message });
            if (!message.hasOwnProperty("lastTradeTime"))
                throw $util.ProtocolError("missing required 'lastTradeTime'", { instance: message });
            if (!message.hasOwnProperty("conversionRatio"))
                throw $util.ProtocolError("missing required 'conversionRatio'", { instance: message });
            if (!message.hasOwnProperty("lotSize"))
                throw $util.ProtocolError("missing required 'lotSize'", { instance: message });
            if (!message.hasOwnProperty("strikePrice"))
                throw $util.ProtocolError("missing required 'strikePrice'", { instance: message });
            if (!message.hasOwnProperty("lastClosePrice"))
                throw $util.ProtocolError("missing required 'lastClosePrice'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("curPrice"))
                throw $util.ProtocolError("missing required 'curPrice'", { instance: message });
            if (!message.hasOwnProperty("priceChangeVal"))
                throw $util.ProtocolError("missing required 'priceChangeVal'", { instance: message });
            if (!message.hasOwnProperty("changeRate"))
                throw $util.ProtocolError("missing required 'changeRate'", { instance: message });
            if (!message.hasOwnProperty("status"))
                throw $util.ProtocolError("missing required 'status'", { instance: message });
            if (!message.hasOwnProperty("bidPrice"))
                throw $util.ProtocolError("missing required 'bidPrice'", { instance: message });
            if (!message.hasOwnProperty("askPrice"))
                throw $util.ProtocolError("missing required 'askPrice'", { instance: message });
            if (!message.hasOwnProperty("bidVol"))
                throw $util.ProtocolError("missing required 'bidVol'", { instance: message });
            if (!message.hasOwnProperty("askVol"))
                throw $util.ProtocolError("missing required 'askVol'", { instance: message });
            if (!message.hasOwnProperty("volume"))
                throw $util.ProtocolError("missing required 'volume'", { instance: message });
            if (!message.hasOwnProperty("turnover"))
                throw $util.ProtocolError("missing required 'turnover'", { instance: message });
            if (!message.hasOwnProperty("score"))
                throw $util.ProtocolError("missing required 'score'", { instance: message });
            if (!message.hasOwnProperty("premium"))
                throw $util.ProtocolError("missing required 'premium'", { instance: message });
            if (!message.hasOwnProperty("breakEvenPoint"))
                throw $util.ProtocolError("missing required 'breakEvenPoint'", { instance: message });
            if (!message.hasOwnProperty("leverage"))
                throw $util.ProtocolError("missing required 'leverage'", { instance: message });
            if (!message.hasOwnProperty("ipop"))
                throw $util.ProtocolError("missing required 'ipop'", { instance: message });
            if (!message.hasOwnProperty("conversionPrice"))
                throw $util.ProtocolError("missing required 'conversionPrice'", { instance: message });
            if (!message.hasOwnProperty("streetRate"))
                throw $util.ProtocolError("missing required 'streetRate'", { instance: message });
            if (!message.hasOwnProperty("streetVol"))
                throw $util.ProtocolError("missing required 'streetVol'", { instance: message });
            if (!message.hasOwnProperty("amplitude"))
                throw $util.ProtocolError("missing required 'amplitude'", { instance: message });
            if (!message.hasOwnProperty("issueSize"))
                throw $util.ProtocolError("missing required 'issueSize'", { instance: message });
            if (!message.hasOwnProperty("highPrice"))
                throw $util.ProtocolError("missing required 'highPrice'", { instance: message });
            if (!message.hasOwnProperty("lowPrice"))
                throw $util.ProtocolError("missing required 'lowPrice'", { instance: message });
            if (!message.hasOwnProperty("effectiveLeverage"))
                throw $util.ProtocolError("missing required 'effectiveLeverage'", { instance: message });
            return message;
        };

        /**
         * Decodes a WarrantData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetWarrant.WarrantData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetWarrant.WarrantData} WarrantData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarrantData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WarrantData message.
         * @function verify
         * @memberof Qot_GetWarrant.WarrantData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WarrantData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.stock);
                if (error)
                    return "stock." + error;
            }
            {
                var error = $root.Qot_Common.Security.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            if (!$util.isInteger(message.issuer))
                return "issuer: integer expected";
            if (!$util.isString(message.maturityTime))
                return "maturityTime: string expected";
            if (message.maturityTimestamp != null && message.hasOwnProperty("maturityTimestamp"))
                if (typeof message.maturityTimestamp !== "number")
                    return "maturityTimestamp: number expected";
            if (!$util.isString(message.listTime))
                return "listTime: string expected";
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                if (typeof message.listTimestamp !== "number")
                    return "listTimestamp: number expected";
            if (!$util.isString(message.lastTradeTime))
                return "lastTradeTime: string expected";
            if (message.lastTradeTimestamp != null && message.hasOwnProperty("lastTradeTimestamp"))
                if (typeof message.lastTradeTimestamp !== "number")
                    return "lastTradeTimestamp: number expected";
            if (message.recoveryPrice != null && message.hasOwnProperty("recoveryPrice"))
                if (typeof message.recoveryPrice !== "number")
                    return "recoveryPrice: number expected";
            if (typeof message.conversionRatio !== "number")
                return "conversionRatio: number expected";
            if (!$util.isInteger(message.lotSize))
                return "lotSize: integer expected";
            if (typeof message.strikePrice !== "number")
                return "strikePrice: number expected";
            if (typeof message.lastClosePrice !== "number")
                return "lastClosePrice: number expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (typeof message.curPrice !== "number")
                return "curPrice: number expected";
            if (typeof message.priceChangeVal !== "number")
                return "priceChangeVal: number expected";
            if (typeof message.changeRate !== "number")
                return "changeRate: number expected";
            if (!$util.isInteger(message.status))
                return "status: integer expected";
            if (typeof message.bidPrice !== "number")
                return "bidPrice: number expected";
            if (typeof message.askPrice !== "number")
                return "askPrice: number expected";
            if (!$util.isInteger(message.bidVol) && !(message.bidVol && $util.isInteger(message.bidVol.low) && $util.isInteger(message.bidVol.high)))
                return "bidVol: integer|Long expected";
            if (!$util.isInteger(message.askVol) && !(message.askVol && $util.isInteger(message.askVol.low) && $util.isInteger(message.askVol.high)))
                return "askVol: integer|Long expected";
            if (!$util.isInteger(message.volume) && !(message.volume && $util.isInteger(message.volume.low) && $util.isInteger(message.volume.high)))
                return "volume: integer|Long expected";
            if (typeof message.turnover !== "number")
                return "turnover: number expected";
            if (typeof message.score !== "number")
                return "score: number expected";
            if (typeof message.premium !== "number")
                return "premium: number expected";
            if (typeof message.breakEvenPoint !== "number")
                return "breakEvenPoint: number expected";
            if (typeof message.leverage !== "number")
                return "leverage: number expected";
            if (typeof message.ipop !== "number")
                return "ipop: number expected";
            if (message.priceRecoveryRatio != null && message.hasOwnProperty("priceRecoveryRatio"))
                if (typeof message.priceRecoveryRatio !== "number")
                    return "priceRecoveryRatio: number expected";
            if (typeof message.conversionPrice !== "number")
                return "conversionPrice: number expected";
            if (typeof message.streetRate !== "number")
                return "streetRate: number expected";
            if (!$util.isInteger(message.streetVol) && !(message.streetVol && $util.isInteger(message.streetVol.low) && $util.isInteger(message.streetVol.high)))
                return "streetVol: integer|Long expected";
            if (typeof message.amplitude !== "number")
                return "amplitude: number expected";
            if (!$util.isInteger(message.issueSize) && !(message.issueSize && $util.isInteger(message.issueSize.low) && $util.isInteger(message.issueSize.high)))
                return "issueSize: integer|Long expected";
            if (typeof message.highPrice !== "number")
                return "highPrice: number expected";
            if (typeof message.lowPrice !== "number")
                return "lowPrice: number expected";
            if (message.impliedVolatility != null && message.hasOwnProperty("impliedVolatility"))
                if (typeof message.impliedVolatility !== "number")
                    return "impliedVolatility: number expected";
            if (message.delta != null && message.hasOwnProperty("delta"))
                if (typeof message.delta !== "number")
                    return "delta: number expected";
            if (typeof message.effectiveLeverage !== "number")
                return "effectiveLeverage: number expected";
            if (message.upperStrikePrice != null && message.hasOwnProperty("upperStrikePrice"))
                if (typeof message.upperStrikePrice !== "number")
                    return "upperStrikePrice: number expected";
            if (message.lowerStrikePrice != null && message.hasOwnProperty("lowerStrikePrice"))
                if (typeof message.lowerStrikePrice !== "number")
                    return "lowerStrikePrice: number expected";
            if (message.inLinePriceStatus != null && message.hasOwnProperty("inLinePriceStatus"))
                if (!$util.isInteger(message.inLinePriceStatus))
                    return "inLinePriceStatus: integer expected";
            return null;
        };

        /**
         * Creates a WarrantData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetWarrant.WarrantData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetWarrant.WarrantData} WarrantData
         */
        WarrantData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetWarrant.WarrantData)
                return object;
            var message = new $root.Qot_GetWarrant.WarrantData();
            if (object.stock != null) {
                if (typeof object.stock !== "object")
                    throw TypeError(".Qot_GetWarrant.WarrantData.stock: object expected");
                message.stock = $root.Qot_Common.Security.fromObject(object.stock);
            }
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".Qot_GetWarrant.WarrantData.owner: object expected");
                message.owner = $root.Qot_Common.Security.fromObject(object.owner);
            }
            if (object.type != null)
                message.type = object.type | 0;
            if (object.issuer != null)
                message.issuer = object.issuer | 0;
            if (object.maturityTime != null)
                message.maturityTime = String(object.maturityTime);
            if (object.maturityTimestamp != null)
                message.maturityTimestamp = Number(object.maturityTimestamp);
            if (object.listTime != null)
                message.listTime = String(object.listTime);
            if (object.listTimestamp != null)
                message.listTimestamp = Number(object.listTimestamp);
            if (object.lastTradeTime != null)
                message.lastTradeTime = String(object.lastTradeTime);
            if (object.lastTradeTimestamp != null)
                message.lastTradeTimestamp = Number(object.lastTradeTimestamp);
            if (object.recoveryPrice != null)
                message.recoveryPrice = Number(object.recoveryPrice);
            if (object.conversionRatio != null)
                message.conversionRatio = Number(object.conversionRatio);
            if (object.lotSize != null)
                message.lotSize = object.lotSize | 0;
            if (object.strikePrice != null)
                message.strikePrice = Number(object.strikePrice);
            if (object.lastClosePrice != null)
                message.lastClosePrice = Number(object.lastClosePrice);
            if (object.name != null)
                message.name = String(object.name);
            if (object.curPrice != null)
                message.curPrice = Number(object.curPrice);
            if (object.priceChangeVal != null)
                message.priceChangeVal = Number(object.priceChangeVal);
            if (object.changeRate != null)
                message.changeRate = Number(object.changeRate);
            if (object.status != null)
                message.status = object.status | 0;
            if (object.bidPrice != null)
                message.bidPrice = Number(object.bidPrice);
            if (object.askPrice != null)
                message.askPrice = Number(object.askPrice);
            if (object.bidVol != null)
                if ($util.Long)
                    (message.bidVol = $util.Long.fromValue(object.bidVol)).unsigned = false;
                else if (typeof object.bidVol === "string")
                    message.bidVol = parseInt(object.bidVol, 10);
                else if (typeof object.bidVol === "number")
                    message.bidVol = object.bidVol;
                else if (typeof object.bidVol === "object")
                    message.bidVol = new $util.LongBits(object.bidVol.low >>> 0, object.bidVol.high >>> 0).toNumber();
            if (object.askVol != null)
                if ($util.Long)
                    (message.askVol = $util.Long.fromValue(object.askVol)).unsigned = false;
                else if (typeof object.askVol === "string")
                    message.askVol = parseInt(object.askVol, 10);
                else if (typeof object.askVol === "number")
                    message.askVol = object.askVol;
                else if (typeof object.askVol === "object")
                    message.askVol = new $util.LongBits(object.askVol.low >>> 0, object.askVol.high >>> 0).toNumber();
            if (object.volume != null)
                if ($util.Long)
                    (message.volume = $util.Long.fromValue(object.volume)).unsigned = false;
                else if (typeof object.volume === "string")
                    message.volume = parseInt(object.volume, 10);
                else if (typeof object.volume === "number")
                    message.volume = object.volume;
                else if (typeof object.volume === "object")
                    message.volume = new $util.LongBits(object.volume.low >>> 0, object.volume.high >>> 0).toNumber();
            if (object.turnover != null)
                message.turnover = Number(object.turnover);
            if (object.score != null)
                message.score = Number(object.score);
            if (object.premium != null)
                message.premium = Number(object.premium);
            if (object.breakEvenPoint != null)
                message.breakEvenPoint = Number(object.breakEvenPoint);
            if (object.leverage != null)
                message.leverage = Number(object.leverage);
            if (object.ipop != null)
                message.ipop = Number(object.ipop);
            if (object.priceRecoveryRatio != null)
                message.priceRecoveryRatio = Number(object.priceRecoveryRatio);
            if (object.conversionPrice != null)
                message.conversionPrice = Number(object.conversionPrice);
            if (object.streetRate != null)
                message.streetRate = Number(object.streetRate);
            if (object.streetVol != null)
                if ($util.Long)
                    (message.streetVol = $util.Long.fromValue(object.streetVol)).unsigned = false;
                else if (typeof object.streetVol === "string")
                    message.streetVol = parseInt(object.streetVol, 10);
                else if (typeof object.streetVol === "number")
                    message.streetVol = object.streetVol;
                else if (typeof object.streetVol === "object")
                    message.streetVol = new $util.LongBits(object.streetVol.low >>> 0, object.streetVol.high >>> 0).toNumber();
            if (object.amplitude != null)
                message.amplitude = Number(object.amplitude);
            if (object.issueSize != null)
                if ($util.Long)
                    (message.issueSize = $util.Long.fromValue(object.issueSize)).unsigned = false;
                else if (typeof object.issueSize === "string")
                    message.issueSize = parseInt(object.issueSize, 10);
                else if (typeof object.issueSize === "number")
                    message.issueSize = object.issueSize;
                else if (typeof object.issueSize === "object")
                    message.issueSize = new $util.LongBits(object.issueSize.low >>> 0, object.issueSize.high >>> 0).toNumber();
            if (object.highPrice != null)
                message.highPrice = Number(object.highPrice);
            if (object.lowPrice != null)
                message.lowPrice = Number(object.lowPrice);
            if (object.impliedVolatility != null)
                message.impliedVolatility = Number(object.impliedVolatility);
            if (object.delta != null)
                message.delta = Number(object.delta);
            if (object.effectiveLeverage != null)
                message.effectiveLeverage = Number(object.effectiveLeverage);
            if (object.upperStrikePrice != null)
                message.upperStrikePrice = Number(object.upperStrikePrice);
            if (object.lowerStrikePrice != null)
                message.lowerStrikePrice = Number(object.lowerStrikePrice);
            if (object.inLinePriceStatus != null)
                message.inLinePriceStatus = object.inLinePriceStatus | 0;
            return message;
        };

        /**
         * Creates a plain object from a WarrantData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetWarrant.WarrantData
         * @static
         * @param {Qot_GetWarrant.WarrantData} message WarrantData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WarrantData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.stock = null;
                object.owner = null;
                object.type = 0;
                object.issuer = 0;
                object.maturityTime = "";
                object.maturityTimestamp = 0;
                object.listTime = "";
                object.listTimestamp = 0;
                object.lastTradeTime = "";
                object.lastTradeTimestamp = 0;
                object.recoveryPrice = 0;
                object.conversionRatio = 0;
                object.lotSize = 0;
                object.strikePrice = 0;
                object.lastClosePrice = 0;
                object.name = "";
                object.curPrice = 0;
                object.priceChangeVal = 0;
                object.changeRate = 0;
                object.status = 0;
                object.bidPrice = 0;
                object.askPrice = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.bidVol = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bidVol = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.askVol = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.askVol = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.volume = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.volume = options.longs === String ? "0" : 0;
                object.turnover = 0;
                object.score = 0;
                object.premium = 0;
                object.breakEvenPoint = 0;
                object.leverage = 0;
                object.ipop = 0;
                object.priceRecoveryRatio = 0;
                object.conversionPrice = 0;
                object.streetRate = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.streetVol = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.streetVol = options.longs === String ? "0" : 0;
                object.amplitude = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.issueSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.issueSize = options.longs === String ? "0" : 0;
                object.highPrice = 0;
                object.lowPrice = 0;
                object.impliedVolatility = 0;
                object.delta = 0;
                object.effectiveLeverage = 0;
                object.upperStrikePrice = 0;
                object.lowerStrikePrice = 0;
                object.inLinePriceStatus = 0;
            }
            if (message.stock != null && message.hasOwnProperty("stock"))
                object.stock = $root.Qot_Common.Security.toObject(message.stock, options);
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.Qot_Common.Security.toObject(message.owner, options);
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.issuer != null && message.hasOwnProperty("issuer"))
                object.issuer = message.issuer;
            if (message.maturityTime != null && message.hasOwnProperty("maturityTime"))
                object.maturityTime = message.maturityTime;
            if (message.maturityTimestamp != null && message.hasOwnProperty("maturityTimestamp"))
                object.maturityTimestamp = options.json && !isFinite(message.maturityTimestamp) ? String(message.maturityTimestamp) : message.maturityTimestamp;
            if (message.listTime != null && message.hasOwnProperty("listTime"))
                object.listTime = message.listTime;
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                object.listTimestamp = options.json && !isFinite(message.listTimestamp) ? String(message.listTimestamp) : message.listTimestamp;
            if (message.lastTradeTime != null && message.hasOwnProperty("lastTradeTime"))
                object.lastTradeTime = message.lastTradeTime;
            if (message.lastTradeTimestamp != null && message.hasOwnProperty("lastTradeTimestamp"))
                object.lastTradeTimestamp = options.json && !isFinite(message.lastTradeTimestamp) ? String(message.lastTradeTimestamp) : message.lastTradeTimestamp;
            if (message.recoveryPrice != null && message.hasOwnProperty("recoveryPrice"))
                object.recoveryPrice = options.json && !isFinite(message.recoveryPrice) ? String(message.recoveryPrice) : message.recoveryPrice;
            if (message.conversionRatio != null && message.hasOwnProperty("conversionRatio"))
                object.conversionRatio = options.json && !isFinite(message.conversionRatio) ? String(message.conversionRatio) : message.conversionRatio;
            if (message.lotSize != null && message.hasOwnProperty("lotSize"))
                object.lotSize = message.lotSize;
            if (message.strikePrice != null && message.hasOwnProperty("strikePrice"))
                object.strikePrice = options.json && !isFinite(message.strikePrice) ? String(message.strikePrice) : message.strikePrice;
            if (message.lastClosePrice != null && message.hasOwnProperty("lastClosePrice"))
                object.lastClosePrice = options.json && !isFinite(message.lastClosePrice) ? String(message.lastClosePrice) : message.lastClosePrice;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.curPrice != null && message.hasOwnProperty("curPrice"))
                object.curPrice = options.json && !isFinite(message.curPrice) ? String(message.curPrice) : message.curPrice;
            if (message.priceChangeVal != null && message.hasOwnProperty("priceChangeVal"))
                object.priceChangeVal = options.json && !isFinite(message.priceChangeVal) ? String(message.priceChangeVal) : message.priceChangeVal;
            if (message.changeRate != null && message.hasOwnProperty("changeRate"))
                object.changeRate = options.json && !isFinite(message.changeRate) ? String(message.changeRate) : message.changeRate;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.bidPrice != null && message.hasOwnProperty("bidPrice"))
                object.bidPrice = options.json && !isFinite(message.bidPrice) ? String(message.bidPrice) : message.bidPrice;
            if (message.askPrice != null && message.hasOwnProperty("askPrice"))
                object.askPrice = options.json && !isFinite(message.askPrice) ? String(message.askPrice) : message.askPrice;
            if (message.bidVol != null && message.hasOwnProperty("bidVol"))
                if (typeof message.bidVol === "number")
                    object.bidVol = options.longs === String ? String(message.bidVol) : message.bidVol;
                else
                    object.bidVol = options.longs === String ? $util.Long.prototype.toString.call(message.bidVol) : options.longs === Number ? new $util.LongBits(message.bidVol.low >>> 0, message.bidVol.high >>> 0).toNumber() : message.bidVol;
            if (message.askVol != null && message.hasOwnProperty("askVol"))
                if (typeof message.askVol === "number")
                    object.askVol = options.longs === String ? String(message.askVol) : message.askVol;
                else
                    object.askVol = options.longs === String ? $util.Long.prototype.toString.call(message.askVol) : options.longs === Number ? new $util.LongBits(message.askVol.low >>> 0, message.askVol.high >>> 0).toNumber() : message.askVol;
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (typeof message.volume === "number")
                    object.volume = options.longs === String ? String(message.volume) : message.volume;
                else
                    object.volume = options.longs === String ? $util.Long.prototype.toString.call(message.volume) : options.longs === Number ? new $util.LongBits(message.volume.low >>> 0, message.volume.high >>> 0).toNumber() : message.volume;
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                object.turnover = options.json && !isFinite(message.turnover) ? String(message.turnover) : message.turnover;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = options.json && !isFinite(message.score) ? String(message.score) : message.score;
            if (message.premium != null && message.hasOwnProperty("premium"))
                object.premium = options.json && !isFinite(message.premium) ? String(message.premium) : message.premium;
            if (message.breakEvenPoint != null && message.hasOwnProperty("breakEvenPoint"))
                object.breakEvenPoint = options.json && !isFinite(message.breakEvenPoint) ? String(message.breakEvenPoint) : message.breakEvenPoint;
            if (message.leverage != null && message.hasOwnProperty("leverage"))
                object.leverage = options.json && !isFinite(message.leverage) ? String(message.leverage) : message.leverage;
            if (message.ipop != null && message.hasOwnProperty("ipop"))
                object.ipop = options.json && !isFinite(message.ipop) ? String(message.ipop) : message.ipop;
            if (message.priceRecoveryRatio != null && message.hasOwnProperty("priceRecoveryRatio"))
                object.priceRecoveryRatio = options.json && !isFinite(message.priceRecoveryRatio) ? String(message.priceRecoveryRatio) : message.priceRecoveryRatio;
            if (message.conversionPrice != null && message.hasOwnProperty("conversionPrice"))
                object.conversionPrice = options.json && !isFinite(message.conversionPrice) ? String(message.conversionPrice) : message.conversionPrice;
            if (message.streetRate != null && message.hasOwnProperty("streetRate"))
                object.streetRate = options.json && !isFinite(message.streetRate) ? String(message.streetRate) : message.streetRate;
            if (message.streetVol != null && message.hasOwnProperty("streetVol"))
                if (typeof message.streetVol === "number")
                    object.streetVol = options.longs === String ? String(message.streetVol) : message.streetVol;
                else
                    object.streetVol = options.longs === String ? $util.Long.prototype.toString.call(message.streetVol) : options.longs === Number ? new $util.LongBits(message.streetVol.low >>> 0, message.streetVol.high >>> 0).toNumber() : message.streetVol;
            if (message.amplitude != null && message.hasOwnProperty("amplitude"))
                object.amplitude = options.json && !isFinite(message.amplitude) ? String(message.amplitude) : message.amplitude;
            if (message.issueSize != null && message.hasOwnProperty("issueSize"))
                if (typeof message.issueSize === "number")
                    object.issueSize = options.longs === String ? String(message.issueSize) : message.issueSize;
                else
                    object.issueSize = options.longs === String ? $util.Long.prototype.toString.call(message.issueSize) : options.longs === Number ? new $util.LongBits(message.issueSize.low >>> 0, message.issueSize.high >>> 0).toNumber() : message.issueSize;
            if (message.highPrice != null && message.hasOwnProperty("highPrice"))
                object.highPrice = options.json && !isFinite(message.highPrice) ? String(message.highPrice) : message.highPrice;
            if (message.lowPrice != null && message.hasOwnProperty("lowPrice"))
                object.lowPrice = options.json && !isFinite(message.lowPrice) ? String(message.lowPrice) : message.lowPrice;
            if (message.impliedVolatility != null && message.hasOwnProperty("impliedVolatility"))
                object.impliedVolatility = options.json && !isFinite(message.impliedVolatility) ? String(message.impliedVolatility) : message.impliedVolatility;
            if (message.delta != null && message.hasOwnProperty("delta"))
                object.delta = options.json && !isFinite(message.delta) ? String(message.delta) : message.delta;
            if (message.effectiveLeverage != null && message.hasOwnProperty("effectiveLeverage"))
                object.effectiveLeverage = options.json && !isFinite(message.effectiveLeverage) ? String(message.effectiveLeverage) : message.effectiveLeverage;
            if (message.upperStrikePrice != null && message.hasOwnProperty("upperStrikePrice"))
                object.upperStrikePrice = options.json && !isFinite(message.upperStrikePrice) ? String(message.upperStrikePrice) : message.upperStrikePrice;
            if (message.lowerStrikePrice != null && message.hasOwnProperty("lowerStrikePrice"))
                object.lowerStrikePrice = options.json && !isFinite(message.lowerStrikePrice) ? String(message.lowerStrikePrice) : message.lowerStrikePrice;
            if (message.inLinePriceStatus != null && message.hasOwnProperty("inLinePriceStatus"))
                object.inLinePriceStatus = message.inLinePriceStatus;
            return object;
        };

        /**
         * Converts this WarrantData to JSON.
         * @function toJSON
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WarrantData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WarrantData;
    })();

    Qot_GetWarrant.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetWarrant
         * @interface IS2C
         * @property {boolean} lastPage S2C lastPage
         * @property {number} allCount S2C allCount
         * @property {Array.<Qot_GetWarrant.IWarrantData>|null} [warrantDataList] S2C warrantDataList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetWarrant
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetWarrant.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.warrantDataList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C lastPage.
         * @member {boolean} lastPage
         * @memberof Qot_GetWarrant.S2C
         * @instance
         */
        S2C.prototype.lastPage = false;

        /**
         * S2C allCount.
         * @member {number} allCount
         * @memberof Qot_GetWarrant.S2C
         * @instance
         */
        S2C.prototype.allCount = 0;

        /**
         * S2C warrantDataList.
         * @member {Array.<Qot_GetWarrant.IWarrantData>} warrantDataList
         * @memberof Qot_GetWarrant.S2C
         * @instance
         */
        S2C.prototype.warrantDataList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetWarrant.S2C
         * @static
         * @param {Qot_GetWarrant.IS2C=} [properties] Properties to set
         * @returns {Qot_GetWarrant.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetWarrant.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetWarrant.S2C
         * @static
         * @param {Qot_GetWarrant.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.lastPage);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.allCount);
            if (message.warrantDataList != null && message.warrantDataList.length)
                for (var i = 0; i < message.warrantDataList.length; ++i)
                    $root.Qot_GetWarrant.WarrantData.encode(message.warrantDataList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetWarrant.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetWarrant.S2C
         * @static
         * @param {Qot_GetWarrant.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetWarrant.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetWarrant.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetWarrant.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lastPage = reader.bool();
                    break;
                case 2:
                    message.allCount = reader.int32();
                    break;
                case 3:
                    if (!(message.warrantDataList && message.warrantDataList.length))
                        message.warrantDataList = [];
                    message.warrantDataList.push($root.Qot_GetWarrant.WarrantData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("lastPage"))
                throw $util.ProtocolError("missing required 'lastPage'", { instance: message });
            if (!message.hasOwnProperty("allCount"))
                throw $util.ProtocolError("missing required 'allCount'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetWarrant.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetWarrant.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetWarrant.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.lastPage !== "boolean")
                return "lastPage: boolean expected";
            if (!$util.isInteger(message.allCount))
                return "allCount: integer expected";
            if (message.warrantDataList != null && message.hasOwnProperty("warrantDataList")) {
                if (!Array.isArray(message.warrantDataList))
                    return "warrantDataList: array expected";
                for (var i = 0; i < message.warrantDataList.length; ++i) {
                    var error = $root.Qot_GetWarrant.WarrantData.verify(message.warrantDataList[i]);
                    if (error)
                        return "warrantDataList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetWarrant.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetWarrant.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetWarrant.S2C)
                return object;
            var message = new $root.Qot_GetWarrant.S2C();
            if (object.lastPage != null)
                message.lastPage = Boolean(object.lastPage);
            if (object.allCount != null)
                message.allCount = object.allCount | 0;
            if (object.warrantDataList) {
                if (!Array.isArray(object.warrantDataList))
                    throw TypeError(".Qot_GetWarrant.S2C.warrantDataList: array expected");
                message.warrantDataList = [];
                for (var i = 0; i < object.warrantDataList.length; ++i) {
                    if (typeof object.warrantDataList[i] !== "object")
                        throw TypeError(".Qot_GetWarrant.S2C.warrantDataList: object expected");
                    message.warrantDataList[i] = $root.Qot_GetWarrant.WarrantData.fromObject(object.warrantDataList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetWarrant.S2C
         * @static
         * @param {Qot_GetWarrant.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.warrantDataList = [];
            if (options.defaults) {
                object.lastPage = false;
                object.allCount = 0;
            }
            if (message.lastPage != null && message.hasOwnProperty("lastPage"))
                object.lastPage = message.lastPage;
            if (message.allCount != null && message.hasOwnProperty("allCount"))
                object.allCount = message.allCount;
            if (message.warrantDataList && message.warrantDataList.length) {
                object.warrantDataList = [];
                for (var j = 0; j < message.warrantDataList.length; ++j)
                    object.warrantDataList[j] = $root.Qot_GetWarrant.WarrantData.toObject(message.warrantDataList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetWarrant.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetWarrant.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetWarrant
         * @interface IRequest
         * @property {Qot_GetWarrant.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetWarrant
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetWarrant.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetWarrant.IC2S} c2s
         * @memberof Qot_GetWarrant.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetWarrant.Request
         * @static
         * @param {Qot_GetWarrant.IRequest=} [properties] Properties to set
         * @returns {Qot_GetWarrant.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetWarrant.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetWarrant.Request
         * @static
         * @param {Qot_GetWarrant.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetWarrant.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetWarrant.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetWarrant.Request
         * @static
         * @param {Qot_GetWarrant.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetWarrant.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetWarrant.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetWarrant.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetWarrant.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetWarrant.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetWarrant.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetWarrant.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetWarrant.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetWarrant.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetWarrant.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetWarrant.Request)
                return object;
            var message = new $root.Qot_GetWarrant.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetWarrant.Request.c2s: object expected");
                message.c2s = $root.Qot_GetWarrant.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetWarrant.Request
         * @static
         * @param {Qot_GetWarrant.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetWarrant.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetWarrant.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetWarrant.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetWarrant
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetWarrant.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetWarrant
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetWarrant.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetWarrant.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetWarrant.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetWarrant.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetWarrant.IS2C|null|undefined} s2c
         * @memberof Qot_GetWarrant.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetWarrant.Response
         * @static
         * @param {Qot_GetWarrant.IResponse=} [properties] Properties to set
         * @returns {Qot_GetWarrant.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetWarrant.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetWarrant.Response
         * @static
         * @param {Qot_GetWarrant.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetWarrant.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetWarrant.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetWarrant.Response
         * @static
         * @param {Qot_GetWarrant.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetWarrant.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetWarrant.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetWarrant.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetWarrant.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetWarrant.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetWarrant.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetWarrant.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetWarrant.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetWarrant.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetWarrant.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetWarrant.Response)
                return object;
            var message = new $root.Qot_GetWarrant.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetWarrant.Response.s2c: object expected");
                message.s2c = $root.Qot_GetWarrant.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetWarrant.Response
         * @static
         * @param {Qot_GetWarrant.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetWarrant.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetWarrant.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetWarrant;
})();

$root.Qot_ModifyUserSecurity = (function() {

    /**
     * Namespace Qot_ModifyUserSecurity.
     * @exports Qot_ModifyUserSecurity
     * @namespace
     */
    var Qot_ModifyUserSecurity = {};

    /**
     * ModifyUserSecurityOp enum.
     * @name Qot_ModifyUserSecurity.ModifyUserSecurityOp
     * @enum {string}
     * @property {number} ModifyUserSecurityOp_Unknown=0 ModifyUserSecurityOp_Unknown value
     * @property {number} ModifyUserSecurityOp_Add=1 ModifyUserSecurityOp_Add value
     * @property {number} ModifyUserSecurityOp_Del=2 ModifyUserSecurityOp_Del value
     * @property {number} ModifyUserSecurityOp_MoveOut=3 ModifyUserSecurityOp_MoveOut value
     */
    Qot_ModifyUserSecurity.ModifyUserSecurityOp = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ModifyUserSecurityOp_Unknown"] = 0;
        values[valuesById[1] = "ModifyUserSecurityOp_Add"] = 1;
        values[valuesById[2] = "ModifyUserSecurityOp_Del"] = 2;
        values[valuesById[3] = "ModifyUserSecurityOp_MoveOut"] = 3;
        return values;
    })();

    Qot_ModifyUserSecurity.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_ModifyUserSecurity
         * @interface IC2S
         * @property {string} groupName C2S groupName
         * @property {number} op C2S op
         * @property {Array.<Qot_Common.ISecurity>|null} [securityList] C2S securityList
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_ModifyUserSecurity
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_ModifyUserSecurity.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.securityList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S groupName.
         * @member {string} groupName
         * @memberof Qot_ModifyUserSecurity.C2S
         * @instance
         */
        C2S.prototype.groupName = "";

        /**
         * C2S op.
         * @member {number} op
         * @memberof Qot_ModifyUserSecurity.C2S
         * @instance
         */
        C2S.prototype.op = 0;

        /**
         * C2S securityList.
         * @member {Array.<Qot_Common.ISecurity>} securityList
         * @memberof Qot_ModifyUserSecurity.C2S
         * @instance
         */
        C2S.prototype.securityList = $util.emptyArray;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_ModifyUserSecurity.C2S
         * @static
         * @param {Qot_ModifyUserSecurity.IC2S=} [properties] Properties to set
         * @returns {Qot_ModifyUserSecurity.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_ModifyUserSecurity.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_ModifyUserSecurity.C2S
         * @static
         * @param {Qot_ModifyUserSecurity.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupName);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.op);
            if (message.securityList != null && message.securityList.length)
                for (var i = 0; i < message.securityList.length; ++i)
                    $root.Qot_Common.Security.encode(message.securityList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_ModifyUserSecurity.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_ModifyUserSecurity.C2S
         * @static
         * @param {Qot_ModifyUserSecurity.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_ModifyUserSecurity.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_ModifyUserSecurity.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_ModifyUserSecurity.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.groupName = reader.string();
                    break;
                case 2:
                    message.op = reader.int32();
                    break;
                case 3:
                    if (!(message.securityList && message.securityList.length))
                        message.securityList = [];
                    message.securityList.push($root.Qot_Common.Security.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("groupName"))
                throw $util.ProtocolError("missing required 'groupName'", { instance: message });
            if (!message.hasOwnProperty("op"))
                throw $util.ProtocolError("missing required 'op'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_ModifyUserSecurity.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_ModifyUserSecurity.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_ModifyUserSecurity.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.groupName))
                return "groupName: string expected";
            if (!$util.isInteger(message.op))
                return "op: integer expected";
            if (message.securityList != null && message.hasOwnProperty("securityList")) {
                if (!Array.isArray(message.securityList))
                    return "securityList: array expected";
                for (var i = 0; i < message.securityList.length; ++i) {
                    var error = $root.Qot_Common.Security.verify(message.securityList[i]);
                    if (error)
                        return "securityList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_ModifyUserSecurity.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_ModifyUserSecurity.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_ModifyUserSecurity.C2S)
                return object;
            var message = new $root.Qot_ModifyUserSecurity.C2S();
            if (object.groupName != null)
                message.groupName = String(object.groupName);
            if (object.op != null)
                message.op = object.op | 0;
            if (object.securityList) {
                if (!Array.isArray(object.securityList))
                    throw TypeError(".Qot_ModifyUserSecurity.C2S.securityList: array expected");
                message.securityList = [];
                for (var i = 0; i < object.securityList.length; ++i) {
                    if (typeof object.securityList[i] !== "object")
                        throw TypeError(".Qot_ModifyUserSecurity.C2S.securityList: object expected");
                    message.securityList[i] = $root.Qot_Common.Security.fromObject(object.securityList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_ModifyUserSecurity.C2S
         * @static
         * @param {Qot_ModifyUserSecurity.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.securityList = [];
            if (options.defaults) {
                object.groupName = "";
                object.op = 0;
            }
            if (message.groupName != null && message.hasOwnProperty("groupName"))
                object.groupName = message.groupName;
            if (message.op != null && message.hasOwnProperty("op"))
                object.op = message.op;
            if (message.securityList && message.securityList.length) {
                object.securityList = [];
                for (var j = 0; j < message.securityList.length; ++j)
                    object.securityList[j] = $root.Qot_Common.Security.toObject(message.securityList[j], options);
            }
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_ModifyUserSecurity.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_ModifyUserSecurity.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_ModifyUserSecurity
         * @interface IS2C
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_ModifyUserSecurity
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_ModifyUserSecurity.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_ModifyUserSecurity.S2C
         * @static
         * @param {Qot_ModifyUserSecurity.IS2C=} [properties] Properties to set
         * @returns {Qot_ModifyUserSecurity.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_ModifyUserSecurity.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_ModifyUserSecurity.S2C
         * @static
         * @param {Qot_ModifyUserSecurity.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_ModifyUserSecurity.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_ModifyUserSecurity.S2C
         * @static
         * @param {Qot_ModifyUserSecurity.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_ModifyUserSecurity.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_ModifyUserSecurity.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_ModifyUserSecurity.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_ModifyUserSecurity.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_ModifyUserSecurity.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_ModifyUserSecurity.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_ModifyUserSecurity.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_ModifyUserSecurity.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_ModifyUserSecurity.S2C)
                return object;
            return new $root.Qot_ModifyUserSecurity.S2C();
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_ModifyUserSecurity.S2C
         * @static
         * @param {Qot_ModifyUserSecurity.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_ModifyUserSecurity.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_ModifyUserSecurity.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_ModifyUserSecurity
         * @interface IRequest
         * @property {Qot_ModifyUserSecurity.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_ModifyUserSecurity
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_ModifyUserSecurity.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_ModifyUserSecurity.IC2S} c2s
         * @memberof Qot_ModifyUserSecurity.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_ModifyUserSecurity.Request
         * @static
         * @param {Qot_ModifyUserSecurity.IRequest=} [properties] Properties to set
         * @returns {Qot_ModifyUserSecurity.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_ModifyUserSecurity.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_ModifyUserSecurity.Request
         * @static
         * @param {Qot_ModifyUserSecurity.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_ModifyUserSecurity.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_ModifyUserSecurity.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_ModifyUserSecurity.Request
         * @static
         * @param {Qot_ModifyUserSecurity.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_ModifyUserSecurity.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_ModifyUserSecurity.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_ModifyUserSecurity.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_ModifyUserSecurity.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_ModifyUserSecurity.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_ModifyUserSecurity.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_ModifyUserSecurity.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_ModifyUserSecurity.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_ModifyUserSecurity.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_ModifyUserSecurity.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_ModifyUserSecurity.Request)
                return object;
            var message = new $root.Qot_ModifyUserSecurity.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_ModifyUserSecurity.Request.c2s: object expected");
                message.c2s = $root.Qot_ModifyUserSecurity.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_ModifyUserSecurity.Request
         * @static
         * @param {Qot_ModifyUserSecurity.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_ModifyUserSecurity.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_ModifyUserSecurity.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_ModifyUserSecurity.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_ModifyUserSecurity
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_ModifyUserSecurity.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_ModifyUserSecurity
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_ModifyUserSecurity.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_ModifyUserSecurity.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_ModifyUserSecurity.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_ModifyUserSecurity.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_ModifyUserSecurity.IS2C|null|undefined} s2c
         * @memberof Qot_ModifyUserSecurity.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_ModifyUserSecurity.Response
         * @static
         * @param {Qot_ModifyUserSecurity.IResponse=} [properties] Properties to set
         * @returns {Qot_ModifyUserSecurity.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_ModifyUserSecurity.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_ModifyUserSecurity.Response
         * @static
         * @param {Qot_ModifyUserSecurity.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_ModifyUserSecurity.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_ModifyUserSecurity.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_ModifyUserSecurity.Response
         * @static
         * @param {Qot_ModifyUserSecurity.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_ModifyUserSecurity.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_ModifyUserSecurity.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_ModifyUserSecurity.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_ModifyUserSecurity.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_ModifyUserSecurity.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_ModifyUserSecurity.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_ModifyUserSecurity.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_ModifyUserSecurity.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_ModifyUserSecurity.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_ModifyUserSecurity.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_ModifyUserSecurity.Response)
                return object;
            var message = new $root.Qot_ModifyUserSecurity.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_ModifyUserSecurity.Response.s2c: object expected");
                message.s2c = $root.Qot_ModifyUserSecurity.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_ModifyUserSecurity.Response
         * @static
         * @param {Qot_ModifyUserSecurity.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_ModifyUserSecurity.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_ModifyUserSecurity.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_ModifyUserSecurity;
})();

$root.Qot_RegQotPush = (function() {

    /**
     * Namespace Qot_RegQotPush.
     * @exports Qot_RegQotPush
     * @namespace
     */
    var Qot_RegQotPush = {};

    Qot_RegQotPush.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_RegQotPush
         * @interface IC2S
         * @property {Array.<Qot_Common.ISecurity>|null} [securityList] C2S securityList
         * @property {Array.<number>|null} [subTypeList] C2S subTypeList
         * @property {Array.<number>|null} [rehabTypeList] C2S rehabTypeList
         * @property {boolean} isRegOrUnReg C2S isRegOrUnReg
         * @property {boolean|null} [isFirstPush] C2S isFirstPush
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_RegQotPush
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_RegQotPush.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.securityList = [];
            this.subTypeList = [];
            this.rehabTypeList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S securityList.
         * @member {Array.<Qot_Common.ISecurity>} securityList
         * @memberof Qot_RegQotPush.C2S
         * @instance
         */
        C2S.prototype.securityList = $util.emptyArray;

        /**
         * C2S subTypeList.
         * @member {Array.<number>} subTypeList
         * @memberof Qot_RegQotPush.C2S
         * @instance
         */
        C2S.prototype.subTypeList = $util.emptyArray;

        /**
         * C2S rehabTypeList.
         * @member {Array.<number>} rehabTypeList
         * @memberof Qot_RegQotPush.C2S
         * @instance
         */
        C2S.prototype.rehabTypeList = $util.emptyArray;

        /**
         * C2S isRegOrUnReg.
         * @member {boolean} isRegOrUnReg
         * @memberof Qot_RegQotPush.C2S
         * @instance
         */
        C2S.prototype.isRegOrUnReg = false;

        /**
         * C2S isFirstPush.
         * @member {boolean} isFirstPush
         * @memberof Qot_RegQotPush.C2S
         * @instance
         */
        C2S.prototype.isFirstPush = false;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_RegQotPush.C2S
         * @static
         * @param {Qot_RegQotPush.IC2S=} [properties] Properties to set
         * @returns {Qot_RegQotPush.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_RegQotPush.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_RegQotPush.C2S
         * @static
         * @param {Qot_RegQotPush.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.securityList != null && message.securityList.length)
                for (var i = 0; i < message.securityList.length; ++i)
                    $root.Qot_Common.Security.encode(message.securityList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.subTypeList != null && message.subTypeList.length)
                for (var i = 0; i < message.subTypeList.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.subTypeList[i]);
            if (message.rehabTypeList != null && message.rehabTypeList.length)
                for (var i = 0; i < message.rehabTypeList.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.rehabTypeList[i]);
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isRegOrUnReg);
            if (message.isFirstPush != null && message.hasOwnProperty("isFirstPush"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.isFirstPush);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_RegQotPush.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RegQotPush.C2S
         * @static
         * @param {Qot_RegQotPush.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RegQotPush.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RegQotPush.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RegQotPush.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.securityList && message.securityList.length))
                        message.securityList = [];
                    message.securityList.push($root.Qot_Common.Security.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.subTypeList && message.subTypeList.length))
                        message.subTypeList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.subTypeList.push(reader.int32());
                    } else
                        message.subTypeList.push(reader.int32());
                    break;
                case 3:
                    if (!(message.rehabTypeList && message.rehabTypeList.length))
                        message.rehabTypeList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.rehabTypeList.push(reader.int32());
                    } else
                        message.rehabTypeList.push(reader.int32());
                    break;
                case 4:
                    message.isRegOrUnReg = reader.bool();
                    break;
                case 5:
                    message.isFirstPush = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("isRegOrUnReg"))
                throw $util.ProtocolError("missing required 'isRegOrUnReg'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RegQotPush.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RegQotPush.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_RegQotPush.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.securityList != null && message.hasOwnProperty("securityList")) {
                if (!Array.isArray(message.securityList))
                    return "securityList: array expected";
                for (var i = 0; i < message.securityList.length; ++i) {
                    var error = $root.Qot_Common.Security.verify(message.securityList[i]);
                    if (error)
                        return "securityList." + error;
                }
            }
            if (message.subTypeList != null && message.hasOwnProperty("subTypeList")) {
                if (!Array.isArray(message.subTypeList))
                    return "subTypeList: array expected";
                for (var i = 0; i < message.subTypeList.length; ++i)
                    if (!$util.isInteger(message.subTypeList[i]))
                        return "subTypeList: integer[] expected";
            }
            if (message.rehabTypeList != null && message.hasOwnProperty("rehabTypeList")) {
                if (!Array.isArray(message.rehabTypeList))
                    return "rehabTypeList: array expected";
                for (var i = 0; i < message.rehabTypeList.length; ++i)
                    if (!$util.isInteger(message.rehabTypeList[i]))
                        return "rehabTypeList: integer[] expected";
            }
            if (typeof message.isRegOrUnReg !== "boolean")
                return "isRegOrUnReg: boolean expected";
            if (message.isFirstPush != null && message.hasOwnProperty("isFirstPush"))
                if (typeof message.isFirstPush !== "boolean")
                    return "isFirstPush: boolean expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RegQotPush.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RegQotPush.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RegQotPush.C2S)
                return object;
            var message = new $root.Qot_RegQotPush.C2S();
            if (object.securityList) {
                if (!Array.isArray(object.securityList))
                    throw TypeError(".Qot_RegQotPush.C2S.securityList: array expected");
                message.securityList = [];
                for (var i = 0; i < object.securityList.length; ++i) {
                    if (typeof object.securityList[i] !== "object")
                        throw TypeError(".Qot_RegQotPush.C2S.securityList: object expected");
                    message.securityList[i] = $root.Qot_Common.Security.fromObject(object.securityList[i]);
                }
            }
            if (object.subTypeList) {
                if (!Array.isArray(object.subTypeList))
                    throw TypeError(".Qot_RegQotPush.C2S.subTypeList: array expected");
                message.subTypeList = [];
                for (var i = 0; i < object.subTypeList.length; ++i)
                    message.subTypeList[i] = object.subTypeList[i] | 0;
            }
            if (object.rehabTypeList) {
                if (!Array.isArray(object.rehabTypeList))
                    throw TypeError(".Qot_RegQotPush.C2S.rehabTypeList: array expected");
                message.rehabTypeList = [];
                for (var i = 0; i < object.rehabTypeList.length; ++i)
                    message.rehabTypeList[i] = object.rehabTypeList[i] | 0;
            }
            if (object.isRegOrUnReg != null)
                message.isRegOrUnReg = Boolean(object.isRegOrUnReg);
            if (object.isFirstPush != null)
                message.isFirstPush = Boolean(object.isFirstPush);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RegQotPush.C2S
         * @static
         * @param {Qot_RegQotPush.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.securityList = [];
                object.subTypeList = [];
                object.rehabTypeList = [];
            }
            if (options.defaults) {
                object.isRegOrUnReg = false;
                object.isFirstPush = false;
            }
            if (message.securityList && message.securityList.length) {
                object.securityList = [];
                for (var j = 0; j < message.securityList.length; ++j)
                    object.securityList[j] = $root.Qot_Common.Security.toObject(message.securityList[j], options);
            }
            if (message.subTypeList && message.subTypeList.length) {
                object.subTypeList = [];
                for (var j = 0; j < message.subTypeList.length; ++j)
                    object.subTypeList[j] = message.subTypeList[j];
            }
            if (message.rehabTypeList && message.rehabTypeList.length) {
                object.rehabTypeList = [];
                for (var j = 0; j < message.rehabTypeList.length; ++j)
                    object.rehabTypeList[j] = message.rehabTypeList[j];
            }
            if (message.isRegOrUnReg != null && message.hasOwnProperty("isRegOrUnReg"))
                object.isRegOrUnReg = message.isRegOrUnReg;
            if (message.isFirstPush != null && message.hasOwnProperty("isFirstPush"))
                object.isFirstPush = message.isFirstPush;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_RegQotPush.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_RegQotPush.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_RegQotPush
         * @interface IS2C
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_RegQotPush
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_RegQotPush.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_RegQotPush.S2C
         * @static
         * @param {Qot_RegQotPush.IS2C=} [properties] Properties to set
         * @returns {Qot_RegQotPush.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_RegQotPush.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_RegQotPush.S2C
         * @static
         * @param {Qot_RegQotPush.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_RegQotPush.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RegQotPush.S2C
         * @static
         * @param {Qot_RegQotPush.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RegQotPush.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RegQotPush.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RegQotPush.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RegQotPush.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RegQotPush.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_RegQotPush.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RegQotPush.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RegQotPush.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RegQotPush.S2C)
                return object;
            return new $root.Qot_RegQotPush.S2C();
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RegQotPush.S2C
         * @static
         * @param {Qot_RegQotPush.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_RegQotPush.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_RegQotPush.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_RegQotPush
         * @interface IRequest
         * @property {Qot_RegQotPush.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_RegQotPush
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_RegQotPush.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_RegQotPush.IC2S} c2s
         * @memberof Qot_RegQotPush.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_RegQotPush.Request
         * @static
         * @param {Qot_RegQotPush.IRequest=} [properties] Properties to set
         * @returns {Qot_RegQotPush.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_RegQotPush.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_RegQotPush.Request
         * @static
         * @param {Qot_RegQotPush.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_RegQotPush.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_RegQotPush.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RegQotPush.Request
         * @static
         * @param {Qot_RegQotPush.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RegQotPush.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RegQotPush.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RegQotPush.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_RegQotPush.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RegQotPush.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RegQotPush.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_RegQotPush.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_RegQotPush.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RegQotPush.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RegQotPush.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RegQotPush.Request)
                return object;
            var message = new $root.Qot_RegQotPush.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_RegQotPush.Request.c2s: object expected");
                message.c2s = $root.Qot_RegQotPush.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RegQotPush.Request
         * @static
         * @param {Qot_RegQotPush.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_RegQotPush.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_RegQotPush.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_RegQotPush.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_RegQotPush
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_RegQotPush.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_RegQotPush
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_RegQotPush.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_RegQotPush.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_RegQotPush.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_RegQotPush.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_RegQotPush.IS2C|null|undefined} s2c
         * @memberof Qot_RegQotPush.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_RegQotPush.Response
         * @static
         * @param {Qot_RegQotPush.IResponse=} [properties] Properties to set
         * @returns {Qot_RegQotPush.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_RegQotPush.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_RegQotPush.Response
         * @static
         * @param {Qot_RegQotPush.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_RegQotPush.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_RegQotPush.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RegQotPush.Response
         * @static
         * @param {Qot_RegQotPush.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RegQotPush.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RegQotPush.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RegQotPush.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_RegQotPush.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RegQotPush.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RegQotPush.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_RegQotPush.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_RegQotPush.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RegQotPush.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RegQotPush.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RegQotPush.Response)
                return object;
            var message = new $root.Qot_RegQotPush.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_RegQotPush.Response.s2c: object expected");
                message.s2c = $root.Qot_RegQotPush.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RegQotPush.Response
         * @static
         * @param {Qot_RegQotPush.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_RegQotPush.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_RegQotPush.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_RegQotPush;
})();

$root.Qot_RequestHistoryKL = (function() {

    /**
     * Namespace Qot_RequestHistoryKL.
     * @exports Qot_RequestHistoryKL
     * @namespace
     */
    var Qot_RequestHistoryKL = {};

    Qot_RequestHistoryKL.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_RequestHistoryKL
         * @interface IC2S
         * @property {number} rehabType C2S rehabType
         * @property {number} klType C2S klType
         * @property {Qot_Common.ISecurity} security C2S security
         * @property {string} beginTime C2S beginTime
         * @property {string} endTime C2S endTime
         * @property {number|null} [maxAckKLNum] C2S maxAckKLNum
         * @property {number|Long|null} [needKLFieldsFlag] C2S needKLFieldsFlag
         * @property {Uint8Array|null} [nextReqKey] C2S nextReqKey
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_RequestHistoryKL
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_RequestHistoryKL.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S rehabType.
         * @member {number} rehabType
         * @memberof Qot_RequestHistoryKL.C2S
         * @instance
         */
        C2S.prototype.rehabType = 0;

        /**
         * C2S klType.
         * @member {number} klType
         * @memberof Qot_RequestHistoryKL.C2S
         * @instance
         */
        C2S.prototype.klType = 0;

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_RequestHistoryKL.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * C2S beginTime.
         * @member {string} beginTime
         * @memberof Qot_RequestHistoryKL.C2S
         * @instance
         */
        C2S.prototype.beginTime = "";

        /**
         * C2S endTime.
         * @member {string} endTime
         * @memberof Qot_RequestHistoryKL.C2S
         * @instance
         */
        C2S.prototype.endTime = "";

        /**
         * C2S maxAckKLNum.
         * @member {number} maxAckKLNum
         * @memberof Qot_RequestHistoryKL.C2S
         * @instance
         */
        C2S.prototype.maxAckKLNum = 0;

        /**
         * C2S needKLFieldsFlag.
         * @member {number|Long} needKLFieldsFlag
         * @memberof Qot_RequestHistoryKL.C2S
         * @instance
         */
        C2S.prototype.needKLFieldsFlag = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * C2S nextReqKey.
         * @member {Uint8Array} nextReqKey
         * @memberof Qot_RequestHistoryKL.C2S
         * @instance
         */
        C2S.prototype.nextReqKey = $util.newBuffer([]);

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_RequestHistoryKL.C2S
         * @static
         * @param {Qot_RequestHistoryKL.IC2S=} [properties] Properties to set
         * @returns {Qot_RequestHistoryKL.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_RequestHistoryKL.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestHistoryKL.C2S
         * @static
         * @param {Qot_RequestHistoryKL.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rehabType);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.klType);
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.beginTime);
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.endTime);
            if (message.maxAckKLNum != null && message.hasOwnProperty("maxAckKLNum"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.maxAckKLNum);
            if (message.needKLFieldsFlag != null && message.hasOwnProperty("needKLFieldsFlag"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.needKLFieldsFlag);
            if (message.nextReqKey != null && message.hasOwnProperty("nextReqKey"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.nextReqKey);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_RequestHistoryKL.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestHistoryKL.C2S
         * @static
         * @param {Qot_RequestHistoryKL.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestHistoryKL.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestHistoryKL.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestHistoryKL.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rehabType = reader.int32();
                    break;
                case 2:
                    message.klType = reader.int32();
                    break;
                case 3:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.beginTime = reader.string();
                    break;
                case 5:
                    message.endTime = reader.string();
                    break;
                case 6:
                    message.maxAckKLNum = reader.int32();
                    break;
                case 7:
                    message.needKLFieldsFlag = reader.int64();
                    break;
                case 8:
                    message.nextReqKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("rehabType"))
                throw $util.ProtocolError("missing required 'rehabType'", { instance: message });
            if (!message.hasOwnProperty("klType"))
                throw $util.ProtocolError("missing required 'klType'", { instance: message });
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("beginTime"))
                throw $util.ProtocolError("missing required 'beginTime'", { instance: message });
            if (!message.hasOwnProperty("endTime"))
                throw $util.ProtocolError("missing required 'endTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestHistoryKL.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestHistoryKL.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_RequestHistoryKL.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.rehabType))
                return "rehabType: integer expected";
            if (!$util.isInteger(message.klType))
                return "klType: integer expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (!$util.isString(message.beginTime))
                return "beginTime: string expected";
            if (!$util.isString(message.endTime))
                return "endTime: string expected";
            if (message.maxAckKLNum != null && message.hasOwnProperty("maxAckKLNum"))
                if (!$util.isInteger(message.maxAckKLNum))
                    return "maxAckKLNum: integer expected";
            if (message.needKLFieldsFlag != null && message.hasOwnProperty("needKLFieldsFlag"))
                if (!$util.isInteger(message.needKLFieldsFlag) && !(message.needKLFieldsFlag && $util.isInteger(message.needKLFieldsFlag.low) && $util.isInteger(message.needKLFieldsFlag.high)))
                    return "needKLFieldsFlag: integer|Long expected";
            if (message.nextReqKey != null && message.hasOwnProperty("nextReqKey"))
                if (!(message.nextReqKey && typeof message.nextReqKey.length === "number" || $util.isString(message.nextReqKey)))
                    return "nextReqKey: buffer expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestHistoryKL.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestHistoryKL.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestHistoryKL.C2S)
                return object;
            var message = new $root.Qot_RequestHistoryKL.C2S();
            if (object.rehabType != null)
                message.rehabType = object.rehabType | 0;
            if (object.klType != null)
                message.klType = object.klType | 0;
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_RequestHistoryKL.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.beginTime != null)
                message.beginTime = String(object.beginTime);
            if (object.endTime != null)
                message.endTime = String(object.endTime);
            if (object.maxAckKLNum != null)
                message.maxAckKLNum = object.maxAckKLNum | 0;
            if (object.needKLFieldsFlag != null)
                if ($util.Long)
                    (message.needKLFieldsFlag = $util.Long.fromValue(object.needKLFieldsFlag)).unsigned = false;
                else if (typeof object.needKLFieldsFlag === "string")
                    message.needKLFieldsFlag = parseInt(object.needKLFieldsFlag, 10);
                else if (typeof object.needKLFieldsFlag === "number")
                    message.needKLFieldsFlag = object.needKLFieldsFlag;
                else if (typeof object.needKLFieldsFlag === "object")
                    message.needKLFieldsFlag = new $util.LongBits(object.needKLFieldsFlag.low >>> 0, object.needKLFieldsFlag.high >>> 0).toNumber();
            if (object.nextReqKey != null)
                if (typeof object.nextReqKey === "string")
                    $util.base64.decode(object.nextReqKey, message.nextReqKey = $util.newBuffer($util.base64.length(object.nextReqKey)), 0);
                else if (object.nextReqKey.length)
                    message.nextReqKey = object.nextReqKey;
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestHistoryKL.C2S
         * @static
         * @param {Qot_RequestHistoryKL.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.rehabType = 0;
                object.klType = 0;
                object.security = null;
                object.beginTime = "";
                object.endTime = "";
                object.maxAckKLNum = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.needKLFieldsFlag = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.needKLFieldsFlag = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.nextReqKey = "";
                else {
                    object.nextReqKey = [];
                    if (options.bytes !== Array)
                        object.nextReqKey = $util.newBuffer(object.nextReqKey);
                }
            }
            if (message.rehabType != null && message.hasOwnProperty("rehabType"))
                object.rehabType = message.rehabType;
            if (message.klType != null && message.hasOwnProperty("klType"))
                object.klType = message.klType;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                object.beginTime = message.beginTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            if (message.maxAckKLNum != null && message.hasOwnProperty("maxAckKLNum"))
                object.maxAckKLNum = message.maxAckKLNum;
            if (message.needKLFieldsFlag != null && message.hasOwnProperty("needKLFieldsFlag"))
                if (typeof message.needKLFieldsFlag === "number")
                    object.needKLFieldsFlag = options.longs === String ? String(message.needKLFieldsFlag) : message.needKLFieldsFlag;
                else
                    object.needKLFieldsFlag = options.longs === String ? $util.Long.prototype.toString.call(message.needKLFieldsFlag) : options.longs === Number ? new $util.LongBits(message.needKLFieldsFlag.low >>> 0, message.needKLFieldsFlag.high >>> 0).toNumber() : message.needKLFieldsFlag;
            if (message.nextReqKey != null && message.hasOwnProperty("nextReqKey"))
                object.nextReqKey = options.bytes === String ? $util.base64.encode(message.nextReqKey, 0, message.nextReqKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.nextReqKey) : message.nextReqKey;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_RequestHistoryKL.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_RequestHistoryKL.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_RequestHistoryKL
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.IKLine>|null} [klList] S2C klList
         * @property {Uint8Array|null} [nextReqKey] S2C nextReqKey
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_RequestHistoryKL
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_RequestHistoryKL.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.klList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_RequestHistoryKL.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C klList.
         * @member {Array.<Qot_Common.IKLine>} klList
         * @memberof Qot_RequestHistoryKL.S2C
         * @instance
         */
        S2C.prototype.klList = $util.emptyArray;

        /**
         * S2C nextReqKey.
         * @member {Uint8Array} nextReqKey
         * @memberof Qot_RequestHistoryKL.S2C
         * @instance
         */
        S2C.prototype.nextReqKey = $util.newBuffer([]);

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_RequestHistoryKL.S2C
         * @static
         * @param {Qot_RequestHistoryKL.IS2C=} [properties] Properties to set
         * @returns {Qot_RequestHistoryKL.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_RequestHistoryKL.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestHistoryKL.S2C
         * @static
         * @param {Qot_RequestHistoryKL.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.klList != null && message.klList.length)
                for (var i = 0; i < message.klList.length; ++i)
                    $root.Qot_Common.KLine.encode(message.klList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.nextReqKey != null && message.hasOwnProperty("nextReqKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.nextReqKey);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_RequestHistoryKL.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestHistoryKL.S2C
         * @static
         * @param {Qot_RequestHistoryKL.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestHistoryKL.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestHistoryKL.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestHistoryKL.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.klList && message.klList.length))
                        message.klList = [];
                    message.klList.push($root.Qot_Common.KLine.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.nextReqKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestHistoryKL.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestHistoryKL.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_RequestHistoryKL.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.klList != null && message.hasOwnProperty("klList")) {
                if (!Array.isArray(message.klList))
                    return "klList: array expected";
                for (var i = 0; i < message.klList.length; ++i) {
                    var error = $root.Qot_Common.KLine.verify(message.klList[i]);
                    if (error)
                        return "klList." + error;
                }
            }
            if (message.nextReqKey != null && message.hasOwnProperty("nextReqKey"))
                if (!(message.nextReqKey && typeof message.nextReqKey.length === "number" || $util.isString(message.nextReqKey)))
                    return "nextReqKey: buffer expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestHistoryKL.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestHistoryKL.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestHistoryKL.S2C)
                return object;
            var message = new $root.Qot_RequestHistoryKL.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_RequestHistoryKL.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.klList) {
                if (!Array.isArray(object.klList))
                    throw TypeError(".Qot_RequestHistoryKL.S2C.klList: array expected");
                message.klList = [];
                for (var i = 0; i < object.klList.length; ++i) {
                    if (typeof object.klList[i] !== "object")
                        throw TypeError(".Qot_RequestHistoryKL.S2C.klList: object expected");
                    message.klList[i] = $root.Qot_Common.KLine.fromObject(object.klList[i]);
                }
            }
            if (object.nextReqKey != null)
                if (typeof object.nextReqKey === "string")
                    $util.base64.decode(object.nextReqKey, message.nextReqKey = $util.newBuffer($util.base64.length(object.nextReqKey)), 0);
                else if (object.nextReqKey.length)
                    message.nextReqKey = object.nextReqKey;
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestHistoryKL.S2C
         * @static
         * @param {Qot_RequestHistoryKL.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.klList = [];
            if (options.defaults) {
                object.security = null;
                if (options.bytes === String)
                    object.nextReqKey = "";
                else {
                    object.nextReqKey = [];
                    if (options.bytes !== Array)
                        object.nextReqKey = $util.newBuffer(object.nextReqKey);
                }
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.klList && message.klList.length) {
                object.klList = [];
                for (var j = 0; j < message.klList.length; ++j)
                    object.klList[j] = $root.Qot_Common.KLine.toObject(message.klList[j], options);
            }
            if (message.nextReqKey != null && message.hasOwnProperty("nextReqKey"))
                object.nextReqKey = options.bytes === String ? $util.base64.encode(message.nextReqKey, 0, message.nextReqKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.nextReqKey) : message.nextReqKey;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_RequestHistoryKL.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_RequestHistoryKL.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_RequestHistoryKL
         * @interface IRequest
         * @property {Qot_RequestHistoryKL.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_RequestHistoryKL
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_RequestHistoryKL.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_RequestHistoryKL.IC2S} c2s
         * @memberof Qot_RequestHistoryKL.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_RequestHistoryKL.Request
         * @static
         * @param {Qot_RequestHistoryKL.IRequest=} [properties] Properties to set
         * @returns {Qot_RequestHistoryKL.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_RequestHistoryKL.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestHistoryKL.Request
         * @static
         * @param {Qot_RequestHistoryKL.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_RequestHistoryKL.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_RequestHistoryKL.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestHistoryKL.Request
         * @static
         * @param {Qot_RequestHistoryKL.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestHistoryKL.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestHistoryKL.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestHistoryKL.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_RequestHistoryKL.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestHistoryKL.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestHistoryKL.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_RequestHistoryKL.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_RequestHistoryKL.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestHistoryKL.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestHistoryKL.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestHistoryKL.Request)
                return object;
            var message = new $root.Qot_RequestHistoryKL.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_RequestHistoryKL.Request.c2s: object expected");
                message.c2s = $root.Qot_RequestHistoryKL.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestHistoryKL.Request
         * @static
         * @param {Qot_RequestHistoryKL.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_RequestHistoryKL.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_RequestHistoryKL.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_RequestHistoryKL.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_RequestHistoryKL
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_RequestHistoryKL.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_RequestHistoryKL
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_RequestHistoryKL.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_RequestHistoryKL.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_RequestHistoryKL.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_RequestHistoryKL.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_RequestHistoryKL.IS2C|null|undefined} s2c
         * @memberof Qot_RequestHistoryKL.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_RequestHistoryKL.Response
         * @static
         * @param {Qot_RequestHistoryKL.IResponse=} [properties] Properties to set
         * @returns {Qot_RequestHistoryKL.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_RequestHistoryKL.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestHistoryKL.Response
         * @static
         * @param {Qot_RequestHistoryKL.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_RequestHistoryKL.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_RequestHistoryKL.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestHistoryKL.Response
         * @static
         * @param {Qot_RequestHistoryKL.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestHistoryKL.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestHistoryKL.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestHistoryKL.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_RequestHistoryKL.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestHistoryKL.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestHistoryKL.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_RequestHistoryKL.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_RequestHistoryKL.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestHistoryKL.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestHistoryKL.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestHistoryKL.Response)
                return object;
            var message = new $root.Qot_RequestHistoryKL.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_RequestHistoryKL.Response.s2c: object expected");
                message.s2c = $root.Qot_RequestHistoryKL.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestHistoryKL.Response
         * @static
         * @param {Qot_RequestHistoryKL.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_RequestHistoryKL.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_RequestHistoryKL.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_RequestHistoryKL;
})();

$root.Qot_RequestHistoryKLQuota = (function() {

    /**
     * Namespace Qot_RequestHistoryKLQuota.
     * @exports Qot_RequestHistoryKLQuota
     * @namespace
     */
    var Qot_RequestHistoryKLQuota = {};

    Qot_RequestHistoryKLQuota.DetailItem = (function() {

        /**
         * Properties of a DetailItem.
         * @memberof Qot_RequestHistoryKLQuota
         * @interface IDetailItem
         * @property {Qot_Common.ISecurity} security DetailItem security
         * @property {string} requestTime DetailItem requestTime
         * @property {number|Long|null} [requestTimeStamp] DetailItem requestTimeStamp
         */

        /**
         * Constructs a new DetailItem.
         * @memberof Qot_RequestHistoryKLQuota
         * @classdesc Represents a DetailItem.
         * @implements IDetailItem
         * @constructor
         * @param {Qot_RequestHistoryKLQuota.IDetailItem=} [properties] Properties to set
         */
        function DetailItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DetailItem security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_RequestHistoryKLQuota.DetailItem
         * @instance
         */
        DetailItem.prototype.security = null;

        /**
         * DetailItem requestTime.
         * @member {string} requestTime
         * @memberof Qot_RequestHistoryKLQuota.DetailItem
         * @instance
         */
        DetailItem.prototype.requestTime = "";

        /**
         * DetailItem requestTimeStamp.
         * @member {number|Long} requestTimeStamp
         * @memberof Qot_RequestHistoryKLQuota.DetailItem
         * @instance
         */
        DetailItem.prototype.requestTimeStamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new DetailItem instance using the specified properties.
         * @function create
         * @memberof Qot_RequestHistoryKLQuota.DetailItem
         * @static
         * @param {Qot_RequestHistoryKLQuota.IDetailItem=} [properties] Properties to set
         * @returns {Qot_RequestHistoryKLQuota.DetailItem} DetailItem instance
         */
        DetailItem.create = function create(properties) {
            return new DetailItem(properties);
        };

        /**
         * Encodes the specified DetailItem message. Does not implicitly {@link Qot_RequestHistoryKLQuota.DetailItem.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestHistoryKLQuota.DetailItem
         * @static
         * @param {Qot_RequestHistoryKLQuota.IDetailItem} message DetailItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DetailItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.requestTime);
            if (message.requestTimeStamp != null && message.hasOwnProperty("requestTimeStamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.requestTimeStamp);
            return writer;
        };

        /**
         * Encodes the specified DetailItem message, length delimited. Does not implicitly {@link Qot_RequestHistoryKLQuota.DetailItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestHistoryKLQuota.DetailItem
         * @static
         * @param {Qot_RequestHistoryKLQuota.IDetailItem} message DetailItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DetailItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DetailItem message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestHistoryKLQuota.DetailItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestHistoryKLQuota.DetailItem} DetailItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DetailItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestHistoryKLQuota.DetailItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.requestTime = reader.string();
                    break;
                case 3:
                    message.requestTimeStamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("requestTime"))
                throw $util.ProtocolError("missing required 'requestTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a DetailItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestHistoryKLQuota.DetailItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestHistoryKLQuota.DetailItem} DetailItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DetailItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DetailItem message.
         * @function verify
         * @memberof Qot_RequestHistoryKLQuota.DetailItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DetailItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (!$util.isString(message.requestTime))
                return "requestTime: string expected";
            if (message.requestTimeStamp != null && message.hasOwnProperty("requestTimeStamp"))
                if (!$util.isInteger(message.requestTimeStamp) && !(message.requestTimeStamp && $util.isInteger(message.requestTimeStamp.low) && $util.isInteger(message.requestTimeStamp.high)))
                    return "requestTimeStamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a DetailItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestHistoryKLQuota.DetailItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestHistoryKLQuota.DetailItem} DetailItem
         */
        DetailItem.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestHistoryKLQuota.DetailItem)
                return object;
            var message = new $root.Qot_RequestHistoryKLQuota.DetailItem();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_RequestHistoryKLQuota.DetailItem.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.requestTime != null)
                message.requestTime = String(object.requestTime);
            if (object.requestTimeStamp != null)
                if ($util.Long)
                    (message.requestTimeStamp = $util.Long.fromValue(object.requestTimeStamp)).unsigned = false;
                else if (typeof object.requestTimeStamp === "string")
                    message.requestTimeStamp = parseInt(object.requestTimeStamp, 10);
                else if (typeof object.requestTimeStamp === "number")
                    message.requestTimeStamp = object.requestTimeStamp;
                else if (typeof object.requestTimeStamp === "object")
                    message.requestTimeStamp = new $util.LongBits(object.requestTimeStamp.low >>> 0, object.requestTimeStamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a DetailItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestHistoryKLQuota.DetailItem
         * @static
         * @param {Qot_RequestHistoryKLQuota.DetailItem} message DetailItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DetailItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.security = null;
                object.requestTime = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.requestTimeStamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.requestTimeStamp = options.longs === String ? "0" : 0;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.requestTime != null && message.hasOwnProperty("requestTime"))
                object.requestTime = message.requestTime;
            if (message.requestTimeStamp != null && message.hasOwnProperty("requestTimeStamp"))
                if (typeof message.requestTimeStamp === "number")
                    object.requestTimeStamp = options.longs === String ? String(message.requestTimeStamp) : message.requestTimeStamp;
                else
                    object.requestTimeStamp = options.longs === String ? $util.Long.prototype.toString.call(message.requestTimeStamp) : options.longs === Number ? new $util.LongBits(message.requestTimeStamp.low >>> 0, message.requestTimeStamp.high >>> 0).toNumber() : message.requestTimeStamp;
            return object;
        };

        /**
         * Converts this DetailItem to JSON.
         * @function toJSON
         * @memberof Qot_RequestHistoryKLQuota.DetailItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DetailItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DetailItem;
    })();

    Qot_RequestHistoryKLQuota.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_RequestHistoryKLQuota
         * @interface IC2S
         * @property {boolean|null} [bGetDetail] C2S bGetDetail
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_RequestHistoryKLQuota
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_RequestHistoryKLQuota.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S bGetDetail.
         * @member {boolean} bGetDetail
         * @memberof Qot_RequestHistoryKLQuota.C2S
         * @instance
         */
        C2S.prototype.bGetDetail = false;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_RequestHistoryKLQuota.C2S
         * @static
         * @param {Qot_RequestHistoryKLQuota.IC2S=} [properties] Properties to set
         * @returns {Qot_RequestHistoryKLQuota.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_RequestHistoryKLQuota.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestHistoryKLQuota.C2S
         * @static
         * @param {Qot_RequestHistoryKLQuota.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bGetDetail != null && message.hasOwnProperty("bGetDetail"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.bGetDetail);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_RequestHistoryKLQuota.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestHistoryKLQuota.C2S
         * @static
         * @param {Qot_RequestHistoryKLQuota.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestHistoryKLQuota.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestHistoryKLQuota.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestHistoryKLQuota.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.bGetDetail = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestHistoryKLQuota.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestHistoryKLQuota.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_RequestHistoryKLQuota.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bGetDetail != null && message.hasOwnProperty("bGetDetail"))
                if (typeof message.bGetDetail !== "boolean")
                    return "bGetDetail: boolean expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestHistoryKLQuota.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestHistoryKLQuota.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestHistoryKLQuota.C2S)
                return object;
            var message = new $root.Qot_RequestHistoryKLQuota.C2S();
            if (object.bGetDetail != null)
                message.bGetDetail = Boolean(object.bGetDetail);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestHistoryKLQuota.C2S
         * @static
         * @param {Qot_RequestHistoryKLQuota.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.bGetDetail = false;
            if (message.bGetDetail != null && message.hasOwnProperty("bGetDetail"))
                object.bGetDetail = message.bGetDetail;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_RequestHistoryKLQuota.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_RequestHistoryKLQuota.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_RequestHistoryKLQuota
         * @interface IS2C
         * @property {number} usedQuota S2C usedQuota
         * @property {number} remainQuota S2C remainQuota
         * @property {Array.<Qot_RequestHistoryKLQuota.IDetailItem>|null} [detailList] S2C detailList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_RequestHistoryKLQuota
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_RequestHistoryKLQuota.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.detailList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C usedQuota.
         * @member {number} usedQuota
         * @memberof Qot_RequestHistoryKLQuota.S2C
         * @instance
         */
        S2C.prototype.usedQuota = 0;

        /**
         * S2C remainQuota.
         * @member {number} remainQuota
         * @memberof Qot_RequestHistoryKLQuota.S2C
         * @instance
         */
        S2C.prototype.remainQuota = 0;

        /**
         * S2C detailList.
         * @member {Array.<Qot_RequestHistoryKLQuota.IDetailItem>} detailList
         * @memberof Qot_RequestHistoryKLQuota.S2C
         * @instance
         */
        S2C.prototype.detailList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_RequestHistoryKLQuota.S2C
         * @static
         * @param {Qot_RequestHistoryKLQuota.IS2C=} [properties] Properties to set
         * @returns {Qot_RequestHistoryKLQuota.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_RequestHistoryKLQuota.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestHistoryKLQuota.S2C
         * @static
         * @param {Qot_RequestHistoryKLQuota.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.usedQuota);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.remainQuota);
            if (message.detailList != null && message.detailList.length)
                for (var i = 0; i < message.detailList.length; ++i)
                    $root.Qot_RequestHistoryKLQuota.DetailItem.encode(message.detailList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_RequestHistoryKLQuota.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestHistoryKLQuota.S2C
         * @static
         * @param {Qot_RequestHistoryKLQuota.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestHistoryKLQuota.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestHistoryKLQuota.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestHistoryKLQuota.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.usedQuota = reader.int32();
                    break;
                case 2:
                    message.remainQuota = reader.int32();
                    break;
                case 3:
                    if (!(message.detailList && message.detailList.length))
                        message.detailList = [];
                    message.detailList.push($root.Qot_RequestHistoryKLQuota.DetailItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("usedQuota"))
                throw $util.ProtocolError("missing required 'usedQuota'", { instance: message });
            if (!message.hasOwnProperty("remainQuota"))
                throw $util.ProtocolError("missing required 'remainQuota'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestHistoryKLQuota.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestHistoryKLQuota.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_RequestHistoryKLQuota.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.usedQuota))
                return "usedQuota: integer expected";
            if (!$util.isInteger(message.remainQuota))
                return "remainQuota: integer expected";
            if (message.detailList != null && message.hasOwnProperty("detailList")) {
                if (!Array.isArray(message.detailList))
                    return "detailList: array expected";
                for (var i = 0; i < message.detailList.length; ++i) {
                    var error = $root.Qot_RequestHistoryKLQuota.DetailItem.verify(message.detailList[i]);
                    if (error)
                        return "detailList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestHistoryKLQuota.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestHistoryKLQuota.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestHistoryKLQuota.S2C)
                return object;
            var message = new $root.Qot_RequestHistoryKLQuota.S2C();
            if (object.usedQuota != null)
                message.usedQuota = object.usedQuota | 0;
            if (object.remainQuota != null)
                message.remainQuota = object.remainQuota | 0;
            if (object.detailList) {
                if (!Array.isArray(object.detailList))
                    throw TypeError(".Qot_RequestHistoryKLQuota.S2C.detailList: array expected");
                message.detailList = [];
                for (var i = 0; i < object.detailList.length; ++i) {
                    if (typeof object.detailList[i] !== "object")
                        throw TypeError(".Qot_RequestHistoryKLQuota.S2C.detailList: object expected");
                    message.detailList[i] = $root.Qot_RequestHistoryKLQuota.DetailItem.fromObject(object.detailList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestHistoryKLQuota.S2C
         * @static
         * @param {Qot_RequestHistoryKLQuota.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.detailList = [];
            if (options.defaults) {
                object.usedQuota = 0;
                object.remainQuota = 0;
            }
            if (message.usedQuota != null && message.hasOwnProperty("usedQuota"))
                object.usedQuota = message.usedQuota;
            if (message.remainQuota != null && message.hasOwnProperty("remainQuota"))
                object.remainQuota = message.remainQuota;
            if (message.detailList && message.detailList.length) {
                object.detailList = [];
                for (var j = 0; j < message.detailList.length; ++j)
                    object.detailList[j] = $root.Qot_RequestHistoryKLQuota.DetailItem.toObject(message.detailList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_RequestHistoryKLQuota.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_RequestHistoryKLQuota.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_RequestHistoryKLQuota
         * @interface IRequest
         * @property {Qot_RequestHistoryKLQuota.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_RequestHistoryKLQuota
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_RequestHistoryKLQuota.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_RequestHistoryKLQuota.IC2S} c2s
         * @memberof Qot_RequestHistoryKLQuota.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_RequestHistoryKLQuota.Request
         * @static
         * @param {Qot_RequestHistoryKLQuota.IRequest=} [properties] Properties to set
         * @returns {Qot_RequestHistoryKLQuota.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_RequestHistoryKLQuota.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestHistoryKLQuota.Request
         * @static
         * @param {Qot_RequestHistoryKLQuota.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_RequestHistoryKLQuota.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_RequestHistoryKLQuota.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestHistoryKLQuota.Request
         * @static
         * @param {Qot_RequestHistoryKLQuota.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestHistoryKLQuota.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestHistoryKLQuota.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestHistoryKLQuota.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_RequestHistoryKLQuota.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestHistoryKLQuota.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestHistoryKLQuota.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_RequestHistoryKLQuota.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_RequestHistoryKLQuota.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestHistoryKLQuota.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestHistoryKLQuota.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestHistoryKLQuota.Request)
                return object;
            var message = new $root.Qot_RequestHistoryKLQuota.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_RequestHistoryKLQuota.Request.c2s: object expected");
                message.c2s = $root.Qot_RequestHistoryKLQuota.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestHistoryKLQuota.Request
         * @static
         * @param {Qot_RequestHistoryKLQuota.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_RequestHistoryKLQuota.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_RequestHistoryKLQuota.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_RequestHistoryKLQuota.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_RequestHistoryKLQuota
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_RequestHistoryKLQuota.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_RequestHistoryKLQuota
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_RequestHistoryKLQuota.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_RequestHistoryKLQuota.IS2C|null|undefined} s2c
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @static
         * @param {Qot_RequestHistoryKLQuota.IResponse=} [properties] Properties to set
         * @returns {Qot_RequestHistoryKLQuota.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_RequestHistoryKLQuota.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @static
         * @param {Qot_RequestHistoryKLQuota.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_RequestHistoryKLQuota.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_RequestHistoryKLQuota.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @static
         * @param {Qot_RequestHistoryKLQuota.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestHistoryKLQuota.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestHistoryKLQuota.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_RequestHistoryKLQuota.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestHistoryKLQuota.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_RequestHistoryKLQuota.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestHistoryKLQuota.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestHistoryKLQuota.Response)
                return object;
            var message = new $root.Qot_RequestHistoryKLQuota.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_RequestHistoryKLQuota.Response.s2c: object expected");
                message.s2c = $root.Qot_RequestHistoryKLQuota.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @static
         * @param {Qot_RequestHistoryKLQuota.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_RequestHistoryKLQuota.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_RequestHistoryKLQuota;
})();

$root.Qot_RequestRehab = (function() {

    /**
     * Namespace Qot_RequestRehab.
     * @exports Qot_RequestRehab
     * @namespace
     */
    var Qot_RequestRehab = {};

    Qot_RequestRehab.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_RequestRehab
         * @interface IC2S
         * @property {Qot_Common.ISecurity} security C2S security
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_RequestRehab
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_RequestRehab.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_RequestRehab.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_RequestRehab.C2S
         * @static
         * @param {Qot_RequestRehab.IC2S=} [properties] Properties to set
         * @returns {Qot_RequestRehab.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_RequestRehab.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestRehab.C2S
         * @static
         * @param {Qot_RequestRehab.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_RequestRehab.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestRehab.C2S
         * @static
         * @param {Qot_RequestRehab.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestRehab.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestRehab.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestRehab.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestRehab.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestRehab.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_RequestRehab.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestRehab.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestRehab.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestRehab.C2S)
                return object;
            var message = new $root.Qot_RequestRehab.C2S();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_RequestRehab.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestRehab.C2S
         * @static
         * @param {Qot_RequestRehab.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_RequestRehab.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_RequestRehab.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_RequestRehab
         * @interface IS2C
         * @property {Array.<Qot_Common.IRehab>|null} [rehabList] S2C rehabList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_RequestRehab
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_RequestRehab.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.rehabList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C rehabList.
         * @member {Array.<Qot_Common.IRehab>} rehabList
         * @memberof Qot_RequestRehab.S2C
         * @instance
         */
        S2C.prototype.rehabList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_RequestRehab.S2C
         * @static
         * @param {Qot_RequestRehab.IS2C=} [properties] Properties to set
         * @returns {Qot_RequestRehab.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_RequestRehab.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestRehab.S2C
         * @static
         * @param {Qot_RequestRehab.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rehabList != null && message.rehabList.length)
                for (var i = 0; i < message.rehabList.length; ++i)
                    $root.Qot_Common.Rehab.encode(message.rehabList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_RequestRehab.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestRehab.S2C
         * @static
         * @param {Qot_RequestRehab.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestRehab.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestRehab.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestRehab.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.rehabList && message.rehabList.length))
                        message.rehabList = [];
                    message.rehabList.push($root.Qot_Common.Rehab.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestRehab.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestRehab.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_RequestRehab.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rehabList != null && message.hasOwnProperty("rehabList")) {
                if (!Array.isArray(message.rehabList))
                    return "rehabList: array expected";
                for (var i = 0; i < message.rehabList.length; ++i) {
                    var error = $root.Qot_Common.Rehab.verify(message.rehabList[i]);
                    if (error)
                        return "rehabList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestRehab.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestRehab.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestRehab.S2C)
                return object;
            var message = new $root.Qot_RequestRehab.S2C();
            if (object.rehabList) {
                if (!Array.isArray(object.rehabList))
                    throw TypeError(".Qot_RequestRehab.S2C.rehabList: array expected");
                message.rehabList = [];
                for (var i = 0; i < object.rehabList.length; ++i) {
                    if (typeof object.rehabList[i] !== "object")
                        throw TypeError(".Qot_RequestRehab.S2C.rehabList: object expected");
                    message.rehabList[i] = $root.Qot_Common.Rehab.fromObject(object.rehabList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestRehab.S2C
         * @static
         * @param {Qot_RequestRehab.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.rehabList = [];
            if (message.rehabList && message.rehabList.length) {
                object.rehabList = [];
                for (var j = 0; j < message.rehabList.length; ++j)
                    object.rehabList[j] = $root.Qot_Common.Rehab.toObject(message.rehabList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_RequestRehab.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_RequestRehab.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_RequestRehab
         * @interface IRequest
         * @property {Qot_RequestRehab.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_RequestRehab
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_RequestRehab.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_RequestRehab.IC2S} c2s
         * @memberof Qot_RequestRehab.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_RequestRehab.Request
         * @static
         * @param {Qot_RequestRehab.IRequest=} [properties] Properties to set
         * @returns {Qot_RequestRehab.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_RequestRehab.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestRehab.Request
         * @static
         * @param {Qot_RequestRehab.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_RequestRehab.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_RequestRehab.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestRehab.Request
         * @static
         * @param {Qot_RequestRehab.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestRehab.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestRehab.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestRehab.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_RequestRehab.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestRehab.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestRehab.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_RequestRehab.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_RequestRehab.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestRehab.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestRehab.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestRehab.Request)
                return object;
            var message = new $root.Qot_RequestRehab.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_RequestRehab.Request.c2s: object expected");
                message.c2s = $root.Qot_RequestRehab.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestRehab.Request
         * @static
         * @param {Qot_RequestRehab.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_RequestRehab.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_RequestRehab.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_RequestRehab.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_RequestRehab
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_RequestRehab.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_RequestRehab
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_RequestRehab.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_RequestRehab.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_RequestRehab.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_RequestRehab.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_RequestRehab.IS2C|null|undefined} s2c
         * @memberof Qot_RequestRehab.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_RequestRehab.Response
         * @static
         * @param {Qot_RequestRehab.IResponse=} [properties] Properties to set
         * @returns {Qot_RequestRehab.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_RequestRehab.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestRehab.Response
         * @static
         * @param {Qot_RequestRehab.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_RequestRehab.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_RequestRehab.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestRehab.Response
         * @static
         * @param {Qot_RequestRehab.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestRehab.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestRehab.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestRehab.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_RequestRehab.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestRehab.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestRehab.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_RequestRehab.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_RequestRehab.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestRehab.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestRehab.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestRehab.Response)
                return object;
            var message = new $root.Qot_RequestRehab.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_RequestRehab.Response.s2c: object expected");
                message.s2c = $root.Qot_RequestRehab.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestRehab.Response
         * @static
         * @param {Qot_RequestRehab.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_RequestRehab.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_RequestRehab.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_RequestRehab;
})();

$root.Qot_RequestTradeDate = (function() {

    /**
     * Namespace Qot_RequestTradeDate.
     * @exports Qot_RequestTradeDate
     * @namespace
     */
    var Qot_RequestTradeDate = {};

    Qot_RequestTradeDate.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_RequestTradeDate
         * @interface IC2S
         * @property {number} market C2S market
         * @property {string} beginTime C2S beginTime
         * @property {string} endTime C2S endTime
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_RequestTradeDate
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_RequestTradeDate.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S market.
         * @member {number} market
         * @memberof Qot_RequestTradeDate.C2S
         * @instance
         */
        C2S.prototype.market = 0;

        /**
         * C2S beginTime.
         * @member {string} beginTime
         * @memberof Qot_RequestTradeDate.C2S
         * @instance
         */
        C2S.prototype.beginTime = "";

        /**
         * C2S endTime.
         * @member {string} endTime
         * @memberof Qot_RequestTradeDate.C2S
         * @instance
         */
        C2S.prototype.endTime = "";

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_RequestTradeDate.C2S
         * @static
         * @param {Qot_RequestTradeDate.IC2S=} [properties] Properties to set
         * @returns {Qot_RequestTradeDate.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_RequestTradeDate.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestTradeDate.C2S
         * @static
         * @param {Qot_RequestTradeDate.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.market);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.beginTime);
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.endTime);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_RequestTradeDate.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestTradeDate.C2S
         * @static
         * @param {Qot_RequestTradeDate.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestTradeDate.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestTradeDate.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestTradeDate.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.market = reader.int32();
                    break;
                case 2:
                    message.beginTime = reader.string();
                    break;
                case 3:
                    message.endTime = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("market"))
                throw $util.ProtocolError("missing required 'market'", { instance: message });
            if (!message.hasOwnProperty("beginTime"))
                throw $util.ProtocolError("missing required 'beginTime'", { instance: message });
            if (!message.hasOwnProperty("endTime"))
                throw $util.ProtocolError("missing required 'endTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestTradeDate.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestTradeDate.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_RequestTradeDate.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.market))
                return "market: integer expected";
            if (!$util.isString(message.beginTime))
                return "beginTime: string expected";
            if (!$util.isString(message.endTime))
                return "endTime: string expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestTradeDate.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestTradeDate.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestTradeDate.C2S)
                return object;
            var message = new $root.Qot_RequestTradeDate.C2S();
            if (object.market != null)
                message.market = object.market | 0;
            if (object.beginTime != null)
                message.beginTime = String(object.beginTime);
            if (object.endTime != null)
                message.endTime = String(object.endTime);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestTradeDate.C2S
         * @static
         * @param {Qot_RequestTradeDate.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.market = 0;
                object.beginTime = "";
                object.endTime = "";
            }
            if (message.market != null && message.hasOwnProperty("market"))
                object.market = message.market;
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                object.beginTime = message.beginTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_RequestTradeDate.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_RequestTradeDate.TradeDate = (function() {

        /**
         * Properties of a TradeDate.
         * @memberof Qot_RequestTradeDate
         * @interface ITradeDate
         * @property {string} time TradeDate time
         * @property {number|null} [timestamp] TradeDate timestamp
         * @property {number|null} [tradeDateType] TradeDate tradeDateType
         */

        /**
         * Constructs a new TradeDate.
         * @memberof Qot_RequestTradeDate
         * @classdesc Represents a TradeDate.
         * @implements ITradeDate
         * @constructor
         * @param {Qot_RequestTradeDate.ITradeDate=} [properties] Properties to set
         */
        function TradeDate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TradeDate time.
         * @member {string} time
         * @memberof Qot_RequestTradeDate.TradeDate
         * @instance
         */
        TradeDate.prototype.time = "";

        /**
         * TradeDate timestamp.
         * @member {number} timestamp
         * @memberof Qot_RequestTradeDate.TradeDate
         * @instance
         */
        TradeDate.prototype.timestamp = 0;

        /**
         * TradeDate tradeDateType.
         * @member {number} tradeDateType
         * @memberof Qot_RequestTradeDate.TradeDate
         * @instance
         */
        TradeDate.prototype.tradeDateType = 0;

        /**
         * Creates a new TradeDate instance using the specified properties.
         * @function create
         * @memberof Qot_RequestTradeDate.TradeDate
         * @static
         * @param {Qot_RequestTradeDate.ITradeDate=} [properties] Properties to set
         * @returns {Qot_RequestTradeDate.TradeDate} TradeDate instance
         */
        TradeDate.create = function create(properties) {
            return new TradeDate(properties);
        };

        /**
         * Encodes the specified TradeDate message. Does not implicitly {@link Qot_RequestTradeDate.TradeDate.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestTradeDate.TradeDate
         * @static
         * @param {Qot_RequestTradeDate.ITradeDate} message TradeDate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeDate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.time);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.timestamp);
            if (message.tradeDateType != null && message.hasOwnProperty("tradeDateType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.tradeDateType);
            return writer;
        };

        /**
         * Encodes the specified TradeDate message, length delimited. Does not implicitly {@link Qot_RequestTradeDate.TradeDate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestTradeDate.TradeDate
         * @static
         * @param {Qot_RequestTradeDate.ITradeDate} message TradeDate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeDate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TradeDate message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestTradeDate.TradeDate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestTradeDate.TradeDate} TradeDate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeDate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestTradeDate.TradeDate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.string();
                    break;
                case 2:
                    message.timestamp = reader.double();
                    break;
                case 3:
                    message.tradeDateType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("time"))
                throw $util.ProtocolError("missing required 'time'", { instance: message });
            return message;
        };

        /**
         * Decodes a TradeDate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestTradeDate.TradeDate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestTradeDate.TradeDate} TradeDate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeDate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TradeDate message.
         * @function verify
         * @memberof Qot_RequestTradeDate.TradeDate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TradeDate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.time))
                return "time: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp !== "number")
                    return "timestamp: number expected";
            if (message.tradeDateType != null && message.hasOwnProperty("tradeDateType"))
                if (!$util.isInteger(message.tradeDateType))
                    return "tradeDateType: integer expected";
            return null;
        };

        /**
         * Creates a TradeDate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestTradeDate.TradeDate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestTradeDate.TradeDate} TradeDate
         */
        TradeDate.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestTradeDate.TradeDate)
                return object;
            var message = new $root.Qot_RequestTradeDate.TradeDate();
            if (object.time != null)
                message.time = String(object.time);
            if (object.timestamp != null)
                message.timestamp = Number(object.timestamp);
            if (object.tradeDateType != null)
                message.tradeDateType = object.tradeDateType | 0;
            return message;
        };

        /**
         * Creates a plain object from a TradeDate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestTradeDate.TradeDate
         * @static
         * @param {Qot_RequestTradeDate.TradeDate} message TradeDate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TradeDate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.time = "";
                object.timestamp = 0;
                object.tradeDateType = 0;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            if (message.tradeDateType != null && message.hasOwnProperty("tradeDateType"))
                object.tradeDateType = message.tradeDateType;
            return object;
        };

        /**
         * Converts this TradeDate to JSON.
         * @function toJSON
         * @memberof Qot_RequestTradeDate.TradeDate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TradeDate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TradeDate;
    })();

    Qot_RequestTradeDate.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_RequestTradeDate
         * @interface IS2C
         * @property {Array.<Qot_RequestTradeDate.ITradeDate>|null} [tradeDateList] S2C tradeDateList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_RequestTradeDate
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_RequestTradeDate.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.tradeDateList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C tradeDateList.
         * @member {Array.<Qot_RequestTradeDate.ITradeDate>} tradeDateList
         * @memberof Qot_RequestTradeDate.S2C
         * @instance
         */
        S2C.prototype.tradeDateList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_RequestTradeDate.S2C
         * @static
         * @param {Qot_RequestTradeDate.IS2C=} [properties] Properties to set
         * @returns {Qot_RequestTradeDate.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_RequestTradeDate.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestTradeDate.S2C
         * @static
         * @param {Qot_RequestTradeDate.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tradeDateList != null && message.tradeDateList.length)
                for (var i = 0; i < message.tradeDateList.length; ++i)
                    $root.Qot_RequestTradeDate.TradeDate.encode(message.tradeDateList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_RequestTradeDate.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestTradeDate.S2C
         * @static
         * @param {Qot_RequestTradeDate.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestTradeDate.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestTradeDate.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestTradeDate.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.tradeDateList && message.tradeDateList.length))
                        message.tradeDateList = [];
                    message.tradeDateList.push($root.Qot_RequestTradeDate.TradeDate.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestTradeDate.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestTradeDate.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_RequestTradeDate.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tradeDateList != null && message.hasOwnProperty("tradeDateList")) {
                if (!Array.isArray(message.tradeDateList))
                    return "tradeDateList: array expected";
                for (var i = 0; i < message.tradeDateList.length; ++i) {
                    var error = $root.Qot_RequestTradeDate.TradeDate.verify(message.tradeDateList[i]);
                    if (error)
                        return "tradeDateList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestTradeDate.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestTradeDate.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestTradeDate.S2C)
                return object;
            var message = new $root.Qot_RequestTradeDate.S2C();
            if (object.tradeDateList) {
                if (!Array.isArray(object.tradeDateList))
                    throw TypeError(".Qot_RequestTradeDate.S2C.tradeDateList: array expected");
                message.tradeDateList = [];
                for (var i = 0; i < object.tradeDateList.length; ++i) {
                    if (typeof object.tradeDateList[i] !== "object")
                        throw TypeError(".Qot_RequestTradeDate.S2C.tradeDateList: object expected");
                    message.tradeDateList[i] = $root.Qot_RequestTradeDate.TradeDate.fromObject(object.tradeDateList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestTradeDate.S2C
         * @static
         * @param {Qot_RequestTradeDate.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tradeDateList = [];
            if (message.tradeDateList && message.tradeDateList.length) {
                object.tradeDateList = [];
                for (var j = 0; j < message.tradeDateList.length; ++j)
                    object.tradeDateList[j] = $root.Qot_RequestTradeDate.TradeDate.toObject(message.tradeDateList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_RequestTradeDate.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_RequestTradeDate.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_RequestTradeDate
         * @interface IRequest
         * @property {Qot_RequestTradeDate.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_RequestTradeDate
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_RequestTradeDate.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_RequestTradeDate.IC2S} c2s
         * @memberof Qot_RequestTradeDate.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_RequestTradeDate.Request
         * @static
         * @param {Qot_RequestTradeDate.IRequest=} [properties] Properties to set
         * @returns {Qot_RequestTradeDate.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_RequestTradeDate.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestTradeDate.Request
         * @static
         * @param {Qot_RequestTradeDate.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_RequestTradeDate.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_RequestTradeDate.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestTradeDate.Request
         * @static
         * @param {Qot_RequestTradeDate.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestTradeDate.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestTradeDate.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestTradeDate.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_RequestTradeDate.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestTradeDate.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestTradeDate.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_RequestTradeDate.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_RequestTradeDate.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestTradeDate.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestTradeDate.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestTradeDate.Request)
                return object;
            var message = new $root.Qot_RequestTradeDate.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_RequestTradeDate.Request.c2s: object expected");
                message.c2s = $root.Qot_RequestTradeDate.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestTradeDate.Request
         * @static
         * @param {Qot_RequestTradeDate.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_RequestTradeDate.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_RequestTradeDate.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_RequestTradeDate.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_RequestTradeDate
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_RequestTradeDate.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_RequestTradeDate
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_RequestTradeDate.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_RequestTradeDate.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_RequestTradeDate.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_RequestTradeDate.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_RequestTradeDate.IS2C|null|undefined} s2c
         * @memberof Qot_RequestTradeDate.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_RequestTradeDate.Response
         * @static
         * @param {Qot_RequestTradeDate.IResponse=} [properties] Properties to set
         * @returns {Qot_RequestTradeDate.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_RequestTradeDate.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestTradeDate.Response
         * @static
         * @param {Qot_RequestTradeDate.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_RequestTradeDate.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_RequestTradeDate.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestTradeDate.Response
         * @static
         * @param {Qot_RequestTradeDate.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestTradeDate.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestTradeDate.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestTradeDate.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_RequestTradeDate.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestTradeDate.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestTradeDate.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_RequestTradeDate.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_RequestTradeDate.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestTradeDate.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestTradeDate.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestTradeDate.Response)
                return object;
            var message = new $root.Qot_RequestTradeDate.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_RequestTradeDate.Response.s2c: object expected");
                message.s2c = $root.Qot_RequestTradeDate.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestTradeDate.Response
         * @static
         * @param {Qot_RequestTradeDate.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_RequestTradeDate.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_RequestTradeDate.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_RequestTradeDate;
})();

$root.Qot_SetPriceReminder = (function() {

    /**
     * Namespace Qot_SetPriceReminder.
     * @exports Qot_SetPriceReminder
     * @namespace
     */
    var Qot_SetPriceReminder = {};

    /**
     * SetPriceReminderOp enum.
     * @name Qot_SetPriceReminder.SetPriceReminderOp
     * @enum {string}
     * @property {number} SetPriceReminderOp_Unknown=0 SetPriceReminderOp_Unknown value
     * @property {number} SetPriceReminderOp_Add=1 SetPriceReminderOp_Add value
     * @property {number} SetPriceReminderOp_Del=2 SetPriceReminderOp_Del value
     * @property {number} SetPriceReminderOp_Enable=3 SetPriceReminderOp_Enable value
     * @property {number} SetPriceReminderOp_Disable=4 SetPriceReminderOp_Disable value
     * @property {number} SetPriceReminderOp_Modify=5 SetPriceReminderOp_Modify value
     */
    Qot_SetPriceReminder.SetPriceReminderOp = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SetPriceReminderOp_Unknown"] = 0;
        values[valuesById[1] = "SetPriceReminderOp_Add"] = 1;
        values[valuesById[2] = "SetPriceReminderOp_Del"] = 2;
        values[valuesById[3] = "SetPriceReminderOp_Enable"] = 3;
        values[valuesById[4] = "SetPriceReminderOp_Disable"] = 4;
        values[valuesById[5] = "SetPriceReminderOp_Modify"] = 5;
        return values;
    })();

    Qot_SetPriceReminder.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_SetPriceReminder
         * @interface IC2S
         * @property {Qot_Common.ISecurity} security C2S security
         * @property {number} op C2S op
         * @property {number|Long|null} [key] C2S key
         * @property {number|null} [type] C2S type
         * @property {number|null} [freq] C2S freq
         * @property {number|null} [value] C2S value
         * @property {string|null} [note] C2S note
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_SetPriceReminder
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_SetPriceReminder.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_SetPriceReminder.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * C2S op.
         * @member {number} op
         * @memberof Qot_SetPriceReminder.C2S
         * @instance
         */
        C2S.prototype.op = 0;

        /**
         * C2S key.
         * @member {number|Long} key
         * @memberof Qot_SetPriceReminder.C2S
         * @instance
         */
        C2S.prototype.key = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * C2S type.
         * @member {number} type
         * @memberof Qot_SetPriceReminder.C2S
         * @instance
         */
        C2S.prototype.type = 0;

        /**
         * C2S freq.
         * @member {number} freq
         * @memberof Qot_SetPriceReminder.C2S
         * @instance
         */
        C2S.prototype.freq = 0;

        /**
         * C2S value.
         * @member {number} value
         * @memberof Qot_SetPriceReminder.C2S
         * @instance
         */
        C2S.prototype.value = 0;

        /**
         * C2S note.
         * @member {string} note
         * @memberof Qot_SetPriceReminder.C2S
         * @instance
         */
        C2S.prototype.note = "";

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_SetPriceReminder.C2S
         * @static
         * @param {Qot_SetPriceReminder.IC2S=} [properties] Properties to set
         * @returns {Qot_SetPriceReminder.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_SetPriceReminder.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_SetPriceReminder.C2S
         * @static
         * @param {Qot_SetPriceReminder.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.op);
            if (message.key != null && message.hasOwnProperty("key"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.key);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.type);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.value);
            if (message.note != null && message.hasOwnProperty("note"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.note);
            if (message.freq != null && message.hasOwnProperty("freq"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.freq);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_SetPriceReminder.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_SetPriceReminder.C2S
         * @static
         * @param {Qot_SetPriceReminder.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_SetPriceReminder.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_SetPriceReminder.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_SetPriceReminder.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.op = reader.int32();
                    break;
                case 3:
                    message.key = reader.int64();
                    break;
                case 4:
                    message.type = reader.int32();
                    break;
                case 7:
                    message.freq = reader.int32();
                    break;
                case 5:
                    message.value = reader.double();
                    break;
                case 6:
                    message.note = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("op"))
                throw $util.ProtocolError("missing required 'op'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_SetPriceReminder.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_SetPriceReminder.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_SetPriceReminder.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (!$util.isInteger(message.op))
                return "op: integer expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isInteger(message.key) && !(message.key && $util.isInteger(message.key.low) && $util.isInteger(message.key.high)))
                    return "key: integer|Long expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.freq != null && message.hasOwnProperty("freq"))
                if (!$util.isInteger(message.freq))
                    return "freq: integer expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value !== "number")
                    return "value: number expected";
            if (message.note != null && message.hasOwnProperty("note"))
                if (!$util.isString(message.note))
                    return "note: string expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_SetPriceReminder.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_SetPriceReminder.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_SetPriceReminder.C2S)
                return object;
            var message = new $root.Qot_SetPriceReminder.C2S();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_SetPriceReminder.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.op != null)
                message.op = object.op | 0;
            if (object.key != null)
                if ($util.Long)
                    (message.key = $util.Long.fromValue(object.key)).unsigned = false;
                else if (typeof object.key === "string")
                    message.key = parseInt(object.key, 10);
                else if (typeof object.key === "number")
                    message.key = object.key;
                else if (typeof object.key === "object")
                    message.key = new $util.LongBits(object.key.low >>> 0, object.key.high >>> 0).toNumber();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.freq != null)
                message.freq = object.freq | 0;
            if (object.value != null)
                message.value = Number(object.value);
            if (object.note != null)
                message.note = String(object.note);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_SetPriceReminder.C2S
         * @static
         * @param {Qot_SetPriceReminder.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.security = null;
                object.op = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.key = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.key = options.longs === String ? "0" : 0;
                object.type = 0;
                object.value = 0;
                object.note = "";
                object.freq = 0;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.op != null && message.hasOwnProperty("op"))
                object.op = message.op;
            if (message.key != null && message.hasOwnProperty("key"))
                if (typeof message.key === "number")
                    object.key = options.longs === String ? String(message.key) : message.key;
                else
                    object.key = options.longs === String ? $util.Long.prototype.toString.call(message.key) : options.longs === Number ? new $util.LongBits(message.key.low >>> 0, message.key.high >>> 0).toNumber() : message.key;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
            if (message.note != null && message.hasOwnProperty("note"))
                object.note = message.note;
            if (message.freq != null && message.hasOwnProperty("freq"))
                object.freq = message.freq;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_SetPriceReminder.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_SetPriceReminder.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_SetPriceReminder
         * @interface IS2C
         * @property {number|Long} key S2C key
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_SetPriceReminder
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_SetPriceReminder.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C key.
         * @member {number|Long} key
         * @memberof Qot_SetPriceReminder.S2C
         * @instance
         */
        S2C.prototype.key = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_SetPriceReminder.S2C
         * @static
         * @param {Qot_SetPriceReminder.IS2C=} [properties] Properties to set
         * @returns {Qot_SetPriceReminder.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_SetPriceReminder.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_SetPriceReminder.S2C
         * @static
         * @param {Qot_SetPriceReminder.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.key);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_SetPriceReminder.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_SetPriceReminder.S2C
         * @static
         * @param {Qot_SetPriceReminder.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_SetPriceReminder.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_SetPriceReminder.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_SetPriceReminder.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("key"))
                throw $util.ProtocolError("missing required 'key'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_SetPriceReminder.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_SetPriceReminder.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_SetPriceReminder.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.key) && !(message.key && $util.isInteger(message.key.low) && $util.isInteger(message.key.high)))
                return "key: integer|Long expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_SetPriceReminder.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_SetPriceReminder.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_SetPriceReminder.S2C)
                return object;
            var message = new $root.Qot_SetPriceReminder.S2C();
            if (object.key != null)
                if ($util.Long)
                    (message.key = $util.Long.fromValue(object.key)).unsigned = false;
                else if (typeof object.key === "string")
                    message.key = parseInt(object.key, 10);
                else if (typeof object.key === "number")
                    message.key = object.key;
                else if (typeof object.key === "object")
                    message.key = new $util.LongBits(object.key.low >>> 0, object.key.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_SetPriceReminder.S2C
         * @static
         * @param {Qot_SetPriceReminder.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.key = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.key = options.longs === String ? "0" : 0;
            if (message.key != null && message.hasOwnProperty("key"))
                if (typeof message.key === "number")
                    object.key = options.longs === String ? String(message.key) : message.key;
                else
                    object.key = options.longs === String ? $util.Long.prototype.toString.call(message.key) : options.longs === Number ? new $util.LongBits(message.key.low >>> 0, message.key.high >>> 0).toNumber() : message.key;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_SetPriceReminder.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_SetPriceReminder.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_SetPriceReminder
         * @interface IRequest
         * @property {Qot_SetPriceReminder.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_SetPriceReminder
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_SetPriceReminder.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_SetPriceReminder.IC2S} c2s
         * @memberof Qot_SetPriceReminder.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_SetPriceReminder.Request
         * @static
         * @param {Qot_SetPriceReminder.IRequest=} [properties] Properties to set
         * @returns {Qot_SetPriceReminder.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_SetPriceReminder.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_SetPriceReminder.Request
         * @static
         * @param {Qot_SetPriceReminder.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_SetPriceReminder.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_SetPriceReminder.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_SetPriceReminder.Request
         * @static
         * @param {Qot_SetPriceReminder.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_SetPriceReminder.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_SetPriceReminder.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_SetPriceReminder.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_SetPriceReminder.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_SetPriceReminder.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_SetPriceReminder.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_SetPriceReminder.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_SetPriceReminder.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_SetPriceReminder.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_SetPriceReminder.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_SetPriceReminder.Request)
                return object;
            var message = new $root.Qot_SetPriceReminder.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_SetPriceReminder.Request.c2s: object expected");
                message.c2s = $root.Qot_SetPriceReminder.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_SetPriceReminder.Request
         * @static
         * @param {Qot_SetPriceReminder.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_SetPriceReminder.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_SetPriceReminder.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_SetPriceReminder.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_SetPriceReminder
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_SetPriceReminder.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_SetPriceReminder
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_SetPriceReminder.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_SetPriceReminder.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_SetPriceReminder.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_SetPriceReminder.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_SetPriceReminder.IS2C|null|undefined} s2c
         * @memberof Qot_SetPriceReminder.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_SetPriceReminder.Response
         * @static
         * @param {Qot_SetPriceReminder.IResponse=} [properties] Properties to set
         * @returns {Qot_SetPriceReminder.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_SetPriceReminder.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_SetPriceReminder.Response
         * @static
         * @param {Qot_SetPriceReminder.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_SetPriceReminder.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_SetPriceReminder.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_SetPriceReminder.Response
         * @static
         * @param {Qot_SetPriceReminder.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_SetPriceReminder.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_SetPriceReminder.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_SetPriceReminder.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_SetPriceReminder.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_SetPriceReminder.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_SetPriceReminder.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_SetPriceReminder.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_SetPriceReminder.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_SetPriceReminder.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_SetPriceReminder.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_SetPriceReminder.Response)
                return object;
            var message = new $root.Qot_SetPriceReminder.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_SetPriceReminder.Response.s2c: object expected");
                message.s2c = $root.Qot_SetPriceReminder.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_SetPriceReminder.Response
         * @static
         * @param {Qot_SetPriceReminder.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_SetPriceReminder.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_SetPriceReminder.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_SetPriceReminder;
})();

$root.Qot_StockFilter = (function() {

    /**
     * Namespace Qot_StockFilter.
     * @exports Qot_StockFilter
     * @namespace
     */
    var Qot_StockFilter = {};

    /**
     * StockField enum.
     * @name Qot_StockFilter.StockField
     * @enum {string}
     * @property {number} StockField_Unknown=0 StockField_Unknown value
     * @property {number} StockField_StockCode=1 StockField_StockCode value
     * @property {number} StockField_StockName=2 StockField_StockName value
     * @property {number} StockField_CurPrice=3 StockField_CurPrice value
     * @property {number} StockField_CurPriceToHighest52WeeksRatio=4 StockField_CurPriceToHighest52WeeksRatio value
     * @property {number} StockField_CurPriceToLowest52WeeksRatio=5 StockField_CurPriceToLowest52WeeksRatio value
     * @property {number} StockField_HighPriceToHighest52WeeksRatio=6 StockField_HighPriceToHighest52WeeksRatio value
     * @property {number} StockField_LowPriceToLowest52WeeksRatio=7 StockField_LowPriceToLowest52WeeksRatio value
     * @property {number} StockField_VolumeRatio=8 StockField_VolumeRatio value
     * @property {number} StockField_BidAskRatio=9 StockField_BidAskRatio value
     * @property {number} StockField_LotPrice=10 StockField_LotPrice value
     * @property {number} StockField_MarketVal=11 StockField_MarketVal value
     * @property {number} StockField_PeAnnual=12 StockField_PeAnnual value
     * @property {number} StockField_PeTTM=13 StockField_PeTTM value
     * @property {number} StockField_PbRate=14 StockField_PbRate value
     * @property {number} StockField_ChangeRate5min=15 StockField_ChangeRate5min value
     * @property {number} StockField_ChangeRateBeginYear=16 StockField_ChangeRateBeginYear value
     * @property {number} StockField_PSTTM=17 StockField_PSTTM value
     * @property {number} StockField_PCFTTM=18 StockField_PCFTTM value
     * @property {number} StockField_TotalShare=19 StockField_TotalShare value
     * @property {number} StockField_FloatShare=20 StockField_FloatShare value
     * @property {number} StockField_FloatMarketVal=21 StockField_FloatMarketVal value
     */
    Qot_StockFilter.StockField = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "StockField_Unknown"] = 0;
        values[valuesById[1] = "StockField_StockCode"] = 1;
        values[valuesById[2] = "StockField_StockName"] = 2;
        values[valuesById[3] = "StockField_CurPrice"] = 3;
        values[valuesById[4] = "StockField_CurPriceToHighest52WeeksRatio"] = 4;
        values[valuesById[5] = "StockField_CurPriceToLowest52WeeksRatio"] = 5;
        values[valuesById[6] = "StockField_HighPriceToHighest52WeeksRatio"] = 6;
        values[valuesById[7] = "StockField_LowPriceToLowest52WeeksRatio"] = 7;
        values[valuesById[8] = "StockField_VolumeRatio"] = 8;
        values[valuesById[9] = "StockField_BidAskRatio"] = 9;
        values[valuesById[10] = "StockField_LotPrice"] = 10;
        values[valuesById[11] = "StockField_MarketVal"] = 11;
        values[valuesById[12] = "StockField_PeAnnual"] = 12;
        values[valuesById[13] = "StockField_PeTTM"] = 13;
        values[valuesById[14] = "StockField_PbRate"] = 14;
        values[valuesById[15] = "StockField_ChangeRate5min"] = 15;
        values[valuesById[16] = "StockField_ChangeRateBeginYear"] = 16;
        values[valuesById[17] = "StockField_PSTTM"] = 17;
        values[valuesById[18] = "StockField_PCFTTM"] = 18;
        values[valuesById[19] = "StockField_TotalShare"] = 19;
        values[valuesById[20] = "StockField_FloatShare"] = 20;
        values[valuesById[21] = "StockField_FloatMarketVal"] = 21;
        return values;
    })();

    /**
     * AccumulateField enum.
     * @name Qot_StockFilter.AccumulateField
     * @enum {string}
     * @property {number} AccumulateField_Unknown=0 AccumulateField_Unknown value
     * @property {number} AccumulateField_ChangeRate=1 AccumulateField_ChangeRate value
     * @property {number} AccumulateField_Amplitude=2 AccumulateField_Amplitude value
     * @property {number} AccumulateField_Volume=3 AccumulateField_Volume value
     * @property {number} AccumulateField_Turnover=4 AccumulateField_Turnover value
     * @property {number} AccumulateField_TurnoverRate=5 AccumulateField_TurnoverRate value
     */
    Qot_StockFilter.AccumulateField = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "AccumulateField_Unknown"] = 0;
        values[valuesById[1] = "AccumulateField_ChangeRate"] = 1;
        values[valuesById[2] = "AccumulateField_Amplitude"] = 2;
        values[valuesById[3] = "AccumulateField_Volume"] = 3;
        values[valuesById[4] = "AccumulateField_Turnover"] = 4;
        values[valuesById[5] = "AccumulateField_TurnoverRate"] = 5;
        return values;
    })();

    /**
     * FinancialField enum.
     * @name Qot_StockFilter.FinancialField
     * @enum {string}
     * @property {number} FinancialField_Unknown=0 FinancialField_Unknown value
     * @property {number} FinancialField_NetProfit=1 FinancialField_NetProfit value
     * @property {number} FinancialField_NetProfitGrowth=2 FinancialField_NetProfitGrowth value
     * @property {number} FinancialField_SumOfBusiness=3 FinancialField_SumOfBusiness value
     * @property {number} FinancialField_SumOfBusinessGrowth=4 FinancialField_SumOfBusinessGrowth value
     * @property {number} FinancialField_NetProfitRate=5 FinancialField_NetProfitRate value
     * @property {number} FinancialField_GrossProfitRate=6 FinancialField_GrossProfitRate value
     * @property {number} FinancialField_DebtAssetsRate=7 FinancialField_DebtAssetsRate value
     * @property {number} FinancialField_ReturnOnEquityRate=8 FinancialField_ReturnOnEquityRate value
     * @property {number} FinancialField_ROIC=9 FinancialField_ROIC value
     * @property {number} FinancialField_ROATTM=10 FinancialField_ROATTM value
     * @property {number} FinancialField_EBITTTM=11 FinancialField_EBITTTM value
     * @property {number} FinancialField_EBITDA=12 FinancialField_EBITDA value
     * @property {number} FinancialField_OperatingMarginTTM=13 FinancialField_OperatingMarginTTM value
     * @property {number} FinancialField_EBITMargin=14 FinancialField_EBITMargin value
     * @property {number} FinancialField_EBITDAMargin=15 FinancialField_EBITDAMargin value
     * @property {number} FinancialField_FinancialCostRate=16 FinancialField_FinancialCostRate value
     * @property {number} FinancialField_OperatingProfitTTM=17 FinancialField_OperatingProfitTTM value
     * @property {number} FinancialField_ShareholderNetProfitTTM=18 FinancialField_ShareholderNetProfitTTM value
     * @property {number} FinancialField_NetProfitCashCoverTTM=19 FinancialField_NetProfitCashCoverTTM value
     * @property {number} FinancialField_CurrentRatio=20 FinancialField_CurrentRatio value
     * @property {number} FinancialField_QuickRatio=21 FinancialField_QuickRatio value
     * @property {number} FinancialField_CurrentAssetRatio=22 FinancialField_CurrentAssetRatio value
     * @property {number} FinancialField_CurrentDebtRatio=23 FinancialField_CurrentDebtRatio value
     * @property {number} FinancialField_EquityMultiplier=24 FinancialField_EquityMultiplier value
     * @property {number} FinancialField_PropertyRatio=25 FinancialField_PropertyRatio value
     * @property {number} FinancialField_CashAndCashEquivalents=26 FinancialField_CashAndCashEquivalents value
     * @property {number} FinancialField_TotalAssetTurnover=27 FinancialField_TotalAssetTurnover value
     * @property {number} FinancialField_FixedAssetTurnover=28 FinancialField_FixedAssetTurnover value
     * @property {number} FinancialField_InventoryTurnover=29 FinancialField_InventoryTurnover value
     * @property {number} FinancialField_OperatingCashFlowTTM=30 FinancialField_OperatingCashFlowTTM value
     * @property {number} FinancialField_AccountsReceivable=31 FinancialField_AccountsReceivable value
     * @property {number} FinancialField_EBITGrowthRate=32 FinancialField_EBITGrowthRate value
     * @property {number} FinancialField_OperatingProfitGrowthRate=33 FinancialField_OperatingProfitGrowthRate value
     * @property {number} FinancialField_TotalAssetsGrowthRate=34 FinancialField_TotalAssetsGrowthRate value
     * @property {number} FinancialField_ProfitToShareholdersGrowthRate=35 FinancialField_ProfitToShareholdersGrowthRate value
     * @property {number} FinancialField_ProfitBeforeTaxGrowthRate=36 FinancialField_ProfitBeforeTaxGrowthRate value
     * @property {number} FinancialField_EPSGrowthRate=37 FinancialField_EPSGrowthRate value
     * @property {number} FinancialField_ROEGrowthRate=38 FinancialField_ROEGrowthRate value
     * @property {number} FinancialField_ROICGrowthRate=39 FinancialField_ROICGrowthRate value
     * @property {number} FinancialField_NOCFGrowthRate=40 FinancialField_NOCFGrowthRate value
     * @property {number} FinancialField_NOCFPerShareGrowthRate=41 FinancialField_NOCFPerShareGrowthRate value
     * @property {number} FinancialField_OperatingRevenueCashCover=42 FinancialField_OperatingRevenueCashCover value
     * @property {number} FinancialField_OperatingProfitToTotalProfit=43 FinancialField_OperatingProfitToTotalProfit value
     * @property {number} FinancialField_BasicEPS=44 FinancialField_BasicEPS value
     * @property {number} FinancialField_DilutedEPS=45 FinancialField_DilutedEPS value
     * @property {number} FinancialField_NOCFPerShare=46 FinancialField_NOCFPerShare value
     */
    Qot_StockFilter.FinancialField = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FinancialField_Unknown"] = 0;
        values[valuesById[1] = "FinancialField_NetProfit"] = 1;
        values[valuesById[2] = "FinancialField_NetProfitGrowth"] = 2;
        values[valuesById[3] = "FinancialField_SumOfBusiness"] = 3;
        values[valuesById[4] = "FinancialField_SumOfBusinessGrowth"] = 4;
        values[valuesById[5] = "FinancialField_NetProfitRate"] = 5;
        values[valuesById[6] = "FinancialField_GrossProfitRate"] = 6;
        values[valuesById[7] = "FinancialField_DebtAssetsRate"] = 7;
        values[valuesById[8] = "FinancialField_ReturnOnEquityRate"] = 8;
        values[valuesById[9] = "FinancialField_ROIC"] = 9;
        values[valuesById[10] = "FinancialField_ROATTM"] = 10;
        values[valuesById[11] = "FinancialField_EBITTTM"] = 11;
        values[valuesById[12] = "FinancialField_EBITDA"] = 12;
        values[valuesById[13] = "FinancialField_OperatingMarginTTM"] = 13;
        values[valuesById[14] = "FinancialField_EBITMargin"] = 14;
        values[valuesById[15] = "FinancialField_EBITDAMargin"] = 15;
        values[valuesById[16] = "FinancialField_FinancialCostRate"] = 16;
        values[valuesById[17] = "FinancialField_OperatingProfitTTM"] = 17;
        values[valuesById[18] = "FinancialField_ShareholderNetProfitTTM"] = 18;
        values[valuesById[19] = "FinancialField_NetProfitCashCoverTTM"] = 19;
        values[valuesById[20] = "FinancialField_CurrentRatio"] = 20;
        values[valuesById[21] = "FinancialField_QuickRatio"] = 21;
        values[valuesById[22] = "FinancialField_CurrentAssetRatio"] = 22;
        values[valuesById[23] = "FinancialField_CurrentDebtRatio"] = 23;
        values[valuesById[24] = "FinancialField_EquityMultiplier"] = 24;
        values[valuesById[25] = "FinancialField_PropertyRatio"] = 25;
        values[valuesById[26] = "FinancialField_CashAndCashEquivalents"] = 26;
        values[valuesById[27] = "FinancialField_TotalAssetTurnover"] = 27;
        values[valuesById[28] = "FinancialField_FixedAssetTurnover"] = 28;
        values[valuesById[29] = "FinancialField_InventoryTurnover"] = 29;
        values[valuesById[30] = "FinancialField_OperatingCashFlowTTM"] = 30;
        values[valuesById[31] = "FinancialField_AccountsReceivable"] = 31;
        values[valuesById[32] = "FinancialField_EBITGrowthRate"] = 32;
        values[valuesById[33] = "FinancialField_OperatingProfitGrowthRate"] = 33;
        values[valuesById[34] = "FinancialField_TotalAssetsGrowthRate"] = 34;
        values[valuesById[35] = "FinancialField_ProfitToShareholdersGrowthRate"] = 35;
        values[valuesById[36] = "FinancialField_ProfitBeforeTaxGrowthRate"] = 36;
        values[valuesById[37] = "FinancialField_EPSGrowthRate"] = 37;
        values[valuesById[38] = "FinancialField_ROEGrowthRate"] = 38;
        values[valuesById[39] = "FinancialField_ROICGrowthRate"] = 39;
        values[valuesById[40] = "FinancialField_NOCFGrowthRate"] = 40;
        values[valuesById[41] = "FinancialField_NOCFPerShareGrowthRate"] = 41;
        values[valuesById[42] = "FinancialField_OperatingRevenueCashCover"] = 42;
        values[valuesById[43] = "FinancialField_OperatingProfitToTotalProfit"] = 43;
        values[valuesById[44] = "FinancialField_BasicEPS"] = 44;
        values[valuesById[45] = "FinancialField_DilutedEPS"] = 45;
        values[valuesById[46] = "FinancialField_NOCFPerShare"] = 46;
        return values;
    })();

    /**
     * FinancialQuarter enum.
     * @name Qot_StockFilter.FinancialQuarter
     * @enum {string}
     * @property {number} FinancialQuarter_Unknown=0 FinancialQuarter_Unknown value
     * @property {number} FinancialQuarter_Annual=1 FinancialQuarter_Annual value
     * @property {number} FinancialQuarter_FirstQuarter=2 FinancialQuarter_FirstQuarter value
     * @property {number} FinancialQuarter_Interim=3 FinancialQuarter_Interim value
     * @property {number} FinancialQuarter_ThirdQuarter=4 FinancialQuarter_ThirdQuarter value
     * @property {number} FinancialQuarter_MostRecentQuarter=5 FinancialQuarter_MostRecentQuarter value
     */
    Qot_StockFilter.FinancialQuarter = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FinancialQuarter_Unknown"] = 0;
        values[valuesById[1] = "FinancialQuarter_Annual"] = 1;
        values[valuesById[2] = "FinancialQuarter_FirstQuarter"] = 2;
        values[valuesById[3] = "FinancialQuarter_Interim"] = 3;
        values[valuesById[4] = "FinancialQuarter_ThirdQuarter"] = 4;
        values[valuesById[5] = "FinancialQuarter_MostRecentQuarter"] = 5;
        return values;
    })();

    /**
     * SortDir enum.
     * @name Qot_StockFilter.SortDir
     * @enum {string}
     * @property {number} SortDir_No=0 SortDir_No value
     * @property {number} SortDir_Ascend=1 SortDir_Ascend value
     * @property {number} SortDir_Descend=2 SortDir_Descend value
     */
    Qot_StockFilter.SortDir = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SortDir_No"] = 0;
        values[valuesById[1] = "SortDir_Ascend"] = 1;
        values[valuesById[2] = "SortDir_Descend"] = 2;
        return values;
    })();

    Qot_StockFilter.BaseFilter = (function() {

        /**
         * Properties of a BaseFilter.
         * @memberof Qot_StockFilter
         * @interface IBaseFilter
         * @property {number} fieldName BaseFilter fieldName
         * @property {number|null} [filterMin] BaseFilter filterMin
         * @property {number|null} [filterMax] BaseFilter filterMax
         * @property {boolean|null} [isNoFilter] BaseFilter isNoFilter
         * @property {number|null} [sortDir] BaseFilter sortDir
         */

        /**
         * Constructs a new BaseFilter.
         * @memberof Qot_StockFilter
         * @classdesc Represents a BaseFilter.
         * @implements IBaseFilter
         * @constructor
         * @param {Qot_StockFilter.IBaseFilter=} [properties] Properties to set
         */
        function BaseFilter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BaseFilter fieldName.
         * @member {number} fieldName
         * @memberof Qot_StockFilter.BaseFilter
         * @instance
         */
        BaseFilter.prototype.fieldName = 0;

        /**
         * BaseFilter filterMin.
         * @member {number} filterMin
         * @memberof Qot_StockFilter.BaseFilter
         * @instance
         */
        BaseFilter.prototype.filterMin = 0;

        /**
         * BaseFilter filterMax.
         * @member {number} filterMax
         * @memberof Qot_StockFilter.BaseFilter
         * @instance
         */
        BaseFilter.prototype.filterMax = 0;

        /**
         * BaseFilter isNoFilter.
         * @member {boolean} isNoFilter
         * @memberof Qot_StockFilter.BaseFilter
         * @instance
         */
        BaseFilter.prototype.isNoFilter = false;

        /**
         * BaseFilter sortDir.
         * @member {number} sortDir
         * @memberof Qot_StockFilter.BaseFilter
         * @instance
         */
        BaseFilter.prototype.sortDir = 0;

        /**
         * Creates a new BaseFilter instance using the specified properties.
         * @function create
         * @memberof Qot_StockFilter.BaseFilter
         * @static
         * @param {Qot_StockFilter.IBaseFilter=} [properties] Properties to set
         * @returns {Qot_StockFilter.BaseFilter} BaseFilter instance
         */
        BaseFilter.create = function create(properties) {
            return new BaseFilter(properties);
        };

        /**
         * Encodes the specified BaseFilter message. Does not implicitly {@link Qot_StockFilter.BaseFilter.verify|verify} messages.
         * @function encode
         * @memberof Qot_StockFilter.BaseFilter
         * @static
         * @param {Qot_StockFilter.IBaseFilter} message BaseFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BaseFilter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fieldName);
            if (message.filterMin != null && message.hasOwnProperty("filterMin"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.filterMin);
            if (message.filterMax != null && message.hasOwnProperty("filterMax"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.filterMax);
            if (message.isNoFilter != null && message.hasOwnProperty("isNoFilter"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isNoFilter);
            if (message.sortDir != null && message.hasOwnProperty("sortDir"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.sortDir);
            return writer;
        };

        /**
         * Encodes the specified BaseFilter message, length delimited. Does not implicitly {@link Qot_StockFilter.BaseFilter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_StockFilter.BaseFilter
         * @static
         * @param {Qot_StockFilter.IBaseFilter} message BaseFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BaseFilter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BaseFilter message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_StockFilter.BaseFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_StockFilter.BaseFilter} BaseFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BaseFilter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_StockFilter.BaseFilter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fieldName = reader.int32();
                    break;
                case 2:
                    message.filterMin = reader.double();
                    break;
                case 3:
                    message.filterMax = reader.double();
                    break;
                case 4:
                    message.isNoFilter = reader.bool();
                    break;
                case 5:
                    message.sortDir = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("fieldName"))
                throw $util.ProtocolError("missing required 'fieldName'", { instance: message });
            return message;
        };

        /**
         * Decodes a BaseFilter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_StockFilter.BaseFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_StockFilter.BaseFilter} BaseFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BaseFilter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BaseFilter message.
         * @function verify
         * @memberof Qot_StockFilter.BaseFilter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BaseFilter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.fieldName))
                return "fieldName: integer expected";
            if (message.filterMin != null && message.hasOwnProperty("filterMin"))
                if (typeof message.filterMin !== "number")
                    return "filterMin: number expected";
            if (message.filterMax != null && message.hasOwnProperty("filterMax"))
                if (typeof message.filterMax !== "number")
                    return "filterMax: number expected";
            if (message.isNoFilter != null && message.hasOwnProperty("isNoFilter"))
                if (typeof message.isNoFilter !== "boolean")
                    return "isNoFilter: boolean expected";
            if (message.sortDir != null && message.hasOwnProperty("sortDir"))
                if (!$util.isInteger(message.sortDir))
                    return "sortDir: integer expected";
            return null;
        };

        /**
         * Creates a BaseFilter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_StockFilter.BaseFilter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_StockFilter.BaseFilter} BaseFilter
         */
        BaseFilter.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_StockFilter.BaseFilter)
                return object;
            var message = new $root.Qot_StockFilter.BaseFilter();
            if (object.fieldName != null)
                message.fieldName = object.fieldName | 0;
            if (object.filterMin != null)
                message.filterMin = Number(object.filterMin);
            if (object.filterMax != null)
                message.filterMax = Number(object.filterMax);
            if (object.isNoFilter != null)
                message.isNoFilter = Boolean(object.isNoFilter);
            if (object.sortDir != null)
                message.sortDir = object.sortDir | 0;
            return message;
        };

        /**
         * Creates a plain object from a BaseFilter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_StockFilter.BaseFilter
         * @static
         * @param {Qot_StockFilter.BaseFilter} message BaseFilter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BaseFilter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fieldName = 0;
                object.filterMin = 0;
                object.filterMax = 0;
                object.isNoFilter = false;
                object.sortDir = 0;
            }
            if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                object.fieldName = message.fieldName;
            if (message.filterMin != null && message.hasOwnProperty("filterMin"))
                object.filterMin = options.json && !isFinite(message.filterMin) ? String(message.filterMin) : message.filterMin;
            if (message.filterMax != null && message.hasOwnProperty("filterMax"))
                object.filterMax = options.json && !isFinite(message.filterMax) ? String(message.filterMax) : message.filterMax;
            if (message.isNoFilter != null && message.hasOwnProperty("isNoFilter"))
                object.isNoFilter = message.isNoFilter;
            if (message.sortDir != null && message.hasOwnProperty("sortDir"))
                object.sortDir = message.sortDir;
            return object;
        };

        /**
         * Converts this BaseFilter to JSON.
         * @function toJSON
         * @memberof Qot_StockFilter.BaseFilter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BaseFilter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BaseFilter;
    })();

    Qot_StockFilter.AccumulateFilter = (function() {

        /**
         * Properties of an AccumulateFilter.
         * @memberof Qot_StockFilter
         * @interface IAccumulateFilter
         * @property {number} fieldName AccumulateFilter fieldName
         * @property {number|null} [filterMin] AccumulateFilter filterMin
         * @property {number|null} [filterMax] AccumulateFilter filterMax
         * @property {boolean|null} [isNoFilter] AccumulateFilter isNoFilter
         * @property {number|null} [sortDir] AccumulateFilter sortDir
         * @property {number} days AccumulateFilter days
         */

        /**
         * Constructs a new AccumulateFilter.
         * @memberof Qot_StockFilter
         * @classdesc Represents an AccumulateFilter.
         * @implements IAccumulateFilter
         * @constructor
         * @param {Qot_StockFilter.IAccumulateFilter=} [properties] Properties to set
         */
        function AccumulateFilter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccumulateFilter fieldName.
         * @member {number} fieldName
         * @memberof Qot_StockFilter.AccumulateFilter
         * @instance
         */
        AccumulateFilter.prototype.fieldName = 0;

        /**
         * AccumulateFilter filterMin.
         * @member {number} filterMin
         * @memberof Qot_StockFilter.AccumulateFilter
         * @instance
         */
        AccumulateFilter.prototype.filterMin = 0;

        /**
         * AccumulateFilter filterMax.
         * @member {number} filterMax
         * @memberof Qot_StockFilter.AccumulateFilter
         * @instance
         */
        AccumulateFilter.prototype.filterMax = 0;

        /**
         * AccumulateFilter isNoFilter.
         * @member {boolean} isNoFilter
         * @memberof Qot_StockFilter.AccumulateFilter
         * @instance
         */
        AccumulateFilter.prototype.isNoFilter = false;

        /**
         * AccumulateFilter sortDir.
         * @member {number} sortDir
         * @memberof Qot_StockFilter.AccumulateFilter
         * @instance
         */
        AccumulateFilter.prototype.sortDir = 0;

        /**
         * AccumulateFilter days.
         * @member {number} days
         * @memberof Qot_StockFilter.AccumulateFilter
         * @instance
         */
        AccumulateFilter.prototype.days = 0;

        /**
         * Creates a new AccumulateFilter instance using the specified properties.
         * @function create
         * @memberof Qot_StockFilter.AccumulateFilter
         * @static
         * @param {Qot_StockFilter.IAccumulateFilter=} [properties] Properties to set
         * @returns {Qot_StockFilter.AccumulateFilter} AccumulateFilter instance
         */
        AccumulateFilter.create = function create(properties) {
            return new AccumulateFilter(properties);
        };

        /**
         * Encodes the specified AccumulateFilter message. Does not implicitly {@link Qot_StockFilter.AccumulateFilter.verify|verify} messages.
         * @function encode
         * @memberof Qot_StockFilter.AccumulateFilter
         * @static
         * @param {Qot_StockFilter.IAccumulateFilter} message AccumulateFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccumulateFilter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fieldName);
            if (message.filterMin != null && message.hasOwnProperty("filterMin"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.filterMin);
            if (message.filterMax != null && message.hasOwnProperty("filterMax"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.filterMax);
            if (message.isNoFilter != null && message.hasOwnProperty("isNoFilter"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isNoFilter);
            if (message.sortDir != null && message.hasOwnProperty("sortDir"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.sortDir);
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.days);
            return writer;
        };

        /**
         * Encodes the specified AccumulateFilter message, length delimited. Does not implicitly {@link Qot_StockFilter.AccumulateFilter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_StockFilter.AccumulateFilter
         * @static
         * @param {Qot_StockFilter.IAccumulateFilter} message AccumulateFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccumulateFilter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccumulateFilter message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_StockFilter.AccumulateFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_StockFilter.AccumulateFilter} AccumulateFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccumulateFilter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_StockFilter.AccumulateFilter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fieldName = reader.int32();
                    break;
                case 2:
                    message.filterMin = reader.double();
                    break;
                case 3:
                    message.filterMax = reader.double();
                    break;
                case 4:
                    message.isNoFilter = reader.bool();
                    break;
                case 5:
                    message.sortDir = reader.int32();
                    break;
                case 6:
                    message.days = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("fieldName"))
                throw $util.ProtocolError("missing required 'fieldName'", { instance: message });
            if (!message.hasOwnProperty("days"))
                throw $util.ProtocolError("missing required 'days'", { instance: message });
            return message;
        };

        /**
         * Decodes an AccumulateFilter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_StockFilter.AccumulateFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_StockFilter.AccumulateFilter} AccumulateFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccumulateFilter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccumulateFilter message.
         * @function verify
         * @memberof Qot_StockFilter.AccumulateFilter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccumulateFilter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.fieldName))
                return "fieldName: integer expected";
            if (message.filterMin != null && message.hasOwnProperty("filterMin"))
                if (typeof message.filterMin !== "number")
                    return "filterMin: number expected";
            if (message.filterMax != null && message.hasOwnProperty("filterMax"))
                if (typeof message.filterMax !== "number")
                    return "filterMax: number expected";
            if (message.isNoFilter != null && message.hasOwnProperty("isNoFilter"))
                if (typeof message.isNoFilter !== "boolean")
                    return "isNoFilter: boolean expected";
            if (message.sortDir != null && message.hasOwnProperty("sortDir"))
                if (!$util.isInteger(message.sortDir))
                    return "sortDir: integer expected";
            if (!$util.isInteger(message.days))
                return "days: integer expected";
            return null;
        };

        /**
         * Creates an AccumulateFilter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_StockFilter.AccumulateFilter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_StockFilter.AccumulateFilter} AccumulateFilter
         */
        AccumulateFilter.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_StockFilter.AccumulateFilter)
                return object;
            var message = new $root.Qot_StockFilter.AccumulateFilter();
            if (object.fieldName != null)
                message.fieldName = object.fieldName | 0;
            if (object.filterMin != null)
                message.filterMin = Number(object.filterMin);
            if (object.filterMax != null)
                message.filterMax = Number(object.filterMax);
            if (object.isNoFilter != null)
                message.isNoFilter = Boolean(object.isNoFilter);
            if (object.sortDir != null)
                message.sortDir = object.sortDir | 0;
            if (object.days != null)
                message.days = object.days | 0;
            return message;
        };

        /**
         * Creates a plain object from an AccumulateFilter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_StockFilter.AccumulateFilter
         * @static
         * @param {Qot_StockFilter.AccumulateFilter} message AccumulateFilter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccumulateFilter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fieldName = 0;
                object.filterMin = 0;
                object.filterMax = 0;
                object.isNoFilter = false;
                object.sortDir = 0;
                object.days = 0;
            }
            if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                object.fieldName = message.fieldName;
            if (message.filterMin != null && message.hasOwnProperty("filterMin"))
                object.filterMin = options.json && !isFinite(message.filterMin) ? String(message.filterMin) : message.filterMin;
            if (message.filterMax != null && message.hasOwnProperty("filterMax"))
                object.filterMax = options.json && !isFinite(message.filterMax) ? String(message.filterMax) : message.filterMax;
            if (message.isNoFilter != null && message.hasOwnProperty("isNoFilter"))
                object.isNoFilter = message.isNoFilter;
            if (message.sortDir != null && message.hasOwnProperty("sortDir"))
                object.sortDir = message.sortDir;
            if (message.days != null && message.hasOwnProperty("days"))
                object.days = message.days;
            return object;
        };

        /**
         * Converts this AccumulateFilter to JSON.
         * @function toJSON
         * @memberof Qot_StockFilter.AccumulateFilter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccumulateFilter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccumulateFilter;
    })();

    Qot_StockFilter.FinancialFilter = (function() {

        /**
         * Properties of a FinancialFilter.
         * @memberof Qot_StockFilter
         * @interface IFinancialFilter
         * @property {number} fieldName FinancialFilter fieldName
         * @property {number|null} [filterMin] FinancialFilter filterMin
         * @property {number|null} [filterMax] FinancialFilter filterMax
         * @property {boolean|null} [isNoFilter] FinancialFilter isNoFilter
         * @property {number|null} [sortDir] FinancialFilter sortDir
         * @property {number} quarter FinancialFilter quarter
         */

        /**
         * Constructs a new FinancialFilter.
         * @memberof Qot_StockFilter
         * @classdesc Represents a FinancialFilter.
         * @implements IFinancialFilter
         * @constructor
         * @param {Qot_StockFilter.IFinancialFilter=} [properties] Properties to set
         */
        function FinancialFilter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FinancialFilter fieldName.
         * @member {number} fieldName
         * @memberof Qot_StockFilter.FinancialFilter
         * @instance
         */
        FinancialFilter.prototype.fieldName = 0;

        /**
         * FinancialFilter filterMin.
         * @member {number} filterMin
         * @memberof Qot_StockFilter.FinancialFilter
         * @instance
         */
        FinancialFilter.prototype.filterMin = 0;

        /**
         * FinancialFilter filterMax.
         * @member {number} filterMax
         * @memberof Qot_StockFilter.FinancialFilter
         * @instance
         */
        FinancialFilter.prototype.filterMax = 0;

        /**
         * FinancialFilter isNoFilter.
         * @member {boolean} isNoFilter
         * @memberof Qot_StockFilter.FinancialFilter
         * @instance
         */
        FinancialFilter.prototype.isNoFilter = false;

        /**
         * FinancialFilter sortDir.
         * @member {number} sortDir
         * @memberof Qot_StockFilter.FinancialFilter
         * @instance
         */
        FinancialFilter.prototype.sortDir = 0;

        /**
         * FinancialFilter quarter.
         * @member {number} quarter
         * @memberof Qot_StockFilter.FinancialFilter
         * @instance
         */
        FinancialFilter.prototype.quarter = 0;

        /**
         * Creates a new FinancialFilter instance using the specified properties.
         * @function create
         * @memberof Qot_StockFilter.FinancialFilter
         * @static
         * @param {Qot_StockFilter.IFinancialFilter=} [properties] Properties to set
         * @returns {Qot_StockFilter.FinancialFilter} FinancialFilter instance
         */
        FinancialFilter.create = function create(properties) {
            return new FinancialFilter(properties);
        };

        /**
         * Encodes the specified FinancialFilter message. Does not implicitly {@link Qot_StockFilter.FinancialFilter.verify|verify} messages.
         * @function encode
         * @memberof Qot_StockFilter.FinancialFilter
         * @static
         * @param {Qot_StockFilter.IFinancialFilter} message FinancialFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FinancialFilter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fieldName);
            if (message.filterMin != null && message.hasOwnProperty("filterMin"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.filterMin);
            if (message.filterMax != null && message.hasOwnProperty("filterMax"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.filterMax);
            if (message.isNoFilter != null && message.hasOwnProperty("isNoFilter"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isNoFilter);
            if (message.sortDir != null && message.hasOwnProperty("sortDir"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.sortDir);
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.quarter);
            return writer;
        };

        /**
         * Encodes the specified FinancialFilter message, length delimited. Does not implicitly {@link Qot_StockFilter.FinancialFilter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_StockFilter.FinancialFilter
         * @static
         * @param {Qot_StockFilter.IFinancialFilter} message FinancialFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FinancialFilter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FinancialFilter message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_StockFilter.FinancialFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_StockFilter.FinancialFilter} FinancialFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FinancialFilter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_StockFilter.FinancialFilter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fieldName = reader.int32();
                    break;
                case 2:
                    message.filterMin = reader.double();
                    break;
                case 3:
                    message.filterMax = reader.double();
                    break;
                case 4:
                    message.isNoFilter = reader.bool();
                    break;
                case 5:
                    message.sortDir = reader.int32();
                    break;
                case 6:
                    message.quarter = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("fieldName"))
                throw $util.ProtocolError("missing required 'fieldName'", { instance: message });
            if (!message.hasOwnProperty("quarter"))
                throw $util.ProtocolError("missing required 'quarter'", { instance: message });
            return message;
        };

        /**
         * Decodes a FinancialFilter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_StockFilter.FinancialFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_StockFilter.FinancialFilter} FinancialFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FinancialFilter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FinancialFilter message.
         * @function verify
         * @memberof Qot_StockFilter.FinancialFilter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FinancialFilter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.fieldName))
                return "fieldName: integer expected";
            if (message.filterMin != null && message.hasOwnProperty("filterMin"))
                if (typeof message.filterMin !== "number")
                    return "filterMin: number expected";
            if (message.filterMax != null && message.hasOwnProperty("filterMax"))
                if (typeof message.filterMax !== "number")
                    return "filterMax: number expected";
            if (message.isNoFilter != null && message.hasOwnProperty("isNoFilter"))
                if (typeof message.isNoFilter !== "boolean")
                    return "isNoFilter: boolean expected";
            if (message.sortDir != null && message.hasOwnProperty("sortDir"))
                if (!$util.isInteger(message.sortDir))
                    return "sortDir: integer expected";
            if (!$util.isInteger(message.quarter))
                return "quarter: integer expected";
            return null;
        };

        /**
         * Creates a FinancialFilter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_StockFilter.FinancialFilter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_StockFilter.FinancialFilter} FinancialFilter
         */
        FinancialFilter.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_StockFilter.FinancialFilter)
                return object;
            var message = new $root.Qot_StockFilter.FinancialFilter();
            if (object.fieldName != null)
                message.fieldName = object.fieldName | 0;
            if (object.filterMin != null)
                message.filterMin = Number(object.filterMin);
            if (object.filterMax != null)
                message.filterMax = Number(object.filterMax);
            if (object.isNoFilter != null)
                message.isNoFilter = Boolean(object.isNoFilter);
            if (object.sortDir != null)
                message.sortDir = object.sortDir | 0;
            if (object.quarter != null)
                message.quarter = object.quarter | 0;
            return message;
        };

        /**
         * Creates a plain object from a FinancialFilter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_StockFilter.FinancialFilter
         * @static
         * @param {Qot_StockFilter.FinancialFilter} message FinancialFilter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FinancialFilter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fieldName = 0;
                object.filterMin = 0;
                object.filterMax = 0;
                object.isNoFilter = false;
                object.sortDir = 0;
                object.quarter = 0;
            }
            if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                object.fieldName = message.fieldName;
            if (message.filterMin != null && message.hasOwnProperty("filterMin"))
                object.filterMin = options.json && !isFinite(message.filterMin) ? String(message.filterMin) : message.filterMin;
            if (message.filterMax != null && message.hasOwnProperty("filterMax"))
                object.filterMax = options.json && !isFinite(message.filterMax) ? String(message.filterMax) : message.filterMax;
            if (message.isNoFilter != null && message.hasOwnProperty("isNoFilter"))
                object.isNoFilter = message.isNoFilter;
            if (message.sortDir != null && message.hasOwnProperty("sortDir"))
                object.sortDir = message.sortDir;
            if (message.quarter != null && message.hasOwnProperty("quarter"))
                object.quarter = message.quarter;
            return object;
        };

        /**
         * Converts this FinancialFilter to JSON.
         * @function toJSON
         * @memberof Qot_StockFilter.FinancialFilter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FinancialFilter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FinancialFilter;
    })();

    Qot_StockFilter.BaseData = (function() {

        /**
         * Properties of a BaseData.
         * @memberof Qot_StockFilter
         * @interface IBaseData
         * @property {number} fieldName BaseData fieldName
         * @property {number} value BaseData value
         */

        /**
         * Constructs a new BaseData.
         * @memberof Qot_StockFilter
         * @classdesc Represents a BaseData.
         * @implements IBaseData
         * @constructor
         * @param {Qot_StockFilter.IBaseData=} [properties] Properties to set
         */
        function BaseData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BaseData fieldName.
         * @member {number} fieldName
         * @memberof Qot_StockFilter.BaseData
         * @instance
         */
        BaseData.prototype.fieldName = 0;

        /**
         * BaseData value.
         * @member {number} value
         * @memberof Qot_StockFilter.BaseData
         * @instance
         */
        BaseData.prototype.value = 0;

        /**
         * Creates a new BaseData instance using the specified properties.
         * @function create
         * @memberof Qot_StockFilter.BaseData
         * @static
         * @param {Qot_StockFilter.IBaseData=} [properties] Properties to set
         * @returns {Qot_StockFilter.BaseData} BaseData instance
         */
        BaseData.create = function create(properties) {
            return new BaseData(properties);
        };

        /**
         * Encodes the specified BaseData message. Does not implicitly {@link Qot_StockFilter.BaseData.verify|verify} messages.
         * @function encode
         * @memberof Qot_StockFilter.BaseData
         * @static
         * @param {Qot_StockFilter.IBaseData} message BaseData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BaseData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fieldName);
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.value);
            return writer;
        };

        /**
         * Encodes the specified BaseData message, length delimited. Does not implicitly {@link Qot_StockFilter.BaseData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_StockFilter.BaseData
         * @static
         * @param {Qot_StockFilter.IBaseData} message BaseData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BaseData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BaseData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_StockFilter.BaseData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_StockFilter.BaseData} BaseData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BaseData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_StockFilter.BaseData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fieldName = reader.int32();
                    break;
                case 2:
                    message.value = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("fieldName"))
                throw $util.ProtocolError("missing required 'fieldName'", { instance: message });
            if (!message.hasOwnProperty("value"))
                throw $util.ProtocolError("missing required 'value'", { instance: message });
            return message;
        };

        /**
         * Decodes a BaseData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_StockFilter.BaseData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_StockFilter.BaseData} BaseData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BaseData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BaseData message.
         * @function verify
         * @memberof Qot_StockFilter.BaseData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BaseData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.fieldName))
                return "fieldName: integer expected";
            if (typeof message.value !== "number")
                return "value: number expected";
            return null;
        };

        /**
         * Creates a BaseData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_StockFilter.BaseData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_StockFilter.BaseData} BaseData
         */
        BaseData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_StockFilter.BaseData)
                return object;
            var message = new $root.Qot_StockFilter.BaseData();
            if (object.fieldName != null)
                message.fieldName = object.fieldName | 0;
            if (object.value != null)
                message.value = Number(object.value);
            return message;
        };

        /**
         * Creates a plain object from a BaseData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_StockFilter.BaseData
         * @static
         * @param {Qot_StockFilter.BaseData} message BaseData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BaseData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fieldName = 0;
                object.value = 0;
            }
            if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                object.fieldName = message.fieldName;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
            return object;
        };

        /**
         * Converts this BaseData to JSON.
         * @function toJSON
         * @memberof Qot_StockFilter.BaseData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BaseData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BaseData;
    })();

    Qot_StockFilter.AccumulateData = (function() {

        /**
         * Properties of an AccumulateData.
         * @memberof Qot_StockFilter
         * @interface IAccumulateData
         * @property {number} fieldName AccumulateData fieldName
         * @property {number} value AccumulateData value
         * @property {number} days AccumulateData days
         */

        /**
         * Constructs a new AccumulateData.
         * @memberof Qot_StockFilter
         * @classdesc Represents an AccumulateData.
         * @implements IAccumulateData
         * @constructor
         * @param {Qot_StockFilter.IAccumulateData=} [properties] Properties to set
         */
        function AccumulateData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccumulateData fieldName.
         * @member {number} fieldName
         * @memberof Qot_StockFilter.AccumulateData
         * @instance
         */
        AccumulateData.prototype.fieldName = 0;

        /**
         * AccumulateData value.
         * @member {number} value
         * @memberof Qot_StockFilter.AccumulateData
         * @instance
         */
        AccumulateData.prototype.value = 0;

        /**
         * AccumulateData days.
         * @member {number} days
         * @memberof Qot_StockFilter.AccumulateData
         * @instance
         */
        AccumulateData.prototype.days = 0;

        /**
         * Creates a new AccumulateData instance using the specified properties.
         * @function create
         * @memberof Qot_StockFilter.AccumulateData
         * @static
         * @param {Qot_StockFilter.IAccumulateData=} [properties] Properties to set
         * @returns {Qot_StockFilter.AccumulateData} AccumulateData instance
         */
        AccumulateData.create = function create(properties) {
            return new AccumulateData(properties);
        };

        /**
         * Encodes the specified AccumulateData message. Does not implicitly {@link Qot_StockFilter.AccumulateData.verify|verify} messages.
         * @function encode
         * @memberof Qot_StockFilter.AccumulateData
         * @static
         * @param {Qot_StockFilter.IAccumulateData} message AccumulateData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccumulateData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fieldName);
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.value);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.days);
            return writer;
        };

        /**
         * Encodes the specified AccumulateData message, length delimited. Does not implicitly {@link Qot_StockFilter.AccumulateData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_StockFilter.AccumulateData
         * @static
         * @param {Qot_StockFilter.IAccumulateData} message AccumulateData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccumulateData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccumulateData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_StockFilter.AccumulateData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_StockFilter.AccumulateData} AccumulateData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccumulateData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_StockFilter.AccumulateData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fieldName = reader.int32();
                    break;
                case 2:
                    message.value = reader.double();
                    break;
                case 3:
                    message.days = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("fieldName"))
                throw $util.ProtocolError("missing required 'fieldName'", { instance: message });
            if (!message.hasOwnProperty("value"))
                throw $util.ProtocolError("missing required 'value'", { instance: message });
            if (!message.hasOwnProperty("days"))
                throw $util.ProtocolError("missing required 'days'", { instance: message });
            return message;
        };

        /**
         * Decodes an AccumulateData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_StockFilter.AccumulateData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_StockFilter.AccumulateData} AccumulateData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccumulateData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccumulateData message.
         * @function verify
         * @memberof Qot_StockFilter.AccumulateData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccumulateData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.fieldName))
                return "fieldName: integer expected";
            if (typeof message.value !== "number")
                return "value: number expected";
            if (!$util.isInteger(message.days))
                return "days: integer expected";
            return null;
        };

        /**
         * Creates an AccumulateData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_StockFilter.AccumulateData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_StockFilter.AccumulateData} AccumulateData
         */
        AccumulateData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_StockFilter.AccumulateData)
                return object;
            var message = new $root.Qot_StockFilter.AccumulateData();
            if (object.fieldName != null)
                message.fieldName = object.fieldName | 0;
            if (object.value != null)
                message.value = Number(object.value);
            if (object.days != null)
                message.days = object.days | 0;
            return message;
        };

        /**
         * Creates a plain object from an AccumulateData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_StockFilter.AccumulateData
         * @static
         * @param {Qot_StockFilter.AccumulateData} message AccumulateData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccumulateData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fieldName = 0;
                object.value = 0;
                object.days = 0;
            }
            if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                object.fieldName = message.fieldName;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
            if (message.days != null && message.hasOwnProperty("days"))
                object.days = message.days;
            return object;
        };

        /**
         * Converts this AccumulateData to JSON.
         * @function toJSON
         * @memberof Qot_StockFilter.AccumulateData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccumulateData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccumulateData;
    })();

    Qot_StockFilter.FinancialData = (function() {

        /**
         * Properties of a FinancialData.
         * @memberof Qot_StockFilter
         * @interface IFinancialData
         * @property {number} fieldName FinancialData fieldName
         * @property {number} value FinancialData value
         * @property {number} quarter FinancialData quarter
         */

        /**
         * Constructs a new FinancialData.
         * @memberof Qot_StockFilter
         * @classdesc Represents a FinancialData.
         * @implements IFinancialData
         * @constructor
         * @param {Qot_StockFilter.IFinancialData=} [properties] Properties to set
         */
        function FinancialData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FinancialData fieldName.
         * @member {number} fieldName
         * @memberof Qot_StockFilter.FinancialData
         * @instance
         */
        FinancialData.prototype.fieldName = 0;

        /**
         * FinancialData value.
         * @member {number} value
         * @memberof Qot_StockFilter.FinancialData
         * @instance
         */
        FinancialData.prototype.value = 0;

        /**
         * FinancialData quarter.
         * @member {number} quarter
         * @memberof Qot_StockFilter.FinancialData
         * @instance
         */
        FinancialData.prototype.quarter = 0;

        /**
         * Creates a new FinancialData instance using the specified properties.
         * @function create
         * @memberof Qot_StockFilter.FinancialData
         * @static
         * @param {Qot_StockFilter.IFinancialData=} [properties] Properties to set
         * @returns {Qot_StockFilter.FinancialData} FinancialData instance
         */
        FinancialData.create = function create(properties) {
            return new FinancialData(properties);
        };

        /**
         * Encodes the specified FinancialData message. Does not implicitly {@link Qot_StockFilter.FinancialData.verify|verify} messages.
         * @function encode
         * @memberof Qot_StockFilter.FinancialData
         * @static
         * @param {Qot_StockFilter.IFinancialData} message FinancialData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FinancialData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fieldName);
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.value);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.quarter);
            return writer;
        };

        /**
         * Encodes the specified FinancialData message, length delimited. Does not implicitly {@link Qot_StockFilter.FinancialData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_StockFilter.FinancialData
         * @static
         * @param {Qot_StockFilter.IFinancialData} message FinancialData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FinancialData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FinancialData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_StockFilter.FinancialData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_StockFilter.FinancialData} FinancialData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FinancialData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_StockFilter.FinancialData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fieldName = reader.int32();
                    break;
                case 2:
                    message.value = reader.double();
                    break;
                case 3:
                    message.quarter = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("fieldName"))
                throw $util.ProtocolError("missing required 'fieldName'", { instance: message });
            if (!message.hasOwnProperty("value"))
                throw $util.ProtocolError("missing required 'value'", { instance: message });
            if (!message.hasOwnProperty("quarter"))
                throw $util.ProtocolError("missing required 'quarter'", { instance: message });
            return message;
        };

        /**
         * Decodes a FinancialData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_StockFilter.FinancialData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_StockFilter.FinancialData} FinancialData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FinancialData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FinancialData message.
         * @function verify
         * @memberof Qot_StockFilter.FinancialData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FinancialData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.fieldName))
                return "fieldName: integer expected";
            if (typeof message.value !== "number")
                return "value: number expected";
            if (!$util.isInteger(message.quarter))
                return "quarter: integer expected";
            return null;
        };

        /**
         * Creates a FinancialData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_StockFilter.FinancialData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_StockFilter.FinancialData} FinancialData
         */
        FinancialData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_StockFilter.FinancialData)
                return object;
            var message = new $root.Qot_StockFilter.FinancialData();
            if (object.fieldName != null)
                message.fieldName = object.fieldName | 0;
            if (object.value != null)
                message.value = Number(object.value);
            if (object.quarter != null)
                message.quarter = object.quarter | 0;
            return message;
        };

        /**
         * Creates a plain object from a FinancialData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_StockFilter.FinancialData
         * @static
         * @param {Qot_StockFilter.FinancialData} message FinancialData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FinancialData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fieldName = 0;
                object.value = 0;
                object.quarter = 0;
            }
            if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                object.fieldName = message.fieldName;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
            if (message.quarter != null && message.hasOwnProperty("quarter"))
                object.quarter = message.quarter;
            return object;
        };

        /**
         * Converts this FinancialData to JSON.
         * @function toJSON
         * @memberof Qot_StockFilter.FinancialData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FinancialData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FinancialData;
    })();

    Qot_StockFilter.StockData = (function() {

        /**
         * Properties of a StockData.
         * @memberof Qot_StockFilter
         * @interface IStockData
         * @property {Qot_Common.ISecurity} security StockData security
         * @property {string} name StockData name
         * @property {Array.<Qot_StockFilter.IBaseData>|null} [baseDataList] StockData baseDataList
         * @property {Array.<Qot_StockFilter.IAccumulateData>|null} [accumulateDataList] StockData accumulateDataList
         * @property {Array.<Qot_StockFilter.IFinancialData>|null} [financialDataList] StockData financialDataList
         */

        /**
         * Constructs a new StockData.
         * @memberof Qot_StockFilter
         * @classdesc Represents a StockData.
         * @implements IStockData
         * @constructor
         * @param {Qot_StockFilter.IStockData=} [properties] Properties to set
         */
        function StockData(properties) {
            this.baseDataList = [];
            this.accumulateDataList = [];
            this.financialDataList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StockData security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_StockFilter.StockData
         * @instance
         */
        StockData.prototype.security = null;

        /**
         * StockData name.
         * @member {string} name
         * @memberof Qot_StockFilter.StockData
         * @instance
         */
        StockData.prototype.name = "";

        /**
         * StockData baseDataList.
         * @member {Array.<Qot_StockFilter.IBaseData>} baseDataList
         * @memberof Qot_StockFilter.StockData
         * @instance
         */
        StockData.prototype.baseDataList = $util.emptyArray;

        /**
         * StockData accumulateDataList.
         * @member {Array.<Qot_StockFilter.IAccumulateData>} accumulateDataList
         * @memberof Qot_StockFilter.StockData
         * @instance
         */
        StockData.prototype.accumulateDataList = $util.emptyArray;

        /**
         * StockData financialDataList.
         * @member {Array.<Qot_StockFilter.IFinancialData>} financialDataList
         * @memberof Qot_StockFilter.StockData
         * @instance
         */
        StockData.prototype.financialDataList = $util.emptyArray;

        /**
         * Creates a new StockData instance using the specified properties.
         * @function create
         * @memberof Qot_StockFilter.StockData
         * @static
         * @param {Qot_StockFilter.IStockData=} [properties] Properties to set
         * @returns {Qot_StockFilter.StockData} StockData instance
         */
        StockData.create = function create(properties) {
            return new StockData(properties);
        };

        /**
         * Encodes the specified StockData message. Does not implicitly {@link Qot_StockFilter.StockData.verify|verify} messages.
         * @function encode
         * @memberof Qot_StockFilter.StockData
         * @static
         * @param {Qot_StockFilter.IStockData} message StockData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StockData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.baseDataList != null && message.baseDataList.length)
                for (var i = 0; i < message.baseDataList.length; ++i)
                    $root.Qot_StockFilter.BaseData.encode(message.baseDataList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.accumulateDataList != null && message.accumulateDataList.length)
                for (var i = 0; i < message.accumulateDataList.length; ++i)
                    $root.Qot_StockFilter.AccumulateData.encode(message.accumulateDataList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.financialDataList != null && message.financialDataList.length)
                for (var i = 0; i < message.financialDataList.length; ++i)
                    $root.Qot_StockFilter.FinancialData.encode(message.financialDataList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StockData message, length delimited. Does not implicitly {@link Qot_StockFilter.StockData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_StockFilter.StockData
         * @static
         * @param {Qot_StockFilter.IStockData} message StockData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StockData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StockData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_StockFilter.StockData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_StockFilter.StockData} StockData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StockData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_StockFilter.StockData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    if (!(message.baseDataList && message.baseDataList.length))
                        message.baseDataList = [];
                    message.baseDataList.push($root.Qot_StockFilter.BaseData.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.accumulateDataList && message.accumulateDataList.length))
                        message.accumulateDataList = [];
                    message.accumulateDataList.push($root.Qot_StockFilter.AccumulateData.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.financialDataList && message.financialDataList.length))
                        message.financialDataList = [];
                    message.financialDataList.push($root.Qot_StockFilter.FinancialData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            return message;
        };

        /**
         * Decodes a StockData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_StockFilter.StockData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_StockFilter.StockData} StockData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StockData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StockData message.
         * @function verify
         * @memberof Qot_StockFilter.StockData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StockData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (!$util.isString(message.name))
                return "name: string expected";
            if (message.baseDataList != null && message.hasOwnProperty("baseDataList")) {
                if (!Array.isArray(message.baseDataList))
                    return "baseDataList: array expected";
                for (var i = 0; i < message.baseDataList.length; ++i) {
                    var error = $root.Qot_StockFilter.BaseData.verify(message.baseDataList[i]);
                    if (error)
                        return "baseDataList." + error;
                }
            }
            if (message.accumulateDataList != null && message.hasOwnProperty("accumulateDataList")) {
                if (!Array.isArray(message.accumulateDataList))
                    return "accumulateDataList: array expected";
                for (var i = 0; i < message.accumulateDataList.length; ++i) {
                    var error = $root.Qot_StockFilter.AccumulateData.verify(message.accumulateDataList[i]);
                    if (error)
                        return "accumulateDataList." + error;
                }
            }
            if (message.financialDataList != null && message.hasOwnProperty("financialDataList")) {
                if (!Array.isArray(message.financialDataList))
                    return "financialDataList: array expected";
                for (var i = 0; i < message.financialDataList.length; ++i) {
                    var error = $root.Qot_StockFilter.FinancialData.verify(message.financialDataList[i]);
                    if (error)
                        return "financialDataList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a StockData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_StockFilter.StockData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_StockFilter.StockData} StockData
         */
        StockData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_StockFilter.StockData)
                return object;
            var message = new $root.Qot_StockFilter.StockData();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_StockFilter.StockData.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.baseDataList) {
                if (!Array.isArray(object.baseDataList))
                    throw TypeError(".Qot_StockFilter.StockData.baseDataList: array expected");
                message.baseDataList = [];
                for (var i = 0; i < object.baseDataList.length; ++i) {
                    if (typeof object.baseDataList[i] !== "object")
                        throw TypeError(".Qot_StockFilter.StockData.baseDataList: object expected");
                    message.baseDataList[i] = $root.Qot_StockFilter.BaseData.fromObject(object.baseDataList[i]);
                }
            }
            if (object.accumulateDataList) {
                if (!Array.isArray(object.accumulateDataList))
                    throw TypeError(".Qot_StockFilter.StockData.accumulateDataList: array expected");
                message.accumulateDataList = [];
                for (var i = 0; i < object.accumulateDataList.length; ++i) {
                    if (typeof object.accumulateDataList[i] !== "object")
                        throw TypeError(".Qot_StockFilter.StockData.accumulateDataList: object expected");
                    message.accumulateDataList[i] = $root.Qot_StockFilter.AccumulateData.fromObject(object.accumulateDataList[i]);
                }
            }
            if (object.financialDataList) {
                if (!Array.isArray(object.financialDataList))
                    throw TypeError(".Qot_StockFilter.StockData.financialDataList: array expected");
                message.financialDataList = [];
                for (var i = 0; i < object.financialDataList.length; ++i) {
                    if (typeof object.financialDataList[i] !== "object")
                        throw TypeError(".Qot_StockFilter.StockData.financialDataList: object expected");
                    message.financialDataList[i] = $root.Qot_StockFilter.FinancialData.fromObject(object.financialDataList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a StockData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_StockFilter.StockData
         * @static
         * @param {Qot_StockFilter.StockData} message StockData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StockData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.baseDataList = [];
                object.accumulateDataList = [];
                object.financialDataList = [];
            }
            if (options.defaults) {
                object.security = null;
                object.name = "";
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.baseDataList && message.baseDataList.length) {
                object.baseDataList = [];
                for (var j = 0; j < message.baseDataList.length; ++j)
                    object.baseDataList[j] = $root.Qot_StockFilter.BaseData.toObject(message.baseDataList[j], options);
            }
            if (message.accumulateDataList && message.accumulateDataList.length) {
                object.accumulateDataList = [];
                for (var j = 0; j < message.accumulateDataList.length; ++j)
                    object.accumulateDataList[j] = $root.Qot_StockFilter.AccumulateData.toObject(message.accumulateDataList[j], options);
            }
            if (message.financialDataList && message.financialDataList.length) {
                object.financialDataList = [];
                for (var j = 0; j < message.financialDataList.length; ++j)
                    object.financialDataList[j] = $root.Qot_StockFilter.FinancialData.toObject(message.financialDataList[j], options);
            }
            return object;
        };

        /**
         * Converts this StockData to JSON.
         * @function toJSON
         * @memberof Qot_StockFilter.StockData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StockData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StockData;
    })();

    Qot_StockFilter.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_StockFilter
         * @interface IC2S
         * @property {number} begin C2S begin
         * @property {number} num C2S num
         * @property {number} market C2S market
         * @property {Qot_Common.ISecurity|null} [plate] C2S plate
         * @property {Array.<Qot_StockFilter.IBaseFilter>|null} [baseFilterList] C2S baseFilterList
         * @property {Array.<Qot_StockFilter.IAccumulateFilter>|null} [accumulateFilterList] C2S accumulateFilterList
         * @property {Array.<Qot_StockFilter.IFinancialFilter>|null} [financialFilterList] C2S financialFilterList
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_StockFilter
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_StockFilter.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.baseFilterList = [];
            this.accumulateFilterList = [];
            this.financialFilterList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S begin.
         * @member {number} begin
         * @memberof Qot_StockFilter.C2S
         * @instance
         */
        C2S.prototype.begin = 0;

        /**
         * C2S num.
         * @member {number} num
         * @memberof Qot_StockFilter.C2S
         * @instance
         */
        C2S.prototype.num = 0;

        /**
         * C2S market.
         * @member {number} market
         * @memberof Qot_StockFilter.C2S
         * @instance
         */
        C2S.prototype.market = 0;

        /**
         * C2S plate.
         * @member {Qot_Common.ISecurity|null|undefined} plate
         * @memberof Qot_StockFilter.C2S
         * @instance
         */
        C2S.prototype.plate = null;

        /**
         * C2S baseFilterList.
         * @member {Array.<Qot_StockFilter.IBaseFilter>} baseFilterList
         * @memberof Qot_StockFilter.C2S
         * @instance
         */
        C2S.prototype.baseFilterList = $util.emptyArray;

        /**
         * C2S accumulateFilterList.
         * @member {Array.<Qot_StockFilter.IAccumulateFilter>} accumulateFilterList
         * @memberof Qot_StockFilter.C2S
         * @instance
         */
        C2S.prototype.accumulateFilterList = $util.emptyArray;

        /**
         * C2S financialFilterList.
         * @member {Array.<Qot_StockFilter.IFinancialFilter>} financialFilterList
         * @memberof Qot_StockFilter.C2S
         * @instance
         */
        C2S.prototype.financialFilterList = $util.emptyArray;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_StockFilter.C2S
         * @static
         * @param {Qot_StockFilter.IC2S=} [properties] Properties to set
         * @returns {Qot_StockFilter.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_StockFilter.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_StockFilter.C2S
         * @static
         * @param {Qot_StockFilter.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.begin);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.market);
            if (message.plate != null && message.hasOwnProperty("plate"))
                $root.Qot_Common.Security.encode(message.plate, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.baseFilterList != null && message.baseFilterList.length)
                for (var i = 0; i < message.baseFilterList.length; ++i)
                    $root.Qot_StockFilter.BaseFilter.encode(message.baseFilterList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.accumulateFilterList != null && message.accumulateFilterList.length)
                for (var i = 0; i < message.accumulateFilterList.length; ++i)
                    $root.Qot_StockFilter.AccumulateFilter.encode(message.accumulateFilterList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.financialFilterList != null && message.financialFilterList.length)
                for (var i = 0; i < message.financialFilterList.length; ++i)
                    $root.Qot_StockFilter.FinancialFilter.encode(message.financialFilterList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_StockFilter.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_StockFilter.C2S
         * @static
         * @param {Qot_StockFilter.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_StockFilter.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_StockFilter.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_StockFilter.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.begin = reader.int32();
                    break;
                case 2:
                    message.num = reader.int32();
                    break;
                case 3:
                    message.market = reader.int32();
                    break;
                case 4:
                    message.plate = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 5:
                    if (!(message.baseFilterList && message.baseFilterList.length))
                        message.baseFilterList = [];
                    message.baseFilterList.push($root.Qot_StockFilter.BaseFilter.decode(reader, reader.uint32()));
                    break;
                case 6:
                    if (!(message.accumulateFilterList && message.accumulateFilterList.length))
                        message.accumulateFilterList = [];
                    message.accumulateFilterList.push($root.Qot_StockFilter.AccumulateFilter.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.financialFilterList && message.financialFilterList.length))
                        message.financialFilterList = [];
                    message.financialFilterList.push($root.Qot_StockFilter.FinancialFilter.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("begin"))
                throw $util.ProtocolError("missing required 'begin'", { instance: message });
            if (!message.hasOwnProperty("num"))
                throw $util.ProtocolError("missing required 'num'", { instance: message });
            if (!message.hasOwnProperty("market"))
                throw $util.ProtocolError("missing required 'market'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_StockFilter.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_StockFilter.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_StockFilter.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.begin))
                return "begin: integer expected";
            if (!$util.isInteger(message.num))
                return "num: integer expected";
            if (!$util.isInteger(message.market))
                return "market: integer expected";
            if (message.plate != null && message.hasOwnProperty("plate")) {
                var error = $root.Qot_Common.Security.verify(message.plate);
                if (error)
                    return "plate." + error;
            }
            if (message.baseFilterList != null && message.hasOwnProperty("baseFilterList")) {
                if (!Array.isArray(message.baseFilterList))
                    return "baseFilterList: array expected";
                for (var i = 0; i < message.baseFilterList.length; ++i) {
                    var error = $root.Qot_StockFilter.BaseFilter.verify(message.baseFilterList[i]);
                    if (error)
                        return "baseFilterList." + error;
                }
            }
            if (message.accumulateFilterList != null && message.hasOwnProperty("accumulateFilterList")) {
                if (!Array.isArray(message.accumulateFilterList))
                    return "accumulateFilterList: array expected";
                for (var i = 0; i < message.accumulateFilterList.length; ++i) {
                    var error = $root.Qot_StockFilter.AccumulateFilter.verify(message.accumulateFilterList[i]);
                    if (error)
                        return "accumulateFilterList." + error;
                }
            }
            if (message.financialFilterList != null && message.hasOwnProperty("financialFilterList")) {
                if (!Array.isArray(message.financialFilterList))
                    return "financialFilterList: array expected";
                for (var i = 0; i < message.financialFilterList.length; ++i) {
                    var error = $root.Qot_StockFilter.FinancialFilter.verify(message.financialFilterList[i]);
                    if (error)
                        return "financialFilterList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_StockFilter.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_StockFilter.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_StockFilter.C2S)
                return object;
            var message = new $root.Qot_StockFilter.C2S();
            if (object.begin != null)
                message.begin = object.begin | 0;
            if (object.num != null)
                message.num = object.num | 0;
            if (object.market != null)
                message.market = object.market | 0;
            if (object.plate != null) {
                if (typeof object.plate !== "object")
                    throw TypeError(".Qot_StockFilter.C2S.plate: object expected");
                message.plate = $root.Qot_Common.Security.fromObject(object.plate);
            }
            if (object.baseFilterList) {
                if (!Array.isArray(object.baseFilterList))
                    throw TypeError(".Qot_StockFilter.C2S.baseFilterList: array expected");
                message.baseFilterList = [];
                for (var i = 0; i < object.baseFilterList.length; ++i) {
                    if (typeof object.baseFilterList[i] !== "object")
                        throw TypeError(".Qot_StockFilter.C2S.baseFilterList: object expected");
                    message.baseFilterList[i] = $root.Qot_StockFilter.BaseFilter.fromObject(object.baseFilterList[i]);
                }
            }
            if (object.accumulateFilterList) {
                if (!Array.isArray(object.accumulateFilterList))
                    throw TypeError(".Qot_StockFilter.C2S.accumulateFilterList: array expected");
                message.accumulateFilterList = [];
                for (var i = 0; i < object.accumulateFilterList.length; ++i) {
                    if (typeof object.accumulateFilterList[i] !== "object")
                        throw TypeError(".Qot_StockFilter.C2S.accumulateFilterList: object expected");
                    message.accumulateFilterList[i] = $root.Qot_StockFilter.AccumulateFilter.fromObject(object.accumulateFilterList[i]);
                }
            }
            if (object.financialFilterList) {
                if (!Array.isArray(object.financialFilterList))
                    throw TypeError(".Qot_StockFilter.C2S.financialFilterList: array expected");
                message.financialFilterList = [];
                for (var i = 0; i < object.financialFilterList.length; ++i) {
                    if (typeof object.financialFilterList[i] !== "object")
                        throw TypeError(".Qot_StockFilter.C2S.financialFilterList: object expected");
                    message.financialFilterList[i] = $root.Qot_StockFilter.FinancialFilter.fromObject(object.financialFilterList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_StockFilter.C2S
         * @static
         * @param {Qot_StockFilter.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.baseFilterList = [];
                object.accumulateFilterList = [];
                object.financialFilterList = [];
            }
            if (options.defaults) {
                object.begin = 0;
                object.num = 0;
                object.market = 0;
                object.plate = null;
            }
            if (message.begin != null && message.hasOwnProperty("begin"))
                object.begin = message.begin;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.market != null && message.hasOwnProperty("market"))
                object.market = message.market;
            if (message.plate != null && message.hasOwnProperty("plate"))
                object.plate = $root.Qot_Common.Security.toObject(message.plate, options);
            if (message.baseFilterList && message.baseFilterList.length) {
                object.baseFilterList = [];
                for (var j = 0; j < message.baseFilterList.length; ++j)
                    object.baseFilterList[j] = $root.Qot_StockFilter.BaseFilter.toObject(message.baseFilterList[j], options);
            }
            if (message.accumulateFilterList && message.accumulateFilterList.length) {
                object.accumulateFilterList = [];
                for (var j = 0; j < message.accumulateFilterList.length; ++j)
                    object.accumulateFilterList[j] = $root.Qot_StockFilter.AccumulateFilter.toObject(message.accumulateFilterList[j], options);
            }
            if (message.financialFilterList && message.financialFilterList.length) {
                object.financialFilterList = [];
                for (var j = 0; j < message.financialFilterList.length; ++j)
                    object.financialFilterList[j] = $root.Qot_StockFilter.FinancialFilter.toObject(message.financialFilterList[j], options);
            }
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_StockFilter.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_StockFilter.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_StockFilter
         * @interface IS2C
         * @property {boolean} lastPage S2C lastPage
         * @property {number} allCount S2C allCount
         * @property {Array.<Qot_StockFilter.IStockData>|null} [dataList] S2C dataList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_StockFilter
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_StockFilter.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.dataList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C lastPage.
         * @member {boolean} lastPage
         * @memberof Qot_StockFilter.S2C
         * @instance
         */
        S2C.prototype.lastPage = false;

        /**
         * S2C allCount.
         * @member {number} allCount
         * @memberof Qot_StockFilter.S2C
         * @instance
         */
        S2C.prototype.allCount = 0;

        /**
         * S2C dataList.
         * @member {Array.<Qot_StockFilter.IStockData>} dataList
         * @memberof Qot_StockFilter.S2C
         * @instance
         */
        S2C.prototype.dataList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_StockFilter.S2C
         * @static
         * @param {Qot_StockFilter.IS2C=} [properties] Properties to set
         * @returns {Qot_StockFilter.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_StockFilter.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_StockFilter.S2C
         * @static
         * @param {Qot_StockFilter.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.lastPage);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.allCount);
            if (message.dataList != null && message.dataList.length)
                for (var i = 0; i < message.dataList.length; ++i)
                    $root.Qot_StockFilter.StockData.encode(message.dataList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_StockFilter.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_StockFilter.S2C
         * @static
         * @param {Qot_StockFilter.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_StockFilter.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_StockFilter.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_StockFilter.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lastPage = reader.bool();
                    break;
                case 2:
                    message.allCount = reader.int32();
                    break;
                case 3:
                    if (!(message.dataList && message.dataList.length))
                        message.dataList = [];
                    message.dataList.push($root.Qot_StockFilter.StockData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("lastPage"))
                throw $util.ProtocolError("missing required 'lastPage'", { instance: message });
            if (!message.hasOwnProperty("allCount"))
                throw $util.ProtocolError("missing required 'allCount'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_StockFilter.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_StockFilter.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_StockFilter.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.lastPage !== "boolean")
                return "lastPage: boolean expected";
            if (!$util.isInteger(message.allCount))
                return "allCount: integer expected";
            if (message.dataList != null && message.hasOwnProperty("dataList")) {
                if (!Array.isArray(message.dataList))
                    return "dataList: array expected";
                for (var i = 0; i < message.dataList.length; ++i) {
                    var error = $root.Qot_StockFilter.StockData.verify(message.dataList[i]);
                    if (error)
                        return "dataList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_StockFilter.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_StockFilter.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_StockFilter.S2C)
                return object;
            var message = new $root.Qot_StockFilter.S2C();
            if (object.lastPage != null)
                message.lastPage = Boolean(object.lastPage);
            if (object.allCount != null)
                message.allCount = object.allCount | 0;
            if (object.dataList) {
                if (!Array.isArray(object.dataList))
                    throw TypeError(".Qot_StockFilter.S2C.dataList: array expected");
                message.dataList = [];
                for (var i = 0; i < object.dataList.length; ++i) {
                    if (typeof object.dataList[i] !== "object")
                        throw TypeError(".Qot_StockFilter.S2C.dataList: object expected");
                    message.dataList[i] = $root.Qot_StockFilter.StockData.fromObject(object.dataList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_StockFilter.S2C
         * @static
         * @param {Qot_StockFilter.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.dataList = [];
            if (options.defaults) {
                object.lastPage = false;
                object.allCount = 0;
            }
            if (message.lastPage != null && message.hasOwnProperty("lastPage"))
                object.lastPage = message.lastPage;
            if (message.allCount != null && message.hasOwnProperty("allCount"))
                object.allCount = message.allCount;
            if (message.dataList && message.dataList.length) {
                object.dataList = [];
                for (var j = 0; j < message.dataList.length; ++j)
                    object.dataList[j] = $root.Qot_StockFilter.StockData.toObject(message.dataList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_StockFilter.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_StockFilter.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_StockFilter
         * @interface IRequest
         * @property {Qot_StockFilter.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_StockFilter
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_StockFilter.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_StockFilter.IC2S} c2s
         * @memberof Qot_StockFilter.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_StockFilter.Request
         * @static
         * @param {Qot_StockFilter.IRequest=} [properties] Properties to set
         * @returns {Qot_StockFilter.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_StockFilter.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_StockFilter.Request
         * @static
         * @param {Qot_StockFilter.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_StockFilter.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_StockFilter.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_StockFilter.Request
         * @static
         * @param {Qot_StockFilter.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_StockFilter.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_StockFilter.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_StockFilter.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_StockFilter.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_StockFilter.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_StockFilter.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_StockFilter.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_StockFilter.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_StockFilter.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_StockFilter.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_StockFilter.Request)
                return object;
            var message = new $root.Qot_StockFilter.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_StockFilter.Request.c2s: object expected");
                message.c2s = $root.Qot_StockFilter.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_StockFilter.Request
         * @static
         * @param {Qot_StockFilter.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_StockFilter.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_StockFilter.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_StockFilter.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_StockFilter
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_StockFilter.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_StockFilter
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_StockFilter.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_StockFilter.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_StockFilter.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_StockFilter.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_StockFilter.IS2C|null|undefined} s2c
         * @memberof Qot_StockFilter.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_StockFilter.Response
         * @static
         * @param {Qot_StockFilter.IResponse=} [properties] Properties to set
         * @returns {Qot_StockFilter.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_StockFilter.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_StockFilter.Response
         * @static
         * @param {Qot_StockFilter.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_StockFilter.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_StockFilter.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_StockFilter.Response
         * @static
         * @param {Qot_StockFilter.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_StockFilter.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_StockFilter.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_StockFilter.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_StockFilter.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_StockFilter.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_StockFilter.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_StockFilter.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_StockFilter.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_StockFilter.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_StockFilter.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_StockFilter.Response)
                return object;
            var message = new $root.Qot_StockFilter.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_StockFilter.Response.s2c: object expected");
                message.s2c = $root.Qot_StockFilter.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_StockFilter.Response
         * @static
         * @param {Qot_StockFilter.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_StockFilter.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_StockFilter.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_StockFilter;
})();

$root.Qot_Sub = (function() {

    /**
     * Namespace Qot_Sub.
     * @exports Qot_Sub
     * @namespace
     */
    var Qot_Sub = {};

    Qot_Sub.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_Sub
         * @interface IC2S
         * @property {Array.<Qot_Common.ISecurity>|null} [securityList] C2S securityList
         * @property {Array.<number>|null} [subTypeList] C2S subTypeList
         * @property {boolean} isSubOrUnSub C2S isSubOrUnSub
         * @property {boolean|null} [isRegOrUnRegPush] C2S isRegOrUnRegPush
         * @property {Array.<number>|null} [regPushRehabTypeList] C2S regPushRehabTypeList
         * @property {boolean|null} [isFirstPush] C2S isFirstPush
         * @property {boolean|null} [isUnsubAll] C2S isUnsubAll
         * @property {boolean|null} [isSubOrderBookDetail] C2S isSubOrderBookDetail
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_Sub
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_Sub.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.securityList = [];
            this.subTypeList = [];
            this.regPushRehabTypeList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S securityList.
         * @member {Array.<Qot_Common.ISecurity>} securityList
         * @memberof Qot_Sub.C2S
         * @instance
         */
        C2S.prototype.securityList = $util.emptyArray;

        /**
         * C2S subTypeList.
         * @member {Array.<number>} subTypeList
         * @memberof Qot_Sub.C2S
         * @instance
         */
        C2S.prototype.subTypeList = $util.emptyArray;

        /**
         * C2S isSubOrUnSub.
         * @member {boolean} isSubOrUnSub
         * @memberof Qot_Sub.C2S
         * @instance
         */
        C2S.prototype.isSubOrUnSub = false;

        /**
         * C2S isRegOrUnRegPush.
         * @member {boolean} isRegOrUnRegPush
         * @memberof Qot_Sub.C2S
         * @instance
         */
        C2S.prototype.isRegOrUnRegPush = false;

        /**
         * C2S regPushRehabTypeList.
         * @member {Array.<number>} regPushRehabTypeList
         * @memberof Qot_Sub.C2S
         * @instance
         */
        C2S.prototype.regPushRehabTypeList = $util.emptyArray;

        /**
         * C2S isFirstPush.
         * @member {boolean} isFirstPush
         * @memberof Qot_Sub.C2S
         * @instance
         */
        C2S.prototype.isFirstPush = false;

        /**
         * C2S isUnsubAll.
         * @member {boolean} isUnsubAll
         * @memberof Qot_Sub.C2S
         * @instance
         */
        C2S.prototype.isUnsubAll = false;

        /**
         * C2S isSubOrderBookDetail.
         * @member {boolean} isSubOrderBookDetail
         * @memberof Qot_Sub.C2S
         * @instance
         */
        C2S.prototype.isSubOrderBookDetail = false;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_Sub.C2S
         * @static
         * @param {Qot_Sub.IC2S=} [properties] Properties to set
         * @returns {Qot_Sub.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_Sub.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_Sub.C2S
         * @static
         * @param {Qot_Sub.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.securityList != null && message.securityList.length)
                for (var i = 0; i < message.securityList.length; ++i)
                    $root.Qot_Common.Security.encode(message.securityList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.subTypeList != null && message.subTypeList.length)
                for (var i = 0; i < message.subTypeList.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.subTypeList[i]);
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isSubOrUnSub);
            if (message.isRegOrUnRegPush != null && message.hasOwnProperty("isRegOrUnRegPush"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isRegOrUnRegPush);
            if (message.regPushRehabTypeList != null && message.regPushRehabTypeList.length)
                for (var i = 0; i < message.regPushRehabTypeList.length; ++i)
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.regPushRehabTypeList[i]);
            if (message.isFirstPush != null && message.hasOwnProperty("isFirstPush"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isFirstPush);
            if (message.isUnsubAll != null && message.hasOwnProperty("isUnsubAll"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.isUnsubAll);
            if (message.isSubOrderBookDetail != null && message.hasOwnProperty("isSubOrderBookDetail"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.isSubOrderBookDetail);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_Sub.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Sub.C2S
         * @static
         * @param {Qot_Sub.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Sub.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Sub.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Sub.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.securityList && message.securityList.length))
                        message.securityList = [];
                    message.securityList.push($root.Qot_Common.Security.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.subTypeList && message.subTypeList.length))
                        message.subTypeList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.subTypeList.push(reader.int32());
                    } else
                        message.subTypeList.push(reader.int32());
                    break;
                case 3:
                    message.isSubOrUnSub = reader.bool();
                    break;
                case 4:
                    message.isRegOrUnRegPush = reader.bool();
                    break;
                case 5:
                    if (!(message.regPushRehabTypeList && message.regPushRehabTypeList.length))
                        message.regPushRehabTypeList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.regPushRehabTypeList.push(reader.int32());
                    } else
                        message.regPushRehabTypeList.push(reader.int32());
                    break;
                case 6:
                    message.isFirstPush = reader.bool();
                    break;
                case 7:
                    message.isUnsubAll = reader.bool();
                    break;
                case 8:
                    message.isSubOrderBookDetail = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("isSubOrUnSub"))
                throw $util.ProtocolError("missing required 'isSubOrUnSub'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Sub.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Sub.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_Sub.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.securityList != null && message.hasOwnProperty("securityList")) {
                if (!Array.isArray(message.securityList))
                    return "securityList: array expected";
                for (var i = 0; i < message.securityList.length; ++i) {
                    var error = $root.Qot_Common.Security.verify(message.securityList[i]);
                    if (error)
                        return "securityList." + error;
                }
            }
            if (message.subTypeList != null && message.hasOwnProperty("subTypeList")) {
                if (!Array.isArray(message.subTypeList))
                    return "subTypeList: array expected";
                for (var i = 0; i < message.subTypeList.length; ++i)
                    if (!$util.isInteger(message.subTypeList[i]))
                        return "subTypeList: integer[] expected";
            }
            if (typeof message.isSubOrUnSub !== "boolean")
                return "isSubOrUnSub: boolean expected";
            if (message.isRegOrUnRegPush != null && message.hasOwnProperty("isRegOrUnRegPush"))
                if (typeof message.isRegOrUnRegPush !== "boolean")
                    return "isRegOrUnRegPush: boolean expected";
            if (message.regPushRehabTypeList != null && message.hasOwnProperty("regPushRehabTypeList")) {
                if (!Array.isArray(message.regPushRehabTypeList))
                    return "regPushRehabTypeList: array expected";
                for (var i = 0; i < message.regPushRehabTypeList.length; ++i)
                    if (!$util.isInteger(message.regPushRehabTypeList[i]))
                        return "regPushRehabTypeList: integer[] expected";
            }
            if (message.isFirstPush != null && message.hasOwnProperty("isFirstPush"))
                if (typeof message.isFirstPush !== "boolean")
                    return "isFirstPush: boolean expected";
            if (message.isUnsubAll != null && message.hasOwnProperty("isUnsubAll"))
                if (typeof message.isUnsubAll !== "boolean")
                    return "isUnsubAll: boolean expected";
            if (message.isSubOrderBookDetail != null && message.hasOwnProperty("isSubOrderBookDetail"))
                if (typeof message.isSubOrderBookDetail !== "boolean")
                    return "isSubOrderBookDetail: boolean expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Sub.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Sub.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Sub.C2S)
                return object;
            var message = new $root.Qot_Sub.C2S();
            if (object.securityList) {
                if (!Array.isArray(object.securityList))
                    throw TypeError(".Qot_Sub.C2S.securityList: array expected");
                message.securityList = [];
                for (var i = 0; i < object.securityList.length; ++i) {
                    if (typeof object.securityList[i] !== "object")
                        throw TypeError(".Qot_Sub.C2S.securityList: object expected");
                    message.securityList[i] = $root.Qot_Common.Security.fromObject(object.securityList[i]);
                }
            }
            if (object.subTypeList) {
                if (!Array.isArray(object.subTypeList))
                    throw TypeError(".Qot_Sub.C2S.subTypeList: array expected");
                message.subTypeList = [];
                for (var i = 0; i < object.subTypeList.length; ++i)
                    message.subTypeList[i] = object.subTypeList[i] | 0;
            }
            if (object.isSubOrUnSub != null)
                message.isSubOrUnSub = Boolean(object.isSubOrUnSub);
            if (object.isRegOrUnRegPush != null)
                message.isRegOrUnRegPush = Boolean(object.isRegOrUnRegPush);
            if (object.regPushRehabTypeList) {
                if (!Array.isArray(object.regPushRehabTypeList))
                    throw TypeError(".Qot_Sub.C2S.regPushRehabTypeList: array expected");
                message.regPushRehabTypeList = [];
                for (var i = 0; i < object.regPushRehabTypeList.length; ++i)
                    message.regPushRehabTypeList[i] = object.regPushRehabTypeList[i] | 0;
            }
            if (object.isFirstPush != null)
                message.isFirstPush = Boolean(object.isFirstPush);
            if (object.isUnsubAll != null)
                message.isUnsubAll = Boolean(object.isUnsubAll);
            if (object.isSubOrderBookDetail != null)
                message.isSubOrderBookDetail = Boolean(object.isSubOrderBookDetail);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Sub.C2S
         * @static
         * @param {Qot_Sub.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.securityList = [];
                object.subTypeList = [];
                object.regPushRehabTypeList = [];
            }
            if (options.defaults) {
                object.isSubOrUnSub = false;
                object.isRegOrUnRegPush = false;
                object.isFirstPush = false;
                object.isUnsubAll = false;
                object.isSubOrderBookDetail = false;
            }
            if (message.securityList && message.securityList.length) {
                object.securityList = [];
                for (var j = 0; j < message.securityList.length; ++j)
                    object.securityList[j] = $root.Qot_Common.Security.toObject(message.securityList[j], options);
            }
            if (message.subTypeList && message.subTypeList.length) {
                object.subTypeList = [];
                for (var j = 0; j < message.subTypeList.length; ++j)
                    object.subTypeList[j] = message.subTypeList[j];
            }
            if (message.isSubOrUnSub != null && message.hasOwnProperty("isSubOrUnSub"))
                object.isSubOrUnSub = message.isSubOrUnSub;
            if (message.isRegOrUnRegPush != null && message.hasOwnProperty("isRegOrUnRegPush"))
                object.isRegOrUnRegPush = message.isRegOrUnRegPush;
            if (message.regPushRehabTypeList && message.regPushRehabTypeList.length) {
                object.regPushRehabTypeList = [];
                for (var j = 0; j < message.regPushRehabTypeList.length; ++j)
                    object.regPushRehabTypeList[j] = message.regPushRehabTypeList[j];
            }
            if (message.isFirstPush != null && message.hasOwnProperty("isFirstPush"))
                object.isFirstPush = message.isFirstPush;
            if (message.isUnsubAll != null && message.hasOwnProperty("isUnsubAll"))
                object.isUnsubAll = message.isUnsubAll;
            if (message.isSubOrderBookDetail != null && message.hasOwnProperty("isSubOrderBookDetail"))
                object.isSubOrderBookDetail = message.isSubOrderBookDetail;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_Sub.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_Sub.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_Sub
         * @interface IS2C
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_Sub
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_Sub.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_Sub.S2C
         * @static
         * @param {Qot_Sub.IS2C=} [properties] Properties to set
         * @returns {Qot_Sub.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_Sub.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_Sub.S2C
         * @static
         * @param {Qot_Sub.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_Sub.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Sub.S2C
         * @static
         * @param {Qot_Sub.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Sub.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Sub.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Sub.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Sub.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Sub.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_Sub.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Sub.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Sub.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Sub.S2C)
                return object;
            return new $root.Qot_Sub.S2C();
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Sub.S2C
         * @static
         * @param {Qot_Sub.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_Sub.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_Sub.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_Sub
         * @interface IRequest
         * @property {Qot_Sub.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_Sub
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_Sub.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_Sub.IC2S} c2s
         * @memberof Qot_Sub.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_Sub.Request
         * @static
         * @param {Qot_Sub.IRequest=} [properties] Properties to set
         * @returns {Qot_Sub.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_Sub.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_Sub.Request
         * @static
         * @param {Qot_Sub.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Sub.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_Sub.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Sub.Request
         * @static
         * @param {Qot_Sub.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Sub.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Sub.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Sub.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_Sub.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Sub.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Sub.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_Sub.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Sub.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Sub.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Sub.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Sub.Request)
                return object;
            var message = new $root.Qot_Sub.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_Sub.Request.c2s: object expected");
                message.c2s = $root.Qot_Sub.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Sub.Request
         * @static
         * @param {Qot_Sub.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_Sub.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_Sub.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_Sub.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_Sub
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_Sub.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_Sub
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_Sub.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_Sub.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_Sub.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_Sub.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_Sub.IS2C|null|undefined} s2c
         * @memberof Qot_Sub.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_Sub.Response
         * @static
         * @param {Qot_Sub.IResponse=} [properties] Properties to set
         * @returns {Qot_Sub.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_Sub.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_Sub.Response
         * @static
         * @param {Qot_Sub.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_Sub.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_Sub.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Sub.Response
         * @static
         * @param {Qot_Sub.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Sub.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Sub.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Sub.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_Sub.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Sub.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Sub.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_Sub.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_Sub.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Sub.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Sub.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Sub.Response)
                return object;
            var message = new $root.Qot_Sub.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_Sub.Response.s2c: object expected");
                message.s2c = $root.Qot_Sub.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Sub.Response
         * @static
         * @param {Qot_Sub.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_Sub.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_Sub.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_Sub;
})();

$root.Qot_UpdateBasicQot = (function() {

    /**
     * Namespace Qot_UpdateBasicQot.
     * @exports Qot_UpdateBasicQot
     * @namespace
     */
    var Qot_UpdateBasicQot = {};

    Qot_UpdateBasicQot.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_UpdateBasicQot
         * @interface IS2C
         * @property {Array.<Qot_Common.IBasicQot>|null} [basicQotList] S2C basicQotList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_UpdateBasicQot
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_UpdateBasicQot.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.basicQotList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C basicQotList.
         * @member {Array.<Qot_Common.IBasicQot>} basicQotList
         * @memberof Qot_UpdateBasicQot.S2C
         * @instance
         */
        S2C.prototype.basicQotList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateBasicQot.S2C
         * @static
         * @param {Qot_UpdateBasicQot.IS2C=} [properties] Properties to set
         * @returns {Qot_UpdateBasicQot.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_UpdateBasicQot.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateBasicQot.S2C
         * @static
         * @param {Qot_UpdateBasicQot.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.basicQotList != null && message.basicQotList.length)
                for (var i = 0; i < message.basicQotList.length; ++i)
                    $root.Qot_Common.BasicQot.encode(message.basicQotList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_UpdateBasicQot.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateBasicQot.S2C
         * @static
         * @param {Qot_UpdateBasicQot.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateBasicQot.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateBasicQot.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateBasicQot.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.basicQotList && message.basicQotList.length))
                        message.basicQotList = [];
                    message.basicQotList.push($root.Qot_Common.BasicQot.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateBasicQot.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateBasicQot.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_UpdateBasicQot.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.basicQotList != null && message.hasOwnProperty("basicQotList")) {
                if (!Array.isArray(message.basicQotList))
                    return "basicQotList: array expected";
                for (var i = 0; i < message.basicQotList.length; ++i) {
                    var error = $root.Qot_Common.BasicQot.verify(message.basicQotList[i]);
                    if (error)
                        return "basicQotList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateBasicQot.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateBasicQot.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateBasicQot.S2C)
                return object;
            var message = new $root.Qot_UpdateBasicQot.S2C();
            if (object.basicQotList) {
                if (!Array.isArray(object.basicQotList))
                    throw TypeError(".Qot_UpdateBasicQot.S2C.basicQotList: array expected");
                message.basicQotList = [];
                for (var i = 0; i < object.basicQotList.length; ++i) {
                    if (typeof object.basicQotList[i] !== "object")
                        throw TypeError(".Qot_UpdateBasicQot.S2C.basicQotList: object expected");
                    message.basicQotList[i] = $root.Qot_Common.BasicQot.fromObject(object.basicQotList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateBasicQot.S2C
         * @static
         * @param {Qot_UpdateBasicQot.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.basicQotList = [];
            if (message.basicQotList && message.basicQotList.length) {
                object.basicQotList = [];
                for (var j = 0; j < message.basicQotList.length; ++j)
                    object.basicQotList[j] = $root.Qot_Common.BasicQot.toObject(message.basicQotList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_UpdateBasicQot.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_UpdateBasicQot.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_UpdateBasicQot
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_UpdateBasicQot.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_UpdateBasicQot
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_UpdateBasicQot.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_UpdateBasicQot.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_UpdateBasicQot.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_UpdateBasicQot.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_UpdateBasicQot.IS2C|null|undefined} s2c
         * @memberof Qot_UpdateBasicQot.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateBasicQot.Response
         * @static
         * @param {Qot_UpdateBasicQot.IResponse=} [properties] Properties to set
         * @returns {Qot_UpdateBasicQot.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_UpdateBasicQot.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateBasicQot.Response
         * @static
         * @param {Qot_UpdateBasicQot.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_UpdateBasicQot.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_UpdateBasicQot.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateBasicQot.Response
         * @static
         * @param {Qot_UpdateBasicQot.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateBasicQot.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateBasicQot.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateBasicQot.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_UpdateBasicQot.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateBasicQot.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateBasicQot.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_UpdateBasicQot.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_UpdateBasicQot.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateBasicQot.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateBasicQot.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateBasicQot.Response)
                return object;
            var message = new $root.Qot_UpdateBasicQot.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_UpdateBasicQot.Response.s2c: object expected");
                message.s2c = $root.Qot_UpdateBasicQot.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateBasicQot.Response
         * @static
         * @param {Qot_UpdateBasicQot.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_UpdateBasicQot.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_UpdateBasicQot.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_UpdateBasicQot;
})();

$root.Qot_UpdateBroker = (function() {

    /**
     * Namespace Qot_UpdateBroker.
     * @exports Qot_UpdateBroker
     * @namespace
     */
    var Qot_UpdateBroker = {};

    Qot_UpdateBroker.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_UpdateBroker
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.IBroker>|null} [brokerAskList] S2C brokerAskList
         * @property {Array.<Qot_Common.IBroker>|null} [brokerBidList] S2C brokerBidList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_UpdateBroker
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_UpdateBroker.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.brokerAskList = [];
            this.brokerBidList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_UpdateBroker.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C brokerAskList.
         * @member {Array.<Qot_Common.IBroker>} brokerAskList
         * @memberof Qot_UpdateBroker.S2C
         * @instance
         */
        S2C.prototype.brokerAskList = $util.emptyArray;

        /**
         * S2C brokerBidList.
         * @member {Array.<Qot_Common.IBroker>} brokerBidList
         * @memberof Qot_UpdateBroker.S2C
         * @instance
         */
        S2C.prototype.brokerBidList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateBroker.S2C
         * @static
         * @param {Qot_UpdateBroker.IS2C=} [properties] Properties to set
         * @returns {Qot_UpdateBroker.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_UpdateBroker.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateBroker.S2C
         * @static
         * @param {Qot_UpdateBroker.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.brokerAskList != null && message.brokerAskList.length)
                for (var i = 0; i < message.brokerAskList.length; ++i)
                    $root.Qot_Common.Broker.encode(message.brokerAskList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.brokerBidList != null && message.brokerBidList.length)
                for (var i = 0; i < message.brokerBidList.length; ++i)
                    $root.Qot_Common.Broker.encode(message.brokerBidList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_UpdateBroker.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateBroker.S2C
         * @static
         * @param {Qot_UpdateBroker.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateBroker.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateBroker.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateBroker.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.brokerAskList && message.brokerAskList.length))
                        message.brokerAskList = [];
                    message.brokerAskList.push($root.Qot_Common.Broker.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.brokerBidList && message.brokerBidList.length))
                        message.brokerBidList = [];
                    message.brokerBidList.push($root.Qot_Common.Broker.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateBroker.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateBroker.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_UpdateBroker.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.brokerAskList != null && message.hasOwnProperty("brokerAskList")) {
                if (!Array.isArray(message.brokerAskList))
                    return "brokerAskList: array expected";
                for (var i = 0; i < message.brokerAskList.length; ++i) {
                    var error = $root.Qot_Common.Broker.verify(message.brokerAskList[i]);
                    if (error)
                        return "brokerAskList." + error;
                }
            }
            if (message.brokerBidList != null && message.hasOwnProperty("brokerBidList")) {
                if (!Array.isArray(message.brokerBidList))
                    return "brokerBidList: array expected";
                for (var i = 0; i < message.brokerBidList.length; ++i) {
                    var error = $root.Qot_Common.Broker.verify(message.brokerBidList[i]);
                    if (error)
                        return "brokerBidList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateBroker.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateBroker.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateBroker.S2C)
                return object;
            var message = new $root.Qot_UpdateBroker.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_UpdateBroker.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.brokerAskList) {
                if (!Array.isArray(object.brokerAskList))
                    throw TypeError(".Qot_UpdateBroker.S2C.brokerAskList: array expected");
                message.brokerAskList = [];
                for (var i = 0; i < object.brokerAskList.length; ++i) {
                    if (typeof object.brokerAskList[i] !== "object")
                        throw TypeError(".Qot_UpdateBroker.S2C.brokerAskList: object expected");
                    message.brokerAskList[i] = $root.Qot_Common.Broker.fromObject(object.brokerAskList[i]);
                }
            }
            if (object.brokerBidList) {
                if (!Array.isArray(object.brokerBidList))
                    throw TypeError(".Qot_UpdateBroker.S2C.brokerBidList: array expected");
                message.brokerBidList = [];
                for (var i = 0; i < object.brokerBidList.length; ++i) {
                    if (typeof object.brokerBidList[i] !== "object")
                        throw TypeError(".Qot_UpdateBroker.S2C.brokerBidList: object expected");
                    message.brokerBidList[i] = $root.Qot_Common.Broker.fromObject(object.brokerBidList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateBroker.S2C
         * @static
         * @param {Qot_UpdateBroker.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.brokerAskList = [];
                object.brokerBidList = [];
            }
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.brokerAskList && message.brokerAskList.length) {
                object.brokerAskList = [];
                for (var j = 0; j < message.brokerAskList.length; ++j)
                    object.brokerAskList[j] = $root.Qot_Common.Broker.toObject(message.brokerAskList[j], options);
            }
            if (message.brokerBidList && message.brokerBidList.length) {
                object.brokerBidList = [];
                for (var j = 0; j < message.brokerBidList.length; ++j)
                    object.brokerBidList[j] = $root.Qot_Common.Broker.toObject(message.brokerBidList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_UpdateBroker.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_UpdateBroker.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_UpdateBroker
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_UpdateBroker.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_UpdateBroker
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_UpdateBroker.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_UpdateBroker.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_UpdateBroker.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_UpdateBroker.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_UpdateBroker.IS2C|null|undefined} s2c
         * @memberof Qot_UpdateBroker.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateBroker.Response
         * @static
         * @param {Qot_UpdateBroker.IResponse=} [properties] Properties to set
         * @returns {Qot_UpdateBroker.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_UpdateBroker.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateBroker.Response
         * @static
         * @param {Qot_UpdateBroker.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_UpdateBroker.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_UpdateBroker.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateBroker.Response
         * @static
         * @param {Qot_UpdateBroker.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateBroker.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateBroker.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateBroker.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_UpdateBroker.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateBroker.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateBroker.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_UpdateBroker.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_UpdateBroker.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateBroker.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateBroker.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateBroker.Response)
                return object;
            var message = new $root.Qot_UpdateBroker.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_UpdateBroker.Response.s2c: object expected");
                message.s2c = $root.Qot_UpdateBroker.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateBroker.Response
         * @static
         * @param {Qot_UpdateBroker.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_UpdateBroker.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_UpdateBroker.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_UpdateBroker;
})();

$root.Qot_UpdateKL = (function() {

    /**
     * Namespace Qot_UpdateKL.
     * @exports Qot_UpdateKL
     * @namespace
     */
    var Qot_UpdateKL = {};

    Qot_UpdateKL.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_UpdateKL
         * @interface IS2C
         * @property {number} rehabType S2C rehabType
         * @property {number} klType S2C klType
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.IKLine>|null} [klList] S2C klList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_UpdateKL
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_UpdateKL.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.klList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C rehabType.
         * @member {number} rehabType
         * @memberof Qot_UpdateKL.S2C
         * @instance
         */
        S2C.prototype.rehabType = 0;

        /**
         * S2C klType.
         * @member {number} klType
         * @memberof Qot_UpdateKL.S2C
         * @instance
         */
        S2C.prototype.klType = 0;

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_UpdateKL.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C klList.
         * @member {Array.<Qot_Common.IKLine>} klList
         * @memberof Qot_UpdateKL.S2C
         * @instance
         */
        S2C.prototype.klList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateKL.S2C
         * @static
         * @param {Qot_UpdateKL.IS2C=} [properties] Properties to set
         * @returns {Qot_UpdateKL.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_UpdateKL.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateKL.S2C
         * @static
         * @param {Qot_UpdateKL.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rehabType);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.klType);
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.klList != null && message.klList.length)
                for (var i = 0; i < message.klList.length; ++i)
                    $root.Qot_Common.KLine.encode(message.klList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_UpdateKL.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateKL.S2C
         * @static
         * @param {Qot_UpdateKL.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateKL.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateKL.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateKL.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rehabType = reader.int32();
                    break;
                case 2:
                    message.klType = reader.int32();
                    break;
                case 3:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.klList && message.klList.length))
                        message.klList = [];
                    message.klList.push($root.Qot_Common.KLine.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("rehabType"))
                throw $util.ProtocolError("missing required 'rehabType'", { instance: message });
            if (!message.hasOwnProperty("klType"))
                throw $util.ProtocolError("missing required 'klType'", { instance: message });
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateKL.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateKL.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_UpdateKL.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.rehabType))
                return "rehabType: integer expected";
            if (!$util.isInteger(message.klType))
                return "klType: integer expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.klList != null && message.hasOwnProperty("klList")) {
                if (!Array.isArray(message.klList))
                    return "klList: array expected";
                for (var i = 0; i < message.klList.length; ++i) {
                    var error = $root.Qot_Common.KLine.verify(message.klList[i]);
                    if (error)
                        return "klList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateKL.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateKL.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateKL.S2C)
                return object;
            var message = new $root.Qot_UpdateKL.S2C();
            if (object.rehabType != null)
                message.rehabType = object.rehabType | 0;
            if (object.klType != null)
                message.klType = object.klType | 0;
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_UpdateKL.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.klList) {
                if (!Array.isArray(object.klList))
                    throw TypeError(".Qot_UpdateKL.S2C.klList: array expected");
                message.klList = [];
                for (var i = 0; i < object.klList.length; ++i) {
                    if (typeof object.klList[i] !== "object")
                        throw TypeError(".Qot_UpdateKL.S2C.klList: object expected");
                    message.klList[i] = $root.Qot_Common.KLine.fromObject(object.klList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateKL.S2C
         * @static
         * @param {Qot_UpdateKL.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.klList = [];
            if (options.defaults) {
                object.rehabType = 0;
                object.klType = 0;
                object.security = null;
            }
            if (message.rehabType != null && message.hasOwnProperty("rehabType"))
                object.rehabType = message.rehabType;
            if (message.klType != null && message.hasOwnProperty("klType"))
                object.klType = message.klType;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.klList && message.klList.length) {
                object.klList = [];
                for (var j = 0; j < message.klList.length; ++j)
                    object.klList[j] = $root.Qot_Common.KLine.toObject(message.klList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_UpdateKL.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_UpdateKL.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_UpdateKL
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_UpdateKL.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_UpdateKL
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_UpdateKL.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_UpdateKL.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_UpdateKL.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_UpdateKL.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_UpdateKL.IS2C|null|undefined} s2c
         * @memberof Qot_UpdateKL.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateKL.Response
         * @static
         * @param {Qot_UpdateKL.IResponse=} [properties] Properties to set
         * @returns {Qot_UpdateKL.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_UpdateKL.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateKL.Response
         * @static
         * @param {Qot_UpdateKL.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_UpdateKL.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_UpdateKL.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateKL.Response
         * @static
         * @param {Qot_UpdateKL.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateKL.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateKL.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateKL.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_UpdateKL.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateKL.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateKL.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_UpdateKL.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_UpdateKL.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateKL.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateKL.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateKL.Response)
                return object;
            var message = new $root.Qot_UpdateKL.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_UpdateKL.Response.s2c: object expected");
                message.s2c = $root.Qot_UpdateKL.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateKL.Response
         * @static
         * @param {Qot_UpdateKL.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_UpdateKL.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_UpdateKL.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_UpdateKL;
})();

$root.Qot_UpdateOrderBook = (function() {

    /**
     * Namespace Qot_UpdateOrderBook.
     * @exports Qot_UpdateOrderBook
     * @namespace
     */
    var Qot_UpdateOrderBook = {};

    Qot_UpdateOrderBook.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_UpdateOrderBook
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.IOrderBook>|null} [orderBookAskList] S2C orderBookAskList
         * @property {Array.<Qot_Common.IOrderBook>|null} [orderBookBidList] S2C orderBookBidList
         * @property {string|null} [svrRecvTimeBid] S2C svrRecvTimeBid
         * @property {number|null} [svrRecvTimeBidTimestamp] S2C svrRecvTimeBidTimestamp
         * @property {string|null} [svrRecvTimeAsk] S2C svrRecvTimeAsk
         * @property {number|null} [svrRecvTimeAskTimestamp] S2C svrRecvTimeAskTimestamp
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_UpdateOrderBook
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_UpdateOrderBook.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.orderBookAskList = [];
            this.orderBookBidList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_UpdateOrderBook.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C orderBookAskList.
         * @member {Array.<Qot_Common.IOrderBook>} orderBookAskList
         * @memberof Qot_UpdateOrderBook.S2C
         * @instance
         */
        S2C.prototype.orderBookAskList = $util.emptyArray;

        /**
         * S2C orderBookBidList.
         * @member {Array.<Qot_Common.IOrderBook>} orderBookBidList
         * @memberof Qot_UpdateOrderBook.S2C
         * @instance
         */
        S2C.prototype.orderBookBidList = $util.emptyArray;

        /**
         * S2C svrRecvTimeBid.
         * @member {string} svrRecvTimeBid
         * @memberof Qot_UpdateOrderBook.S2C
         * @instance
         */
        S2C.prototype.svrRecvTimeBid = "";

        /**
         * S2C svrRecvTimeBidTimestamp.
         * @member {number} svrRecvTimeBidTimestamp
         * @memberof Qot_UpdateOrderBook.S2C
         * @instance
         */
        S2C.prototype.svrRecvTimeBidTimestamp = 0;

        /**
         * S2C svrRecvTimeAsk.
         * @member {string} svrRecvTimeAsk
         * @memberof Qot_UpdateOrderBook.S2C
         * @instance
         */
        S2C.prototype.svrRecvTimeAsk = "";

        /**
         * S2C svrRecvTimeAskTimestamp.
         * @member {number} svrRecvTimeAskTimestamp
         * @memberof Qot_UpdateOrderBook.S2C
         * @instance
         */
        S2C.prototype.svrRecvTimeAskTimestamp = 0;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateOrderBook.S2C
         * @static
         * @param {Qot_UpdateOrderBook.IS2C=} [properties] Properties to set
         * @returns {Qot_UpdateOrderBook.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_UpdateOrderBook.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateOrderBook.S2C
         * @static
         * @param {Qot_UpdateOrderBook.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.orderBookAskList != null && message.orderBookAskList.length)
                for (var i = 0; i < message.orderBookAskList.length; ++i)
                    $root.Qot_Common.OrderBook.encode(message.orderBookAskList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.orderBookBidList != null && message.orderBookBidList.length)
                for (var i = 0; i < message.orderBookBidList.length; ++i)
                    $root.Qot_Common.OrderBook.encode(message.orderBookBidList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.svrRecvTimeBid != null && message.hasOwnProperty("svrRecvTimeBid"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.svrRecvTimeBid);
            if (message.svrRecvTimeBidTimestamp != null && message.hasOwnProperty("svrRecvTimeBidTimestamp"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.svrRecvTimeBidTimestamp);
            if (message.svrRecvTimeAsk != null && message.hasOwnProperty("svrRecvTimeAsk"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.svrRecvTimeAsk);
            if (message.svrRecvTimeAskTimestamp != null && message.hasOwnProperty("svrRecvTimeAskTimestamp"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.svrRecvTimeAskTimestamp);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_UpdateOrderBook.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateOrderBook.S2C
         * @static
         * @param {Qot_UpdateOrderBook.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateOrderBook.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateOrderBook.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateOrderBook.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.orderBookAskList && message.orderBookAskList.length))
                        message.orderBookAskList = [];
                    message.orderBookAskList.push($root.Qot_Common.OrderBook.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.orderBookBidList && message.orderBookBidList.length))
                        message.orderBookBidList = [];
                    message.orderBookBidList.push($root.Qot_Common.OrderBook.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.svrRecvTimeBid = reader.string();
                    break;
                case 5:
                    message.svrRecvTimeBidTimestamp = reader.double();
                    break;
                case 6:
                    message.svrRecvTimeAsk = reader.string();
                    break;
                case 7:
                    message.svrRecvTimeAskTimestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateOrderBook.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateOrderBook.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_UpdateOrderBook.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.orderBookAskList != null && message.hasOwnProperty("orderBookAskList")) {
                if (!Array.isArray(message.orderBookAskList))
                    return "orderBookAskList: array expected";
                for (var i = 0; i < message.orderBookAskList.length; ++i) {
                    var error = $root.Qot_Common.OrderBook.verify(message.orderBookAskList[i]);
                    if (error)
                        return "orderBookAskList." + error;
                }
            }
            if (message.orderBookBidList != null && message.hasOwnProperty("orderBookBidList")) {
                if (!Array.isArray(message.orderBookBidList))
                    return "orderBookBidList: array expected";
                for (var i = 0; i < message.orderBookBidList.length; ++i) {
                    var error = $root.Qot_Common.OrderBook.verify(message.orderBookBidList[i]);
                    if (error)
                        return "orderBookBidList." + error;
                }
            }
            if (message.svrRecvTimeBid != null && message.hasOwnProperty("svrRecvTimeBid"))
                if (!$util.isString(message.svrRecvTimeBid))
                    return "svrRecvTimeBid: string expected";
            if (message.svrRecvTimeBidTimestamp != null && message.hasOwnProperty("svrRecvTimeBidTimestamp"))
                if (typeof message.svrRecvTimeBidTimestamp !== "number")
                    return "svrRecvTimeBidTimestamp: number expected";
            if (message.svrRecvTimeAsk != null && message.hasOwnProperty("svrRecvTimeAsk"))
                if (!$util.isString(message.svrRecvTimeAsk))
                    return "svrRecvTimeAsk: string expected";
            if (message.svrRecvTimeAskTimestamp != null && message.hasOwnProperty("svrRecvTimeAskTimestamp"))
                if (typeof message.svrRecvTimeAskTimestamp !== "number")
                    return "svrRecvTimeAskTimestamp: number expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateOrderBook.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateOrderBook.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateOrderBook.S2C)
                return object;
            var message = new $root.Qot_UpdateOrderBook.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_UpdateOrderBook.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.orderBookAskList) {
                if (!Array.isArray(object.orderBookAskList))
                    throw TypeError(".Qot_UpdateOrderBook.S2C.orderBookAskList: array expected");
                message.orderBookAskList = [];
                for (var i = 0; i < object.orderBookAskList.length; ++i) {
                    if (typeof object.orderBookAskList[i] !== "object")
                        throw TypeError(".Qot_UpdateOrderBook.S2C.orderBookAskList: object expected");
                    message.orderBookAskList[i] = $root.Qot_Common.OrderBook.fromObject(object.orderBookAskList[i]);
                }
            }
            if (object.orderBookBidList) {
                if (!Array.isArray(object.orderBookBidList))
                    throw TypeError(".Qot_UpdateOrderBook.S2C.orderBookBidList: array expected");
                message.orderBookBidList = [];
                for (var i = 0; i < object.orderBookBidList.length; ++i) {
                    if (typeof object.orderBookBidList[i] !== "object")
                        throw TypeError(".Qot_UpdateOrderBook.S2C.orderBookBidList: object expected");
                    message.orderBookBidList[i] = $root.Qot_Common.OrderBook.fromObject(object.orderBookBidList[i]);
                }
            }
            if (object.svrRecvTimeBid != null)
                message.svrRecvTimeBid = String(object.svrRecvTimeBid);
            if (object.svrRecvTimeBidTimestamp != null)
                message.svrRecvTimeBidTimestamp = Number(object.svrRecvTimeBidTimestamp);
            if (object.svrRecvTimeAsk != null)
                message.svrRecvTimeAsk = String(object.svrRecvTimeAsk);
            if (object.svrRecvTimeAskTimestamp != null)
                message.svrRecvTimeAskTimestamp = Number(object.svrRecvTimeAskTimestamp);
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateOrderBook.S2C
         * @static
         * @param {Qot_UpdateOrderBook.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.orderBookAskList = [];
                object.orderBookBidList = [];
            }
            if (options.defaults) {
                object.security = null;
                object.svrRecvTimeBid = "";
                object.svrRecvTimeBidTimestamp = 0;
                object.svrRecvTimeAsk = "";
                object.svrRecvTimeAskTimestamp = 0;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.orderBookAskList && message.orderBookAskList.length) {
                object.orderBookAskList = [];
                for (var j = 0; j < message.orderBookAskList.length; ++j)
                    object.orderBookAskList[j] = $root.Qot_Common.OrderBook.toObject(message.orderBookAskList[j], options);
            }
            if (message.orderBookBidList && message.orderBookBidList.length) {
                object.orderBookBidList = [];
                for (var j = 0; j < message.orderBookBidList.length; ++j)
                    object.orderBookBidList[j] = $root.Qot_Common.OrderBook.toObject(message.orderBookBidList[j], options);
            }
            if (message.svrRecvTimeBid != null && message.hasOwnProperty("svrRecvTimeBid"))
                object.svrRecvTimeBid = message.svrRecvTimeBid;
            if (message.svrRecvTimeBidTimestamp != null && message.hasOwnProperty("svrRecvTimeBidTimestamp"))
                object.svrRecvTimeBidTimestamp = options.json && !isFinite(message.svrRecvTimeBidTimestamp) ? String(message.svrRecvTimeBidTimestamp) : message.svrRecvTimeBidTimestamp;
            if (message.svrRecvTimeAsk != null && message.hasOwnProperty("svrRecvTimeAsk"))
                object.svrRecvTimeAsk = message.svrRecvTimeAsk;
            if (message.svrRecvTimeAskTimestamp != null && message.hasOwnProperty("svrRecvTimeAskTimestamp"))
                object.svrRecvTimeAskTimestamp = options.json && !isFinite(message.svrRecvTimeAskTimestamp) ? String(message.svrRecvTimeAskTimestamp) : message.svrRecvTimeAskTimestamp;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_UpdateOrderBook.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_UpdateOrderBook.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_UpdateOrderBook
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_UpdateOrderBook.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_UpdateOrderBook
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_UpdateOrderBook.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_UpdateOrderBook.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_UpdateOrderBook.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_UpdateOrderBook.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_UpdateOrderBook.IS2C|null|undefined} s2c
         * @memberof Qot_UpdateOrderBook.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateOrderBook.Response
         * @static
         * @param {Qot_UpdateOrderBook.IResponse=} [properties] Properties to set
         * @returns {Qot_UpdateOrderBook.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_UpdateOrderBook.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateOrderBook.Response
         * @static
         * @param {Qot_UpdateOrderBook.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_UpdateOrderBook.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_UpdateOrderBook.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateOrderBook.Response
         * @static
         * @param {Qot_UpdateOrderBook.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateOrderBook.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateOrderBook.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateOrderBook.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_UpdateOrderBook.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateOrderBook.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateOrderBook.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_UpdateOrderBook.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_UpdateOrderBook.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateOrderBook.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateOrderBook.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateOrderBook.Response)
                return object;
            var message = new $root.Qot_UpdateOrderBook.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_UpdateOrderBook.Response.s2c: object expected");
                message.s2c = $root.Qot_UpdateOrderBook.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateOrderBook.Response
         * @static
         * @param {Qot_UpdateOrderBook.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_UpdateOrderBook.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_UpdateOrderBook.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_UpdateOrderBook;
})();

$root.Qot_UpdateOrderDetail = (function() {

    /**
     * Namespace Qot_UpdateOrderDetail.
     * @exports Qot_UpdateOrderDetail
     * @namespace
     */
    var Qot_UpdateOrderDetail = {};

    Qot_UpdateOrderDetail.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_UpdateOrderDetail
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Qot_Common.IOrderDetail} orderDetailAsk S2C orderDetailAsk
         * @property {Qot_Common.IOrderDetail} orderDetailBid S2C orderDetailBid
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_UpdateOrderDetail
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_UpdateOrderDetail.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_UpdateOrderDetail.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C orderDetailAsk.
         * @member {Qot_Common.IOrderDetail} orderDetailAsk
         * @memberof Qot_UpdateOrderDetail.S2C
         * @instance
         */
        S2C.prototype.orderDetailAsk = null;

        /**
         * S2C orderDetailBid.
         * @member {Qot_Common.IOrderDetail} orderDetailBid
         * @memberof Qot_UpdateOrderDetail.S2C
         * @instance
         */
        S2C.prototype.orderDetailBid = null;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateOrderDetail.S2C
         * @static
         * @param {Qot_UpdateOrderDetail.IS2C=} [properties] Properties to set
         * @returns {Qot_UpdateOrderDetail.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_UpdateOrderDetail.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateOrderDetail.S2C
         * @static
         * @param {Qot_UpdateOrderDetail.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            $root.Qot_Common.OrderDetail.encode(message.orderDetailAsk, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            $root.Qot_Common.OrderDetail.encode(message.orderDetailBid, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_UpdateOrderDetail.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateOrderDetail.S2C
         * @static
         * @param {Qot_UpdateOrderDetail.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateOrderDetail.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateOrderDetail.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateOrderDetail.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.orderDetailAsk = $root.Qot_Common.OrderDetail.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.orderDetailBid = $root.Qot_Common.OrderDetail.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("orderDetailAsk"))
                throw $util.ProtocolError("missing required 'orderDetailAsk'", { instance: message });
            if (!message.hasOwnProperty("orderDetailBid"))
                throw $util.ProtocolError("missing required 'orderDetailBid'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateOrderDetail.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateOrderDetail.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_UpdateOrderDetail.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            {
                var error = $root.Qot_Common.OrderDetail.verify(message.orderDetailAsk);
                if (error)
                    return "orderDetailAsk." + error;
            }
            {
                var error = $root.Qot_Common.OrderDetail.verify(message.orderDetailBid);
                if (error)
                    return "orderDetailBid." + error;
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateOrderDetail.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateOrderDetail.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateOrderDetail.S2C)
                return object;
            var message = new $root.Qot_UpdateOrderDetail.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_UpdateOrderDetail.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.orderDetailAsk != null) {
                if (typeof object.orderDetailAsk !== "object")
                    throw TypeError(".Qot_UpdateOrderDetail.S2C.orderDetailAsk: object expected");
                message.orderDetailAsk = $root.Qot_Common.OrderDetail.fromObject(object.orderDetailAsk);
            }
            if (object.orderDetailBid != null) {
                if (typeof object.orderDetailBid !== "object")
                    throw TypeError(".Qot_UpdateOrderDetail.S2C.orderDetailBid: object expected");
                message.orderDetailBid = $root.Qot_Common.OrderDetail.fromObject(object.orderDetailBid);
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateOrderDetail.S2C
         * @static
         * @param {Qot_UpdateOrderDetail.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.security = null;
                object.orderDetailAsk = null;
                object.orderDetailBid = null;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.orderDetailAsk != null && message.hasOwnProperty("orderDetailAsk"))
                object.orderDetailAsk = $root.Qot_Common.OrderDetail.toObject(message.orderDetailAsk, options);
            if (message.orderDetailBid != null && message.hasOwnProperty("orderDetailBid"))
                object.orderDetailBid = $root.Qot_Common.OrderDetail.toObject(message.orderDetailBid, options);
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_UpdateOrderDetail.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_UpdateOrderDetail.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_UpdateOrderDetail
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_UpdateOrderDetail.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_UpdateOrderDetail
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_UpdateOrderDetail.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_UpdateOrderDetail.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_UpdateOrderDetail.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_UpdateOrderDetail.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_UpdateOrderDetail.IS2C|null|undefined} s2c
         * @memberof Qot_UpdateOrderDetail.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateOrderDetail.Response
         * @static
         * @param {Qot_UpdateOrderDetail.IResponse=} [properties] Properties to set
         * @returns {Qot_UpdateOrderDetail.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_UpdateOrderDetail.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateOrderDetail.Response
         * @static
         * @param {Qot_UpdateOrderDetail.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_UpdateOrderDetail.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_UpdateOrderDetail.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateOrderDetail.Response
         * @static
         * @param {Qot_UpdateOrderDetail.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateOrderDetail.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateOrderDetail.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateOrderDetail.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_UpdateOrderDetail.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateOrderDetail.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateOrderDetail.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_UpdateOrderDetail.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_UpdateOrderDetail.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateOrderDetail.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateOrderDetail.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateOrderDetail.Response)
                return object;
            var message = new $root.Qot_UpdateOrderDetail.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_UpdateOrderDetail.Response.s2c: object expected");
                message.s2c = $root.Qot_UpdateOrderDetail.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateOrderDetail.Response
         * @static
         * @param {Qot_UpdateOrderDetail.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_UpdateOrderDetail.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_UpdateOrderDetail.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_UpdateOrderDetail;
})();

$root.Qot_UpdatePriceReminder = (function() {

    /**
     * Namespace Qot_UpdatePriceReminder.
     * @exports Qot_UpdatePriceReminder
     * @namespace
     */
    var Qot_UpdatePriceReminder = {};

    /**
     * MarketStatus enum.
     * @name Qot_UpdatePriceReminder.MarketStatus
     * @enum {string}
     * @property {number} MarketStatus_Unknow=0 MarketStatus_Unknow value
     * @property {number} MarketStatus_Open=1 MarketStatus_Open value
     * @property {number} MarketStatus_USPre=2 MarketStatus_USPre value
     * @property {number} MarketStatus_USAfter=3 MarketStatus_USAfter value
     */
    Qot_UpdatePriceReminder.MarketStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MarketStatus_Unknow"] = 0;
        values[valuesById[1] = "MarketStatus_Open"] = 1;
        values[valuesById[2] = "MarketStatus_USPre"] = 2;
        values[valuesById[3] = "MarketStatus_USAfter"] = 3;
        return values;
    })();

    Qot_UpdatePriceReminder.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_UpdatePriceReminder
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {number} price S2C price
         * @property {number} changeRate S2C changeRate
         * @property {number} marketStatus S2C marketStatus
         * @property {string} content S2C content
         * @property {string} note S2C note
         * @property {number|Long|null} [key] S2C key
         * @property {number|null} [type] S2C type
         * @property {number|null} [setValue] S2C setValue
         * @property {number|null} [curValue] S2C curValue
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_UpdatePriceReminder
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_UpdatePriceReminder.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_UpdatePriceReminder.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C price.
         * @member {number} price
         * @memberof Qot_UpdatePriceReminder.S2C
         * @instance
         */
        S2C.prototype.price = 0;

        /**
         * S2C changeRate.
         * @member {number} changeRate
         * @memberof Qot_UpdatePriceReminder.S2C
         * @instance
         */
        S2C.prototype.changeRate = 0;

        /**
         * S2C marketStatus.
         * @member {number} marketStatus
         * @memberof Qot_UpdatePriceReminder.S2C
         * @instance
         */
        S2C.prototype.marketStatus = 0;

        /**
         * S2C content.
         * @member {string} content
         * @memberof Qot_UpdatePriceReminder.S2C
         * @instance
         */
        S2C.prototype.content = "";

        /**
         * S2C note.
         * @member {string} note
         * @memberof Qot_UpdatePriceReminder.S2C
         * @instance
         */
        S2C.prototype.note = "";

        /**
         * S2C key.
         * @member {number|Long} key
         * @memberof Qot_UpdatePriceReminder.S2C
         * @instance
         */
        S2C.prototype.key = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * S2C type.
         * @member {number} type
         * @memberof Qot_UpdatePriceReminder.S2C
         * @instance
         */
        S2C.prototype.type = 0;

        /**
         * S2C setValue.
         * @member {number} setValue
         * @memberof Qot_UpdatePriceReminder.S2C
         * @instance
         */
        S2C.prototype.setValue = 0;

        /**
         * S2C curValue.
         * @member {number} curValue
         * @memberof Qot_UpdatePriceReminder.S2C
         * @instance
         */
        S2C.prototype.curValue = 0;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_UpdatePriceReminder.S2C
         * @static
         * @param {Qot_UpdatePriceReminder.IS2C=} [properties] Properties to set
         * @returns {Qot_UpdatePriceReminder.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_UpdatePriceReminder.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdatePriceReminder.S2C
         * @static
         * @param {Qot_UpdatePriceReminder.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.price);
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.changeRate);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.marketStatus);
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.content);
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.note);
            if (message.key != null && message.hasOwnProperty("key"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.key);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.type);
            if (message.setValue != null && message.hasOwnProperty("setValue"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.setValue);
            if (message.curValue != null && message.hasOwnProperty("curValue"))
                writer.uint32(/* id 10, wireType 1 =*/81).double(message.curValue);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_UpdatePriceReminder.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdatePriceReminder.S2C
         * @static
         * @param {Qot_UpdatePriceReminder.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdatePriceReminder.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdatePriceReminder.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdatePriceReminder.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.price = reader.double();
                    break;
                case 3:
                    message.changeRate = reader.double();
                    break;
                case 4:
                    message.marketStatus = reader.int32();
                    break;
                case 5:
                    message.content = reader.string();
                    break;
                case 6:
                    message.note = reader.string();
                    break;
                case 7:
                    message.key = reader.int64();
                    break;
                case 8:
                    message.type = reader.int32();
                    break;
                case 9:
                    message.setValue = reader.double();
                    break;
                case 10:
                    message.curValue = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("price"))
                throw $util.ProtocolError("missing required 'price'", { instance: message });
            if (!message.hasOwnProperty("changeRate"))
                throw $util.ProtocolError("missing required 'changeRate'", { instance: message });
            if (!message.hasOwnProperty("marketStatus"))
                throw $util.ProtocolError("missing required 'marketStatus'", { instance: message });
            if (!message.hasOwnProperty("content"))
                throw $util.ProtocolError("missing required 'content'", { instance: message });
            if (!message.hasOwnProperty("note"))
                throw $util.ProtocolError("missing required 'note'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdatePriceReminder.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdatePriceReminder.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_UpdatePriceReminder.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (typeof message.price !== "number")
                return "price: number expected";
            if (typeof message.changeRate !== "number")
                return "changeRate: number expected";
            if (!$util.isInteger(message.marketStatus))
                return "marketStatus: integer expected";
            if (!$util.isString(message.content))
                return "content: string expected";
            if (!$util.isString(message.note))
                return "note: string expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isInteger(message.key) && !(message.key && $util.isInteger(message.key.low) && $util.isInteger(message.key.high)))
                    return "key: integer|Long expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.setValue != null && message.hasOwnProperty("setValue"))
                if (typeof message.setValue !== "number")
                    return "setValue: number expected";
            if (message.curValue != null && message.hasOwnProperty("curValue"))
                if (typeof message.curValue !== "number")
                    return "curValue: number expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdatePriceReminder.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdatePriceReminder.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdatePriceReminder.S2C)
                return object;
            var message = new $root.Qot_UpdatePriceReminder.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_UpdatePriceReminder.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.price != null)
                message.price = Number(object.price);
            if (object.changeRate != null)
                message.changeRate = Number(object.changeRate);
            if (object.marketStatus != null)
                message.marketStatus = object.marketStatus | 0;
            if (object.content != null)
                message.content = String(object.content);
            if (object.note != null)
                message.note = String(object.note);
            if (object.key != null)
                if ($util.Long)
                    (message.key = $util.Long.fromValue(object.key)).unsigned = false;
                else if (typeof object.key === "string")
                    message.key = parseInt(object.key, 10);
                else if (typeof object.key === "number")
                    message.key = object.key;
                else if (typeof object.key === "object")
                    message.key = new $util.LongBits(object.key.low >>> 0, object.key.high >>> 0).toNumber();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.setValue != null)
                message.setValue = Number(object.setValue);
            if (object.curValue != null)
                message.curValue = Number(object.curValue);
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdatePriceReminder.S2C
         * @static
         * @param {Qot_UpdatePriceReminder.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.security = null;
                object.price = 0;
                object.changeRate = 0;
                object.marketStatus = 0;
                object.content = "";
                object.note = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.key = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.key = options.longs === String ? "0" : 0;
                object.type = 0;
                object.setValue = 0;
                object.curValue = 0;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
            if (message.changeRate != null && message.hasOwnProperty("changeRate"))
                object.changeRate = options.json && !isFinite(message.changeRate) ? String(message.changeRate) : message.changeRate;
            if (message.marketStatus != null && message.hasOwnProperty("marketStatus"))
                object.marketStatus = message.marketStatus;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = message.content;
            if (message.note != null && message.hasOwnProperty("note"))
                object.note = message.note;
            if (message.key != null && message.hasOwnProperty("key"))
                if (typeof message.key === "number")
                    object.key = options.longs === String ? String(message.key) : message.key;
                else
                    object.key = options.longs === String ? $util.Long.prototype.toString.call(message.key) : options.longs === Number ? new $util.LongBits(message.key.low >>> 0, message.key.high >>> 0).toNumber() : message.key;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.setValue != null && message.hasOwnProperty("setValue"))
                object.setValue = options.json && !isFinite(message.setValue) ? String(message.setValue) : message.setValue;
            if (message.curValue != null && message.hasOwnProperty("curValue"))
                object.curValue = options.json && !isFinite(message.curValue) ? String(message.curValue) : message.curValue;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_UpdatePriceReminder.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_UpdatePriceReminder.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_UpdatePriceReminder
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_UpdatePriceReminder.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_UpdatePriceReminder
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_UpdatePriceReminder.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_UpdatePriceReminder.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_UpdatePriceReminder.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_UpdatePriceReminder.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_UpdatePriceReminder.IS2C|null|undefined} s2c
         * @memberof Qot_UpdatePriceReminder.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_UpdatePriceReminder.Response
         * @static
         * @param {Qot_UpdatePriceReminder.IResponse=} [properties] Properties to set
         * @returns {Qot_UpdatePriceReminder.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_UpdatePriceReminder.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdatePriceReminder.Response
         * @static
         * @param {Qot_UpdatePriceReminder.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_UpdatePriceReminder.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_UpdatePriceReminder.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdatePriceReminder.Response
         * @static
         * @param {Qot_UpdatePriceReminder.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdatePriceReminder.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdatePriceReminder.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdatePriceReminder.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_UpdatePriceReminder.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdatePriceReminder.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdatePriceReminder.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_UpdatePriceReminder.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_UpdatePriceReminder.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdatePriceReminder.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdatePriceReminder.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdatePriceReminder.Response)
                return object;
            var message = new $root.Qot_UpdatePriceReminder.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_UpdatePriceReminder.Response.s2c: object expected");
                message.s2c = $root.Qot_UpdatePriceReminder.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdatePriceReminder.Response
         * @static
         * @param {Qot_UpdatePriceReminder.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_UpdatePriceReminder.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_UpdatePriceReminder.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_UpdatePriceReminder;
})();

$root.Qot_UpdateRT = (function() {

    /**
     * Namespace Qot_UpdateRT.
     * @exports Qot_UpdateRT
     * @namespace
     */
    var Qot_UpdateRT = {};

    Qot_UpdateRT.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_UpdateRT
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.ITimeShare>|null} [rtList] S2C rtList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_UpdateRT
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_UpdateRT.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.rtList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_UpdateRT.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C rtList.
         * @member {Array.<Qot_Common.ITimeShare>} rtList
         * @memberof Qot_UpdateRT.S2C
         * @instance
         */
        S2C.prototype.rtList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateRT.S2C
         * @static
         * @param {Qot_UpdateRT.IS2C=} [properties] Properties to set
         * @returns {Qot_UpdateRT.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_UpdateRT.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateRT.S2C
         * @static
         * @param {Qot_UpdateRT.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.rtList != null && message.rtList.length)
                for (var i = 0; i < message.rtList.length; ++i)
                    $root.Qot_Common.TimeShare.encode(message.rtList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_UpdateRT.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateRT.S2C
         * @static
         * @param {Qot_UpdateRT.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateRT.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateRT.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateRT.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.rtList && message.rtList.length))
                        message.rtList = [];
                    message.rtList.push($root.Qot_Common.TimeShare.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateRT.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateRT.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_UpdateRT.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.rtList != null && message.hasOwnProperty("rtList")) {
                if (!Array.isArray(message.rtList))
                    return "rtList: array expected";
                for (var i = 0; i < message.rtList.length; ++i) {
                    var error = $root.Qot_Common.TimeShare.verify(message.rtList[i]);
                    if (error)
                        return "rtList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateRT.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateRT.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateRT.S2C)
                return object;
            var message = new $root.Qot_UpdateRT.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_UpdateRT.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.rtList) {
                if (!Array.isArray(object.rtList))
                    throw TypeError(".Qot_UpdateRT.S2C.rtList: array expected");
                message.rtList = [];
                for (var i = 0; i < object.rtList.length; ++i) {
                    if (typeof object.rtList[i] !== "object")
                        throw TypeError(".Qot_UpdateRT.S2C.rtList: object expected");
                    message.rtList[i] = $root.Qot_Common.TimeShare.fromObject(object.rtList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateRT.S2C
         * @static
         * @param {Qot_UpdateRT.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.rtList = [];
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.rtList && message.rtList.length) {
                object.rtList = [];
                for (var j = 0; j < message.rtList.length; ++j)
                    object.rtList[j] = $root.Qot_Common.TimeShare.toObject(message.rtList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_UpdateRT.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_UpdateRT.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_UpdateRT
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_UpdateRT.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_UpdateRT
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_UpdateRT.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_UpdateRT.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_UpdateRT.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_UpdateRT.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_UpdateRT.IS2C|null|undefined} s2c
         * @memberof Qot_UpdateRT.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateRT.Response
         * @static
         * @param {Qot_UpdateRT.IResponse=} [properties] Properties to set
         * @returns {Qot_UpdateRT.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_UpdateRT.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateRT.Response
         * @static
         * @param {Qot_UpdateRT.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_UpdateRT.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_UpdateRT.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateRT.Response
         * @static
         * @param {Qot_UpdateRT.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateRT.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateRT.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateRT.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_UpdateRT.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateRT.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateRT.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_UpdateRT.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_UpdateRT.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateRT.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateRT.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateRT.Response)
                return object;
            var message = new $root.Qot_UpdateRT.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_UpdateRT.Response.s2c: object expected");
                message.s2c = $root.Qot_UpdateRT.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateRT.Response
         * @static
         * @param {Qot_UpdateRT.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_UpdateRT.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_UpdateRT.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_UpdateRT;
})();

$root.Qot_UpdateTicker = (function() {

    /**
     * Namespace Qot_UpdateTicker.
     * @exports Qot_UpdateTicker
     * @namespace
     */
    var Qot_UpdateTicker = {};

    Qot_UpdateTicker.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_UpdateTicker
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.ITicker>|null} [tickerList] S2C tickerList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_UpdateTicker
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_UpdateTicker.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.tickerList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_UpdateTicker.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C tickerList.
         * @member {Array.<Qot_Common.ITicker>} tickerList
         * @memberof Qot_UpdateTicker.S2C
         * @instance
         */
        S2C.prototype.tickerList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateTicker.S2C
         * @static
         * @param {Qot_UpdateTicker.IS2C=} [properties] Properties to set
         * @returns {Qot_UpdateTicker.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_UpdateTicker.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateTicker.S2C
         * @static
         * @param {Qot_UpdateTicker.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.tickerList != null && message.tickerList.length)
                for (var i = 0; i < message.tickerList.length; ++i)
                    $root.Qot_Common.Ticker.encode(message.tickerList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_UpdateTicker.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateTicker.S2C
         * @static
         * @param {Qot_UpdateTicker.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateTicker.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateTicker.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateTicker.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.tickerList && message.tickerList.length))
                        message.tickerList = [];
                    message.tickerList.push($root.Qot_Common.Ticker.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateTicker.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateTicker.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_UpdateTicker.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.tickerList != null && message.hasOwnProperty("tickerList")) {
                if (!Array.isArray(message.tickerList))
                    return "tickerList: array expected";
                for (var i = 0; i < message.tickerList.length; ++i) {
                    var error = $root.Qot_Common.Ticker.verify(message.tickerList[i]);
                    if (error)
                        return "tickerList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateTicker.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateTicker.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateTicker.S2C)
                return object;
            var message = new $root.Qot_UpdateTicker.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_UpdateTicker.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.tickerList) {
                if (!Array.isArray(object.tickerList))
                    throw TypeError(".Qot_UpdateTicker.S2C.tickerList: array expected");
                message.tickerList = [];
                for (var i = 0; i < object.tickerList.length; ++i) {
                    if (typeof object.tickerList[i] !== "object")
                        throw TypeError(".Qot_UpdateTicker.S2C.tickerList: object expected");
                    message.tickerList[i] = $root.Qot_Common.Ticker.fromObject(object.tickerList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateTicker.S2C
         * @static
         * @param {Qot_UpdateTicker.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tickerList = [];
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.tickerList && message.tickerList.length) {
                object.tickerList = [];
                for (var j = 0; j < message.tickerList.length; ++j)
                    object.tickerList[j] = $root.Qot_Common.Ticker.toObject(message.tickerList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_UpdateTicker.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_UpdateTicker.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_UpdateTicker
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_UpdateTicker.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_UpdateTicker
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_UpdateTicker.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_UpdateTicker.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_UpdateTicker.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_UpdateTicker.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_UpdateTicker.IS2C|null|undefined} s2c
         * @memberof Qot_UpdateTicker.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateTicker.Response
         * @static
         * @param {Qot_UpdateTicker.IResponse=} [properties] Properties to set
         * @returns {Qot_UpdateTicker.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_UpdateTicker.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateTicker.Response
         * @static
         * @param {Qot_UpdateTicker.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_UpdateTicker.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_UpdateTicker.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateTicker.Response
         * @static
         * @param {Qot_UpdateTicker.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateTicker.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateTicker.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateTicker.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_UpdateTicker.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateTicker.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateTicker.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_UpdateTicker.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_UpdateTicker.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateTicker.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateTicker.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateTicker.Response)
                return object;
            var message = new $root.Qot_UpdateTicker.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_UpdateTicker.Response.s2c: object expected");
                message.s2c = $root.Qot_UpdateTicker.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateTicker.Response
         * @static
         * @param {Qot_UpdateTicker.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_UpdateTicker.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_UpdateTicker.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_UpdateTicker;
})();

$root.TestCmd = (function() {

    /**
     * Namespace TestCmd.
     * @exports TestCmd
     * @namespace
     */
    var TestCmd = {};

    TestCmd.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof TestCmd
         * @interface IC2S
         * @property {string} cmd C2S cmd
         * @property {string|null} [params] C2S params
         */

        /**
         * Constructs a new C2S.
         * @memberof TestCmd
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {TestCmd.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S cmd.
         * @member {string} cmd
         * @memberof TestCmd.C2S
         * @instance
         */
        C2S.prototype.cmd = "";

        /**
         * C2S params.
         * @member {string} params
         * @memberof TestCmd.C2S
         * @instance
         */
        C2S.prototype.params = "";

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof TestCmd.C2S
         * @static
         * @param {TestCmd.IC2S=} [properties] Properties to set
         * @returns {TestCmd.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link TestCmd.C2S.verify|verify} messages.
         * @function encode
         * @memberof TestCmd.C2S
         * @static
         * @param {TestCmd.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.cmd);
            if (message.params != null && message.hasOwnProperty("params"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.params);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link TestCmd.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof TestCmd.C2S
         * @static
         * @param {TestCmd.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof TestCmd.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {TestCmd.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TestCmd.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cmd = reader.string();
                    break;
                case 2:
                    message.params = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("cmd"))
                throw $util.ProtocolError("missing required 'cmd'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof TestCmd.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {TestCmd.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof TestCmd.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.cmd))
                return "cmd: string expected";
            if (message.params != null && message.hasOwnProperty("params"))
                if (!$util.isString(message.params))
                    return "params: string expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof TestCmd.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {TestCmd.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.TestCmd.C2S)
                return object;
            var message = new $root.TestCmd.C2S();
            if (object.cmd != null)
                message.cmd = String(object.cmd);
            if (object.params != null)
                message.params = String(object.params);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof TestCmd.C2S
         * @static
         * @param {TestCmd.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.cmd = "";
                object.params = "";
            }
            if (message.cmd != null && message.hasOwnProperty("cmd"))
                object.cmd = message.cmd;
            if (message.params != null && message.hasOwnProperty("params"))
                object.params = message.params;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof TestCmd.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    TestCmd.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof TestCmd
         * @interface IS2C
         * @property {string} cmd S2C cmd
         * @property {string} result S2C result
         */

        /**
         * Constructs a new S2C.
         * @memberof TestCmd
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {TestCmd.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C cmd.
         * @member {string} cmd
         * @memberof TestCmd.S2C
         * @instance
         */
        S2C.prototype.cmd = "";

        /**
         * S2C result.
         * @member {string} result
         * @memberof TestCmd.S2C
         * @instance
         */
        S2C.prototype.result = "";

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof TestCmd.S2C
         * @static
         * @param {TestCmd.IS2C=} [properties] Properties to set
         * @returns {TestCmd.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link TestCmd.S2C.verify|verify} messages.
         * @function encode
         * @memberof TestCmd.S2C
         * @static
         * @param {TestCmd.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.cmd);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.result);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link TestCmd.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof TestCmd.S2C
         * @static
         * @param {TestCmd.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof TestCmd.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {TestCmd.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TestCmd.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cmd = reader.string();
                    break;
                case 2:
                    message.result = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("cmd"))
                throw $util.ProtocolError("missing required 'cmd'", { instance: message });
            if (!message.hasOwnProperty("result"))
                throw $util.ProtocolError("missing required 'result'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof TestCmd.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {TestCmd.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof TestCmd.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.cmd))
                return "cmd: string expected";
            if (!$util.isString(message.result))
                return "result: string expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof TestCmd.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {TestCmd.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.TestCmd.S2C)
                return object;
            var message = new $root.TestCmd.S2C();
            if (object.cmd != null)
                message.cmd = String(object.cmd);
            if (object.result != null)
                message.result = String(object.result);
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof TestCmd.S2C
         * @static
         * @param {TestCmd.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.cmd = "";
                object.result = "";
            }
            if (message.cmd != null && message.hasOwnProperty("cmd"))
                object.cmd = message.cmd;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = message.result;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof TestCmd.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    TestCmd.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof TestCmd
         * @interface IRequest
         * @property {TestCmd.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof TestCmd
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {TestCmd.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {TestCmd.IC2S} c2s
         * @memberof TestCmd.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof TestCmd.Request
         * @static
         * @param {TestCmd.IRequest=} [properties] Properties to set
         * @returns {TestCmd.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link TestCmd.Request.verify|verify} messages.
         * @function encode
         * @memberof TestCmd.Request
         * @static
         * @param {TestCmd.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.TestCmd.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link TestCmd.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof TestCmd.Request
         * @static
         * @param {TestCmd.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof TestCmd.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {TestCmd.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TestCmd.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.TestCmd.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof TestCmd.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {TestCmd.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof TestCmd.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.TestCmd.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof TestCmd.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {TestCmd.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.TestCmd.Request)
                return object;
            var message = new $root.TestCmd.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".TestCmd.Request.c2s: object expected");
                message.c2s = $root.TestCmd.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof TestCmd.Request
         * @static
         * @param {TestCmd.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.TestCmd.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof TestCmd.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    TestCmd.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof TestCmd
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {TestCmd.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof TestCmd
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {TestCmd.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof TestCmd.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof TestCmd.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof TestCmd.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {TestCmd.IS2C|null|undefined} s2c
         * @memberof TestCmd.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof TestCmd.Response
         * @static
         * @param {TestCmd.IResponse=} [properties] Properties to set
         * @returns {TestCmd.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link TestCmd.Response.verify|verify} messages.
         * @function encode
         * @memberof TestCmd.Response
         * @static
         * @param {TestCmd.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.TestCmd.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link TestCmd.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof TestCmd.Response
         * @static
         * @param {TestCmd.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof TestCmd.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {TestCmd.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TestCmd.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.TestCmd.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof TestCmd.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {TestCmd.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof TestCmd.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.TestCmd.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof TestCmd.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {TestCmd.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.TestCmd.Response)
                return object;
            var message = new $root.TestCmd.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".TestCmd.Response.s2c: object expected");
                message.s2c = $root.TestCmd.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof TestCmd.Response
         * @static
         * @param {TestCmd.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.TestCmd.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof TestCmd.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return TestCmd;
})();

$root.Trd_Common = (function() {

    /**
     * Namespace Trd_Common.
     * @exports Trd_Common
     * @namespace
     */
    var Trd_Common = {};

    /**
     * TrdEnv enum.
     * @name Trd_Common.TrdEnv
     * @enum {string}
     * @property {number} TrdEnv_Simulate=0 TrdEnv_Simulate value
     * @property {number} TrdEnv_Real=1 TrdEnv_Real value
     */
    Trd_Common.TrdEnv = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TrdEnv_Simulate"] = 0;
        values[valuesById[1] = "TrdEnv_Real"] = 1;
        return values;
    })();

    /**
     * TrdMarket enum.
     * @name Trd_Common.TrdMarket
     * @enum {string}
     * @property {number} TrdMarket_Unknown=0 TrdMarket_Unknown value
     * @property {number} TrdMarket_HK=1 TrdMarket_HK value
     * @property {number} TrdMarket_US=2 TrdMarket_US value
     * @property {number} TrdMarket_CN=3 TrdMarket_CN value
     * @property {number} TrdMarket_HKCC=4 TrdMarket_HKCC value
     * @property {number} TrdMarket_Futures=5 TrdMarket_Futures value
     */
    Trd_Common.TrdMarket = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TrdMarket_Unknown"] = 0;
        values[valuesById[1] = "TrdMarket_HK"] = 1;
        values[valuesById[2] = "TrdMarket_US"] = 2;
        values[valuesById[3] = "TrdMarket_CN"] = 3;
        values[valuesById[4] = "TrdMarket_HKCC"] = 4;
        values[valuesById[5] = "TrdMarket_Futures"] = 5;
        return values;
    })();

    /**
     * TrdSecMarket enum.
     * @name Trd_Common.TrdSecMarket
     * @enum {string}
     * @property {number} TrdSecMarket_Unknown=0 TrdSecMarket_Unknown value
     * @property {number} TrdSecMarket_HK=1 TrdSecMarket_HK value
     * @property {number} TrdSecMarket_US=2 TrdSecMarket_US value
     * @property {number} TrdSecMarket_CN_SH=31 TrdSecMarket_CN_SH value
     * @property {number} TrdSecMarket_CN_SZ=32 TrdSecMarket_CN_SZ value
     */
    Trd_Common.TrdSecMarket = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TrdSecMarket_Unknown"] = 0;
        values[valuesById[1] = "TrdSecMarket_HK"] = 1;
        values[valuesById[2] = "TrdSecMarket_US"] = 2;
        values[valuesById[31] = "TrdSecMarket_CN_SH"] = 31;
        values[valuesById[32] = "TrdSecMarket_CN_SZ"] = 32;
        return values;
    })();

    /**
     * TrdSide enum.
     * @name Trd_Common.TrdSide
     * @enum {string}
     * @property {number} TrdSide_Unknown=0 TrdSide_Unknown value
     * @property {number} TrdSide_Buy=1 TrdSide_Buy value
     * @property {number} TrdSide_Sell=2 TrdSide_Sell value
     * @property {number} TrdSide_SellShort=3 TrdSide_SellShort value
     * @property {number} TrdSide_BuyBack=4 TrdSide_BuyBack value
     */
    Trd_Common.TrdSide = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TrdSide_Unknown"] = 0;
        values[valuesById[1] = "TrdSide_Buy"] = 1;
        values[valuesById[2] = "TrdSide_Sell"] = 2;
        values[valuesById[3] = "TrdSide_SellShort"] = 3;
        values[valuesById[4] = "TrdSide_BuyBack"] = 4;
        return values;
    })();

    /**
     * OrderType enum.
     * @name Trd_Common.OrderType
     * @enum {string}
     * @property {number} OrderType_Unknown=0 OrderType_Unknown value
     * @property {number} OrderType_Normal=1 OrderType_Normal value
     * @property {number} OrderType_Market=2 OrderType_Market value
     * @property {number} OrderType_AbsoluteLimit=5 OrderType_AbsoluteLimit value
     * @property {number} OrderType_Auction=6 OrderType_Auction value
     * @property {number} OrderType_AuctionLimit=7 OrderType_AuctionLimit value
     * @property {number} OrderType_SpecialLimit=8 OrderType_SpecialLimit value
     * @property {number} OrderType_SpecialLimit_All=9 OrderType_SpecialLimit_All value
     */
    Trd_Common.OrderType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OrderType_Unknown"] = 0;
        values[valuesById[1] = "OrderType_Normal"] = 1;
        values[valuesById[2] = "OrderType_Market"] = 2;
        values[valuesById[5] = "OrderType_AbsoluteLimit"] = 5;
        values[valuesById[6] = "OrderType_Auction"] = 6;
        values[valuesById[7] = "OrderType_AuctionLimit"] = 7;
        values[valuesById[8] = "OrderType_SpecialLimit"] = 8;
        values[valuesById[9] = "OrderType_SpecialLimit_All"] = 9;
        return values;
    })();

    /**
     * OrderStatus enum.
     * @name Trd_Common.OrderStatus
     * @enum {string}
     * @property {number} OrderStatus_Unsubmitted=0 OrderStatus_Unsubmitted value
     * @property {number} OrderStatus_Unknown=-1 OrderStatus_Unknown value
     * @property {number} OrderStatus_WaitingSubmit=1 OrderStatus_WaitingSubmit value
     * @property {number} OrderStatus_Submitting=2 OrderStatus_Submitting value
     * @property {number} OrderStatus_SubmitFailed=3 OrderStatus_SubmitFailed value
     * @property {number} OrderStatus_TimeOut=4 OrderStatus_TimeOut value
     * @property {number} OrderStatus_Submitted=5 OrderStatus_Submitted value
     * @property {number} OrderStatus_Filled_Part=10 OrderStatus_Filled_Part value
     * @property {number} OrderStatus_Filled_All=11 OrderStatus_Filled_All value
     * @property {number} OrderStatus_Cancelling_Part=12 OrderStatus_Cancelling_Part value
     * @property {number} OrderStatus_Cancelling_All=13 OrderStatus_Cancelling_All value
     * @property {number} OrderStatus_Cancelled_Part=14 OrderStatus_Cancelled_Part value
     * @property {number} OrderStatus_Cancelled_All=15 OrderStatus_Cancelled_All value
     * @property {number} OrderStatus_Failed=21 OrderStatus_Failed value
     * @property {number} OrderStatus_Disabled=22 OrderStatus_Disabled value
     * @property {number} OrderStatus_Deleted=23 OrderStatus_Deleted value
     * @property {number} OrderStatus_FillCancelled=24 OrderStatus_FillCancelled value
     */
    Trd_Common.OrderStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OrderStatus_Unsubmitted"] = 0;
        values[valuesById[-1] = "OrderStatus_Unknown"] = -1;
        values[valuesById[1] = "OrderStatus_WaitingSubmit"] = 1;
        values[valuesById[2] = "OrderStatus_Submitting"] = 2;
        values[valuesById[3] = "OrderStatus_SubmitFailed"] = 3;
        values[valuesById[4] = "OrderStatus_TimeOut"] = 4;
        values[valuesById[5] = "OrderStatus_Submitted"] = 5;
        values[valuesById[10] = "OrderStatus_Filled_Part"] = 10;
        values[valuesById[11] = "OrderStatus_Filled_All"] = 11;
        values[valuesById[12] = "OrderStatus_Cancelling_Part"] = 12;
        values[valuesById[13] = "OrderStatus_Cancelling_All"] = 13;
        values[valuesById[14] = "OrderStatus_Cancelled_Part"] = 14;
        values[valuesById[15] = "OrderStatus_Cancelled_All"] = 15;
        values[valuesById[21] = "OrderStatus_Failed"] = 21;
        values[valuesById[22] = "OrderStatus_Disabled"] = 22;
        values[valuesById[23] = "OrderStatus_Deleted"] = 23;
        values[valuesById[24] = "OrderStatus_FillCancelled"] = 24;
        return values;
    })();

    /**
     * OrderFillStatus enum.
     * @name Trd_Common.OrderFillStatus
     * @enum {string}
     * @property {number} OrderFillStatus_OK=0 OrderFillStatus_OK value
     * @property {number} OrderFillStatus_Cancelled=1 OrderFillStatus_Cancelled value
     * @property {number} OrderFillStatus_Changed=2 OrderFillStatus_Changed value
     */
    Trd_Common.OrderFillStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OrderFillStatus_OK"] = 0;
        values[valuesById[1] = "OrderFillStatus_Cancelled"] = 1;
        values[valuesById[2] = "OrderFillStatus_Changed"] = 2;
        return values;
    })();

    /**
     * PositionSide enum.
     * @name Trd_Common.PositionSide
     * @enum {string}
     * @property {number} PositionSide_Long=0 PositionSide_Long value
     * @property {number} PositionSide_Unknown=-1 PositionSide_Unknown value
     * @property {number} PositionSide_Short=1 PositionSide_Short value
     */
    Trd_Common.PositionSide = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PositionSide_Long"] = 0;
        values[valuesById[-1] = "PositionSide_Unknown"] = -1;
        values[valuesById[1] = "PositionSide_Short"] = 1;
        return values;
    })();

    /**
     * ModifyOrderOp enum.
     * @name Trd_Common.ModifyOrderOp
     * @enum {string}
     * @property {number} ModifyOrderOp_Unknown=0 ModifyOrderOp_Unknown value
     * @property {number} ModifyOrderOp_Normal=1 ModifyOrderOp_Normal value
     * @property {number} ModifyOrderOp_Cancel=2 ModifyOrderOp_Cancel value
     * @property {number} ModifyOrderOp_Disable=3 ModifyOrderOp_Disable value
     * @property {number} ModifyOrderOp_Enable=4 ModifyOrderOp_Enable value
     * @property {number} ModifyOrderOp_Delete=5 ModifyOrderOp_Delete value
     */
    Trd_Common.ModifyOrderOp = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ModifyOrderOp_Unknown"] = 0;
        values[valuesById[1] = "ModifyOrderOp_Normal"] = 1;
        values[valuesById[2] = "ModifyOrderOp_Cancel"] = 2;
        values[valuesById[3] = "ModifyOrderOp_Disable"] = 3;
        values[valuesById[4] = "ModifyOrderOp_Enable"] = 4;
        values[valuesById[5] = "ModifyOrderOp_Delete"] = 5;
        return values;
    })();

    /**
     * TrdAccType enum.
     * @name Trd_Common.TrdAccType
     * @enum {string}
     * @property {number} TrdAccType_Unknown=0 TrdAccType_Unknown value
     * @property {number} TrdAccType_Cash=1 TrdAccType_Cash value
     * @property {number} TrdAccType_Margin=2 TrdAccType_Margin value
     */
    Trd_Common.TrdAccType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TrdAccType_Unknown"] = 0;
        values[valuesById[1] = "TrdAccType_Cash"] = 1;
        values[valuesById[2] = "TrdAccType_Margin"] = 2;
        return values;
    })();

    /**
     * Currency enum.
     * @name Trd_Common.Currency
     * @enum {string}
     * @property {number} Currency_Unknown=0 Currency_Unknown value
     * @property {number} Currency_HKD=1 Currency_HKD value
     * @property {number} Currency_USD=2 Currency_USD value
     * @property {number} Currency_CNH=3 Currency_CNH value
     */
    Trd_Common.Currency = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Currency_Unknown"] = 0;
        values[valuesById[1] = "Currency_HKD"] = 1;
        values[valuesById[2] = "Currency_USD"] = 2;
        values[valuesById[3] = "Currency_CNH"] = 3;
        return values;
    })();

    /**
     * CltRiskLevel enum.
     * @name Trd_Common.CltRiskLevel
     * @enum {string}
     * @property {number} CltRiskLevel_Unknown=-1 CltRiskLevel_Unknown value
     * @property {number} CltRiskLevel_Safe=0 CltRiskLevel_Safe value
     * @property {number} CltRiskLevel_Warning=1 CltRiskLevel_Warning value
     * @property {number} CltRiskLevel_Danger=2 CltRiskLevel_Danger value
     * @property {number} CltRiskLevel_AbsoluteSafe=3 CltRiskLevel_AbsoluteSafe value
     * @property {number} CltRiskLevel_OptDanger=4 CltRiskLevel_OptDanger value
     */
    Trd_Common.CltRiskLevel = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[-1] = "CltRiskLevel_Unknown"] = -1;
        values[valuesById[0] = "CltRiskLevel_Safe"] = 0;
        values[valuesById[1] = "CltRiskLevel_Warning"] = 1;
        values[valuesById[2] = "CltRiskLevel_Danger"] = 2;
        values[valuesById[3] = "CltRiskLevel_AbsoluteSafe"] = 3;
        values[valuesById[4] = "CltRiskLevel_OptDanger"] = 4;
        return values;
    })();

    Trd_Common.AccCashInfo = (function() {

        /**
         * Properties of an AccCashInfo.
         * @memberof Trd_Common
         * @interface IAccCashInfo
         * @property {number|null} [currency] AccCashInfo currency
         * @property {number|null} [cash] AccCashInfo cash
         * @property {number|null} [availableBalance] AccCashInfo availableBalance
         */

        /**
         * Constructs a new AccCashInfo.
         * @memberof Trd_Common
         * @classdesc Represents an AccCashInfo.
         * @implements IAccCashInfo
         * @constructor
         * @param {Trd_Common.IAccCashInfo=} [properties] Properties to set
         */
        function AccCashInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccCashInfo currency.
         * @member {number} currency
         * @memberof Trd_Common.AccCashInfo
         * @instance
         */
        AccCashInfo.prototype.currency = 0;

        /**
         * AccCashInfo cash.
         * @member {number} cash
         * @memberof Trd_Common.AccCashInfo
         * @instance
         */
        AccCashInfo.prototype.cash = 0;

        /**
         * AccCashInfo availableBalance.
         * @member {number} availableBalance
         * @memberof Trd_Common.AccCashInfo
         * @instance
         */
        AccCashInfo.prototype.availableBalance = 0;

        /**
         * Creates a new AccCashInfo instance using the specified properties.
         * @function create
         * @memberof Trd_Common.AccCashInfo
         * @static
         * @param {Trd_Common.IAccCashInfo=} [properties] Properties to set
         * @returns {Trd_Common.AccCashInfo} AccCashInfo instance
         */
        AccCashInfo.create = function create(properties) {
            return new AccCashInfo(properties);
        };

        /**
         * Encodes the specified AccCashInfo message. Does not implicitly {@link Trd_Common.AccCashInfo.verify|verify} messages.
         * @function encode
         * @memberof Trd_Common.AccCashInfo
         * @static
         * @param {Trd_Common.IAccCashInfo} message AccCashInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccCashInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currency != null && message.hasOwnProperty("currency"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.currency);
            if (message.cash != null && message.hasOwnProperty("cash"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.cash);
            if (message.availableBalance != null && message.hasOwnProperty("availableBalance"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.availableBalance);
            return writer;
        };

        /**
         * Encodes the specified AccCashInfo message, length delimited. Does not implicitly {@link Trd_Common.AccCashInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_Common.AccCashInfo
         * @static
         * @param {Trd_Common.IAccCashInfo} message AccCashInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccCashInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccCashInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_Common.AccCashInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_Common.AccCashInfo} AccCashInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccCashInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_Common.AccCashInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.currency = reader.int32();
                    break;
                case 2:
                    message.cash = reader.double();
                    break;
                case 3:
                    message.availableBalance = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccCashInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_Common.AccCashInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_Common.AccCashInfo} AccCashInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccCashInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccCashInfo message.
         * @function verify
         * @memberof Trd_Common.AccCashInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccCashInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currency != null && message.hasOwnProperty("currency"))
                if (!$util.isInteger(message.currency))
                    return "currency: integer expected";
            if (message.cash != null && message.hasOwnProperty("cash"))
                if (typeof message.cash !== "number")
                    return "cash: number expected";
            if (message.availableBalance != null && message.hasOwnProperty("availableBalance"))
                if (typeof message.availableBalance !== "number")
                    return "availableBalance: number expected";
            return null;
        };

        /**
         * Creates an AccCashInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_Common.AccCashInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_Common.AccCashInfo} AccCashInfo
         */
        AccCashInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_Common.AccCashInfo)
                return object;
            var message = new $root.Trd_Common.AccCashInfo();
            if (object.currency != null)
                message.currency = object.currency | 0;
            if (object.cash != null)
                message.cash = Number(object.cash);
            if (object.availableBalance != null)
                message.availableBalance = Number(object.availableBalance);
            return message;
        };

        /**
         * Creates a plain object from an AccCashInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_Common.AccCashInfo
         * @static
         * @param {Trd_Common.AccCashInfo} message AccCashInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccCashInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.currency = 0;
                object.cash = 0;
                object.availableBalance = 0;
            }
            if (message.currency != null && message.hasOwnProperty("currency"))
                object.currency = message.currency;
            if (message.cash != null && message.hasOwnProperty("cash"))
                object.cash = options.json && !isFinite(message.cash) ? String(message.cash) : message.cash;
            if (message.availableBalance != null && message.hasOwnProperty("availableBalance"))
                object.availableBalance = options.json && !isFinite(message.availableBalance) ? String(message.availableBalance) : message.availableBalance;
            return object;
        };

        /**
         * Converts this AccCashInfo to JSON.
         * @function toJSON
         * @memberof Trd_Common.AccCashInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccCashInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccCashInfo;
    })();

    Trd_Common.TrdHeader = (function() {

        /**
         * Properties of a TrdHeader.
         * @memberof Trd_Common
         * @interface ITrdHeader
         * @property {number} trdEnv TrdHeader trdEnv
         * @property {number|Long} accID TrdHeader accID
         * @property {number} trdMarket TrdHeader trdMarket
         */

        /**
         * Constructs a new TrdHeader.
         * @memberof Trd_Common
         * @classdesc Represents a TrdHeader.
         * @implements ITrdHeader
         * @constructor
         * @param {Trd_Common.ITrdHeader=} [properties] Properties to set
         */
        function TrdHeader(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TrdHeader trdEnv.
         * @member {number} trdEnv
         * @memberof Trd_Common.TrdHeader
         * @instance
         */
        TrdHeader.prototype.trdEnv = 0;

        /**
         * TrdHeader accID.
         * @member {number|Long} accID
         * @memberof Trd_Common.TrdHeader
         * @instance
         */
        TrdHeader.prototype.accID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TrdHeader trdMarket.
         * @member {number} trdMarket
         * @memberof Trd_Common.TrdHeader
         * @instance
         */
        TrdHeader.prototype.trdMarket = 0;

        /**
         * Creates a new TrdHeader instance using the specified properties.
         * @function create
         * @memberof Trd_Common.TrdHeader
         * @static
         * @param {Trd_Common.ITrdHeader=} [properties] Properties to set
         * @returns {Trd_Common.TrdHeader} TrdHeader instance
         */
        TrdHeader.create = function create(properties) {
            return new TrdHeader(properties);
        };

        /**
         * Encodes the specified TrdHeader message. Does not implicitly {@link Trd_Common.TrdHeader.verify|verify} messages.
         * @function encode
         * @memberof Trd_Common.TrdHeader
         * @static
         * @param {Trd_Common.ITrdHeader} message TrdHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrdHeader.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.trdEnv);
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.accID);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.trdMarket);
            return writer;
        };

        /**
         * Encodes the specified TrdHeader message, length delimited. Does not implicitly {@link Trd_Common.TrdHeader.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_Common.TrdHeader
         * @static
         * @param {Trd_Common.ITrdHeader} message TrdHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrdHeader.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TrdHeader message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_Common.TrdHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_Common.TrdHeader} TrdHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrdHeader.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_Common.TrdHeader();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trdEnv = reader.int32();
                    break;
                case 2:
                    message.accID = reader.uint64();
                    break;
                case 3:
                    message.trdMarket = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("trdEnv"))
                throw $util.ProtocolError("missing required 'trdEnv'", { instance: message });
            if (!message.hasOwnProperty("accID"))
                throw $util.ProtocolError("missing required 'accID'", { instance: message });
            if (!message.hasOwnProperty("trdMarket"))
                throw $util.ProtocolError("missing required 'trdMarket'", { instance: message });
            return message;
        };

        /**
         * Decodes a TrdHeader message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_Common.TrdHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_Common.TrdHeader} TrdHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrdHeader.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TrdHeader message.
         * @function verify
         * @memberof Trd_Common.TrdHeader
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TrdHeader.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.trdEnv))
                return "trdEnv: integer expected";
            if (!$util.isInteger(message.accID) && !(message.accID && $util.isInteger(message.accID.low) && $util.isInteger(message.accID.high)))
                return "accID: integer|Long expected";
            if (!$util.isInteger(message.trdMarket))
                return "trdMarket: integer expected";
            return null;
        };

        /**
         * Creates a TrdHeader message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_Common.TrdHeader
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_Common.TrdHeader} TrdHeader
         */
        TrdHeader.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_Common.TrdHeader)
                return object;
            var message = new $root.Trd_Common.TrdHeader();
            if (object.trdEnv != null)
                message.trdEnv = object.trdEnv | 0;
            if (object.accID != null)
                if ($util.Long)
                    (message.accID = $util.Long.fromValue(object.accID)).unsigned = true;
                else if (typeof object.accID === "string")
                    message.accID = parseInt(object.accID, 10);
                else if (typeof object.accID === "number")
                    message.accID = object.accID;
                else if (typeof object.accID === "object")
                    message.accID = new $util.LongBits(object.accID.low >>> 0, object.accID.high >>> 0).toNumber(true);
            if (object.trdMarket != null)
                message.trdMarket = object.trdMarket | 0;
            return message;
        };

        /**
         * Creates a plain object from a TrdHeader message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_Common.TrdHeader
         * @static
         * @param {Trd_Common.TrdHeader} message TrdHeader
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TrdHeader.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.trdEnv = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.accID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.accID = options.longs === String ? "0" : 0;
                object.trdMarket = 0;
            }
            if (message.trdEnv != null && message.hasOwnProperty("trdEnv"))
                object.trdEnv = message.trdEnv;
            if (message.accID != null && message.hasOwnProperty("accID"))
                if (typeof message.accID === "number")
                    object.accID = options.longs === String ? String(message.accID) : message.accID;
                else
                    object.accID = options.longs === String ? $util.Long.prototype.toString.call(message.accID) : options.longs === Number ? new $util.LongBits(message.accID.low >>> 0, message.accID.high >>> 0).toNumber(true) : message.accID;
            if (message.trdMarket != null && message.hasOwnProperty("trdMarket"))
                object.trdMarket = message.trdMarket;
            return object;
        };

        /**
         * Converts this TrdHeader to JSON.
         * @function toJSON
         * @memberof Trd_Common.TrdHeader
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TrdHeader.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TrdHeader;
    })();

    Trd_Common.TrdAcc = (function() {

        /**
         * Properties of a TrdAcc.
         * @memberof Trd_Common
         * @interface ITrdAcc
         * @property {number} trdEnv TrdAcc trdEnv
         * @property {number|Long} accID TrdAcc accID
         * @property {Array.<number>|null} [trdMarketAuthList] TrdAcc trdMarketAuthList
         * @property {number|null} [accType] TrdAcc accType
         * @property {string|null} [cardNum] TrdAcc cardNum
         */

        /**
         * Constructs a new TrdAcc.
         * @memberof Trd_Common
         * @classdesc Represents a TrdAcc.
         * @implements ITrdAcc
         * @constructor
         * @param {Trd_Common.ITrdAcc=} [properties] Properties to set
         */
        function TrdAcc(properties) {
            this.trdMarketAuthList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TrdAcc trdEnv.
         * @member {number} trdEnv
         * @memberof Trd_Common.TrdAcc
         * @instance
         */
        TrdAcc.prototype.trdEnv = 0;

        /**
         * TrdAcc accID.
         * @member {number|Long} accID
         * @memberof Trd_Common.TrdAcc
         * @instance
         */
        TrdAcc.prototype.accID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TrdAcc trdMarketAuthList.
         * @member {Array.<number>} trdMarketAuthList
         * @memberof Trd_Common.TrdAcc
         * @instance
         */
        TrdAcc.prototype.trdMarketAuthList = $util.emptyArray;

        /**
         * TrdAcc accType.
         * @member {number} accType
         * @memberof Trd_Common.TrdAcc
         * @instance
         */
        TrdAcc.prototype.accType = 0;

        /**
         * TrdAcc cardNum.
         * @member {string} cardNum
         * @memberof Trd_Common.TrdAcc
         * @instance
         */
        TrdAcc.prototype.cardNum = "";

        /**
         * Creates a new TrdAcc instance using the specified properties.
         * @function create
         * @memberof Trd_Common.TrdAcc
         * @static
         * @param {Trd_Common.ITrdAcc=} [properties] Properties to set
         * @returns {Trd_Common.TrdAcc} TrdAcc instance
         */
        TrdAcc.create = function create(properties) {
            return new TrdAcc(properties);
        };

        /**
         * Encodes the specified TrdAcc message. Does not implicitly {@link Trd_Common.TrdAcc.verify|verify} messages.
         * @function encode
         * @memberof Trd_Common.TrdAcc
         * @static
         * @param {Trd_Common.ITrdAcc} message TrdAcc message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrdAcc.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.trdEnv);
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.accID);
            if (message.trdMarketAuthList != null && message.trdMarketAuthList.length)
                for (var i = 0; i < message.trdMarketAuthList.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.trdMarketAuthList[i]);
            if (message.accType != null && message.hasOwnProperty("accType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.accType);
            if (message.cardNum != null && message.hasOwnProperty("cardNum"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.cardNum);
            return writer;
        };

        /**
         * Encodes the specified TrdAcc message, length delimited. Does not implicitly {@link Trd_Common.TrdAcc.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_Common.TrdAcc
         * @static
         * @param {Trd_Common.ITrdAcc} message TrdAcc message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrdAcc.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TrdAcc message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_Common.TrdAcc
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_Common.TrdAcc} TrdAcc
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrdAcc.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_Common.TrdAcc();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trdEnv = reader.int32();
                    break;
                case 2:
                    message.accID = reader.uint64();
                    break;
                case 3:
                    if (!(message.trdMarketAuthList && message.trdMarketAuthList.length))
                        message.trdMarketAuthList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.trdMarketAuthList.push(reader.int32());
                    } else
                        message.trdMarketAuthList.push(reader.int32());
                    break;
                case 4:
                    message.accType = reader.int32();
                    break;
                case 5:
                    message.cardNum = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("trdEnv"))
                throw $util.ProtocolError("missing required 'trdEnv'", { instance: message });
            if (!message.hasOwnProperty("accID"))
                throw $util.ProtocolError("missing required 'accID'", { instance: message });
            return message;
        };

        /**
         * Decodes a TrdAcc message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_Common.TrdAcc
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_Common.TrdAcc} TrdAcc
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrdAcc.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TrdAcc message.
         * @function verify
         * @memberof Trd_Common.TrdAcc
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TrdAcc.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.trdEnv))
                return "trdEnv: integer expected";
            if (!$util.isInteger(message.accID) && !(message.accID && $util.isInteger(message.accID.low) && $util.isInteger(message.accID.high)))
                return "accID: integer|Long expected";
            if (message.trdMarketAuthList != null && message.hasOwnProperty("trdMarketAuthList")) {
                if (!Array.isArray(message.trdMarketAuthList))
                    return "trdMarketAuthList: array expected";
                for (var i = 0; i < message.trdMarketAuthList.length; ++i)
                    if (!$util.isInteger(message.trdMarketAuthList[i]))
                        return "trdMarketAuthList: integer[] expected";
            }
            if (message.accType != null && message.hasOwnProperty("accType"))
                if (!$util.isInteger(message.accType))
                    return "accType: integer expected";
            if (message.cardNum != null && message.hasOwnProperty("cardNum"))
                if (!$util.isString(message.cardNum))
                    return "cardNum: string expected";
            return null;
        };

        /**
         * Creates a TrdAcc message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_Common.TrdAcc
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_Common.TrdAcc} TrdAcc
         */
        TrdAcc.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_Common.TrdAcc)
                return object;
            var message = new $root.Trd_Common.TrdAcc();
            if (object.trdEnv != null)
                message.trdEnv = object.trdEnv | 0;
            if (object.accID != null)
                if ($util.Long)
                    (message.accID = $util.Long.fromValue(object.accID)).unsigned = true;
                else if (typeof object.accID === "string")
                    message.accID = parseInt(object.accID, 10);
                else if (typeof object.accID === "number")
                    message.accID = object.accID;
                else if (typeof object.accID === "object")
                    message.accID = new $util.LongBits(object.accID.low >>> 0, object.accID.high >>> 0).toNumber(true);
            if (object.trdMarketAuthList) {
                if (!Array.isArray(object.trdMarketAuthList))
                    throw TypeError(".Trd_Common.TrdAcc.trdMarketAuthList: array expected");
                message.trdMarketAuthList = [];
                for (var i = 0; i < object.trdMarketAuthList.length; ++i)
                    message.trdMarketAuthList[i] = object.trdMarketAuthList[i] | 0;
            }
            if (object.accType != null)
                message.accType = object.accType | 0;
            if (object.cardNum != null)
                message.cardNum = String(object.cardNum);
            return message;
        };

        /**
         * Creates a plain object from a TrdAcc message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_Common.TrdAcc
         * @static
         * @param {Trd_Common.TrdAcc} message TrdAcc
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TrdAcc.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.trdMarketAuthList = [];
            if (options.defaults) {
                object.trdEnv = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.accID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.accID = options.longs === String ? "0" : 0;
                object.accType = 0;
                object.cardNum = "";
            }
            if (message.trdEnv != null && message.hasOwnProperty("trdEnv"))
                object.trdEnv = message.trdEnv;
            if (message.accID != null && message.hasOwnProperty("accID"))
                if (typeof message.accID === "number")
                    object.accID = options.longs === String ? String(message.accID) : message.accID;
                else
                    object.accID = options.longs === String ? $util.Long.prototype.toString.call(message.accID) : options.longs === Number ? new $util.LongBits(message.accID.low >>> 0, message.accID.high >>> 0).toNumber(true) : message.accID;
            if (message.trdMarketAuthList && message.trdMarketAuthList.length) {
                object.trdMarketAuthList = [];
                for (var j = 0; j < message.trdMarketAuthList.length; ++j)
                    object.trdMarketAuthList[j] = message.trdMarketAuthList[j];
            }
            if (message.accType != null && message.hasOwnProperty("accType"))
                object.accType = message.accType;
            if (message.cardNum != null && message.hasOwnProperty("cardNum"))
                object.cardNum = message.cardNum;
            return object;
        };

        /**
         * Converts this TrdAcc to JSON.
         * @function toJSON
         * @memberof Trd_Common.TrdAcc
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TrdAcc.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TrdAcc;
    })();

    Trd_Common.Funds = (function() {

        /**
         * Properties of a Funds.
         * @memberof Trd_Common
         * @interface IFunds
         * @property {number} power Funds power
         * @property {number} totalAssets Funds totalAssets
         * @property {number} cash Funds cash
         * @property {number} marketVal Funds marketVal
         * @property {number} frozenCash Funds frozenCash
         * @property {number} debtCash Funds debtCash
         * @property {number} avlWithdrawalCash Funds avlWithdrawalCash
         * @property {number|null} [currency] Funds currency
         * @property {number|null} [availableFunds] Funds availableFunds
         * @property {number|null} [unrealizedPL] Funds unrealizedPL
         * @property {number|null} [realizedPL] Funds realizedPL
         * @property {number|null} [riskLevel] Funds riskLevel
         * @property {number|null} [initialMargin] Funds initialMargin
         * @property {number|null} [maintenanceMargin] Funds maintenanceMargin
         * @property {Array.<Trd_Common.IAccCashInfo>|null} [cashInfoList] Funds cashInfoList
         */

        /**
         * Constructs a new Funds.
         * @memberof Trd_Common
         * @classdesc Represents a Funds.
         * @implements IFunds
         * @constructor
         * @param {Trd_Common.IFunds=} [properties] Properties to set
         */
        function Funds(properties) {
            this.cashInfoList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Funds power.
         * @member {number} power
         * @memberof Trd_Common.Funds
         * @instance
         */
        Funds.prototype.power = 0;

        /**
         * Funds totalAssets.
         * @member {number} totalAssets
         * @memberof Trd_Common.Funds
         * @instance
         */
        Funds.prototype.totalAssets = 0;

        /**
         * Funds cash.
         * @member {number} cash
         * @memberof Trd_Common.Funds
         * @instance
         */
        Funds.prototype.cash = 0;

        /**
         * Funds marketVal.
         * @member {number} marketVal
         * @memberof Trd_Common.Funds
         * @instance
         */
        Funds.prototype.marketVal = 0;

        /**
         * Funds frozenCash.
         * @member {number} frozenCash
         * @memberof Trd_Common.Funds
         * @instance
         */
        Funds.prototype.frozenCash = 0;

        /**
         * Funds debtCash.
         * @member {number} debtCash
         * @memberof Trd_Common.Funds
         * @instance
         */
        Funds.prototype.debtCash = 0;

        /**
         * Funds avlWithdrawalCash.
         * @member {number} avlWithdrawalCash
         * @memberof Trd_Common.Funds
         * @instance
         */
        Funds.prototype.avlWithdrawalCash = 0;

        /**
         * Funds currency.
         * @member {number} currency
         * @memberof Trd_Common.Funds
         * @instance
         */
        Funds.prototype.currency = 0;

        /**
         * Funds availableFunds.
         * @member {number} availableFunds
         * @memberof Trd_Common.Funds
         * @instance
         */
        Funds.prototype.availableFunds = 0;

        /**
         * Funds unrealizedPL.
         * @member {number} unrealizedPL
         * @memberof Trd_Common.Funds
         * @instance
         */
        Funds.prototype.unrealizedPL = 0;

        /**
         * Funds realizedPL.
         * @member {number} realizedPL
         * @memberof Trd_Common.Funds
         * @instance
         */
        Funds.prototype.realizedPL = 0;

        /**
         * Funds riskLevel.
         * @member {number} riskLevel
         * @memberof Trd_Common.Funds
         * @instance
         */
        Funds.prototype.riskLevel = 0;

        /**
         * Funds initialMargin.
         * @member {number} initialMargin
         * @memberof Trd_Common.Funds
         * @instance
         */
        Funds.prototype.initialMargin = 0;

        /**
         * Funds maintenanceMargin.
         * @member {number} maintenanceMargin
         * @memberof Trd_Common.Funds
         * @instance
         */
        Funds.prototype.maintenanceMargin = 0;

        /**
         * Funds cashInfoList.
         * @member {Array.<Trd_Common.IAccCashInfo>} cashInfoList
         * @memberof Trd_Common.Funds
         * @instance
         */
        Funds.prototype.cashInfoList = $util.emptyArray;

        /**
         * Creates a new Funds instance using the specified properties.
         * @function create
         * @memberof Trd_Common.Funds
         * @static
         * @param {Trd_Common.IFunds=} [properties] Properties to set
         * @returns {Trd_Common.Funds} Funds instance
         */
        Funds.create = function create(properties) {
            return new Funds(properties);
        };

        /**
         * Encodes the specified Funds message. Does not implicitly {@link Trd_Common.Funds.verify|verify} messages.
         * @function encode
         * @memberof Trd_Common.Funds
         * @static
         * @param {Trd_Common.IFunds} message Funds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Funds.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.power);
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.totalAssets);
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.cash);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.marketVal);
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.frozenCash);
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.debtCash);
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.avlWithdrawalCash);
            if (message.currency != null && message.hasOwnProperty("currency"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.currency);
            if (message.availableFunds != null && message.hasOwnProperty("availableFunds"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.availableFunds);
            if (message.unrealizedPL != null && message.hasOwnProperty("unrealizedPL"))
                writer.uint32(/* id 10, wireType 1 =*/81).double(message.unrealizedPL);
            if (message.realizedPL != null && message.hasOwnProperty("realizedPL"))
                writer.uint32(/* id 11, wireType 1 =*/89).double(message.realizedPL);
            if (message.riskLevel != null && message.hasOwnProperty("riskLevel"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.riskLevel);
            if (message.initialMargin != null && message.hasOwnProperty("initialMargin"))
                writer.uint32(/* id 13, wireType 1 =*/105).double(message.initialMargin);
            if (message.maintenanceMargin != null && message.hasOwnProperty("maintenanceMargin"))
                writer.uint32(/* id 14, wireType 1 =*/113).double(message.maintenanceMargin);
            if (message.cashInfoList != null && message.cashInfoList.length)
                for (var i = 0; i < message.cashInfoList.length; ++i)
                    $root.Trd_Common.AccCashInfo.encode(message.cashInfoList[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Funds message, length delimited. Does not implicitly {@link Trd_Common.Funds.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_Common.Funds
         * @static
         * @param {Trd_Common.IFunds} message Funds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Funds.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Funds message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_Common.Funds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_Common.Funds} Funds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Funds.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_Common.Funds();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.power = reader.double();
                    break;
                case 2:
                    message.totalAssets = reader.double();
                    break;
                case 3:
                    message.cash = reader.double();
                    break;
                case 4:
                    message.marketVal = reader.double();
                    break;
                case 5:
                    message.frozenCash = reader.double();
                    break;
                case 6:
                    message.debtCash = reader.double();
                    break;
                case 7:
                    message.avlWithdrawalCash = reader.double();
                    break;
                case 8:
                    message.currency = reader.int32();
                    break;
                case 9:
                    message.availableFunds = reader.double();
                    break;
                case 10:
                    message.unrealizedPL = reader.double();
                    break;
                case 11:
                    message.realizedPL = reader.double();
                    break;
                case 12:
                    message.riskLevel = reader.int32();
                    break;
                case 13:
                    message.initialMargin = reader.double();
                    break;
                case 14:
                    message.maintenanceMargin = reader.double();
                    break;
                case 15:
                    if (!(message.cashInfoList && message.cashInfoList.length))
                        message.cashInfoList = [];
                    message.cashInfoList.push($root.Trd_Common.AccCashInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("power"))
                throw $util.ProtocolError("missing required 'power'", { instance: message });
            if (!message.hasOwnProperty("totalAssets"))
                throw $util.ProtocolError("missing required 'totalAssets'", { instance: message });
            if (!message.hasOwnProperty("cash"))
                throw $util.ProtocolError("missing required 'cash'", { instance: message });
            if (!message.hasOwnProperty("marketVal"))
                throw $util.ProtocolError("missing required 'marketVal'", { instance: message });
            if (!message.hasOwnProperty("frozenCash"))
                throw $util.ProtocolError("missing required 'frozenCash'", { instance: message });
            if (!message.hasOwnProperty("debtCash"))
                throw $util.ProtocolError("missing required 'debtCash'", { instance: message });
            if (!message.hasOwnProperty("avlWithdrawalCash"))
                throw $util.ProtocolError("missing required 'avlWithdrawalCash'", { instance: message });
            return message;
        };

        /**
         * Decodes a Funds message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_Common.Funds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_Common.Funds} Funds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Funds.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Funds message.
         * @function verify
         * @memberof Trd_Common.Funds
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Funds.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.power !== "number")
                return "power: number expected";
            if (typeof message.totalAssets !== "number")
                return "totalAssets: number expected";
            if (typeof message.cash !== "number")
                return "cash: number expected";
            if (typeof message.marketVal !== "number")
                return "marketVal: number expected";
            if (typeof message.frozenCash !== "number")
                return "frozenCash: number expected";
            if (typeof message.debtCash !== "number")
                return "debtCash: number expected";
            if (typeof message.avlWithdrawalCash !== "number")
                return "avlWithdrawalCash: number expected";
            if (message.currency != null && message.hasOwnProperty("currency"))
                if (!$util.isInteger(message.currency))
                    return "currency: integer expected";
            if (message.availableFunds != null && message.hasOwnProperty("availableFunds"))
                if (typeof message.availableFunds !== "number")
                    return "availableFunds: number expected";
            if (message.unrealizedPL != null && message.hasOwnProperty("unrealizedPL"))
                if (typeof message.unrealizedPL !== "number")
                    return "unrealizedPL: number expected";
            if (message.realizedPL != null && message.hasOwnProperty("realizedPL"))
                if (typeof message.realizedPL !== "number")
                    return "realizedPL: number expected";
            if (message.riskLevel != null && message.hasOwnProperty("riskLevel"))
                if (!$util.isInteger(message.riskLevel))
                    return "riskLevel: integer expected";
            if (message.initialMargin != null && message.hasOwnProperty("initialMargin"))
                if (typeof message.initialMargin !== "number")
                    return "initialMargin: number expected";
            if (message.maintenanceMargin != null && message.hasOwnProperty("maintenanceMargin"))
                if (typeof message.maintenanceMargin !== "number")
                    return "maintenanceMargin: number expected";
            if (message.cashInfoList != null && message.hasOwnProperty("cashInfoList")) {
                if (!Array.isArray(message.cashInfoList))
                    return "cashInfoList: array expected";
                for (var i = 0; i < message.cashInfoList.length; ++i) {
                    var error = $root.Trd_Common.AccCashInfo.verify(message.cashInfoList[i]);
                    if (error)
                        return "cashInfoList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Funds message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_Common.Funds
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_Common.Funds} Funds
         */
        Funds.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_Common.Funds)
                return object;
            var message = new $root.Trd_Common.Funds();
            if (object.power != null)
                message.power = Number(object.power);
            if (object.totalAssets != null)
                message.totalAssets = Number(object.totalAssets);
            if (object.cash != null)
                message.cash = Number(object.cash);
            if (object.marketVal != null)
                message.marketVal = Number(object.marketVal);
            if (object.frozenCash != null)
                message.frozenCash = Number(object.frozenCash);
            if (object.debtCash != null)
                message.debtCash = Number(object.debtCash);
            if (object.avlWithdrawalCash != null)
                message.avlWithdrawalCash = Number(object.avlWithdrawalCash);
            if (object.currency != null)
                message.currency = object.currency | 0;
            if (object.availableFunds != null)
                message.availableFunds = Number(object.availableFunds);
            if (object.unrealizedPL != null)
                message.unrealizedPL = Number(object.unrealizedPL);
            if (object.realizedPL != null)
                message.realizedPL = Number(object.realizedPL);
            if (object.riskLevel != null)
                message.riskLevel = object.riskLevel | 0;
            if (object.initialMargin != null)
                message.initialMargin = Number(object.initialMargin);
            if (object.maintenanceMargin != null)
                message.maintenanceMargin = Number(object.maintenanceMargin);
            if (object.cashInfoList) {
                if (!Array.isArray(object.cashInfoList))
                    throw TypeError(".Trd_Common.Funds.cashInfoList: array expected");
                message.cashInfoList = [];
                for (var i = 0; i < object.cashInfoList.length; ++i) {
                    if (typeof object.cashInfoList[i] !== "object")
                        throw TypeError(".Trd_Common.Funds.cashInfoList: object expected");
                    message.cashInfoList[i] = $root.Trd_Common.AccCashInfo.fromObject(object.cashInfoList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Funds message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_Common.Funds
         * @static
         * @param {Trd_Common.Funds} message Funds
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Funds.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.cashInfoList = [];
            if (options.defaults) {
                object.power = 0;
                object.totalAssets = 0;
                object.cash = 0;
                object.marketVal = 0;
                object.frozenCash = 0;
                object.debtCash = 0;
                object.avlWithdrawalCash = 0;
                object.currency = 0;
                object.availableFunds = 0;
                object.unrealizedPL = 0;
                object.realizedPL = 0;
                object.riskLevel = 0;
                object.initialMargin = 0;
                object.maintenanceMargin = 0;
            }
            if (message.power != null && message.hasOwnProperty("power"))
                object.power = options.json && !isFinite(message.power) ? String(message.power) : message.power;
            if (message.totalAssets != null && message.hasOwnProperty("totalAssets"))
                object.totalAssets = options.json && !isFinite(message.totalAssets) ? String(message.totalAssets) : message.totalAssets;
            if (message.cash != null && message.hasOwnProperty("cash"))
                object.cash = options.json && !isFinite(message.cash) ? String(message.cash) : message.cash;
            if (message.marketVal != null && message.hasOwnProperty("marketVal"))
                object.marketVal = options.json && !isFinite(message.marketVal) ? String(message.marketVal) : message.marketVal;
            if (message.frozenCash != null && message.hasOwnProperty("frozenCash"))
                object.frozenCash = options.json && !isFinite(message.frozenCash) ? String(message.frozenCash) : message.frozenCash;
            if (message.debtCash != null && message.hasOwnProperty("debtCash"))
                object.debtCash = options.json && !isFinite(message.debtCash) ? String(message.debtCash) : message.debtCash;
            if (message.avlWithdrawalCash != null && message.hasOwnProperty("avlWithdrawalCash"))
                object.avlWithdrawalCash = options.json && !isFinite(message.avlWithdrawalCash) ? String(message.avlWithdrawalCash) : message.avlWithdrawalCash;
            if (message.currency != null && message.hasOwnProperty("currency"))
                object.currency = message.currency;
            if (message.availableFunds != null && message.hasOwnProperty("availableFunds"))
                object.availableFunds = options.json && !isFinite(message.availableFunds) ? String(message.availableFunds) : message.availableFunds;
            if (message.unrealizedPL != null && message.hasOwnProperty("unrealizedPL"))
                object.unrealizedPL = options.json && !isFinite(message.unrealizedPL) ? String(message.unrealizedPL) : message.unrealizedPL;
            if (message.realizedPL != null && message.hasOwnProperty("realizedPL"))
                object.realizedPL = options.json && !isFinite(message.realizedPL) ? String(message.realizedPL) : message.realizedPL;
            if (message.riskLevel != null && message.hasOwnProperty("riskLevel"))
                object.riskLevel = message.riskLevel;
            if (message.initialMargin != null && message.hasOwnProperty("initialMargin"))
                object.initialMargin = options.json && !isFinite(message.initialMargin) ? String(message.initialMargin) : message.initialMargin;
            if (message.maintenanceMargin != null && message.hasOwnProperty("maintenanceMargin"))
                object.maintenanceMargin = options.json && !isFinite(message.maintenanceMargin) ? String(message.maintenanceMargin) : message.maintenanceMargin;
            if (message.cashInfoList && message.cashInfoList.length) {
                object.cashInfoList = [];
                for (var j = 0; j < message.cashInfoList.length; ++j)
                    object.cashInfoList[j] = $root.Trd_Common.AccCashInfo.toObject(message.cashInfoList[j], options);
            }
            return object;
        };

        /**
         * Converts this Funds to JSON.
         * @function toJSON
         * @memberof Trd_Common.Funds
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Funds.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Funds;
    })();

    Trd_Common.Position = (function() {

        /**
         * Properties of a Position.
         * @memberof Trd_Common
         * @interface IPosition
         * @property {number|Long} positionID Position positionID
         * @property {number} positionSide Position positionSide
         * @property {string} code Position code
         * @property {string} name Position name
         * @property {number} qty Position qty
         * @property {number} canSellQty Position canSellQty
         * @property {number} price Position price
         * @property {number|null} [costPrice] Position costPrice
         * @property {number} val Position val
         * @property {number} plVal Position plVal
         * @property {number|null} [plRatio] Position plRatio
         * @property {number|null} [secMarket] Position secMarket
         * @property {number|null} [tdPlVal] Position tdPlVal
         * @property {number|null} [tdTrdVal] Position tdTrdVal
         * @property {number|null} [tdBuyVal] Position tdBuyVal
         * @property {number|null} [tdBuyQty] Position tdBuyQty
         * @property {number|null} [tdSellVal] Position tdSellVal
         * @property {number|null} [tdSellQty] Position tdSellQty
         * @property {number|null} [unrealizedPL] Position unrealizedPL
         * @property {number|null} [realizedPL] Position realizedPL
         */

        /**
         * Constructs a new Position.
         * @memberof Trd_Common
         * @classdesc Represents a Position.
         * @implements IPosition
         * @constructor
         * @param {Trd_Common.IPosition=} [properties] Properties to set
         */
        function Position(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Position positionID.
         * @member {number|Long} positionID
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.positionID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Position positionSide.
         * @member {number} positionSide
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.positionSide = 0;

        /**
         * Position code.
         * @member {string} code
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.code = "";

        /**
         * Position name.
         * @member {string} name
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.name = "";

        /**
         * Position qty.
         * @member {number} qty
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.qty = 0;

        /**
         * Position canSellQty.
         * @member {number} canSellQty
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.canSellQty = 0;

        /**
         * Position price.
         * @member {number} price
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.price = 0;

        /**
         * Position costPrice.
         * @member {number} costPrice
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.costPrice = 0;

        /**
         * Position val.
         * @member {number} val
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.val = 0;

        /**
         * Position plVal.
         * @member {number} plVal
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.plVal = 0;

        /**
         * Position plRatio.
         * @member {number} plRatio
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.plRatio = 0;

        /**
         * Position secMarket.
         * @member {number} secMarket
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.secMarket = 0;

        /**
         * Position tdPlVal.
         * @member {number} tdPlVal
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.tdPlVal = 0;

        /**
         * Position tdTrdVal.
         * @member {number} tdTrdVal
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.tdTrdVal = 0;

        /**
         * Position tdBuyVal.
         * @member {number} tdBuyVal
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.tdBuyVal = 0;

        /**
         * Position tdBuyQty.
         * @member {number} tdBuyQty
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.tdBuyQty = 0;

        /**
         * Position tdSellVal.
         * @member {number} tdSellVal
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.tdSellVal = 0;

        /**
         * Position tdSellQty.
         * @member {number} tdSellQty
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.tdSellQty = 0;

        /**
         * Position unrealizedPL.
         * @member {number} unrealizedPL
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.unrealizedPL = 0;

        /**
         * Position realizedPL.
         * @member {number} realizedPL
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.realizedPL = 0;

        /**
         * Creates a new Position instance using the specified properties.
         * @function create
         * @memberof Trd_Common.Position
         * @static
         * @param {Trd_Common.IPosition=} [properties] Properties to set
         * @returns {Trd_Common.Position} Position instance
         */
        Position.create = function create(properties) {
            return new Position(properties);
        };

        /**
         * Encodes the specified Position message. Does not implicitly {@link Trd_Common.Position.verify|verify} messages.
         * @function encode
         * @memberof Trd_Common.Position
         * @static
         * @param {Trd_Common.IPosition} message Position message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Position.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.positionID);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.positionSide);
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.code);
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.qty);
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.canSellQty);
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.price);
            if (message.costPrice != null && message.hasOwnProperty("costPrice"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.costPrice);
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.val);
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.plVal);
            if (message.plRatio != null && message.hasOwnProperty("plRatio"))
                writer.uint32(/* id 11, wireType 1 =*/89).double(message.plRatio);
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.secMarket);
            if (message.tdPlVal != null && message.hasOwnProperty("tdPlVal"))
                writer.uint32(/* id 21, wireType 1 =*/169).double(message.tdPlVal);
            if (message.tdTrdVal != null && message.hasOwnProperty("tdTrdVal"))
                writer.uint32(/* id 22, wireType 1 =*/177).double(message.tdTrdVal);
            if (message.tdBuyVal != null && message.hasOwnProperty("tdBuyVal"))
                writer.uint32(/* id 23, wireType 1 =*/185).double(message.tdBuyVal);
            if (message.tdBuyQty != null && message.hasOwnProperty("tdBuyQty"))
                writer.uint32(/* id 24, wireType 1 =*/193).double(message.tdBuyQty);
            if (message.tdSellVal != null && message.hasOwnProperty("tdSellVal"))
                writer.uint32(/* id 25, wireType 1 =*/201).double(message.tdSellVal);
            if (message.tdSellQty != null && message.hasOwnProperty("tdSellQty"))
                writer.uint32(/* id 26, wireType 1 =*/209).double(message.tdSellQty);
            if (message.unrealizedPL != null && message.hasOwnProperty("unrealizedPL"))
                writer.uint32(/* id 28, wireType 1 =*/225).double(message.unrealizedPL);
            if (message.realizedPL != null && message.hasOwnProperty("realizedPL"))
                writer.uint32(/* id 29, wireType 1 =*/233).double(message.realizedPL);
            return writer;
        };

        /**
         * Encodes the specified Position message, length delimited. Does not implicitly {@link Trd_Common.Position.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_Common.Position
         * @static
         * @param {Trd_Common.IPosition} message Position message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Position.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Position message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_Common.Position
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_Common.Position} Position
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Position.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_Common.Position();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.positionID = reader.uint64();
                    break;
                case 2:
                    message.positionSide = reader.int32();
                    break;
                case 3:
                    message.code = reader.string();
                    break;
                case 4:
                    message.name = reader.string();
                    break;
                case 5:
                    message.qty = reader.double();
                    break;
                case 6:
                    message.canSellQty = reader.double();
                    break;
                case 7:
                    message.price = reader.double();
                    break;
                case 8:
                    message.costPrice = reader.double();
                    break;
                case 9:
                    message.val = reader.double();
                    break;
                case 10:
                    message.plVal = reader.double();
                    break;
                case 11:
                    message.plRatio = reader.double();
                    break;
                case 12:
                    message.secMarket = reader.int32();
                    break;
                case 21:
                    message.tdPlVal = reader.double();
                    break;
                case 22:
                    message.tdTrdVal = reader.double();
                    break;
                case 23:
                    message.tdBuyVal = reader.double();
                    break;
                case 24:
                    message.tdBuyQty = reader.double();
                    break;
                case 25:
                    message.tdSellVal = reader.double();
                    break;
                case 26:
                    message.tdSellQty = reader.double();
                    break;
                case 28:
                    message.unrealizedPL = reader.double();
                    break;
                case 29:
                    message.realizedPL = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("positionID"))
                throw $util.ProtocolError("missing required 'positionID'", { instance: message });
            if (!message.hasOwnProperty("positionSide"))
                throw $util.ProtocolError("missing required 'positionSide'", { instance: message });
            if (!message.hasOwnProperty("code"))
                throw $util.ProtocolError("missing required 'code'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("qty"))
                throw $util.ProtocolError("missing required 'qty'", { instance: message });
            if (!message.hasOwnProperty("canSellQty"))
                throw $util.ProtocolError("missing required 'canSellQty'", { instance: message });
            if (!message.hasOwnProperty("price"))
                throw $util.ProtocolError("missing required 'price'", { instance: message });
            if (!message.hasOwnProperty("val"))
                throw $util.ProtocolError("missing required 'val'", { instance: message });
            if (!message.hasOwnProperty("plVal"))
                throw $util.ProtocolError("missing required 'plVal'", { instance: message });
            return message;
        };

        /**
         * Decodes a Position message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_Common.Position
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_Common.Position} Position
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Position.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Position message.
         * @function verify
         * @memberof Trd_Common.Position
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Position.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.positionID) && !(message.positionID && $util.isInteger(message.positionID.low) && $util.isInteger(message.positionID.high)))
                return "positionID: integer|Long expected";
            if (!$util.isInteger(message.positionSide))
                return "positionSide: integer expected";
            if (!$util.isString(message.code))
                return "code: string expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (typeof message.qty !== "number")
                return "qty: number expected";
            if (typeof message.canSellQty !== "number")
                return "canSellQty: number expected";
            if (typeof message.price !== "number")
                return "price: number expected";
            if (message.costPrice != null && message.hasOwnProperty("costPrice"))
                if (typeof message.costPrice !== "number")
                    return "costPrice: number expected";
            if (typeof message.val !== "number")
                return "val: number expected";
            if (typeof message.plVal !== "number")
                return "plVal: number expected";
            if (message.plRatio != null && message.hasOwnProperty("plRatio"))
                if (typeof message.plRatio !== "number")
                    return "plRatio: number expected";
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                if (!$util.isInteger(message.secMarket))
                    return "secMarket: integer expected";
            if (message.tdPlVal != null && message.hasOwnProperty("tdPlVal"))
                if (typeof message.tdPlVal !== "number")
                    return "tdPlVal: number expected";
            if (message.tdTrdVal != null && message.hasOwnProperty("tdTrdVal"))
                if (typeof message.tdTrdVal !== "number")
                    return "tdTrdVal: number expected";
            if (message.tdBuyVal != null && message.hasOwnProperty("tdBuyVal"))
                if (typeof message.tdBuyVal !== "number")
                    return "tdBuyVal: number expected";
            if (message.tdBuyQty != null && message.hasOwnProperty("tdBuyQty"))
                if (typeof message.tdBuyQty !== "number")
                    return "tdBuyQty: number expected";
            if (message.tdSellVal != null && message.hasOwnProperty("tdSellVal"))
                if (typeof message.tdSellVal !== "number")
                    return "tdSellVal: number expected";
            if (message.tdSellQty != null && message.hasOwnProperty("tdSellQty"))
                if (typeof message.tdSellQty !== "number")
                    return "tdSellQty: number expected";
            if (message.unrealizedPL != null && message.hasOwnProperty("unrealizedPL"))
                if (typeof message.unrealizedPL !== "number")
                    return "unrealizedPL: number expected";
            if (message.realizedPL != null && message.hasOwnProperty("realizedPL"))
                if (typeof message.realizedPL !== "number")
                    return "realizedPL: number expected";
            return null;
        };

        /**
         * Creates a Position message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_Common.Position
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_Common.Position} Position
         */
        Position.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_Common.Position)
                return object;
            var message = new $root.Trd_Common.Position();
            if (object.positionID != null)
                if ($util.Long)
                    (message.positionID = $util.Long.fromValue(object.positionID)).unsigned = true;
                else if (typeof object.positionID === "string")
                    message.positionID = parseInt(object.positionID, 10);
                else if (typeof object.positionID === "number")
                    message.positionID = object.positionID;
                else if (typeof object.positionID === "object")
                    message.positionID = new $util.LongBits(object.positionID.low >>> 0, object.positionID.high >>> 0).toNumber(true);
            if (object.positionSide != null)
                message.positionSide = object.positionSide | 0;
            if (object.code != null)
                message.code = String(object.code);
            if (object.name != null)
                message.name = String(object.name);
            if (object.qty != null)
                message.qty = Number(object.qty);
            if (object.canSellQty != null)
                message.canSellQty = Number(object.canSellQty);
            if (object.price != null)
                message.price = Number(object.price);
            if (object.costPrice != null)
                message.costPrice = Number(object.costPrice);
            if (object.val != null)
                message.val = Number(object.val);
            if (object.plVal != null)
                message.plVal = Number(object.plVal);
            if (object.plRatio != null)
                message.plRatio = Number(object.plRatio);
            if (object.secMarket != null)
                message.secMarket = object.secMarket | 0;
            if (object.tdPlVal != null)
                message.tdPlVal = Number(object.tdPlVal);
            if (object.tdTrdVal != null)
                message.tdTrdVal = Number(object.tdTrdVal);
            if (object.tdBuyVal != null)
                message.tdBuyVal = Number(object.tdBuyVal);
            if (object.tdBuyQty != null)
                message.tdBuyQty = Number(object.tdBuyQty);
            if (object.tdSellVal != null)
                message.tdSellVal = Number(object.tdSellVal);
            if (object.tdSellQty != null)
                message.tdSellQty = Number(object.tdSellQty);
            if (object.unrealizedPL != null)
                message.unrealizedPL = Number(object.unrealizedPL);
            if (object.realizedPL != null)
                message.realizedPL = Number(object.realizedPL);
            return message;
        };

        /**
         * Creates a plain object from a Position message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_Common.Position
         * @static
         * @param {Trd_Common.Position} message Position
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Position.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.positionID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.positionID = options.longs === String ? "0" : 0;
                object.positionSide = 0;
                object.code = "";
                object.name = "";
                object.qty = 0;
                object.canSellQty = 0;
                object.price = 0;
                object.costPrice = 0;
                object.val = 0;
                object.plVal = 0;
                object.plRatio = 0;
                object.secMarket = 0;
                object.tdPlVal = 0;
                object.tdTrdVal = 0;
                object.tdBuyVal = 0;
                object.tdBuyQty = 0;
                object.tdSellVal = 0;
                object.tdSellQty = 0;
                object.unrealizedPL = 0;
                object.realizedPL = 0;
            }
            if (message.positionID != null && message.hasOwnProperty("positionID"))
                if (typeof message.positionID === "number")
                    object.positionID = options.longs === String ? String(message.positionID) : message.positionID;
                else
                    object.positionID = options.longs === String ? $util.Long.prototype.toString.call(message.positionID) : options.longs === Number ? new $util.LongBits(message.positionID.low >>> 0, message.positionID.high >>> 0).toNumber(true) : message.positionID;
            if (message.positionSide != null && message.hasOwnProperty("positionSide"))
                object.positionSide = message.positionSide;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.qty != null && message.hasOwnProperty("qty"))
                object.qty = options.json && !isFinite(message.qty) ? String(message.qty) : message.qty;
            if (message.canSellQty != null && message.hasOwnProperty("canSellQty"))
                object.canSellQty = options.json && !isFinite(message.canSellQty) ? String(message.canSellQty) : message.canSellQty;
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
            if (message.costPrice != null && message.hasOwnProperty("costPrice"))
                object.costPrice = options.json && !isFinite(message.costPrice) ? String(message.costPrice) : message.costPrice;
            if (message.val != null && message.hasOwnProperty("val"))
                object.val = options.json && !isFinite(message.val) ? String(message.val) : message.val;
            if (message.plVal != null && message.hasOwnProperty("plVal"))
                object.plVal = options.json && !isFinite(message.plVal) ? String(message.plVal) : message.plVal;
            if (message.plRatio != null && message.hasOwnProperty("plRatio"))
                object.plRatio = options.json && !isFinite(message.plRatio) ? String(message.plRatio) : message.plRatio;
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                object.secMarket = message.secMarket;
            if (message.tdPlVal != null && message.hasOwnProperty("tdPlVal"))
                object.tdPlVal = options.json && !isFinite(message.tdPlVal) ? String(message.tdPlVal) : message.tdPlVal;
            if (message.tdTrdVal != null && message.hasOwnProperty("tdTrdVal"))
                object.tdTrdVal = options.json && !isFinite(message.tdTrdVal) ? String(message.tdTrdVal) : message.tdTrdVal;
            if (message.tdBuyVal != null && message.hasOwnProperty("tdBuyVal"))
                object.tdBuyVal = options.json && !isFinite(message.tdBuyVal) ? String(message.tdBuyVal) : message.tdBuyVal;
            if (message.tdBuyQty != null && message.hasOwnProperty("tdBuyQty"))
                object.tdBuyQty = options.json && !isFinite(message.tdBuyQty) ? String(message.tdBuyQty) : message.tdBuyQty;
            if (message.tdSellVal != null && message.hasOwnProperty("tdSellVal"))
                object.tdSellVal = options.json && !isFinite(message.tdSellVal) ? String(message.tdSellVal) : message.tdSellVal;
            if (message.tdSellQty != null && message.hasOwnProperty("tdSellQty"))
                object.tdSellQty = options.json && !isFinite(message.tdSellQty) ? String(message.tdSellQty) : message.tdSellQty;
            if (message.unrealizedPL != null && message.hasOwnProperty("unrealizedPL"))
                object.unrealizedPL = options.json && !isFinite(message.unrealizedPL) ? String(message.unrealizedPL) : message.unrealizedPL;
            if (message.realizedPL != null && message.hasOwnProperty("realizedPL"))
                object.realizedPL = options.json && !isFinite(message.realizedPL) ? String(message.realizedPL) : message.realizedPL;
            return object;
        };

        /**
         * Converts this Position to JSON.
         * @function toJSON
         * @memberof Trd_Common.Position
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Position.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Position;
    })();

    Trd_Common.Order = (function() {

        /**
         * Properties of an Order.
         * @memberof Trd_Common
         * @interface IOrder
         * @property {number} trdSide Order trdSide
         * @property {number} orderType Order orderType
         * @property {number} orderStatus Order orderStatus
         * @property {number|Long} orderID Order orderID
         * @property {string} orderIDEx Order orderIDEx
         * @property {string} code Order code
         * @property {string} name Order name
         * @property {number} qty Order qty
         * @property {number|null} [price] Order price
         * @property {string} createTime Order createTime
         * @property {string} updateTime Order updateTime
         * @property {number|null} [fillQty] Order fillQty
         * @property {number|null} [fillAvgPrice] Order fillAvgPrice
         * @property {string|null} [lastErrMsg] Order lastErrMsg
         * @property {number|null} [secMarket] Order secMarket
         * @property {number|null} [createTimestamp] Order createTimestamp
         * @property {number|null} [updateTimestamp] Order updateTimestamp
         * @property {string|null} [remark] Order remark
         */

        /**
         * Constructs a new Order.
         * @memberof Trd_Common
         * @classdesc Represents an Order.
         * @implements IOrder
         * @constructor
         * @param {Trd_Common.IOrder=} [properties] Properties to set
         */
        function Order(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Order trdSide.
         * @member {number} trdSide
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.trdSide = 0;

        /**
         * Order orderType.
         * @member {number} orderType
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.orderType = 0;

        /**
         * Order orderStatus.
         * @member {number} orderStatus
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.orderStatus = 0;

        /**
         * Order orderID.
         * @member {number|Long} orderID
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.orderID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Order orderIDEx.
         * @member {string} orderIDEx
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.orderIDEx = "";

        /**
         * Order code.
         * @member {string} code
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.code = "";

        /**
         * Order name.
         * @member {string} name
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.name = "";

        /**
         * Order qty.
         * @member {number} qty
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.qty = 0;

        /**
         * Order price.
         * @member {number} price
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.price = 0;

        /**
         * Order createTime.
         * @member {string} createTime
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.createTime = "";

        /**
         * Order updateTime.
         * @member {string} updateTime
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.updateTime = "";

        /**
         * Order fillQty.
         * @member {number} fillQty
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.fillQty = 0;

        /**
         * Order fillAvgPrice.
         * @member {number} fillAvgPrice
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.fillAvgPrice = 0;

        /**
         * Order lastErrMsg.
         * @member {string} lastErrMsg
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.lastErrMsg = "";

        /**
         * Order secMarket.
         * @member {number} secMarket
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.secMarket = 0;

        /**
         * Order createTimestamp.
         * @member {number} createTimestamp
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.createTimestamp = 0;

        /**
         * Order updateTimestamp.
         * @member {number} updateTimestamp
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.updateTimestamp = 0;

        /**
         * Order remark.
         * @member {string} remark
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.remark = "";

        /**
         * Creates a new Order instance using the specified properties.
         * @function create
         * @memberof Trd_Common.Order
         * @static
         * @param {Trd_Common.IOrder=} [properties] Properties to set
         * @returns {Trd_Common.Order} Order instance
         */
        Order.create = function create(properties) {
            return new Order(properties);
        };

        /**
         * Encodes the specified Order message. Does not implicitly {@link Trd_Common.Order.verify|verify} messages.
         * @function encode
         * @memberof Trd_Common.Order
         * @static
         * @param {Trd_Common.IOrder} message Order message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Order.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.trdSide);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.orderType);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.orderStatus);
            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.orderID);
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.orderIDEx);
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.code);
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.name);
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.qty);
            if (message.price != null && message.hasOwnProperty("price"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.price);
            writer.uint32(/* id 10, wireType 2 =*/82).string(message.createTime);
            writer.uint32(/* id 11, wireType 2 =*/90).string(message.updateTime);
            if (message.fillQty != null && message.hasOwnProperty("fillQty"))
                writer.uint32(/* id 12, wireType 1 =*/97).double(message.fillQty);
            if (message.fillAvgPrice != null && message.hasOwnProperty("fillAvgPrice"))
                writer.uint32(/* id 13, wireType 1 =*/105).double(message.fillAvgPrice);
            if (message.lastErrMsg != null && message.hasOwnProperty("lastErrMsg"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.lastErrMsg);
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.secMarket);
            if (message.createTimestamp != null && message.hasOwnProperty("createTimestamp"))
                writer.uint32(/* id 16, wireType 1 =*/129).double(message.createTimestamp);
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                writer.uint32(/* id 17, wireType 1 =*/137).double(message.updateTimestamp);
            if (message.remark != null && message.hasOwnProperty("remark"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.remark);
            return writer;
        };

        /**
         * Encodes the specified Order message, length delimited. Does not implicitly {@link Trd_Common.Order.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_Common.Order
         * @static
         * @param {Trd_Common.IOrder} message Order message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Order.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Order message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_Common.Order
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_Common.Order} Order
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Order.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_Common.Order();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trdSide = reader.int32();
                    break;
                case 2:
                    message.orderType = reader.int32();
                    break;
                case 3:
                    message.orderStatus = reader.int32();
                    break;
                case 4:
                    message.orderID = reader.uint64();
                    break;
                case 5:
                    message.orderIDEx = reader.string();
                    break;
                case 6:
                    message.code = reader.string();
                    break;
                case 7:
                    message.name = reader.string();
                    break;
                case 8:
                    message.qty = reader.double();
                    break;
                case 9:
                    message.price = reader.double();
                    break;
                case 10:
                    message.createTime = reader.string();
                    break;
                case 11:
                    message.updateTime = reader.string();
                    break;
                case 12:
                    message.fillQty = reader.double();
                    break;
                case 13:
                    message.fillAvgPrice = reader.double();
                    break;
                case 14:
                    message.lastErrMsg = reader.string();
                    break;
                case 15:
                    message.secMarket = reader.int32();
                    break;
                case 16:
                    message.createTimestamp = reader.double();
                    break;
                case 17:
                    message.updateTimestamp = reader.double();
                    break;
                case 18:
                    message.remark = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("trdSide"))
                throw $util.ProtocolError("missing required 'trdSide'", { instance: message });
            if (!message.hasOwnProperty("orderType"))
                throw $util.ProtocolError("missing required 'orderType'", { instance: message });
            if (!message.hasOwnProperty("orderStatus"))
                throw $util.ProtocolError("missing required 'orderStatus'", { instance: message });
            if (!message.hasOwnProperty("orderID"))
                throw $util.ProtocolError("missing required 'orderID'", { instance: message });
            if (!message.hasOwnProperty("orderIDEx"))
                throw $util.ProtocolError("missing required 'orderIDEx'", { instance: message });
            if (!message.hasOwnProperty("code"))
                throw $util.ProtocolError("missing required 'code'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("qty"))
                throw $util.ProtocolError("missing required 'qty'", { instance: message });
            if (!message.hasOwnProperty("createTime"))
                throw $util.ProtocolError("missing required 'createTime'", { instance: message });
            if (!message.hasOwnProperty("updateTime"))
                throw $util.ProtocolError("missing required 'updateTime'", { instance: message });
            return message;
        };

        /**
         * Decodes an Order message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_Common.Order
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_Common.Order} Order
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Order.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Order message.
         * @function verify
         * @memberof Trd_Common.Order
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Order.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.trdSide))
                return "trdSide: integer expected";
            if (!$util.isInteger(message.orderType))
                return "orderType: integer expected";
            if (!$util.isInteger(message.orderStatus))
                return "orderStatus: integer expected";
            if (!$util.isInteger(message.orderID) && !(message.orderID && $util.isInteger(message.orderID.low) && $util.isInteger(message.orderID.high)))
                return "orderID: integer|Long expected";
            if (!$util.isString(message.orderIDEx))
                return "orderIDEx: string expected";
            if (!$util.isString(message.code))
                return "code: string expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (typeof message.qty !== "number")
                return "qty: number expected";
            if (message.price != null && message.hasOwnProperty("price"))
                if (typeof message.price !== "number")
                    return "price: number expected";
            if (!$util.isString(message.createTime))
                return "createTime: string expected";
            if (!$util.isString(message.updateTime))
                return "updateTime: string expected";
            if (message.fillQty != null && message.hasOwnProperty("fillQty"))
                if (typeof message.fillQty !== "number")
                    return "fillQty: number expected";
            if (message.fillAvgPrice != null && message.hasOwnProperty("fillAvgPrice"))
                if (typeof message.fillAvgPrice !== "number")
                    return "fillAvgPrice: number expected";
            if (message.lastErrMsg != null && message.hasOwnProperty("lastErrMsg"))
                if (!$util.isString(message.lastErrMsg))
                    return "lastErrMsg: string expected";
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                if (!$util.isInteger(message.secMarket))
                    return "secMarket: integer expected";
            if (message.createTimestamp != null && message.hasOwnProperty("createTimestamp"))
                if (typeof message.createTimestamp !== "number")
                    return "createTimestamp: number expected";
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                if (typeof message.updateTimestamp !== "number")
                    return "updateTimestamp: number expected";
            if (message.remark != null && message.hasOwnProperty("remark"))
                if (!$util.isString(message.remark))
                    return "remark: string expected";
            return null;
        };

        /**
         * Creates an Order message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_Common.Order
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_Common.Order} Order
         */
        Order.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_Common.Order)
                return object;
            var message = new $root.Trd_Common.Order();
            if (object.trdSide != null)
                message.trdSide = object.trdSide | 0;
            if (object.orderType != null)
                message.orderType = object.orderType | 0;
            if (object.orderStatus != null)
                message.orderStatus = object.orderStatus | 0;
            if (object.orderID != null)
                if ($util.Long)
                    (message.orderID = $util.Long.fromValue(object.orderID)).unsigned = true;
                else if (typeof object.orderID === "string")
                    message.orderID = parseInt(object.orderID, 10);
                else if (typeof object.orderID === "number")
                    message.orderID = object.orderID;
                else if (typeof object.orderID === "object")
                    message.orderID = new $util.LongBits(object.orderID.low >>> 0, object.orderID.high >>> 0).toNumber(true);
            if (object.orderIDEx != null)
                message.orderIDEx = String(object.orderIDEx);
            if (object.code != null)
                message.code = String(object.code);
            if (object.name != null)
                message.name = String(object.name);
            if (object.qty != null)
                message.qty = Number(object.qty);
            if (object.price != null)
                message.price = Number(object.price);
            if (object.createTime != null)
                message.createTime = String(object.createTime);
            if (object.updateTime != null)
                message.updateTime = String(object.updateTime);
            if (object.fillQty != null)
                message.fillQty = Number(object.fillQty);
            if (object.fillAvgPrice != null)
                message.fillAvgPrice = Number(object.fillAvgPrice);
            if (object.lastErrMsg != null)
                message.lastErrMsg = String(object.lastErrMsg);
            if (object.secMarket != null)
                message.secMarket = object.secMarket | 0;
            if (object.createTimestamp != null)
                message.createTimestamp = Number(object.createTimestamp);
            if (object.updateTimestamp != null)
                message.updateTimestamp = Number(object.updateTimestamp);
            if (object.remark != null)
                message.remark = String(object.remark);
            return message;
        };

        /**
         * Creates a plain object from an Order message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_Common.Order
         * @static
         * @param {Trd_Common.Order} message Order
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Order.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.trdSide = 0;
                object.orderType = 0;
                object.orderStatus = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.orderID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.orderID = options.longs === String ? "0" : 0;
                object.orderIDEx = "";
                object.code = "";
                object.name = "";
                object.qty = 0;
                object.price = 0;
                object.createTime = "";
                object.updateTime = "";
                object.fillQty = 0;
                object.fillAvgPrice = 0;
                object.lastErrMsg = "";
                object.secMarket = 0;
                object.createTimestamp = 0;
                object.updateTimestamp = 0;
                object.remark = "";
            }
            if (message.trdSide != null && message.hasOwnProperty("trdSide"))
                object.trdSide = message.trdSide;
            if (message.orderType != null && message.hasOwnProperty("orderType"))
                object.orderType = message.orderType;
            if (message.orderStatus != null && message.hasOwnProperty("orderStatus"))
                object.orderStatus = message.orderStatus;
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (typeof message.orderID === "number")
                    object.orderID = options.longs === String ? String(message.orderID) : message.orderID;
                else
                    object.orderID = options.longs === String ? $util.Long.prototype.toString.call(message.orderID) : options.longs === Number ? new $util.LongBits(message.orderID.low >>> 0, message.orderID.high >>> 0).toNumber(true) : message.orderID;
            if (message.orderIDEx != null && message.hasOwnProperty("orderIDEx"))
                object.orderIDEx = message.orderIDEx;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.qty != null && message.hasOwnProperty("qty"))
                object.qty = options.json && !isFinite(message.qty) ? String(message.qty) : message.qty;
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                object.createTime = message.createTime;
            if (message.updateTime != null && message.hasOwnProperty("updateTime"))
                object.updateTime = message.updateTime;
            if (message.fillQty != null && message.hasOwnProperty("fillQty"))
                object.fillQty = options.json && !isFinite(message.fillQty) ? String(message.fillQty) : message.fillQty;
            if (message.fillAvgPrice != null && message.hasOwnProperty("fillAvgPrice"))
                object.fillAvgPrice = options.json && !isFinite(message.fillAvgPrice) ? String(message.fillAvgPrice) : message.fillAvgPrice;
            if (message.lastErrMsg != null && message.hasOwnProperty("lastErrMsg"))
                object.lastErrMsg = message.lastErrMsg;
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                object.secMarket = message.secMarket;
            if (message.createTimestamp != null && message.hasOwnProperty("createTimestamp"))
                object.createTimestamp = options.json && !isFinite(message.createTimestamp) ? String(message.createTimestamp) : message.createTimestamp;
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                object.updateTimestamp = options.json && !isFinite(message.updateTimestamp) ? String(message.updateTimestamp) : message.updateTimestamp;
            if (message.remark != null && message.hasOwnProperty("remark"))
                object.remark = message.remark;
            return object;
        };

        /**
         * Converts this Order to JSON.
         * @function toJSON
         * @memberof Trd_Common.Order
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Order.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Order;
    })();

    Trd_Common.OrderFill = (function() {

        /**
         * Properties of an OrderFill.
         * @memberof Trd_Common
         * @interface IOrderFill
         * @property {number} trdSide OrderFill trdSide
         * @property {number|Long} fillID OrderFill fillID
         * @property {string} fillIDEx OrderFill fillIDEx
         * @property {number|Long|null} [orderID] OrderFill orderID
         * @property {string|null} [orderIDEx] OrderFill orderIDEx
         * @property {string} code OrderFill code
         * @property {string} name OrderFill name
         * @property {number} qty OrderFill qty
         * @property {number} price OrderFill price
         * @property {string} createTime OrderFill createTime
         * @property {number|null} [counterBrokerID] OrderFill counterBrokerID
         * @property {string|null} [counterBrokerName] OrderFill counterBrokerName
         * @property {number|null} [secMarket] OrderFill secMarket
         * @property {number|null} [createTimestamp] OrderFill createTimestamp
         * @property {number|null} [updateTimestamp] OrderFill updateTimestamp
         * @property {number|null} [status] OrderFill status
         */

        /**
         * Constructs a new OrderFill.
         * @memberof Trd_Common
         * @classdesc Represents an OrderFill.
         * @implements IOrderFill
         * @constructor
         * @param {Trd_Common.IOrderFill=} [properties] Properties to set
         */
        function OrderFill(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OrderFill trdSide.
         * @member {number} trdSide
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.trdSide = 0;

        /**
         * OrderFill fillID.
         * @member {number|Long} fillID
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.fillID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * OrderFill fillIDEx.
         * @member {string} fillIDEx
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.fillIDEx = "";

        /**
         * OrderFill orderID.
         * @member {number|Long} orderID
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.orderID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * OrderFill orderIDEx.
         * @member {string} orderIDEx
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.orderIDEx = "";

        /**
         * OrderFill code.
         * @member {string} code
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.code = "";

        /**
         * OrderFill name.
         * @member {string} name
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.name = "";

        /**
         * OrderFill qty.
         * @member {number} qty
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.qty = 0;

        /**
         * OrderFill price.
         * @member {number} price
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.price = 0;

        /**
         * OrderFill createTime.
         * @member {string} createTime
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.createTime = "";

        /**
         * OrderFill counterBrokerID.
         * @member {number} counterBrokerID
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.counterBrokerID = 0;

        /**
         * OrderFill counterBrokerName.
         * @member {string} counterBrokerName
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.counterBrokerName = "";

        /**
         * OrderFill secMarket.
         * @member {number} secMarket
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.secMarket = 0;

        /**
         * OrderFill createTimestamp.
         * @member {number} createTimestamp
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.createTimestamp = 0;

        /**
         * OrderFill updateTimestamp.
         * @member {number} updateTimestamp
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.updateTimestamp = 0;

        /**
         * OrderFill status.
         * @member {number} status
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.status = 0;

        /**
         * Creates a new OrderFill instance using the specified properties.
         * @function create
         * @memberof Trd_Common.OrderFill
         * @static
         * @param {Trd_Common.IOrderFill=} [properties] Properties to set
         * @returns {Trd_Common.OrderFill} OrderFill instance
         */
        OrderFill.create = function create(properties) {
            return new OrderFill(properties);
        };

        /**
         * Encodes the specified OrderFill message. Does not implicitly {@link Trd_Common.OrderFill.verify|verify} messages.
         * @function encode
         * @memberof Trd_Common.OrderFill
         * @static
         * @param {Trd_Common.IOrderFill} message OrderFill message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderFill.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.trdSide);
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.fillID);
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.fillIDEx);
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.orderID);
            if (message.orderIDEx != null && message.hasOwnProperty("orderIDEx"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.orderIDEx);
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.code);
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.name);
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.qty);
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.price);
            writer.uint32(/* id 10, wireType 2 =*/82).string(message.createTime);
            if (message.counterBrokerID != null && message.hasOwnProperty("counterBrokerID"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.counterBrokerID);
            if (message.counterBrokerName != null && message.hasOwnProperty("counterBrokerName"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.counterBrokerName);
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.secMarket);
            if (message.createTimestamp != null && message.hasOwnProperty("createTimestamp"))
                writer.uint32(/* id 14, wireType 1 =*/113).double(message.createTimestamp);
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                writer.uint32(/* id 15, wireType 1 =*/121).double(message.updateTimestamp);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.status);
            return writer;
        };

        /**
         * Encodes the specified OrderFill message, length delimited. Does not implicitly {@link Trd_Common.OrderFill.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_Common.OrderFill
         * @static
         * @param {Trd_Common.IOrderFill} message OrderFill message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderFill.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OrderFill message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_Common.OrderFill
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_Common.OrderFill} OrderFill
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderFill.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_Common.OrderFill();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trdSide = reader.int32();
                    break;
                case 2:
                    message.fillID = reader.uint64();
                    break;
                case 3:
                    message.fillIDEx = reader.string();
                    break;
                case 4:
                    message.orderID = reader.uint64();
                    break;
                case 5:
                    message.orderIDEx = reader.string();
                    break;
                case 6:
                    message.code = reader.string();
                    break;
                case 7:
                    message.name = reader.string();
                    break;
                case 8:
                    message.qty = reader.double();
                    break;
                case 9:
                    message.price = reader.double();
                    break;
                case 10:
                    message.createTime = reader.string();
                    break;
                case 11:
                    message.counterBrokerID = reader.int32();
                    break;
                case 12:
                    message.counterBrokerName = reader.string();
                    break;
                case 13:
                    message.secMarket = reader.int32();
                    break;
                case 14:
                    message.createTimestamp = reader.double();
                    break;
                case 15:
                    message.updateTimestamp = reader.double();
                    break;
                case 16:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("trdSide"))
                throw $util.ProtocolError("missing required 'trdSide'", { instance: message });
            if (!message.hasOwnProperty("fillID"))
                throw $util.ProtocolError("missing required 'fillID'", { instance: message });
            if (!message.hasOwnProperty("fillIDEx"))
                throw $util.ProtocolError("missing required 'fillIDEx'", { instance: message });
            if (!message.hasOwnProperty("code"))
                throw $util.ProtocolError("missing required 'code'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("qty"))
                throw $util.ProtocolError("missing required 'qty'", { instance: message });
            if (!message.hasOwnProperty("price"))
                throw $util.ProtocolError("missing required 'price'", { instance: message });
            if (!message.hasOwnProperty("createTime"))
                throw $util.ProtocolError("missing required 'createTime'", { instance: message });
            return message;
        };

        /**
         * Decodes an OrderFill message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_Common.OrderFill
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_Common.OrderFill} OrderFill
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderFill.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OrderFill message.
         * @function verify
         * @memberof Trd_Common.OrderFill
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OrderFill.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.trdSide))
                return "trdSide: integer expected";
            if (!$util.isInteger(message.fillID) && !(message.fillID && $util.isInteger(message.fillID.low) && $util.isInteger(message.fillID.high)))
                return "fillID: integer|Long expected";
            if (!$util.isString(message.fillIDEx))
                return "fillIDEx: string expected";
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (!$util.isInteger(message.orderID) && !(message.orderID && $util.isInteger(message.orderID.low) && $util.isInteger(message.orderID.high)))
                    return "orderID: integer|Long expected";
            if (message.orderIDEx != null && message.hasOwnProperty("orderIDEx"))
                if (!$util.isString(message.orderIDEx))
                    return "orderIDEx: string expected";
            if (!$util.isString(message.code))
                return "code: string expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (typeof message.qty !== "number")
                return "qty: number expected";
            if (typeof message.price !== "number")
                return "price: number expected";
            if (!$util.isString(message.createTime))
                return "createTime: string expected";
            if (message.counterBrokerID != null && message.hasOwnProperty("counterBrokerID"))
                if (!$util.isInteger(message.counterBrokerID))
                    return "counterBrokerID: integer expected";
            if (message.counterBrokerName != null && message.hasOwnProperty("counterBrokerName"))
                if (!$util.isString(message.counterBrokerName))
                    return "counterBrokerName: string expected";
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                if (!$util.isInteger(message.secMarket))
                    return "secMarket: integer expected";
            if (message.createTimestamp != null && message.hasOwnProperty("createTimestamp"))
                if (typeof message.createTimestamp !== "number")
                    return "createTimestamp: number expected";
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                if (typeof message.updateTimestamp !== "number")
                    return "updateTimestamp: number expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isInteger(message.status))
                    return "status: integer expected";
            return null;
        };

        /**
         * Creates an OrderFill message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_Common.OrderFill
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_Common.OrderFill} OrderFill
         */
        OrderFill.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_Common.OrderFill)
                return object;
            var message = new $root.Trd_Common.OrderFill();
            if (object.trdSide != null)
                message.trdSide = object.trdSide | 0;
            if (object.fillID != null)
                if ($util.Long)
                    (message.fillID = $util.Long.fromValue(object.fillID)).unsigned = true;
                else if (typeof object.fillID === "string")
                    message.fillID = parseInt(object.fillID, 10);
                else if (typeof object.fillID === "number")
                    message.fillID = object.fillID;
                else if (typeof object.fillID === "object")
                    message.fillID = new $util.LongBits(object.fillID.low >>> 0, object.fillID.high >>> 0).toNumber(true);
            if (object.fillIDEx != null)
                message.fillIDEx = String(object.fillIDEx);
            if (object.orderID != null)
                if ($util.Long)
                    (message.orderID = $util.Long.fromValue(object.orderID)).unsigned = true;
                else if (typeof object.orderID === "string")
                    message.orderID = parseInt(object.orderID, 10);
                else if (typeof object.orderID === "number")
                    message.orderID = object.orderID;
                else if (typeof object.orderID === "object")
                    message.orderID = new $util.LongBits(object.orderID.low >>> 0, object.orderID.high >>> 0).toNumber(true);
            if (object.orderIDEx != null)
                message.orderIDEx = String(object.orderIDEx);
            if (object.code != null)
                message.code = String(object.code);
            if (object.name != null)
                message.name = String(object.name);
            if (object.qty != null)
                message.qty = Number(object.qty);
            if (object.price != null)
                message.price = Number(object.price);
            if (object.createTime != null)
                message.createTime = String(object.createTime);
            if (object.counterBrokerID != null)
                message.counterBrokerID = object.counterBrokerID | 0;
            if (object.counterBrokerName != null)
                message.counterBrokerName = String(object.counterBrokerName);
            if (object.secMarket != null)
                message.secMarket = object.secMarket | 0;
            if (object.createTimestamp != null)
                message.createTimestamp = Number(object.createTimestamp);
            if (object.updateTimestamp != null)
                message.updateTimestamp = Number(object.updateTimestamp);
            if (object.status != null)
                message.status = object.status | 0;
            return message;
        };

        /**
         * Creates a plain object from an OrderFill message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_Common.OrderFill
         * @static
         * @param {Trd_Common.OrderFill} message OrderFill
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OrderFill.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.trdSide = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.fillID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fillID = options.longs === String ? "0" : 0;
                object.fillIDEx = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.orderID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.orderID = options.longs === String ? "0" : 0;
                object.orderIDEx = "";
                object.code = "";
                object.name = "";
                object.qty = 0;
                object.price = 0;
                object.createTime = "";
                object.counterBrokerID = 0;
                object.counterBrokerName = "";
                object.secMarket = 0;
                object.createTimestamp = 0;
                object.updateTimestamp = 0;
                object.status = 0;
            }
            if (message.trdSide != null && message.hasOwnProperty("trdSide"))
                object.trdSide = message.trdSide;
            if (message.fillID != null && message.hasOwnProperty("fillID"))
                if (typeof message.fillID === "number")
                    object.fillID = options.longs === String ? String(message.fillID) : message.fillID;
                else
                    object.fillID = options.longs === String ? $util.Long.prototype.toString.call(message.fillID) : options.longs === Number ? new $util.LongBits(message.fillID.low >>> 0, message.fillID.high >>> 0).toNumber(true) : message.fillID;
            if (message.fillIDEx != null && message.hasOwnProperty("fillIDEx"))
                object.fillIDEx = message.fillIDEx;
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (typeof message.orderID === "number")
                    object.orderID = options.longs === String ? String(message.orderID) : message.orderID;
                else
                    object.orderID = options.longs === String ? $util.Long.prototype.toString.call(message.orderID) : options.longs === Number ? new $util.LongBits(message.orderID.low >>> 0, message.orderID.high >>> 0).toNumber(true) : message.orderID;
            if (message.orderIDEx != null && message.hasOwnProperty("orderIDEx"))
                object.orderIDEx = message.orderIDEx;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.qty != null && message.hasOwnProperty("qty"))
                object.qty = options.json && !isFinite(message.qty) ? String(message.qty) : message.qty;
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                object.createTime = message.createTime;
            if (message.counterBrokerID != null && message.hasOwnProperty("counterBrokerID"))
                object.counterBrokerID = message.counterBrokerID;
            if (message.counterBrokerName != null && message.hasOwnProperty("counterBrokerName"))
                object.counterBrokerName = message.counterBrokerName;
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                object.secMarket = message.secMarket;
            if (message.createTimestamp != null && message.hasOwnProperty("createTimestamp"))
                object.createTimestamp = options.json && !isFinite(message.createTimestamp) ? String(message.createTimestamp) : message.createTimestamp;
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                object.updateTimestamp = options.json && !isFinite(message.updateTimestamp) ? String(message.updateTimestamp) : message.updateTimestamp;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            return object;
        };

        /**
         * Converts this OrderFill to JSON.
         * @function toJSON
         * @memberof Trd_Common.OrderFill
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OrderFill.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OrderFill;
    })();

    Trd_Common.MaxTrdQtys = (function() {

        /**
         * Properties of a MaxTrdQtys.
         * @memberof Trd_Common
         * @interface IMaxTrdQtys
         * @property {number} maxCashBuy MaxTrdQtys maxCashBuy
         * @property {number|null} [maxCashAndMarginBuy] MaxTrdQtys maxCashAndMarginBuy
         * @property {number} maxPositionSell MaxTrdQtys maxPositionSell
         * @property {number|null} [maxSellShort] MaxTrdQtys maxSellShort
         * @property {number|null} [maxBuyBack] MaxTrdQtys maxBuyBack
         */

        /**
         * Constructs a new MaxTrdQtys.
         * @memberof Trd_Common
         * @classdesc Represents a MaxTrdQtys.
         * @implements IMaxTrdQtys
         * @constructor
         * @param {Trd_Common.IMaxTrdQtys=} [properties] Properties to set
         */
        function MaxTrdQtys(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MaxTrdQtys maxCashBuy.
         * @member {number} maxCashBuy
         * @memberof Trd_Common.MaxTrdQtys
         * @instance
         */
        MaxTrdQtys.prototype.maxCashBuy = 0;

        /**
         * MaxTrdQtys maxCashAndMarginBuy.
         * @member {number} maxCashAndMarginBuy
         * @memberof Trd_Common.MaxTrdQtys
         * @instance
         */
        MaxTrdQtys.prototype.maxCashAndMarginBuy = 0;

        /**
         * MaxTrdQtys maxPositionSell.
         * @member {number} maxPositionSell
         * @memberof Trd_Common.MaxTrdQtys
         * @instance
         */
        MaxTrdQtys.prototype.maxPositionSell = 0;

        /**
         * MaxTrdQtys maxSellShort.
         * @member {number} maxSellShort
         * @memberof Trd_Common.MaxTrdQtys
         * @instance
         */
        MaxTrdQtys.prototype.maxSellShort = 0;

        /**
         * MaxTrdQtys maxBuyBack.
         * @member {number} maxBuyBack
         * @memberof Trd_Common.MaxTrdQtys
         * @instance
         */
        MaxTrdQtys.prototype.maxBuyBack = 0;

        /**
         * Creates a new MaxTrdQtys instance using the specified properties.
         * @function create
         * @memberof Trd_Common.MaxTrdQtys
         * @static
         * @param {Trd_Common.IMaxTrdQtys=} [properties] Properties to set
         * @returns {Trd_Common.MaxTrdQtys} MaxTrdQtys instance
         */
        MaxTrdQtys.create = function create(properties) {
            return new MaxTrdQtys(properties);
        };

        /**
         * Encodes the specified MaxTrdQtys message. Does not implicitly {@link Trd_Common.MaxTrdQtys.verify|verify} messages.
         * @function encode
         * @memberof Trd_Common.MaxTrdQtys
         * @static
         * @param {Trd_Common.IMaxTrdQtys} message MaxTrdQtys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MaxTrdQtys.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.maxCashBuy);
            if (message.maxCashAndMarginBuy != null && message.hasOwnProperty("maxCashAndMarginBuy"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.maxCashAndMarginBuy);
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.maxPositionSell);
            if (message.maxSellShort != null && message.hasOwnProperty("maxSellShort"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.maxSellShort);
            if (message.maxBuyBack != null && message.hasOwnProperty("maxBuyBack"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.maxBuyBack);
            return writer;
        };

        /**
         * Encodes the specified MaxTrdQtys message, length delimited. Does not implicitly {@link Trd_Common.MaxTrdQtys.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_Common.MaxTrdQtys
         * @static
         * @param {Trd_Common.IMaxTrdQtys} message MaxTrdQtys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MaxTrdQtys.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MaxTrdQtys message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_Common.MaxTrdQtys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_Common.MaxTrdQtys} MaxTrdQtys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MaxTrdQtys.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_Common.MaxTrdQtys();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.maxCashBuy = reader.double();
                    break;
                case 2:
                    message.maxCashAndMarginBuy = reader.double();
                    break;
                case 3:
                    message.maxPositionSell = reader.double();
                    break;
                case 4:
                    message.maxSellShort = reader.double();
                    break;
                case 5:
                    message.maxBuyBack = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("maxCashBuy"))
                throw $util.ProtocolError("missing required 'maxCashBuy'", { instance: message });
            if (!message.hasOwnProperty("maxPositionSell"))
                throw $util.ProtocolError("missing required 'maxPositionSell'", { instance: message });
            return message;
        };

        /**
         * Decodes a MaxTrdQtys message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_Common.MaxTrdQtys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_Common.MaxTrdQtys} MaxTrdQtys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MaxTrdQtys.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MaxTrdQtys message.
         * @function verify
         * @memberof Trd_Common.MaxTrdQtys
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MaxTrdQtys.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.maxCashBuy !== "number")
                return "maxCashBuy: number expected";
            if (message.maxCashAndMarginBuy != null && message.hasOwnProperty("maxCashAndMarginBuy"))
                if (typeof message.maxCashAndMarginBuy !== "number")
                    return "maxCashAndMarginBuy: number expected";
            if (typeof message.maxPositionSell !== "number")
                return "maxPositionSell: number expected";
            if (message.maxSellShort != null && message.hasOwnProperty("maxSellShort"))
                if (typeof message.maxSellShort !== "number")
                    return "maxSellShort: number expected";
            if (message.maxBuyBack != null && message.hasOwnProperty("maxBuyBack"))
                if (typeof message.maxBuyBack !== "number")
                    return "maxBuyBack: number expected";
            return null;
        };

        /**
         * Creates a MaxTrdQtys message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_Common.MaxTrdQtys
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_Common.MaxTrdQtys} MaxTrdQtys
         */
        MaxTrdQtys.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_Common.MaxTrdQtys)
                return object;
            var message = new $root.Trd_Common.MaxTrdQtys();
            if (object.maxCashBuy != null)
                message.maxCashBuy = Number(object.maxCashBuy);
            if (object.maxCashAndMarginBuy != null)
                message.maxCashAndMarginBuy = Number(object.maxCashAndMarginBuy);
            if (object.maxPositionSell != null)
                message.maxPositionSell = Number(object.maxPositionSell);
            if (object.maxSellShort != null)
                message.maxSellShort = Number(object.maxSellShort);
            if (object.maxBuyBack != null)
                message.maxBuyBack = Number(object.maxBuyBack);
            return message;
        };

        /**
         * Creates a plain object from a MaxTrdQtys message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_Common.MaxTrdQtys
         * @static
         * @param {Trd_Common.MaxTrdQtys} message MaxTrdQtys
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MaxTrdQtys.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.maxCashBuy = 0;
                object.maxCashAndMarginBuy = 0;
                object.maxPositionSell = 0;
                object.maxSellShort = 0;
                object.maxBuyBack = 0;
            }
            if (message.maxCashBuy != null && message.hasOwnProperty("maxCashBuy"))
                object.maxCashBuy = options.json && !isFinite(message.maxCashBuy) ? String(message.maxCashBuy) : message.maxCashBuy;
            if (message.maxCashAndMarginBuy != null && message.hasOwnProperty("maxCashAndMarginBuy"))
                object.maxCashAndMarginBuy = options.json && !isFinite(message.maxCashAndMarginBuy) ? String(message.maxCashAndMarginBuy) : message.maxCashAndMarginBuy;
            if (message.maxPositionSell != null && message.hasOwnProperty("maxPositionSell"))
                object.maxPositionSell = options.json && !isFinite(message.maxPositionSell) ? String(message.maxPositionSell) : message.maxPositionSell;
            if (message.maxSellShort != null && message.hasOwnProperty("maxSellShort"))
                object.maxSellShort = options.json && !isFinite(message.maxSellShort) ? String(message.maxSellShort) : message.maxSellShort;
            if (message.maxBuyBack != null && message.hasOwnProperty("maxBuyBack"))
                object.maxBuyBack = options.json && !isFinite(message.maxBuyBack) ? String(message.maxBuyBack) : message.maxBuyBack;
            return object;
        };

        /**
         * Converts this MaxTrdQtys to JSON.
         * @function toJSON
         * @memberof Trd_Common.MaxTrdQtys
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MaxTrdQtys.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MaxTrdQtys;
    })();

    Trd_Common.TrdFilterConditions = (function() {

        /**
         * Properties of a TrdFilterConditions.
         * @memberof Trd_Common
         * @interface ITrdFilterConditions
         * @property {Array.<string>|null} [codeList] TrdFilterConditions codeList
         * @property {Array.<number|Long>|null} [idList] TrdFilterConditions idList
         * @property {string|null} [beginTime] TrdFilterConditions beginTime
         * @property {string|null} [endTime] TrdFilterConditions endTime
         */

        /**
         * Constructs a new TrdFilterConditions.
         * @memberof Trd_Common
         * @classdesc Represents a TrdFilterConditions.
         * @implements ITrdFilterConditions
         * @constructor
         * @param {Trd_Common.ITrdFilterConditions=} [properties] Properties to set
         */
        function TrdFilterConditions(properties) {
            this.codeList = [];
            this.idList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TrdFilterConditions codeList.
         * @member {Array.<string>} codeList
         * @memberof Trd_Common.TrdFilterConditions
         * @instance
         */
        TrdFilterConditions.prototype.codeList = $util.emptyArray;

        /**
         * TrdFilterConditions idList.
         * @member {Array.<number|Long>} idList
         * @memberof Trd_Common.TrdFilterConditions
         * @instance
         */
        TrdFilterConditions.prototype.idList = $util.emptyArray;

        /**
         * TrdFilterConditions beginTime.
         * @member {string} beginTime
         * @memberof Trd_Common.TrdFilterConditions
         * @instance
         */
        TrdFilterConditions.prototype.beginTime = "";

        /**
         * TrdFilterConditions endTime.
         * @member {string} endTime
         * @memberof Trd_Common.TrdFilterConditions
         * @instance
         */
        TrdFilterConditions.prototype.endTime = "";

        /**
         * Creates a new TrdFilterConditions instance using the specified properties.
         * @function create
         * @memberof Trd_Common.TrdFilterConditions
         * @static
         * @param {Trd_Common.ITrdFilterConditions=} [properties] Properties to set
         * @returns {Trd_Common.TrdFilterConditions} TrdFilterConditions instance
         */
        TrdFilterConditions.create = function create(properties) {
            return new TrdFilterConditions(properties);
        };

        /**
         * Encodes the specified TrdFilterConditions message. Does not implicitly {@link Trd_Common.TrdFilterConditions.verify|verify} messages.
         * @function encode
         * @memberof Trd_Common.TrdFilterConditions
         * @static
         * @param {Trd_Common.ITrdFilterConditions} message TrdFilterConditions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrdFilterConditions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.codeList != null && message.codeList.length)
                for (var i = 0; i < message.codeList.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.codeList[i]);
            if (message.idList != null && message.idList.length)
                for (var i = 0; i < message.idList.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.idList[i]);
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.beginTime);
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.endTime);
            return writer;
        };

        /**
         * Encodes the specified TrdFilterConditions message, length delimited. Does not implicitly {@link Trd_Common.TrdFilterConditions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_Common.TrdFilterConditions
         * @static
         * @param {Trd_Common.ITrdFilterConditions} message TrdFilterConditions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrdFilterConditions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TrdFilterConditions message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_Common.TrdFilterConditions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_Common.TrdFilterConditions} TrdFilterConditions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrdFilterConditions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_Common.TrdFilterConditions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.codeList && message.codeList.length))
                        message.codeList = [];
                    message.codeList.push(reader.string());
                    break;
                case 2:
                    if (!(message.idList && message.idList.length))
                        message.idList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.idList.push(reader.uint64());
                    } else
                        message.idList.push(reader.uint64());
                    break;
                case 3:
                    message.beginTime = reader.string();
                    break;
                case 4:
                    message.endTime = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TrdFilterConditions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_Common.TrdFilterConditions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_Common.TrdFilterConditions} TrdFilterConditions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrdFilterConditions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TrdFilterConditions message.
         * @function verify
         * @memberof Trd_Common.TrdFilterConditions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TrdFilterConditions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.codeList != null && message.hasOwnProperty("codeList")) {
                if (!Array.isArray(message.codeList))
                    return "codeList: array expected";
                for (var i = 0; i < message.codeList.length; ++i)
                    if (!$util.isString(message.codeList[i]))
                        return "codeList: string[] expected";
            }
            if (message.idList != null && message.hasOwnProperty("idList")) {
                if (!Array.isArray(message.idList))
                    return "idList: array expected";
                for (var i = 0; i < message.idList.length; ++i)
                    if (!$util.isInteger(message.idList[i]) && !(message.idList[i] && $util.isInteger(message.idList[i].low) && $util.isInteger(message.idList[i].high)))
                        return "idList: integer|Long[] expected";
            }
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                if (!$util.isString(message.beginTime))
                    return "beginTime: string expected";
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isString(message.endTime))
                    return "endTime: string expected";
            return null;
        };

        /**
         * Creates a TrdFilterConditions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_Common.TrdFilterConditions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_Common.TrdFilterConditions} TrdFilterConditions
         */
        TrdFilterConditions.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_Common.TrdFilterConditions)
                return object;
            var message = new $root.Trd_Common.TrdFilterConditions();
            if (object.codeList) {
                if (!Array.isArray(object.codeList))
                    throw TypeError(".Trd_Common.TrdFilterConditions.codeList: array expected");
                message.codeList = [];
                for (var i = 0; i < object.codeList.length; ++i)
                    message.codeList[i] = String(object.codeList[i]);
            }
            if (object.idList) {
                if (!Array.isArray(object.idList))
                    throw TypeError(".Trd_Common.TrdFilterConditions.idList: array expected");
                message.idList = [];
                for (var i = 0; i < object.idList.length; ++i)
                    if ($util.Long)
                        (message.idList[i] = $util.Long.fromValue(object.idList[i])).unsigned = true;
                    else if (typeof object.idList[i] === "string")
                        message.idList[i] = parseInt(object.idList[i], 10);
                    else if (typeof object.idList[i] === "number")
                        message.idList[i] = object.idList[i];
                    else if (typeof object.idList[i] === "object")
                        message.idList[i] = new $util.LongBits(object.idList[i].low >>> 0, object.idList[i].high >>> 0).toNumber(true);
            }
            if (object.beginTime != null)
                message.beginTime = String(object.beginTime);
            if (object.endTime != null)
                message.endTime = String(object.endTime);
            return message;
        };

        /**
         * Creates a plain object from a TrdFilterConditions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_Common.TrdFilterConditions
         * @static
         * @param {Trd_Common.TrdFilterConditions} message TrdFilterConditions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TrdFilterConditions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.codeList = [];
                object.idList = [];
            }
            if (options.defaults) {
                object.beginTime = "";
                object.endTime = "";
            }
            if (message.codeList && message.codeList.length) {
                object.codeList = [];
                for (var j = 0; j < message.codeList.length; ++j)
                    object.codeList[j] = message.codeList[j];
            }
            if (message.idList && message.idList.length) {
                object.idList = [];
                for (var j = 0; j < message.idList.length; ++j)
                    if (typeof message.idList[j] === "number")
                        object.idList[j] = options.longs === String ? String(message.idList[j]) : message.idList[j];
                    else
                        object.idList[j] = options.longs === String ? $util.Long.prototype.toString.call(message.idList[j]) : options.longs === Number ? new $util.LongBits(message.idList[j].low >>> 0, message.idList[j].high >>> 0).toNumber(true) : message.idList[j];
            }
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                object.beginTime = message.beginTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            return object;
        };

        /**
         * Converts this TrdFilterConditions to JSON.
         * @function toJSON
         * @memberof Trd_Common.TrdFilterConditions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TrdFilterConditions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TrdFilterConditions;
    })();

    return Trd_Common;
})();

$root.Trd_GetAccList = (function() {

    /**
     * Namespace Trd_GetAccList.
     * @exports Trd_GetAccList
     * @namespace
     */
    var Trd_GetAccList = {};

    Trd_GetAccList.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_GetAccList
         * @interface IC2S
         * @property {number|Long} userID C2S userID
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_GetAccList
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_GetAccList.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S userID.
         * @member {number|Long} userID
         * @memberof Trd_GetAccList.C2S
         * @instance
         */
        C2S.prototype.userID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_GetAccList.C2S
         * @static
         * @param {Trd_GetAccList.IC2S=} [properties] Properties to set
         * @returns {Trd_GetAccList.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_GetAccList.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetAccList.C2S
         * @static
         * @param {Trd_GetAccList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.userID);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_GetAccList.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetAccList.C2S
         * @static
         * @param {Trd_GetAccList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetAccList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetAccList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetAccList.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userID = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userID"))
                throw $util.ProtocolError("missing required 'userID'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetAccList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetAccList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_GetAccList.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.userID) && !(message.userID && $util.isInteger(message.userID.low) && $util.isInteger(message.userID.high)))
                return "userID: integer|Long expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetAccList.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetAccList.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetAccList.C2S)
                return object;
            var message = new $root.Trd_GetAccList.C2S();
            if (object.userID != null)
                if ($util.Long)
                    (message.userID = $util.Long.fromValue(object.userID)).unsigned = true;
                else if (typeof object.userID === "string")
                    message.userID = parseInt(object.userID, 10);
                else if (typeof object.userID === "number")
                    message.userID = object.userID;
                else if (typeof object.userID === "object")
                    message.userID = new $util.LongBits(object.userID.low >>> 0, object.userID.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetAccList.C2S
         * @static
         * @param {Trd_GetAccList.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.userID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.userID = options.longs === String ? "0" : 0;
            if (message.userID != null && message.hasOwnProperty("userID"))
                if (typeof message.userID === "number")
                    object.userID = options.longs === String ? String(message.userID) : message.userID;
                else
                    object.userID = options.longs === String ? $util.Long.prototype.toString.call(message.userID) : options.longs === Number ? new $util.LongBits(message.userID.low >>> 0, message.userID.high >>> 0).toNumber(true) : message.userID;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_GetAccList.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_GetAccList.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_GetAccList
         * @interface IS2C
         * @property {Array.<Trd_Common.ITrdAcc>|null} [accList] S2C accList
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_GetAccList
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_GetAccList.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.accList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C accList.
         * @member {Array.<Trd_Common.ITrdAcc>} accList
         * @memberof Trd_GetAccList.S2C
         * @instance
         */
        S2C.prototype.accList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_GetAccList.S2C
         * @static
         * @param {Trd_GetAccList.IS2C=} [properties] Properties to set
         * @returns {Trd_GetAccList.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_GetAccList.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetAccList.S2C
         * @static
         * @param {Trd_GetAccList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accList != null && message.accList.length)
                for (var i = 0; i < message.accList.length; ++i)
                    $root.Trd_Common.TrdAcc.encode(message.accList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_GetAccList.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetAccList.S2C
         * @static
         * @param {Trd_GetAccList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetAccList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetAccList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetAccList.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.accList && message.accList.length))
                        message.accList = [];
                    message.accList.push($root.Trd_Common.TrdAcc.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetAccList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetAccList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_GetAccList.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accList != null && message.hasOwnProperty("accList")) {
                if (!Array.isArray(message.accList))
                    return "accList: array expected";
                for (var i = 0; i < message.accList.length; ++i) {
                    var error = $root.Trd_Common.TrdAcc.verify(message.accList[i]);
                    if (error)
                        return "accList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetAccList.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetAccList.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetAccList.S2C)
                return object;
            var message = new $root.Trd_GetAccList.S2C();
            if (object.accList) {
                if (!Array.isArray(object.accList))
                    throw TypeError(".Trd_GetAccList.S2C.accList: array expected");
                message.accList = [];
                for (var i = 0; i < object.accList.length; ++i) {
                    if (typeof object.accList[i] !== "object")
                        throw TypeError(".Trd_GetAccList.S2C.accList: object expected");
                    message.accList[i] = $root.Trd_Common.TrdAcc.fromObject(object.accList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetAccList.S2C
         * @static
         * @param {Trd_GetAccList.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.accList = [];
            if (message.accList && message.accList.length) {
                object.accList = [];
                for (var j = 0; j < message.accList.length; ++j)
                    object.accList[j] = $root.Trd_Common.TrdAcc.toObject(message.accList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_GetAccList.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_GetAccList.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_GetAccList
         * @interface IRequest
         * @property {Trd_GetAccList.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_GetAccList
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_GetAccList.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_GetAccList.IC2S} c2s
         * @memberof Trd_GetAccList.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_GetAccList.Request
         * @static
         * @param {Trd_GetAccList.IRequest=} [properties] Properties to set
         * @returns {Trd_GetAccList.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_GetAccList.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetAccList.Request
         * @static
         * @param {Trd_GetAccList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_GetAccList.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_GetAccList.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetAccList.Request
         * @static
         * @param {Trd_GetAccList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetAccList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetAccList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetAccList.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_GetAccList.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetAccList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetAccList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_GetAccList.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_GetAccList.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetAccList.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetAccList.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetAccList.Request)
                return object;
            var message = new $root.Trd_GetAccList.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_GetAccList.Request.c2s: object expected");
                message.c2s = $root.Trd_GetAccList.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetAccList.Request
         * @static
         * @param {Trd_GetAccList.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_GetAccList.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_GetAccList.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_GetAccList.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_GetAccList
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_GetAccList.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_GetAccList
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_GetAccList.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_GetAccList.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_GetAccList.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_GetAccList.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_GetAccList.IS2C|null|undefined} s2c
         * @memberof Trd_GetAccList.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_GetAccList.Response
         * @static
         * @param {Trd_GetAccList.IResponse=} [properties] Properties to set
         * @returns {Trd_GetAccList.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_GetAccList.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetAccList.Response
         * @static
         * @param {Trd_GetAccList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_GetAccList.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_GetAccList.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetAccList.Response
         * @static
         * @param {Trd_GetAccList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetAccList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetAccList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetAccList.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_GetAccList.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetAccList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetAccList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_GetAccList.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_GetAccList.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetAccList.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetAccList.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetAccList.Response)
                return object;
            var message = new $root.Trd_GetAccList.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_GetAccList.Response.s2c: object expected");
                message.s2c = $root.Trd_GetAccList.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetAccList.Response
         * @static
         * @param {Trd_GetAccList.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_GetAccList.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_GetAccList.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_GetAccList;
})();

$root.Trd_GetFunds = (function() {

    /**
     * Namespace Trd_GetFunds.
     * @exports Trd_GetFunds
     * @namespace
     */
    var Trd_GetFunds = {};

    Trd_GetFunds.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_GetFunds
         * @interface IC2S
         * @property {Trd_Common.ITrdHeader} header C2S header
         * @property {boolean|null} [refreshCache] C2S refreshCache
         * @property {number|null} [currency] C2S currency
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_GetFunds
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_GetFunds.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetFunds.C2S
         * @instance
         */
        C2S.prototype.header = null;

        /**
         * C2S refreshCache.
         * @member {boolean} refreshCache
         * @memberof Trd_GetFunds.C2S
         * @instance
         */
        C2S.prototype.refreshCache = false;

        /**
         * C2S currency.
         * @member {number} currency
         * @memberof Trd_GetFunds.C2S
         * @instance
         */
        C2S.prototype.currency = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_GetFunds.C2S
         * @static
         * @param {Trd_GetFunds.IC2S=} [properties] Properties to set
         * @returns {Trd_GetFunds.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_GetFunds.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetFunds.C2S
         * @static
         * @param {Trd_GetFunds.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.refreshCache != null && message.hasOwnProperty("refreshCache"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.refreshCache);
            if (message.currency != null && message.hasOwnProperty("currency"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.currency);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_GetFunds.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetFunds.C2S
         * @static
         * @param {Trd_GetFunds.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetFunds.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetFunds.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetFunds.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.refreshCache = reader.bool();
                    break;
                case 3:
                    message.currency = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetFunds.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetFunds.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_GetFunds.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.refreshCache != null && message.hasOwnProperty("refreshCache"))
                if (typeof message.refreshCache !== "boolean")
                    return "refreshCache: boolean expected";
            if (message.currency != null && message.hasOwnProperty("currency"))
                if (!$util.isInteger(message.currency))
                    return "currency: integer expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetFunds.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetFunds.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetFunds.C2S)
                return object;
            var message = new $root.Trd_GetFunds.C2S();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetFunds.C2S.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.refreshCache != null)
                message.refreshCache = Boolean(object.refreshCache);
            if (object.currency != null)
                message.currency = object.currency | 0;
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetFunds.C2S
         * @static
         * @param {Trd_GetFunds.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                object.refreshCache = false;
                object.currency = 0;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.refreshCache != null && message.hasOwnProperty("refreshCache"))
                object.refreshCache = message.refreshCache;
            if (message.currency != null && message.hasOwnProperty("currency"))
                object.currency = message.currency;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_GetFunds.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_GetFunds.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_GetFunds
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {Trd_Common.IFunds|null} [funds] S2C funds
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_GetFunds
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_GetFunds.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetFunds.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C funds.
         * @member {Trd_Common.IFunds|null|undefined} funds
         * @memberof Trd_GetFunds.S2C
         * @instance
         */
        S2C.prototype.funds = null;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_GetFunds.S2C
         * @static
         * @param {Trd_GetFunds.IS2C=} [properties] Properties to set
         * @returns {Trd_GetFunds.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_GetFunds.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetFunds.S2C
         * @static
         * @param {Trd_GetFunds.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.funds != null && message.hasOwnProperty("funds"))
                $root.Trd_Common.Funds.encode(message.funds, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_GetFunds.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetFunds.S2C
         * @static
         * @param {Trd_GetFunds.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetFunds.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetFunds.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetFunds.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.funds = $root.Trd_Common.Funds.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetFunds.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetFunds.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_GetFunds.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.funds != null && message.hasOwnProperty("funds")) {
                var error = $root.Trd_Common.Funds.verify(message.funds);
                if (error)
                    return "funds." + error;
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetFunds.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetFunds.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetFunds.S2C)
                return object;
            var message = new $root.Trd_GetFunds.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetFunds.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.funds != null) {
                if (typeof object.funds !== "object")
                    throw TypeError(".Trd_GetFunds.S2C.funds: object expected");
                message.funds = $root.Trd_Common.Funds.fromObject(object.funds);
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetFunds.S2C
         * @static
         * @param {Trd_GetFunds.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                object.funds = null;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.funds != null && message.hasOwnProperty("funds"))
                object.funds = $root.Trd_Common.Funds.toObject(message.funds, options);
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_GetFunds.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_GetFunds.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_GetFunds
         * @interface IRequest
         * @property {Trd_GetFunds.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_GetFunds
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_GetFunds.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_GetFunds.IC2S} c2s
         * @memberof Trd_GetFunds.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_GetFunds.Request
         * @static
         * @param {Trd_GetFunds.IRequest=} [properties] Properties to set
         * @returns {Trd_GetFunds.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_GetFunds.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetFunds.Request
         * @static
         * @param {Trd_GetFunds.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_GetFunds.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_GetFunds.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetFunds.Request
         * @static
         * @param {Trd_GetFunds.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetFunds.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetFunds.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetFunds.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_GetFunds.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetFunds.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetFunds.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_GetFunds.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_GetFunds.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetFunds.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetFunds.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetFunds.Request)
                return object;
            var message = new $root.Trd_GetFunds.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_GetFunds.Request.c2s: object expected");
                message.c2s = $root.Trd_GetFunds.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetFunds.Request
         * @static
         * @param {Trd_GetFunds.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_GetFunds.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_GetFunds.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_GetFunds.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_GetFunds
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_GetFunds.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_GetFunds
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_GetFunds.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_GetFunds.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_GetFunds.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_GetFunds.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_GetFunds.IS2C|null|undefined} s2c
         * @memberof Trd_GetFunds.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_GetFunds.Response
         * @static
         * @param {Trd_GetFunds.IResponse=} [properties] Properties to set
         * @returns {Trd_GetFunds.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_GetFunds.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetFunds.Response
         * @static
         * @param {Trd_GetFunds.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_GetFunds.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_GetFunds.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetFunds.Response
         * @static
         * @param {Trd_GetFunds.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetFunds.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetFunds.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetFunds.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_GetFunds.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetFunds.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetFunds.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_GetFunds.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_GetFunds.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetFunds.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetFunds.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetFunds.Response)
                return object;
            var message = new $root.Trd_GetFunds.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_GetFunds.Response.s2c: object expected");
                message.s2c = $root.Trd_GetFunds.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetFunds.Response
         * @static
         * @param {Trd_GetFunds.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_GetFunds.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_GetFunds.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_GetFunds;
})();

$root.Trd_GetHistoryOrderFillList = (function() {

    /**
     * Namespace Trd_GetHistoryOrderFillList.
     * @exports Trd_GetHistoryOrderFillList
     * @namespace
     */
    var Trd_GetHistoryOrderFillList = {};

    Trd_GetHistoryOrderFillList.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_GetHistoryOrderFillList
         * @interface IC2S
         * @property {Trd_Common.ITrdHeader} header C2S header
         * @property {Trd_Common.ITrdFilterConditions} filterConditions C2S filterConditions
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_GetHistoryOrderFillList
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_GetHistoryOrderFillList.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetHistoryOrderFillList.C2S
         * @instance
         */
        C2S.prototype.header = null;

        /**
         * C2S filterConditions.
         * @member {Trd_Common.ITrdFilterConditions} filterConditions
         * @memberof Trd_GetHistoryOrderFillList.C2S
         * @instance
         */
        C2S.prototype.filterConditions = null;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_GetHistoryOrderFillList.C2S
         * @static
         * @param {Trd_GetHistoryOrderFillList.IC2S=} [properties] Properties to set
         * @returns {Trd_GetHistoryOrderFillList.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_GetHistoryOrderFillList.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetHistoryOrderFillList.C2S
         * @static
         * @param {Trd_GetHistoryOrderFillList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            $root.Trd_Common.TrdFilterConditions.encode(message.filterConditions, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_GetHistoryOrderFillList.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetHistoryOrderFillList.C2S
         * @static
         * @param {Trd_GetHistoryOrderFillList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetHistoryOrderFillList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetHistoryOrderFillList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetHistoryOrderFillList.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.filterConditions = $root.Trd_Common.TrdFilterConditions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            if (!message.hasOwnProperty("filterConditions"))
                throw $util.ProtocolError("missing required 'filterConditions'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetHistoryOrderFillList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetHistoryOrderFillList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_GetHistoryOrderFillList.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            {
                var error = $root.Trd_Common.TrdFilterConditions.verify(message.filterConditions);
                if (error)
                    return "filterConditions." + error;
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetHistoryOrderFillList.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetHistoryOrderFillList.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetHistoryOrderFillList.C2S)
                return object;
            var message = new $root.Trd_GetHistoryOrderFillList.C2S();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetHistoryOrderFillList.C2S.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.filterConditions != null) {
                if (typeof object.filterConditions !== "object")
                    throw TypeError(".Trd_GetHistoryOrderFillList.C2S.filterConditions: object expected");
                message.filterConditions = $root.Trd_Common.TrdFilterConditions.fromObject(object.filterConditions);
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetHistoryOrderFillList.C2S
         * @static
         * @param {Trd_GetHistoryOrderFillList.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                object.filterConditions = null;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.filterConditions != null && message.hasOwnProperty("filterConditions"))
                object.filterConditions = $root.Trd_Common.TrdFilterConditions.toObject(message.filterConditions, options);
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_GetHistoryOrderFillList.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_GetHistoryOrderFillList.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_GetHistoryOrderFillList
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {Array.<Trd_Common.IOrderFill>|null} [orderFillList] S2C orderFillList
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_GetHistoryOrderFillList
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_GetHistoryOrderFillList.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.orderFillList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetHistoryOrderFillList.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C orderFillList.
         * @member {Array.<Trd_Common.IOrderFill>} orderFillList
         * @memberof Trd_GetHistoryOrderFillList.S2C
         * @instance
         */
        S2C.prototype.orderFillList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_GetHistoryOrderFillList.S2C
         * @static
         * @param {Trd_GetHistoryOrderFillList.IS2C=} [properties] Properties to set
         * @returns {Trd_GetHistoryOrderFillList.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_GetHistoryOrderFillList.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetHistoryOrderFillList.S2C
         * @static
         * @param {Trd_GetHistoryOrderFillList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.orderFillList != null && message.orderFillList.length)
                for (var i = 0; i < message.orderFillList.length; ++i)
                    $root.Trd_Common.OrderFill.encode(message.orderFillList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_GetHistoryOrderFillList.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetHistoryOrderFillList.S2C
         * @static
         * @param {Trd_GetHistoryOrderFillList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetHistoryOrderFillList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetHistoryOrderFillList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetHistoryOrderFillList.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.orderFillList && message.orderFillList.length))
                        message.orderFillList = [];
                    message.orderFillList.push($root.Trd_Common.OrderFill.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetHistoryOrderFillList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetHistoryOrderFillList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_GetHistoryOrderFillList.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.orderFillList != null && message.hasOwnProperty("orderFillList")) {
                if (!Array.isArray(message.orderFillList))
                    return "orderFillList: array expected";
                for (var i = 0; i < message.orderFillList.length; ++i) {
                    var error = $root.Trd_Common.OrderFill.verify(message.orderFillList[i]);
                    if (error)
                        return "orderFillList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetHistoryOrderFillList.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetHistoryOrderFillList.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetHistoryOrderFillList.S2C)
                return object;
            var message = new $root.Trd_GetHistoryOrderFillList.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetHistoryOrderFillList.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.orderFillList) {
                if (!Array.isArray(object.orderFillList))
                    throw TypeError(".Trd_GetHistoryOrderFillList.S2C.orderFillList: array expected");
                message.orderFillList = [];
                for (var i = 0; i < object.orderFillList.length; ++i) {
                    if (typeof object.orderFillList[i] !== "object")
                        throw TypeError(".Trd_GetHistoryOrderFillList.S2C.orderFillList: object expected");
                    message.orderFillList[i] = $root.Trd_Common.OrderFill.fromObject(object.orderFillList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetHistoryOrderFillList.S2C
         * @static
         * @param {Trd_GetHistoryOrderFillList.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.orderFillList = [];
            if (options.defaults)
                object.header = null;
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.orderFillList && message.orderFillList.length) {
                object.orderFillList = [];
                for (var j = 0; j < message.orderFillList.length; ++j)
                    object.orderFillList[j] = $root.Trd_Common.OrderFill.toObject(message.orderFillList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_GetHistoryOrderFillList.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_GetHistoryOrderFillList.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_GetHistoryOrderFillList
         * @interface IRequest
         * @property {Trd_GetHistoryOrderFillList.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_GetHistoryOrderFillList
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_GetHistoryOrderFillList.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_GetHistoryOrderFillList.IC2S} c2s
         * @memberof Trd_GetHistoryOrderFillList.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_GetHistoryOrderFillList.Request
         * @static
         * @param {Trd_GetHistoryOrderFillList.IRequest=} [properties] Properties to set
         * @returns {Trd_GetHistoryOrderFillList.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_GetHistoryOrderFillList.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetHistoryOrderFillList.Request
         * @static
         * @param {Trd_GetHistoryOrderFillList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_GetHistoryOrderFillList.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_GetHistoryOrderFillList.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetHistoryOrderFillList.Request
         * @static
         * @param {Trd_GetHistoryOrderFillList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetHistoryOrderFillList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetHistoryOrderFillList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetHistoryOrderFillList.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_GetHistoryOrderFillList.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetHistoryOrderFillList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetHistoryOrderFillList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_GetHistoryOrderFillList.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_GetHistoryOrderFillList.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetHistoryOrderFillList.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetHistoryOrderFillList.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetHistoryOrderFillList.Request)
                return object;
            var message = new $root.Trd_GetHistoryOrderFillList.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_GetHistoryOrderFillList.Request.c2s: object expected");
                message.c2s = $root.Trd_GetHistoryOrderFillList.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetHistoryOrderFillList.Request
         * @static
         * @param {Trd_GetHistoryOrderFillList.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_GetHistoryOrderFillList.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_GetHistoryOrderFillList.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_GetHistoryOrderFillList.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_GetHistoryOrderFillList
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_GetHistoryOrderFillList.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_GetHistoryOrderFillList
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_GetHistoryOrderFillList.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_GetHistoryOrderFillList.IS2C|null|undefined} s2c
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @static
         * @param {Trd_GetHistoryOrderFillList.IResponse=} [properties] Properties to set
         * @returns {Trd_GetHistoryOrderFillList.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_GetHistoryOrderFillList.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @static
         * @param {Trd_GetHistoryOrderFillList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_GetHistoryOrderFillList.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_GetHistoryOrderFillList.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @static
         * @param {Trd_GetHistoryOrderFillList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetHistoryOrderFillList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetHistoryOrderFillList.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_GetHistoryOrderFillList.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetHistoryOrderFillList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_GetHistoryOrderFillList.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetHistoryOrderFillList.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetHistoryOrderFillList.Response)
                return object;
            var message = new $root.Trd_GetHistoryOrderFillList.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_GetHistoryOrderFillList.Response.s2c: object expected");
                message.s2c = $root.Trd_GetHistoryOrderFillList.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @static
         * @param {Trd_GetHistoryOrderFillList.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_GetHistoryOrderFillList.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_GetHistoryOrderFillList;
})();

$root.Trd_GetHistoryOrderList = (function() {

    /**
     * Namespace Trd_GetHistoryOrderList.
     * @exports Trd_GetHistoryOrderList
     * @namespace
     */
    var Trd_GetHistoryOrderList = {};

    Trd_GetHistoryOrderList.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_GetHistoryOrderList
         * @interface IC2S
         * @property {Trd_Common.ITrdHeader} header C2S header
         * @property {Trd_Common.ITrdFilterConditions} filterConditions C2S filterConditions
         * @property {Array.<number>|null} [filterStatusList] C2S filterStatusList
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_GetHistoryOrderList
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_GetHistoryOrderList.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.filterStatusList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetHistoryOrderList.C2S
         * @instance
         */
        C2S.prototype.header = null;

        /**
         * C2S filterConditions.
         * @member {Trd_Common.ITrdFilterConditions} filterConditions
         * @memberof Trd_GetHistoryOrderList.C2S
         * @instance
         */
        C2S.prototype.filterConditions = null;

        /**
         * C2S filterStatusList.
         * @member {Array.<number>} filterStatusList
         * @memberof Trd_GetHistoryOrderList.C2S
         * @instance
         */
        C2S.prototype.filterStatusList = $util.emptyArray;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_GetHistoryOrderList.C2S
         * @static
         * @param {Trd_GetHistoryOrderList.IC2S=} [properties] Properties to set
         * @returns {Trd_GetHistoryOrderList.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_GetHistoryOrderList.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetHistoryOrderList.C2S
         * @static
         * @param {Trd_GetHistoryOrderList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            $root.Trd_Common.TrdFilterConditions.encode(message.filterConditions, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.filterStatusList != null && message.filterStatusList.length)
                for (var i = 0; i < message.filterStatusList.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.filterStatusList[i]);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_GetHistoryOrderList.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetHistoryOrderList.C2S
         * @static
         * @param {Trd_GetHistoryOrderList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetHistoryOrderList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetHistoryOrderList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetHistoryOrderList.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.filterConditions = $root.Trd_Common.TrdFilterConditions.decode(reader, reader.uint32());
                    break;
                case 3:
                    if (!(message.filterStatusList && message.filterStatusList.length))
                        message.filterStatusList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.filterStatusList.push(reader.int32());
                    } else
                        message.filterStatusList.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            if (!message.hasOwnProperty("filterConditions"))
                throw $util.ProtocolError("missing required 'filterConditions'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetHistoryOrderList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetHistoryOrderList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_GetHistoryOrderList.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            {
                var error = $root.Trd_Common.TrdFilterConditions.verify(message.filterConditions);
                if (error)
                    return "filterConditions." + error;
            }
            if (message.filterStatusList != null && message.hasOwnProperty("filterStatusList")) {
                if (!Array.isArray(message.filterStatusList))
                    return "filterStatusList: array expected";
                for (var i = 0; i < message.filterStatusList.length; ++i)
                    if (!$util.isInteger(message.filterStatusList[i]))
                        return "filterStatusList: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetHistoryOrderList.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetHistoryOrderList.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetHistoryOrderList.C2S)
                return object;
            var message = new $root.Trd_GetHistoryOrderList.C2S();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetHistoryOrderList.C2S.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.filterConditions != null) {
                if (typeof object.filterConditions !== "object")
                    throw TypeError(".Trd_GetHistoryOrderList.C2S.filterConditions: object expected");
                message.filterConditions = $root.Trd_Common.TrdFilterConditions.fromObject(object.filterConditions);
            }
            if (object.filterStatusList) {
                if (!Array.isArray(object.filterStatusList))
                    throw TypeError(".Trd_GetHistoryOrderList.C2S.filterStatusList: array expected");
                message.filterStatusList = [];
                for (var i = 0; i < object.filterStatusList.length; ++i)
                    message.filterStatusList[i] = object.filterStatusList[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetHistoryOrderList.C2S
         * @static
         * @param {Trd_GetHistoryOrderList.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.filterStatusList = [];
            if (options.defaults) {
                object.header = null;
                object.filterConditions = null;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.filterConditions != null && message.hasOwnProperty("filterConditions"))
                object.filterConditions = $root.Trd_Common.TrdFilterConditions.toObject(message.filterConditions, options);
            if (message.filterStatusList && message.filterStatusList.length) {
                object.filterStatusList = [];
                for (var j = 0; j < message.filterStatusList.length; ++j)
                    object.filterStatusList[j] = message.filterStatusList[j];
            }
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_GetHistoryOrderList.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_GetHistoryOrderList.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_GetHistoryOrderList
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {Array.<Trd_Common.IOrder>|null} [orderList] S2C orderList
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_GetHistoryOrderList
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_GetHistoryOrderList.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.orderList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetHistoryOrderList.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C orderList.
         * @member {Array.<Trd_Common.IOrder>} orderList
         * @memberof Trd_GetHistoryOrderList.S2C
         * @instance
         */
        S2C.prototype.orderList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_GetHistoryOrderList.S2C
         * @static
         * @param {Trd_GetHistoryOrderList.IS2C=} [properties] Properties to set
         * @returns {Trd_GetHistoryOrderList.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_GetHistoryOrderList.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetHistoryOrderList.S2C
         * @static
         * @param {Trd_GetHistoryOrderList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.orderList != null && message.orderList.length)
                for (var i = 0; i < message.orderList.length; ++i)
                    $root.Trd_Common.Order.encode(message.orderList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_GetHistoryOrderList.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetHistoryOrderList.S2C
         * @static
         * @param {Trd_GetHistoryOrderList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetHistoryOrderList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetHistoryOrderList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetHistoryOrderList.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.orderList && message.orderList.length))
                        message.orderList = [];
                    message.orderList.push($root.Trd_Common.Order.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetHistoryOrderList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetHistoryOrderList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_GetHistoryOrderList.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.orderList != null && message.hasOwnProperty("orderList")) {
                if (!Array.isArray(message.orderList))
                    return "orderList: array expected";
                for (var i = 0; i < message.orderList.length; ++i) {
                    var error = $root.Trd_Common.Order.verify(message.orderList[i]);
                    if (error)
                        return "orderList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetHistoryOrderList.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetHistoryOrderList.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetHistoryOrderList.S2C)
                return object;
            var message = new $root.Trd_GetHistoryOrderList.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetHistoryOrderList.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.orderList) {
                if (!Array.isArray(object.orderList))
                    throw TypeError(".Trd_GetHistoryOrderList.S2C.orderList: array expected");
                message.orderList = [];
                for (var i = 0; i < object.orderList.length; ++i) {
                    if (typeof object.orderList[i] !== "object")
                        throw TypeError(".Trd_GetHistoryOrderList.S2C.orderList: object expected");
                    message.orderList[i] = $root.Trd_Common.Order.fromObject(object.orderList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetHistoryOrderList.S2C
         * @static
         * @param {Trd_GetHistoryOrderList.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.orderList = [];
            if (options.defaults)
                object.header = null;
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.orderList && message.orderList.length) {
                object.orderList = [];
                for (var j = 0; j < message.orderList.length; ++j)
                    object.orderList[j] = $root.Trd_Common.Order.toObject(message.orderList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_GetHistoryOrderList.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_GetHistoryOrderList.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_GetHistoryOrderList
         * @interface IRequest
         * @property {Trd_GetHistoryOrderList.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_GetHistoryOrderList
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_GetHistoryOrderList.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_GetHistoryOrderList.IC2S} c2s
         * @memberof Trd_GetHistoryOrderList.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_GetHistoryOrderList.Request
         * @static
         * @param {Trd_GetHistoryOrderList.IRequest=} [properties] Properties to set
         * @returns {Trd_GetHistoryOrderList.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_GetHistoryOrderList.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetHistoryOrderList.Request
         * @static
         * @param {Trd_GetHistoryOrderList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_GetHistoryOrderList.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_GetHistoryOrderList.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetHistoryOrderList.Request
         * @static
         * @param {Trd_GetHistoryOrderList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetHistoryOrderList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetHistoryOrderList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetHistoryOrderList.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_GetHistoryOrderList.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetHistoryOrderList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetHistoryOrderList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_GetHistoryOrderList.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_GetHistoryOrderList.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetHistoryOrderList.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetHistoryOrderList.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetHistoryOrderList.Request)
                return object;
            var message = new $root.Trd_GetHistoryOrderList.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_GetHistoryOrderList.Request.c2s: object expected");
                message.c2s = $root.Trd_GetHistoryOrderList.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetHistoryOrderList.Request
         * @static
         * @param {Trd_GetHistoryOrderList.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_GetHistoryOrderList.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_GetHistoryOrderList.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_GetHistoryOrderList.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_GetHistoryOrderList
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_GetHistoryOrderList.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_GetHistoryOrderList
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_GetHistoryOrderList.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_GetHistoryOrderList.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_GetHistoryOrderList.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_GetHistoryOrderList.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_GetHistoryOrderList.IS2C|null|undefined} s2c
         * @memberof Trd_GetHistoryOrderList.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_GetHistoryOrderList.Response
         * @static
         * @param {Trd_GetHistoryOrderList.IResponse=} [properties] Properties to set
         * @returns {Trd_GetHistoryOrderList.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_GetHistoryOrderList.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetHistoryOrderList.Response
         * @static
         * @param {Trd_GetHistoryOrderList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_GetHistoryOrderList.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_GetHistoryOrderList.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetHistoryOrderList.Response
         * @static
         * @param {Trd_GetHistoryOrderList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetHistoryOrderList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetHistoryOrderList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetHistoryOrderList.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_GetHistoryOrderList.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetHistoryOrderList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetHistoryOrderList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_GetHistoryOrderList.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_GetHistoryOrderList.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetHistoryOrderList.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetHistoryOrderList.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetHistoryOrderList.Response)
                return object;
            var message = new $root.Trd_GetHistoryOrderList.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_GetHistoryOrderList.Response.s2c: object expected");
                message.s2c = $root.Trd_GetHistoryOrderList.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetHistoryOrderList.Response
         * @static
         * @param {Trd_GetHistoryOrderList.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_GetHistoryOrderList.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_GetHistoryOrderList.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_GetHistoryOrderList;
})();

$root.Trd_GetMaxTrdQtys = (function() {

    /**
     * Namespace Trd_GetMaxTrdQtys.
     * @exports Trd_GetMaxTrdQtys
     * @namespace
     */
    var Trd_GetMaxTrdQtys = {};

    Trd_GetMaxTrdQtys.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_GetMaxTrdQtys
         * @interface IC2S
         * @property {Trd_Common.ITrdHeader} header C2S header
         * @property {number} orderType C2S orderType
         * @property {string} code C2S code
         * @property {number} price C2S price
         * @property {number|Long|null} [orderID] C2S orderID
         * @property {boolean|null} [adjustPrice] C2S adjustPrice
         * @property {number|null} [adjustSideAndLimit] C2S adjustSideAndLimit
         * @property {number|null} [secMarket] C2S secMarket
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_GetMaxTrdQtys
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_GetMaxTrdQtys.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @instance
         */
        C2S.prototype.header = null;

        /**
         * C2S orderType.
         * @member {number} orderType
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @instance
         */
        C2S.prototype.orderType = 0;

        /**
         * C2S code.
         * @member {string} code
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @instance
         */
        C2S.prototype.code = "";

        /**
         * C2S price.
         * @member {number} price
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @instance
         */
        C2S.prototype.price = 0;

        /**
         * C2S orderID.
         * @member {number|Long} orderID
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @instance
         */
        C2S.prototype.orderID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * C2S adjustPrice.
         * @member {boolean} adjustPrice
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @instance
         */
        C2S.prototype.adjustPrice = false;

        /**
         * C2S adjustSideAndLimit.
         * @member {number} adjustSideAndLimit
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @instance
         */
        C2S.prototype.adjustSideAndLimit = 0;

        /**
         * C2S secMarket.
         * @member {number} secMarket
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @instance
         */
        C2S.prototype.secMarket = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @static
         * @param {Trd_GetMaxTrdQtys.IC2S=} [properties] Properties to set
         * @returns {Trd_GetMaxTrdQtys.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_GetMaxTrdQtys.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @static
         * @param {Trd_GetMaxTrdQtys.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.orderType);
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.code);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.price);
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.orderID);
            if (message.adjustPrice != null && message.hasOwnProperty("adjustPrice"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.adjustPrice);
            if (message.adjustSideAndLimit != null && message.hasOwnProperty("adjustSideAndLimit"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.adjustSideAndLimit);
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.secMarket);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_GetMaxTrdQtys.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @static
         * @param {Trd_GetMaxTrdQtys.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetMaxTrdQtys.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetMaxTrdQtys.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.orderType = reader.int32();
                    break;
                case 3:
                    message.code = reader.string();
                    break;
                case 4:
                    message.price = reader.double();
                    break;
                case 5:
                    message.orderID = reader.uint64();
                    break;
                case 6:
                    message.adjustPrice = reader.bool();
                    break;
                case 7:
                    message.adjustSideAndLimit = reader.double();
                    break;
                case 8:
                    message.secMarket = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            if (!message.hasOwnProperty("orderType"))
                throw $util.ProtocolError("missing required 'orderType'", { instance: message });
            if (!message.hasOwnProperty("code"))
                throw $util.ProtocolError("missing required 'code'", { instance: message });
            if (!message.hasOwnProperty("price"))
                throw $util.ProtocolError("missing required 'price'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetMaxTrdQtys.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (!$util.isInteger(message.orderType))
                return "orderType: integer expected";
            if (!$util.isString(message.code))
                return "code: string expected";
            if (typeof message.price !== "number")
                return "price: number expected";
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (!$util.isInteger(message.orderID) && !(message.orderID && $util.isInteger(message.orderID.low) && $util.isInteger(message.orderID.high)))
                    return "orderID: integer|Long expected";
            if (message.adjustPrice != null && message.hasOwnProperty("adjustPrice"))
                if (typeof message.adjustPrice !== "boolean")
                    return "adjustPrice: boolean expected";
            if (message.adjustSideAndLimit != null && message.hasOwnProperty("adjustSideAndLimit"))
                if (typeof message.adjustSideAndLimit !== "number")
                    return "adjustSideAndLimit: number expected";
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                if (!$util.isInteger(message.secMarket))
                    return "secMarket: integer expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetMaxTrdQtys.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetMaxTrdQtys.C2S)
                return object;
            var message = new $root.Trd_GetMaxTrdQtys.C2S();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetMaxTrdQtys.C2S.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.orderType != null)
                message.orderType = object.orderType | 0;
            if (object.code != null)
                message.code = String(object.code);
            if (object.price != null)
                message.price = Number(object.price);
            if (object.orderID != null)
                if ($util.Long)
                    (message.orderID = $util.Long.fromValue(object.orderID)).unsigned = true;
                else if (typeof object.orderID === "string")
                    message.orderID = parseInt(object.orderID, 10);
                else if (typeof object.orderID === "number")
                    message.orderID = object.orderID;
                else if (typeof object.orderID === "object")
                    message.orderID = new $util.LongBits(object.orderID.low >>> 0, object.orderID.high >>> 0).toNumber(true);
            if (object.adjustPrice != null)
                message.adjustPrice = Boolean(object.adjustPrice);
            if (object.adjustSideAndLimit != null)
                message.adjustSideAndLimit = Number(object.adjustSideAndLimit);
            if (object.secMarket != null)
                message.secMarket = object.secMarket | 0;
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @static
         * @param {Trd_GetMaxTrdQtys.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                object.orderType = 0;
                object.code = "";
                object.price = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.orderID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.orderID = options.longs === String ? "0" : 0;
                object.adjustPrice = false;
                object.adjustSideAndLimit = 0;
                object.secMarket = 0;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.orderType != null && message.hasOwnProperty("orderType"))
                object.orderType = message.orderType;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (typeof message.orderID === "number")
                    object.orderID = options.longs === String ? String(message.orderID) : message.orderID;
                else
                    object.orderID = options.longs === String ? $util.Long.prototype.toString.call(message.orderID) : options.longs === Number ? new $util.LongBits(message.orderID.low >>> 0, message.orderID.high >>> 0).toNumber(true) : message.orderID;
            if (message.adjustPrice != null && message.hasOwnProperty("adjustPrice"))
                object.adjustPrice = message.adjustPrice;
            if (message.adjustSideAndLimit != null && message.hasOwnProperty("adjustSideAndLimit"))
                object.adjustSideAndLimit = options.json && !isFinite(message.adjustSideAndLimit) ? String(message.adjustSideAndLimit) : message.adjustSideAndLimit;
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                object.secMarket = message.secMarket;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_GetMaxTrdQtys.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_GetMaxTrdQtys
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {Trd_Common.IMaxTrdQtys|null} [maxTrdQtys] S2C maxTrdQtys
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_GetMaxTrdQtys
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_GetMaxTrdQtys.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetMaxTrdQtys.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C maxTrdQtys.
         * @member {Trd_Common.IMaxTrdQtys|null|undefined} maxTrdQtys
         * @memberof Trd_GetMaxTrdQtys.S2C
         * @instance
         */
        S2C.prototype.maxTrdQtys = null;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_GetMaxTrdQtys.S2C
         * @static
         * @param {Trd_GetMaxTrdQtys.IS2C=} [properties] Properties to set
         * @returns {Trd_GetMaxTrdQtys.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_GetMaxTrdQtys.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetMaxTrdQtys.S2C
         * @static
         * @param {Trd_GetMaxTrdQtys.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.maxTrdQtys != null && message.hasOwnProperty("maxTrdQtys"))
                $root.Trd_Common.MaxTrdQtys.encode(message.maxTrdQtys, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_GetMaxTrdQtys.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetMaxTrdQtys.S2C
         * @static
         * @param {Trd_GetMaxTrdQtys.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetMaxTrdQtys.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetMaxTrdQtys.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetMaxTrdQtys.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.maxTrdQtys = $root.Trd_Common.MaxTrdQtys.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetMaxTrdQtys.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetMaxTrdQtys.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_GetMaxTrdQtys.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.maxTrdQtys != null && message.hasOwnProperty("maxTrdQtys")) {
                var error = $root.Trd_Common.MaxTrdQtys.verify(message.maxTrdQtys);
                if (error)
                    return "maxTrdQtys." + error;
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetMaxTrdQtys.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetMaxTrdQtys.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetMaxTrdQtys.S2C)
                return object;
            var message = new $root.Trd_GetMaxTrdQtys.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetMaxTrdQtys.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.maxTrdQtys != null) {
                if (typeof object.maxTrdQtys !== "object")
                    throw TypeError(".Trd_GetMaxTrdQtys.S2C.maxTrdQtys: object expected");
                message.maxTrdQtys = $root.Trd_Common.MaxTrdQtys.fromObject(object.maxTrdQtys);
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetMaxTrdQtys.S2C
         * @static
         * @param {Trd_GetMaxTrdQtys.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                object.maxTrdQtys = null;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.maxTrdQtys != null && message.hasOwnProperty("maxTrdQtys"))
                object.maxTrdQtys = $root.Trd_Common.MaxTrdQtys.toObject(message.maxTrdQtys, options);
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_GetMaxTrdQtys.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_GetMaxTrdQtys.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_GetMaxTrdQtys
         * @interface IRequest
         * @property {Trd_GetMaxTrdQtys.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_GetMaxTrdQtys
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_GetMaxTrdQtys.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_GetMaxTrdQtys.IC2S} c2s
         * @memberof Trd_GetMaxTrdQtys.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_GetMaxTrdQtys.Request
         * @static
         * @param {Trd_GetMaxTrdQtys.IRequest=} [properties] Properties to set
         * @returns {Trd_GetMaxTrdQtys.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_GetMaxTrdQtys.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetMaxTrdQtys.Request
         * @static
         * @param {Trd_GetMaxTrdQtys.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_GetMaxTrdQtys.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_GetMaxTrdQtys.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetMaxTrdQtys.Request
         * @static
         * @param {Trd_GetMaxTrdQtys.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetMaxTrdQtys.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetMaxTrdQtys.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetMaxTrdQtys.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_GetMaxTrdQtys.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetMaxTrdQtys.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetMaxTrdQtys.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_GetMaxTrdQtys.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_GetMaxTrdQtys.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetMaxTrdQtys.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetMaxTrdQtys.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetMaxTrdQtys.Request)
                return object;
            var message = new $root.Trd_GetMaxTrdQtys.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_GetMaxTrdQtys.Request.c2s: object expected");
                message.c2s = $root.Trd_GetMaxTrdQtys.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetMaxTrdQtys.Request
         * @static
         * @param {Trd_GetMaxTrdQtys.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_GetMaxTrdQtys.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_GetMaxTrdQtys.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_GetMaxTrdQtys.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_GetMaxTrdQtys
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_GetMaxTrdQtys.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_GetMaxTrdQtys
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_GetMaxTrdQtys.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_GetMaxTrdQtys.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_GetMaxTrdQtys.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_GetMaxTrdQtys.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_GetMaxTrdQtys.IS2C|null|undefined} s2c
         * @memberof Trd_GetMaxTrdQtys.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_GetMaxTrdQtys.Response
         * @static
         * @param {Trd_GetMaxTrdQtys.IResponse=} [properties] Properties to set
         * @returns {Trd_GetMaxTrdQtys.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_GetMaxTrdQtys.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetMaxTrdQtys.Response
         * @static
         * @param {Trd_GetMaxTrdQtys.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_GetMaxTrdQtys.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_GetMaxTrdQtys.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetMaxTrdQtys.Response
         * @static
         * @param {Trd_GetMaxTrdQtys.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetMaxTrdQtys.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetMaxTrdQtys.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetMaxTrdQtys.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_GetMaxTrdQtys.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetMaxTrdQtys.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetMaxTrdQtys.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_GetMaxTrdQtys.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_GetMaxTrdQtys.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetMaxTrdQtys.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetMaxTrdQtys.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetMaxTrdQtys.Response)
                return object;
            var message = new $root.Trd_GetMaxTrdQtys.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_GetMaxTrdQtys.Response.s2c: object expected");
                message.s2c = $root.Trd_GetMaxTrdQtys.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetMaxTrdQtys.Response
         * @static
         * @param {Trd_GetMaxTrdQtys.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_GetMaxTrdQtys.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_GetMaxTrdQtys.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_GetMaxTrdQtys;
})();

$root.Trd_GetOrderFillList = (function() {

    /**
     * Namespace Trd_GetOrderFillList.
     * @exports Trd_GetOrderFillList
     * @namespace
     */
    var Trd_GetOrderFillList = {};

    Trd_GetOrderFillList.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_GetOrderFillList
         * @interface IC2S
         * @property {Trd_Common.ITrdHeader} header C2S header
         * @property {Trd_Common.ITrdFilterConditions|null} [filterConditions] C2S filterConditions
         * @property {boolean|null} [refreshCache] C2S refreshCache
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_GetOrderFillList
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_GetOrderFillList.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetOrderFillList.C2S
         * @instance
         */
        C2S.prototype.header = null;

        /**
         * C2S filterConditions.
         * @member {Trd_Common.ITrdFilterConditions|null|undefined} filterConditions
         * @memberof Trd_GetOrderFillList.C2S
         * @instance
         */
        C2S.prototype.filterConditions = null;

        /**
         * C2S refreshCache.
         * @member {boolean} refreshCache
         * @memberof Trd_GetOrderFillList.C2S
         * @instance
         */
        C2S.prototype.refreshCache = false;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_GetOrderFillList.C2S
         * @static
         * @param {Trd_GetOrderFillList.IC2S=} [properties] Properties to set
         * @returns {Trd_GetOrderFillList.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_GetOrderFillList.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetOrderFillList.C2S
         * @static
         * @param {Trd_GetOrderFillList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.filterConditions != null && message.hasOwnProperty("filterConditions"))
                $root.Trd_Common.TrdFilterConditions.encode(message.filterConditions, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.refreshCache != null && message.hasOwnProperty("refreshCache"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.refreshCache);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_GetOrderFillList.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetOrderFillList.C2S
         * @static
         * @param {Trd_GetOrderFillList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetOrderFillList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetOrderFillList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetOrderFillList.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.filterConditions = $root.Trd_Common.TrdFilterConditions.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.refreshCache = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetOrderFillList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetOrderFillList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_GetOrderFillList.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.filterConditions != null && message.hasOwnProperty("filterConditions")) {
                var error = $root.Trd_Common.TrdFilterConditions.verify(message.filterConditions);
                if (error)
                    return "filterConditions." + error;
            }
            if (message.refreshCache != null && message.hasOwnProperty("refreshCache"))
                if (typeof message.refreshCache !== "boolean")
                    return "refreshCache: boolean expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetOrderFillList.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetOrderFillList.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetOrderFillList.C2S)
                return object;
            var message = new $root.Trd_GetOrderFillList.C2S();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetOrderFillList.C2S.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.filterConditions != null) {
                if (typeof object.filterConditions !== "object")
                    throw TypeError(".Trd_GetOrderFillList.C2S.filterConditions: object expected");
                message.filterConditions = $root.Trd_Common.TrdFilterConditions.fromObject(object.filterConditions);
            }
            if (object.refreshCache != null)
                message.refreshCache = Boolean(object.refreshCache);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetOrderFillList.C2S
         * @static
         * @param {Trd_GetOrderFillList.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                object.filterConditions = null;
                object.refreshCache = false;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.filterConditions != null && message.hasOwnProperty("filterConditions"))
                object.filterConditions = $root.Trd_Common.TrdFilterConditions.toObject(message.filterConditions, options);
            if (message.refreshCache != null && message.hasOwnProperty("refreshCache"))
                object.refreshCache = message.refreshCache;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_GetOrderFillList.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_GetOrderFillList.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_GetOrderFillList
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {Array.<Trd_Common.IOrderFill>|null} [orderFillList] S2C orderFillList
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_GetOrderFillList
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_GetOrderFillList.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.orderFillList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetOrderFillList.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C orderFillList.
         * @member {Array.<Trd_Common.IOrderFill>} orderFillList
         * @memberof Trd_GetOrderFillList.S2C
         * @instance
         */
        S2C.prototype.orderFillList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_GetOrderFillList.S2C
         * @static
         * @param {Trd_GetOrderFillList.IS2C=} [properties] Properties to set
         * @returns {Trd_GetOrderFillList.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_GetOrderFillList.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetOrderFillList.S2C
         * @static
         * @param {Trd_GetOrderFillList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.orderFillList != null && message.orderFillList.length)
                for (var i = 0; i < message.orderFillList.length; ++i)
                    $root.Trd_Common.OrderFill.encode(message.orderFillList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_GetOrderFillList.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetOrderFillList.S2C
         * @static
         * @param {Trd_GetOrderFillList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetOrderFillList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetOrderFillList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetOrderFillList.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.orderFillList && message.orderFillList.length))
                        message.orderFillList = [];
                    message.orderFillList.push($root.Trd_Common.OrderFill.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetOrderFillList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetOrderFillList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_GetOrderFillList.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.orderFillList != null && message.hasOwnProperty("orderFillList")) {
                if (!Array.isArray(message.orderFillList))
                    return "orderFillList: array expected";
                for (var i = 0; i < message.orderFillList.length; ++i) {
                    var error = $root.Trd_Common.OrderFill.verify(message.orderFillList[i]);
                    if (error)
                        return "orderFillList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetOrderFillList.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetOrderFillList.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetOrderFillList.S2C)
                return object;
            var message = new $root.Trd_GetOrderFillList.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetOrderFillList.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.orderFillList) {
                if (!Array.isArray(object.orderFillList))
                    throw TypeError(".Trd_GetOrderFillList.S2C.orderFillList: array expected");
                message.orderFillList = [];
                for (var i = 0; i < object.orderFillList.length; ++i) {
                    if (typeof object.orderFillList[i] !== "object")
                        throw TypeError(".Trd_GetOrderFillList.S2C.orderFillList: object expected");
                    message.orderFillList[i] = $root.Trd_Common.OrderFill.fromObject(object.orderFillList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetOrderFillList.S2C
         * @static
         * @param {Trd_GetOrderFillList.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.orderFillList = [];
            if (options.defaults)
                object.header = null;
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.orderFillList && message.orderFillList.length) {
                object.orderFillList = [];
                for (var j = 0; j < message.orderFillList.length; ++j)
                    object.orderFillList[j] = $root.Trd_Common.OrderFill.toObject(message.orderFillList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_GetOrderFillList.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_GetOrderFillList.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_GetOrderFillList
         * @interface IRequest
         * @property {Trd_GetOrderFillList.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_GetOrderFillList
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_GetOrderFillList.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_GetOrderFillList.IC2S} c2s
         * @memberof Trd_GetOrderFillList.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_GetOrderFillList.Request
         * @static
         * @param {Trd_GetOrderFillList.IRequest=} [properties] Properties to set
         * @returns {Trd_GetOrderFillList.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_GetOrderFillList.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetOrderFillList.Request
         * @static
         * @param {Trd_GetOrderFillList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_GetOrderFillList.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_GetOrderFillList.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetOrderFillList.Request
         * @static
         * @param {Trd_GetOrderFillList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetOrderFillList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetOrderFillList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetOrderFillList.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_GetOrderFillList.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetOrderFillList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetOrderFillList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_GetOrderFillList.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_GetOrderFillList.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetOrderFillList.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetOrderFillList.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetOrderFillList.Request)
                return object;
            var message = new $root.Trd_GetOrderFillList.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_GetOrderFillList.Request.c2s: object expected");
                message.c2s = $root.Trd_GetOrderFillList.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetOrderFillList.Request
         * @static
         * @param {Trd_GetOrderFillList.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_GetOrderFillList.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_GetOrderFillList.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_GetOrderFillList.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_GetOrderFillList
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_GetOrderFillList.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_GetOrderFillList
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_GetOrderFillList.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_GetOrderFillList.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_GetOrderFillList.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_GetOrderFillList.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_GetOrderFillList.IS2C|null|undefined} s2c
         * @memberof Trd_GetOrderFillList.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_GetOrderFillList.Response
         * @static
         * @param {Trd_GetOrderFillList.IResponse=} [properties] Properties to set
         * @returns {Trd_GetOrderFillList.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_GetOrderFillList.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetOrderFillList.Response
         * @static
         * @param {Trd_GetOrderFillList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_GetOrderFillList.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_GetOrderFillList.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetOrderFillList.Response
         * @static
         * @param {Trd_GetOrderFillList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetOrderFillList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetOrderFillList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetOrderFillList.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_GetOrderFillList.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetOrderFillList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetOrderFillList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_GetOrderFillList.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_GetOrderFillList.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetOrderFillList.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetOrderFillList.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetOrderFillList.Response)
                return object;
            var message = new $root.Trd_GetOrderFillList.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_GetOrderFillList.Response.s2c: object expected");
                message.s2c = $root.Trd_GetOrderFillList.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetOrderFillList.Response
         * @static
         * @param {Trd_GetOrderFillList.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_GetOrderFillList.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_GetOrderFillList.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_GetOrderFillList;
})();

$root.Trd_GetOrderList = (function() {

    /**
     * Namespace Trd_GetOrderList.
     * @exports Trd_GetOrderList
     * @namespace
     */
    var Trd_GetOrderList = {};

    Trd_GetOrderList.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_GetOrderList
         * @interface IC2S
         * @property {Trd_Common.ITrdHeader} header C2S header
         * @property {Trd_Common.ITrdFilterConditions|null} [filterConditions] C2S filterConditions
         * @property {Array.<number>|null} [filterStatusList] C2S filterStatusList
         * @property {boolean|null} [refreshCache] C2S refreshCache
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_GetOrderList
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_GetOrderList.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.filterStatusList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetOrderList.C2S
         * @instance
         */
        C2S.prototype.header = null;

        /**
         * C2S filterConditions.
         * @member {Trd_Common.ITrdFilterConditions|null|undefined} filterConditions
         * @memberof Trd_GetOrderList.C2S
         * @instance
         */
        C2S.prototype.filterConditions = null;

        /**
         * C2S filterStatusList.
         * @member {Array.<number>} filterStatusList
         * @memberof Trd_GetOrderList.C2S
         * @instance
         */
        C2S.prototype.filterStatusList = $util.emptyArray;

        /**
         * C2S refreshCache.
         * @member {boolean} refreshCache
         * @memberof Trd_GetOrderList.C2S
         * @instance
         */
        C2S.prototype.refreshCache = false;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_GetOrderList.C2S
         * @static
         * @param {Trd_GetOrderList.IC2S=} [properties] Properties to set
         * @returns {Trd_GetOrderList.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_GetOrderList.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetOrderList.C2S
         * @static
         * @param {Trd_GetOrderList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.filterConditions != null && message.hasOwnProperty("filterConditions"))
                $root.Trd_Common.TrdFilterConditions.encode(message.filterConditions, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.filterStatusList != null && message.filterStatusList.length)
                for (var i = 0; i < message.filterStatusList.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.filterStatusList[i]);
            if (message.refreshCache != null && message.hasOwnProperty("refreshCache"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.refreshCache);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_GetOrderList.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetOrderList.C2S
         * @static
         * @param {Trd_GetOrderList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetOrderList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetOrderList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetOrderList.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.filterConditions = $root.Trd_Common.TrdFilterConditions.decode(reader, reader.uint32());
                    break;
                case 3:
                    if (!(message.filterStatusList && message.filterStatusList.length))
                        message.filterStatusList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.filterStatusList.push(reader.int32());
                    } else
                        message.filterStatusList.push(reader.int32());
                    break;
                case 4:
                    message.refreshCache = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetOrderList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetOrderList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_GetOrderList.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.filterConditions != null && message.hasOwnProperty("filterConditions")) {
                var error = $root.Trd_Common.TrdFilterConditions.verify(message.filterConditions);
                if (error)
                    return "filterConditions." + error;
            }
            if (message.filterStatusList != null && message.hasOwnProperty("filterStatusList")) {
                if (!Array.isArray(message.filterStatusList))
                    return "filterStatusList: array expected";
                for (var i = 0; i < message.filterStatusList.length; ++i)
                    if (!$util.isInteger(message.filterStatusList[i]))
                        return "filterStatusList: integer[] expected";
            }
            if (message.refreshCache != null && message.hasOwnProperty("refreshCache"))
                if (typeof message.refreshCache !== "boolean")
                    return "refreshCache: boolean expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetOrderList.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetOrderList.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetOrderList.C2S)
                return object;
            var message = new $root.Trd_GetOrderList.C2S();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetOrderList.C2S.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.filterConditions != null) {
                if (typeof object.filterConditions !== "object")
                    throw TypeError(".Trd_GetOrderList.C2S.filterConditions: object expected");
                message.filterConditions = $root.Trd_Common.TrdFilterConditions.fromObject(object.filterConditions);
            }
            if (object.filterStatusList) {
                if (!Array.isArray(object.filterStatusList))
                    throw TypeError(".Trd_GetOrderList.C2S.filterStatusList: array expected");
                message.filterStatusList = [];
                for (var i = 0; i < object.filterStatusList.length; ++i)
                    message.filterStatusList[i] = object.filterStatusList[i] | 0;
            }
            if (object.refreshCache != null)
                message.refreshCache = Boolean(object.refreshCache);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetOrderList.C2S
         * @static
         * @param {Trd_GetOrderList.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.filterStatusList = [];
            if (options.defaults) {
                object.header = null;
                object.filterConditions = null;
                object.refreshCache = false;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.filterConditions != null && message.hasOwnProperty("filterConditions"))
                object.filterConditions = $root.Trd_Common.TrdFilterConditions.toObject(message.filterConditions, options);
            if (message.filterStatusList && message.filterStatusList.length) {
                object.filterStatusList = [];
                for (var j = 0; j < message.filterStatusList.length; ++j)
                    object.filterStatusList[j] = message.filterStatusList[j];
            }
            if (message.refreshCache != null && message.hasOwnProperty("refreshCache"))
                object.refreshCache = message.refreshCache;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_GetOrderList.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_GetOrderList.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_GetOrderList
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {Array.<Trd_Common.IOrder>|null} [orderList] S2C orderList
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_GetOrderList
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_GetOrderList.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.orderList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetOrderList.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C orderList.
         * @member {Array.<Trd_Common.IOrder>} orderList
         * @memberof Trd_GetOrderList.S2C
         * @instance
         */
        S2C.prototype.orderList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_GetOrderList.S2C
         * @static
         * @param {Trd_GetOrderList.IS2C=} [properties] Properties to set
         * @returns {Trd_GetOrderList.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_GetOrderList.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetOrderList.S2C
         * @static
         * @param {Trd_GetOrderList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.orderList != null && message.orderList.length)
                for (var i = 0; i < message.orderList.length; ++i)
                    $root.Trd_Common.Order.encode(message.orderList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_GetOrderList.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetOrderList.S2C
         * @static
         * @param {Trd_GetOrderList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetOrderList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetOrderList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetOrderList.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.orderList && message.orderList.length))
                        message.orderList = [];
                    message.orderList.push($root.Trd_Common.Order.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetOrderList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetOrderList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_GetOrderList.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.orderList != null && message.hasOwnProperty("orderList")) {
                if (!Array.isArray(message.orderList))
                    return "orderList: array expected";
                for (var i = 0; i < message.orderList.length; ++i) {
                    var error = $root.Trd_Common.Order.verify(message.orderList[i]);
                    if (error)
                        return "orderList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetOrderList.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetOrderList.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetOrderList.S2C)
                return object;
            var message = new $root.Trd_GetOrderList.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetOrderList.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.orderList) {
                if (!Array.isArray(object.orderList))
                    throw TypeError(".Trd_GetOrderList.S2C.orderList: array expected");
                message.orderList = [];
                for (var i = 0; i < object.orderList.length; ++i) {
                    if (typeof object.orderList[i] !== "object")
                        throw TypeError(".Trd_GetOrderList.S2C.orderList: object expected");
                    message.orderList[i] = $root.Trd_Common.Order.fromObject(object.orderList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetOrderList.S2C
         * @static
         * @param {Trd_GetOrderList.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.orderList = [];
            if (options.defaults)
                object.header = null;
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.orderList && message.orderList.length) {
                object.orderList = [];
                for (var j = 0; j < message.orderList.length; ++j)
                    object.orderList[j] = $root.Trd_Common.Order.toObject(message.orderList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_GetOrderList.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_GetOrderList.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_GetOrderList
         * @interface IRequest
         * @property {Trd_GetOrderList.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_GetOrderList
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_GetOrderList.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_GetOrderList.IC2S} c2s
         * @memberof Trd_GetOrderList.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_GetOrderList.Request
         * @static
         * @param {Trd_GetOrderList.IRequest=} [properties] Properties to set
         * @returns {Trd_GetOrderList.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_GetOrderList.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetOrderList.Request
         * @static
         * @param {Trd_GetOrderList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_GetOrderList.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_GetOrderList.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetOrderList.Request
         * @static
         * @param {Trd_GetOrderList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetOrderList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetOrderList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetOrderList.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_GetOrderList.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetOrderList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetOrderList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_GetOrderList.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_GetOrderList.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetOrderList.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetOrderList.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetOrderList.Request)
                return object;
            var message = new $root.Trd_GetOrderList.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_GetOrderList.Request.c2s: object expected");
                message.c2s = $root.Trd_GetOrderList.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetOrderList.Request
         * @static
         * @param {Trd_GetOrderList.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_GetOrderList.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_GetOrderList.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_GetOrderList.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_GetOrderList
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_GetOrderList.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_GetOrderList
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_GetOrderList.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_GetOrderList.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_GetOrderList.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_GetOrderList.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_GetOrderList.IS2C|null|undefined} s2c
         * @memberof Trd_GetOrderList.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_GetOrderList.Response
         * @static
         * @param {Trd_GetOrderList.IResponse=} [properties] Properties to set
         * @returns {Trd_GetOrderList.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_GetOrderList.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetOrderList.Response
         * @static
         * @param {Trd_GetOrderList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_GetOrderList.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_GetOrderList.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetOrderList.Response
         * @static
         * @param {Trd_GetOrderList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetOrderList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetOrderList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetOrderList.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_GetOrderList.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetOrderList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetOrderList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_GetOrderList.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_GetOrderList.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetOrderList.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetOrderList.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetOrderList.Response)
                return object;
            var message = new $root.Trd_GetOrderList.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_GetOrderList.Response.s2c: object expected");
                message.s2c = $root.Trd_GetOrderList.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetOrderList.Response
         * @static
         * @param {Trd_GetOrderList.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_GetOrderList.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_GetOrderList.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_GetOrderList;
})();

$root.Trd_GetPositionList = (function() {

    /**
     * Namespace Trd_GetPositionList.
     * @exports Trd_GetPositionList
     * @namespace
     */
    var Trd_GetPositionList = {};

    Trd_GetPositionList.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_GetPositionList
         * @interface IC2S
         * @property {Trd_Common.ITrdHeader} header C2S header
         * @property {Trd_Common.ITrdFilterConditions|null} [filterConditions] C2S filterConditions
         * @property {number|null} [filterPLRatioMin] C2S filterPLRatioMin
         * @property {number|null} [filterPLRatioMax] C2S filterPLRatioMax
         * @property {boolean|null} [refreshCache] C2S refreshCache
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_GetPositionList
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_GetPositionList.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetPositionList.C2S
         * @instance
         */
        C2S.prototype.header = null;

        /**
         * C2S filterConditions.
         * @member {Trd_Common.ITrdFilterConditions|null|undefined} filterConditions
         * @memberof Trd_GetPositionList.C2S
         * @instance
         */
        C2S.prototype.filterConditions = null;

        /**
         * C2S filterPLRatioMin.
         * @member {number} filterPLRatioMin
         * @memberof Trd_GetPositionList.C2S
         * @instance
         */
        C2S.prototype.filterPLRatioMin = 0;

        /**
         * C2S filterPLRatioMax.
         * @member {number} filterPLRatioMax
         * @memberof Trd_GetPositionList.C2S
         * @instance
         */
        C2S.prototype.filterPLRatioMax = 0;

        /**
         * C2S refreshCache.
         * @member {boolean} refreshCache
         * @memberof Trd_GetPositionList.C2S
         * @instance
         */
        C2S.prototype.refreshCache = false;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_GetPositionList.C2S
         * @static
         * @param {Trd_GetPositionList.IC2S=} [properties] Properties to set
         * @returns {Trd_GetPositionList.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_GetPositionList.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetPositionList.C2S
         * @static
         * @param {Trd_GetPositionList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.filterConditions != null && message.hasOwnProperty("filterConditions"))
                $root.Trd_Common.TrdFilterConditions.encode(message.filterConditions, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.filterPLRatioMin != null && message.hasOwnProperty("filterPLRatioMin"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.filterPLRatioMin);
            if (message.filterPLRatioMax != null && message.hasOwnProperty("filterPLRatioMax"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.filterPLRatioMax);
            if (message.refreshCache != null && message.hasOwnProperty("refreshCache"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.refreshCache);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_GetPositionList.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetPositionList.C2S
         * @static
         * @param {Trd_GetPositionList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetPositionList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetPositionList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetPositionList.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.filterConditions = $root.Trd_Common.TrdFilterConditions.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.filterPLRatioMin = reader.double();
                    break;
                case 4:
                    message.filterPLRatioMax = reader.double();
                    break;
                case 5:
                    message.refreshCache = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetPositionList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetPositionList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_GetPositionList.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.filterConditions != null && message.hasOwnProperty("filterConditions")) {
                var error = $root.Trd_Common.TrdFilterConditions.verify(message.filterConditions);
                if (error)
                    return "filterConditions." + error;
            }
            if (message.filterPLRatioMin != null && message.hasOwnProperty("filterPLRatioMin"))
                if (typeof message.filterPLRatioMin !== "number")
                    return "filterPLRatioMin: number expected";
            if (message.filterPLRatioMax != null && message.hasOwnProperty("filterPLRatioMax"))
                if (typeof message.filterPLRatioMax !== "number")
                    return "filterPLRatioMax: number expected";
            if (message.refreshCache != null && message.hasOwnProperty("refreshCache"))
                if (typeof message.refreshCache !== "boolean")
                    return "refreshCache: boolean expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetPositionList.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetPositionList.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetPositionList.C2S)
                return object;
            var message = new $root.Trd_GetPositionList.C2S();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetPositionList.C2S.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.filterConditions != null) {
                if (typeof object.filterConditions !== "object")
                    throw TypeError(".Trd_GetPositionList.C2S.filterConditions: object expected");
                message.filterConditions = $root.Trd_Common.TrdFilterConditions.fromObject(object.filterConditions);
            }
            if (object.filterPLRatioMin != null)
                message.filterPLRatioMin = Number(object.filterPLRatioMin);
            if (object.filterPLRatioMax != null)
                message.filterPLRatioMax = Number(object.filterPLRatioMax);
            if (object.refreshCache != null)
                message.refreshCache = Boolean(object.refreshCache);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetPositionList.C2S
         * @static
         * @param {Trd_GetPositionList.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                object.filterConditions = null;
                object.filterPLRatioMin = 0;
                object.filterPLRatioMax = 0;
                object.refreshCache = false;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.filterConditions != null && message.hasOwnProperty("filterConditions"))
                object.filterConditions = $root.Trd_Common.TrdFilterConditions.toObject(message.filterConditions, options);
            if (message.filterPLRatioMin != null && message.hasOwnProperty("filterPLRatioMin"))
                object.filterPLRatioMin = options.json && !isFinite(message.filterPLRatioMin) ? String(message.filterPLRatioMin) : message.filterPLRatioMin;
            if (message.filterPLRatioMax != null && message.hasOwnProperty("filterPLRatioMax"))
                object.filterPLRatioMax = options.json && !isFinite(message.filterPLRatioMax) ? String(message.filterPLRatioMax) : message.filterPLRatioMax;
            if (message.refreshCache != null && message.hasOwnProperty("refreshCache"))
                object.refreshCache = message.refreshCache;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_GetPositionList.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_GetPositionList.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_GetPositionList
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {Array.<Trd_Common.IPosition>|null} [positionList] S2C positionList
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_GetPositionList
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_GetPositionList.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.positionList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetPositionList.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C positionList.
         * @member {Array.<Trd_Common.IPosition>} positionList
         * @memberof Trd_GetPositionList.S2C
         * @instance
         */
        S2C.prototype.positionList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_GetPositionList.S2C
         * @static
         * @param {Trd_GetPositionList.IS2C=} [properties] Properties to set
         * @returns {Trd_GetPositionList.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_GetPositionList.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetPositionList.S2C
         * @static
         * @param {Trd_GetPositionList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.positionList != null && message.positionList.length)
                for (var i = 0; i < message.positionList.length; ++i)
                    $root.Trd_Common.Position.encode(message.positionList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_GetPositionList.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetPositionList.S2C
         * @static
         * @param {Trd_GetPositionList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetPositionList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetPositionList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetPositionList.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.positionList && message.positionList.length))
                        message.positionList = [];
                    message.positionList.push($root.Trd_Common.Position.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetPositionList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetPositionList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_GetPositionList.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.positionList != null && message.hasOwnProperty("positionList")) {
                if (!Array.isArray(message.positionList))
                    return "positionList: array expected";
                for (var i = 0; i < message.positionList.length; ++i) {
                    var error = $root.Trd_Common.Position.verify(message.positionList[i]);
                    if (error)
                        return "positionList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetPositionList.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetPositionList.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetPositionList.S2C)
                return object;
            var message = new $root.Trd_GetPositionList.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetPositionList.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.positionList) {
                if (!Array.isArray(object.positionList))
                    throw TypeError(".Trd_GetPositionList.S2C.positionList: array expected");
                message.positionList = [];
                for (var i = 0; i < object.positionList.length; ++i) {
                    if (typeof object.positionList[i] !== "object")
                        throw TypeError(".Trd_GetPositionList.S2C.positionList: object expected");
                    message.positionList[i] = $root.Trd_Common.Position.fromObject(object.positionList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetPositionList.S2C
         * @static
         * @param {Trd_GetPositionList.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.positionList = [];
            if (options.defaults)
                object.header = null;
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.positionList && message.positionList.length) {
                object.positionList = [];
                for (var j = 0; j < message.positionList.length; ++j)
                    object.positionList[j] = $root.Trd_Common.Position.toObject(message.positionList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_GetPositionList.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_GetPositionList.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_GetPositionList
         * @interface IRequest
         * @property {Trd_GetPositionList.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_GetPositionList
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_GetPositionList.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_GetPositionList.IC2S} c2s
         * @memberof Trd_GetPositionList.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_GetPositionList.Request
         * @static
         * @param {Trd_GetPositionList.IRequest=} [properties] Properties to set
         * @returns {Trd_GetPositionList.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_GetPositionList.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetPositionList.Request
         * @static
         * @param {Trd_GetPositionList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_GetPositionList.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_GetPositionList.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetPositionList.Request
         * @static
         * @param {Trd_GetPositionList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetPositionList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetPositionList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetPositionList.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_GetPositionList.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetPositionList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetPositionList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_GetPositionList.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_GetPositionList.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetPositionList.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetPositionList.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetPositionList.Request)
                return object;
            var message = new $root.Trd_GetPositionList.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_GetPositionList.Request.c2s: object expected");
                message.c2s = $root.Trd_GetPositionList.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetPositionList.Request
         * @static
         * @param {Trd_GetPositionList.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_GetPositionList.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_GetPositionList.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_GetPositionList.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_GetPositionList
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_GetPositionList.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_GetPositionList
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_GetPositionList.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_GetPositionList.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_GetPositionList.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_GetPositionList.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_GetPositionList.IS2C|null|undefined} s2c
         * @memberof Trd_GetPositionList.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_GetPositionList.Response
         * @static
         * @param {Trd_GetPositionList.IResponse=} [properties] Properties to set
         * @returns {Trd_GetPositionList.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_GetPositionList.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetPositionList.Response
         * @static
         * @param {Trd_GetPositionList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_GetPositionList.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_GetPositionList.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetPositionList.Response
         * @static
         * @param {Trd_GetPositionList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetPositionList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetPositionList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetPositionList.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_GetPositionList.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetPositionList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetPositionList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_GetPositionList.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_GetPositionList.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetPositionList.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetPositionList.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetPositionList.Response)
                return object;
            var message = new $root.Trd_GetPositionList.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_GetPositionList.Response.s2c: object expected");
                message.s2c = $root.Trd_GetPositionList.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetPositionList.Response
         * @static
         * @param {Trd_GetPositionList.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_GetPositionList.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_GetPositionList.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_GetPositionList;
})();

$root.Trd_ModifyOrder = (function() {

    /**
     * Namespace Trd_ModifyOrder.
     * @exports Trd_ModifyOrder
     * @namespace
     */
    var Trd_ModifyOrder = {};

    Trd_ModifyOrder.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_ModifyOrder
         * @interface IC2S
         * @property {Common.IPacketID} packetID C2S packetID
         * @property {Trd_Common.ITrdHeader} header C2S header
         * @property {number|Long} orderID C2S orderID
         * @property {number} modifyOrderOp C2S modifyOrderOp
         * @property {boolean|null} [forAll] C2S forAll
         * @property {number|null} [qty] C2S qty
         * @property {number|null} [price] C2S price
         * @property {boolean|null} [adjustPrice] C2S adjustPrice
         * @property {number|null} [adjustSideAndLimit] C2S adjustSideAndLimit
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_ModifyOrder
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_ModifyOrder.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S packetID.
         * @member {Common.IPacketID} packetID
         * @memberof Trd_ModifyOrder.C2S
         * @instance
         */
        C2S.prototype.packetID = null;

        /**
         * C2S header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_ModifyOrder.C2S
         * @instance
         */
        C2S.prototype.header = null;

        /**
         * C2S orderID.
         * @member {number|Long} orderID
         * @memberof Trd_ModifyOrder.C2S
         * @instance
         */
        C2S.prototype.orderID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * C2S modifyOrderOp.
         * @member {number} modifyOrderOp
         * @memberof Trd_ModifyOrder.C2S
         * @instance
         */
        C2S.prototype.modifyOrderOp = 0;

        /**
         * C2S forAll.
         * @member {boolean} forAll
         * @memberof Trd_ModifyOrder.C2S
         * @instance
         */
        C2S.prototype.forAll = false;

        /**
         * C2S qty.
         * @member {number} qty
         * @memberof Trd_ModifyOrder.C2S
         * @instance
         */
        C2S.prototype.qty = 0;

        /**
         * C2S price.
         * @member {number} price
         * @memberof Trd_ModifyOrder.C2S
         * @instance
         */
        C2S.prototype.price = 0;

        /**
         * C2S adjustPrice.
         * @member {boolean} adjustPrice
         * @memberof Trd_ModifyOrder.C2S
         * @instance
         */
        C2S.prototype.adjustPrice = false;

        /**
         * C2S adjustSideAndLimit.
         * @member {number} adjustSideAndLimit
         * @memberof Trd_ModifyOrder.C2S
         * @instance
         */
        C2S.prototype.adjustSideAndLimit = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_ModifyOrder.C2S
         * @static
         * @param {Trd_ModifyOrder.IC2S=} [properties] Properties to set
         * @returns {Trd_ModifyOrder.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_ModifyOrder.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_ModifyOrder.C2S
         * @static
         * @param {Trd_ModifyOrder.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Common.PacketID.encode(message.packetID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.orderID);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.modifyOrderOp);
            if (message.forAll != null && message.hasOwnProperty("forAll"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.forAll);
            if (message.qty != null && message.hasOwnProperty("qty"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.qty);
            if (message.price != null && message.hasOwnProperty("price"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.price);
            if (message.adjustPrice != null && message.hasOwnProperty("adjustPrice"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.adjustPrice);
            if (message.adjustSideAndLimit != null && message.hasOwnProperty("adjustSideAndLimit"))
                writer.uint32(/* id 11, wireType 1 =*/89).double(message.adjustSideAndLimit);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_ModifyOrder.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_ModifyOrder.C2S
         * @static
         * @param {Trd_ModifyOrder.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_ModifyOrder.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_ModifyOrder.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_ModifyOrder.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.packetID = $root.Common.PacketID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.orderID = reader.uint64();
                    break;
                case 4:
                    message.modifyOrderOp = reader.int32();
                    break;
                case 5:
                    message.forAll = reader.bool();
                    break;
                case 8:
                    message.qty = reader.double();
                    break;
                case 9:
                    message.price = reader.double();
                    break;
                case 10:
                    message.adjustPrice = reader.bool();
                    break;
                case 11:
                    message.adjustSideAndLimit = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("packetID"))
                throw $util.ProtocolError("missing required 'packetID'", { instance: message });
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            if (!message.hasOwnProperty("orderID"))
                throw $util.ProtocolError("missing required 'orderID'", { instance: message });
            if (!message.hasOwnProperty("modifyOrderOp"))
                throw $util.ProtocolError("missing required 'modifyOrderOp'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_ModifyOrder.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_ModifyOrder.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_ModifyOrder.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Common.PacketID.verify(message.packetID);
                if (error)
                    return "packetID." + error;
            }
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (!$util.isInteger(message.orderID) && !(message.orderID && $util.isInteger(message.orderID.low) && $util.isInteger(message.orderID.high)))
                return "orderID: integer|Long expected";
            if (!$util.isInteger(message.modifyOrderOp))
                return "modifyOrderOp: integer expected";
            if (message.forAll != null && message.hasOwnProperty("forAll"))
                if (typeof message.forAll !== "boolean")
                    return "forAll: boolean expected";
            if (message.qty != null && message.hasOwnProperty("qty"))
                if (typeof message.qty !== "number")
                    return "qty: number expected";
            if (message.price != null && message.hasOwnProperty("price"))
                if (typeof message.price !== "number")
                    return "price: number expected";
            if (message.adjustPrice != null && message.hasOwnProperty("adjustPrice"))
                if (typeof message.adjustPrice !== "boolean")
                    return "adjustPrice: boolean expected";
            if (message.adjustSideAndLimit != null && message.hasOwnProperty("adjustSideAndLimit"))
                if (typeof message.adjustSideAndLimit !== "number")
                    return "adjustSideAndLimit: number expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_ModifyOrder.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_ModifyOrder.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_ModifyOrder.C2S)
                return object;
            var message = new $root.Trd_ModifyOrder.C2S();
            if (object.packetID != null) {
                if (typeof object.packetID !== "object")
                    throw TypeError(".Trd_ModifyOrder.C2S.packetID: object expected");
                message.packetID = $root.Common.PacketID.fromObject(object.packetID);
            }
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_ModifyOrder.C2S.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.orderID != null)
                if ($util.Long)
                    (message.orderID = $util.Long.fromValue(object.orderID)).unsigned = true;
                else if (typeof object.orderID === "string")
                    message.orderID = parseInt(object.orderID, 10);
                else if (typeof object.orderID === "number")
                    message.orderID = object.orderID;
                else if (typeof object.orderID === "object")
                    message.orderID = new $util.LongBits(object.orderID.low >>> 0, object.orderID.high >>> 0).toNumber(true);
            if (object.modifyOrderOp != null)
                message.modifyOrderOp = object.modifyOrderOp | 0;
            if (object.forAll != null)
                message.forAll = Boolean(object.forAll);
            if (object.qty != null)
                message.qty = Number(object.qty);
            if (object.price != null)
                message.price = Number(object.price);
            if (object.adjustPrice != null)
                message.adjustPrice = Boolean(object.adjustPrice);
            if (object.adjustSideAndLimit != null)
                message.adjustSideAndLimit = Number(object.adjustSideAndLimit);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_ModifyOrder.C2S
         * @static
         * @param {Trd_ModifyOrder.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.packetID = null;
                object.header = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.orderID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.orderID = options.longs === String ? "0" : 0;
                object.modifyOrderOp = 0;
                object.forAll = false;
                object.qty = 0;
                object.price = 0;
                object.adjustPrice = false;
                object.adjustSideAndLimit = 0;
            }
            if (message.packetID != null && message.hasOwnProperty("packetID"))
                object.packetID = $root.Common.PacketID.toObject(message.packetID, options);
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (typeof message.orderID === "number")
                    object.orderID = options.longs === String ? String(message.orderID) : message.orderID;
                else
                    object.orderID = options.longs === String ? $util.Long.prototype.toString.call(message.orderID) : options.longs === Number ? new $util.LongBits(message.orderID.low >>> 0, message.orderID.high >>> 0).toNumber(true) : message.orderID;
            if (message.modifyOrderOp != null && message.hasOwnProperty("modifyOrderOp"))
                object.modifyOrderOp = message.modifyOrderOp;
            if (message.forAll != null && message.hasOwnProperty("forAll"))
                object.forAll = message.forAll;
            if (message.qty != null && message.hasOwnProperty("qty"))
                object.qty = options.json && !isFinite(message.qty) ? String(message.qty) : message.qty;
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
            if (message.adjustPrice != null && message.hasOwnProperty("adjustPrice"))
                object.adjustPrice = message.adjustPrice;
            if (message.adjustSideAndLimit != null && message.hasOwnProperty("adjustSideAndLimit"))
                object.adjustSideAndLimit = options.json && !isFinite(message.adjustSideAndLimit) ? String(message.adjustSideAndLimit) : message.adjustSideAndLimit;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_ModifyOrder.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_ModifyOrder.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_ModifyOrder
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {number|Long} orderID S2C orderID
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_ModifyOrder
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_ModifyOrder.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_ModifyOrder.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C orderID.
         * @member {number|Long} orderID
         * @memberof Trd_ModifyOrder.S2C
         * @instance
         */
        S2C.prototype.orderID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_ModifyOrder.S2C
         * @static
         * @param {Trd_ModifyOrder.IS2C=} [properties] Properties to set
         * @returns {Trd_ModifyOrder.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_ModifyOrder.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_ModifyOrder.S2C
         * @static
         * @param {Trd_ModifyOrder.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.orderID);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_ModifyOrder.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_ModifyOrder.S2C
         * @static
         * @param {Trd_ModifyOrder.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_ModifyOrder.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_ModifyOrder.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_ModifyOrder.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.orderID = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            if (!message.hasOwnProperty("orderID"))
                throw $util.ProtocolError("missing required 'orderID'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_ModifyOrder.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_ModifyOrder.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_ModifyOrder.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (!$util.isInteger(message.orderID) && !(message.orderID && $util.isInteger(message.orderID.low) && $util.isInteger(message.orderID.high)))
                return "orderID: integer|Long expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_ModifyOrder.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_ModifyOrder.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_ModifyOrder.S2C)
                return object;
            var message = new $root.Trd_ModifyOrder.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_ModifyOrder.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.orderID != null)
                if ($util.Long)
                    (message.orderID = $util.Long.fromValue(object.orderID)).unsigned = true;
                else if (typeof object.orderID === "string")
                    message.orderID = parseInt(object.orderID, 10);
                else if (typeof object.orderID === "number")
                    message.orderID = object.orderID;
                else if (typeof object.orderID === "object")
                    message.orderID = new $util.LongBits(object.orderID.low >>> 0, object.orderID.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_ModifyOrder.S2C
         * @static
         * @param {Trd_ModifyOrder.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.orderID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.orderID = options.longs === String ? "0" : 0;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (typeof message.orderID === "number")
                    object.orderID = options.longs === String ? String(message.orderID) : message.orderID;
                else
                    object.orderID = options.longs === String ? $util.Long.prototype.toString.call(message.orderID) : options.longs === Number ? new $util.LongBits(message.orderID.low >>> 0, message.orderID.high >>> 0).toNumber(true) : message.orderID;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_ModifyOrder.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_ModifyOrder.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_ModifyOrder
         * @interface IRequest
         * @property {Trd_ModifyOrder.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_ModifyOrder
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_ModifyOrder.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_ModifyOrder.IC2S} c2s
         * @memberof Trd_ModifyOrder.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_ModifyOrder.Request
         * @static
         * @param {Trd_ModifyOrder.IRequest=} [properties] Properties to set
         * @returns {Trd_ModifyOrder.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_ModifyOrder.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_ModifyOrder.Request
         * @static
         * @param {Trd_ModifyOrder.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_ModifyOrder.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_ModifyOrder.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_ModifyOrder.Request
         * @static
         * @param {Trd_ModifyOrder.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_ModifyOrder.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_ModifyOrder.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_ModifyOrder.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_ModifyOrder.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_ModifyOrder.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_ModifyOrder.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_ModifyOrder.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_ModifyOrder.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_ModifyOrder.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_ModifyOrder.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_ModifyOrder.Request)
                return object;
            var message = new $root.Trd_ModifyOrder.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_ModifyOrder.Request.c2s: object expected");
                message.c2s = $root.Trd_ModifyOrder.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_ModifyOrder.Request
         * @static
         * @param {Trd_ModifyOrder.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_ModifyOrder.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_ModifyOrder.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_ModifyOrder.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_ModifyOrder
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_ModifyOrder.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_ModifyOrder
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_ModifyOrder.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_ModifyOrder.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_ModifyOrder.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_ModifyOrder.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_ModifyOrder.IS2C|null|undefined} s2c
         * @memberof Trd_ModifyOrder.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_ModifyOrder.Response
         * @static
         * @param {Trd_ModifyOrder.IResponse=} [properties] Properties to set
         * @returns {Trd_ModifyOrder.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_ModifyOrder.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_ModifyOrder.Response
         * @static
         * @param {Trd_ModifyOrder.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_ModifyOrder.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_ModifyOrder.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_ModifyOrder.Response
         * @static
         * @param {Trd_ModifyOrder.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_ModifyOrder.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_ModifyOrder.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_ModifyOrder.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_ModifyOrder.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_ModifyOrder.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_ModifyOrder.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_ModifyOrder.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_ModifyOrder.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_ModifyOrder.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_ModifyOrder.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_ModifyOrder.Response)
                return object;
            var message = new $root.Trd_ModifyOrder.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_ModifyOrder.Response.s2c: object expected");
                message.s2c = $root.Trd_ModifyOrder.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_ModifyOrder.Response
         * @static
         * @param {Trd_ModifyOrder.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_ModifyOrder.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_ModifyOrder.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_ModifyOrder;
})();

$root.Trd_Notify = (function() {

    /**
     * Namespace Trd_Notify.
     * @exports Trd_Notify
     * @namespace
     */
    var Trd_Notify = {};

    Trd_Notify.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_Notify
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {number} type S2C type
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_Notify
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_Notify.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_Notify.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C type.
         * @member {number} type
         * @memberof Trd_Notify.S2C
         * @instance
         */
        S2C.prototype.type = 0;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_Notify.S2C
         * @static
         * @param {Trd_Notify.IS2C=} [properties] Properties to set
         * @returns {Trd_Notify.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_Notify.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_Notify.S2C
         * @static
         * @param {Trd_Notify.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_Notify.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_Notify.S2C
         * @static
         * @param {Trd_Notify.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_Notify.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_Notify.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_Notify.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_Notify.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_Notify.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_Notify.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_Notify.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_Notify.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_Notify.S2C)
                return object;
            var message = new $root.Trd_Notify.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_Notify.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.type != null)
                message.type = object.type | 0;
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_Notify.S2C
         * @static
         * @param {Trd_Notify.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                object.type = 0;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_Notify.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_Notify.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_Notify
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_Notify.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_Notify
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_Notify.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_Notify.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_Notify.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_Notify.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_Notify.IS2C|null|undefined} s2c
         * @memberof Trd_Notify.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_Notify.Response
         * @static
         * @param {Trd_Notify.IResponse=} [properties] Properties to set
         * @returns {Trd_Notify.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_Notify.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_Notify.Response
         * @static
         * @param {Trd_Notify.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_Notify.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_Notify.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_Notify.Response
         * @static
         * @param {Trd_Notify.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_Notify.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_Notify.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_Notify.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_Notify.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_Notify.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_Notify.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_Notify.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_Notify.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_Notify.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_Notify.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_Notify.Response)
                return object;
            var message = new $root.Trd_Notify.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_Notify.Response.s2c: object expected");
                message.s2c = $root.Trd_Notify.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_Notify.Response
         * @static
         * @param {Trd_Notify.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_Notify.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_Notify.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_Notify;
})();

$root.Trd_PlaceOrder = (function() {

    /**
     * Namespace Trd_PlaceOrder.
     * @exports Trd_PlaceOrder
     * @namespace
     */
    var Trd_PlaceOrder = {};

    Trd_PlaceOrder.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_PlaceOrder
         * @interface IC2S
         * @property {Common.IPacketID} packetID C2S packetID
         * @property {Trd_Common.ITrdHeader} header C2S header
         * @property {number} trdSide C2S trdSide
         * @property {number} orderType C2S orderType
         * @property {string} code C2S code
         * @property {number} qty C2S qty
         * @property {number|null} [price] C2S price
         * @property {boolean|null} [adjustPrice] C2S adjustPrice
         * @property {number|null} [adjustSideAndLimit] C2S adjustSideAndLimit
         * @property {number|null} [secMarket] C2S secMarket
         * @property {string|null} [remark] C2S remark
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_PlaceOrder
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_PlaceOrder.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S packetID.
         * @member {Common.IPacketID} packetID
         * @memberof Trd_PlaceOrder.C2S
         * @instance
         */
        C2S.prototype.packetID = null;

        /**
         * C2S header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_PlaceOrder.C2S
         * @instance
         */
        C2S.prototype.header = null;

        /**
         * C2S trdSide.
         * @member {number} trdSide
         * @memberof Trd_PlaceOrder.C2S
         * @instance
         */
        C2S.prototype.trdSide = 0;

        /**
         * C2S orderType.
         * @member {number} orderType
         * @memberof Trd_PlaceOrder.C2S
         * @instance
         */
        C2S.prototype.orderType = 0;

        /**
         * C2S code.
         * @member {string} code
         * @memberof Trd_PlaceOrder.C2S
         * @instance
         */
        C2S.prototype.code = "";

        /**
         * C2S qty.
         * @member {number} qty
         * @memberof Trd_PlaceOrder.C2S
         * @instance
         */
        C2S.prototype.qty = 0;

        /**
         * C2S price.
         * @member {number} price
         * @memberof Trd_PlaceOrder.C2S
         * @instance
         */
        C2S.prototype.price = 0;

        /**
         * C2S adjustPrice.
         * @member {boolean} adjustPrice
         * @memberof Trd_PlaceOrder.C2S
         * @instance
         */
        C2S.prototype.adjustPrice = false;

        /**
         * C2S adjustSideAndLimit.
         * @member {number} adjustSideAndLimit
         * @memberof Trd_PlaceOrder.C2S
         * @instance
         */
        C2S.prototype.adjustSideAndLimit = 0;

        /**
         * C2S secMarket.
         * @member {number} secMarket
         * @memberof Trd_PlaceOrder.C2S
         * @instance
         */
        C2S.prototype.secMarket = 0;

        /**
         * C2S remark.
         * @member {string} remark
         * @memberof Trd_PlaceOrder.C2S
         * @instance
         */
        C2S.prototype.remark = "";

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_PlaceOrder.C2S
         * @static
         * @param {Trd_PlaceOrder.IC2S=} [properties] Properties to set
         * @returns {Trd_PlaceOrder.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_PlaceOrder.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_PlaceOrder.C2S
         * @static
         * @param {Trd_PlaceOrder.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Common.PacketID.encode(message.packetID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.trdSide);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.orderType);
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.code);
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.qty);
            if (message.price != null && message.hasOwnProperty("price"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.price);
            if (message.adjustPrice != null && message.hasOwnProperty("adjustPrice"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.adjustPrice);
            if (message.adjustSideAndLimit != null && message.hasOwnProperty("adjustSideAndLimit"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.adjustSideAndLimit);
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.secMarket);
            if (message.remark != null && message.hasOwnProperty("remark"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.remark);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_PlaceOrder.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_PlaceOrder.C2S
         * @static
         * @param {Trd_PlaceOrder.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_PlaceOrder.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_PlaceOrder.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_PlaceOrder.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.packetID = $root.Common.PacketID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.trdSide = reader.int32();
                    break;
                case 4:
                    message.orderType = reader.int32();
                    break;
                case 5:
                    message.code = reader.string();
                    break;
                case 6:
                    message.qty = reader.double();
                    break;
                case 7:
                    message.price = reader.double();
                    break;
                case 8:
                    message.adjustPrice = reader.bool();
                    break;
                case 9:
                    message.adjustSideAndLimit = reader.double();
                    break;
                case 10:
                    message.secMarket = reader.int32();
                    break;
                case 11:
                    message.remark = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("packetID"))
                throw $util.ProtocolError("missing required 'packetID'", { instance: message });
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            if (!message.hasOwnProperty("trdSide"))
                throw $util.ProtocolError("missing required 'trdSide'", { instance: message });
            if (!message.hasOwnProperty("orderType"))
                throw $util.ProtocolError("missing required 'orderType'", { instance: message });
            if (!message.hasOwnProperty("code"))
                throw $util.ProtocolError("missing required 'code'", { instance: message });
            if (!message.hasOwnProperty("qty"))
                throw $util.ProtocolError("missing required 'qty'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_PlaceOrder.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_PlaceOrder.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_PlaceOrder.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Common.PacketID.verify(message.packetID);
                if (error)
                    return "packetID." + error;
            }
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (!$util.isInteger(message.trdSide))
                return "trdSide: integer expected";
            if (!$util.isInteger(message.orderType))
                return "orderType: integer expected";
            if (!$util.isString(message.code))
                return "code: string expected";
            if (typeof message.qty !== "number")
                return "qty: number expected";
            if (message.price != null && message.hasOwnProperty("price"))
                if (typeof message.price !== "number")
                    return "price: number expected";
            if (message.adjustPrice != null && message.hasOwnProperty("adjustPrice"))
                if (typeof message.adjustPrice !== "boolean")
                    return "adjustPrice: boolean expected";
            if (message.adjustSideAndLimit != null && message.hasOwnProperty("adjustSideAndLimit"))
                if (typeof message.adjustSideAndLimit !== "number")
                    return "adjustSideAndLimit: number expected";
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                if (!$util.isInteger(message.secMarket))
                    return "secMarket: integer expected";
            if (message.remark != null && message.hasOwnProperty("remark"))
                if (!$util.isString(message.remark))
                    return "remark: string expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_PlaceOrder.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_PlaceOrder.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_PlaceOrder.C2S)
                return object;
            var message = new $root.Trd_PlaceOrder.C2S();
            if (object.packetID != null) {
                if (typeof object.packetID !== "object")
                    throw TypeError(".Trd_PlaceOrder.C2S.packetID: object expected");
                message.packetID = $root.Common.PacketID.fromObject(object.packetID);
            }
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_PlaceOrder.C2S.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.trdSide != null)
                message.trdSide = object.trdSide | 0;
            if (object.orderType != null)
                message.orderType = object.orderType | 0;
            if (object.code != null)
                message.code = String(object.code);
            if (object.qty != null)
                message.qty = Number(object.qty);
            if (object.price != null)
                message.price = Number(object.price);
            if (object.adjustPrice != null)
                message.adjustPrice = Boolean(object.adjustPrice);
            if (object.adjustSideAndLimit != null)
                message.adjustSideAndLimit = Number(object.adjustSideAndLimit);
            if (object.secMarket != null)
                message.secMarket = object.secMarket | 0;
            if (object.remark != null)
                message.remark = String(object.remark);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_PlaceOrder.C2S
         * @static
         * @param {Trd_PlaceOrder.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.packetID = null;
                object.header = null;
                object.trdSide = 0;
                object.orderType = 0;
                object.code = "";
                object.qty = 0;
                object.price = 0;
                object.adjustPrice = false;
                object.adjustSideAndLimit = 0;
                object.secMarket = 0;
                object.remark = "";
            }
            if (message.packetID != null && message.hasOwnProperty("packetID"))
                object.packetID = $root.Common.PacketID.toObject(message.packetID, options);
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.trdSide != null && message.hasOwnProperty("trdSide"))
                object.trdSide = message.trdSide;
            if (message.orderType != null && message.hasOwnProperty("orderType"))
                object.orderType = message.orderType;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.qty != null && message.hasOwnProperty("qty"))
                object.qty = options.json && !isFinite(message.qty) ? String(message.qty) : message.qty;
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
            if (message.adjustPrice != null && message.hasOwnProperty("adjustPrice"))
                object.adjustPrice = message.adjustPrice;
            if (message.adjustSideAndLimit != null && message.hasOwnProperty("adjustSideAndLimit"))
                object.adjustSideAndLimit = options.json && !isFinite(message.adjustSideAndLimit) ? String(message.adjustSideAndLimit) : message.adjustSideAndLimit;
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                object.secMarket = message.secMarket;
            if (message.remark != null && message.hasOwnProperty("remark"))
                object.remark = message.remark;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_PlaceOrder.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_PlaceOrder.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_PlaceOrder
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {number|Long|null} [orderID] S2C orderID
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_PlaceOrder
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_PlaceOrder.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_PlaceOrder.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C orderID.
         * @member {number|Long} orderID
         * @memberof Trd_PlaceOrder.S2C
         * @instance
         */
        S2C.prototype.orderID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_PlaceOrder.S2C
         * @static
         * @param {Trd_PlaceOrder.IS2C=} [properties] Properties to set
         * @returns {Trd_PlaceOrder.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_PlaceOrder.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_PlaceOrder.S2C
         * @static
         * @param {Trd_PlaceOrder.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.orderID);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_PlaceOrder.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_PlaceOrder.S2C
         * @static
         * @param {Trd_PlaceOrder.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_PlaceOrder.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_PlaceOrder.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_PlaceOrder.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.orderID = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_PlaceOrder.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_PlaceOrder.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_PlaceOrder.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (!$util.isInteger(message.orderID) && !(message.orderID && $util.isInteger(message.orderID.low) && $util.isInteger(message.orderID.high)))
                    return "orderID: integer|Long expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_PlaceOrder.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_PlaceOrder.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_PlaceOrder.S2C)
                return object;
            var message = new $root.Trd_PlaceOrder.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_PlaceOrder.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.orderID != null)
                if ($util.Long)
                    (message.orderID = $util.Long.fromValue(object.orderID)).unsigned = true;
                else if (typeof object.orderID === "string")
                    message.orderID = parseInt(object.orderID, 10);
                else if (typeof object.orderID === "number")
                    message.orderID = object.orderID;
                else if (typeof object.orderID === "object")
                    message.orderID = new $util.LongBits(object.orderID.low >>> 0, object.orderID.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_PlaceOrder.S2C
         * @static
         * @param {Trd_PlaceOrder.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.orderID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.orderID = options.longs === String ? "0" : 0;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (typeof message.orderID === "number")
                    object.orderID = options.longs === String ? String(message.orderID) : message.orderID;
                else
                    object.orderID = options.longs === String ? $util.Long.prototype.toString.call(message.orderID) : options.longs === Number ? new $util.LongBits(message.orderID.low >>> 0, message.orderID.high >>> 0).toNumber(true) : message.orderID;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_PlaceOrder.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_PlaceOrder.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_PlaceOrder
         * @interface IRequest
         * @property {Trd_PlaceOrder.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_PlaceOrder
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_PlaceOrder.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_PlaceOrder.IC2S} c2s
         * @memberof Trd_PlaceOrder.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_PlaceOrder.Request
         * @static
         * @param {Trd_PlaceOrder.IRequest=} [properties] Properties to set
         * @returns {Trd_PlaceOrder.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_PlaceOrder.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_PlaceOrder.Request
         * @static
         * @param {Trd_PlaceOrder.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_PlaceOrder.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_PlaceOrder.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_PlaceOrder.Request
         * @static
         * @param {Trd_PlaceOrder.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_PlaceOrder.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_PlaceOrder.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_PlaceOrder.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_PlaceOrder.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_PlaceOrder.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_PlaceOrder.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_PlaceOrder.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_PlaceOrder.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_PlaceOrder.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_PlaceOrder.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_PlaceOrder.Request)
                return object;
            var message = new $root.Trd_PlaceOrder.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_PlaceOrder.Request.c2s: object expected");
                message.c2s = $root.Trd_PlaceOrder.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_PlaceOrder.Request
         * @static
         * @param {Trd_PlaceOrder.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_PlaceOrder.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_PlaceOrder.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_PlaceOrder.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_PlaceOrder
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_PlaceOrder.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_PlaceOrder
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_PlaceOrder.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_PlaceOrder.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_PlaceOrder.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_PlaceOrder.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_PlaceOrder.IS2C|null|undefined} s2c
         * @memberof Trd_PlaceOrder.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_PlaceOrder.Response
         * @static
         * @param {Trd_PlaceOrder.IResponse=} [properties] Properties to set
         * @returns {Trd_PlaceOrder.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_PlaceOrder.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_PlaceOrder.Response
         * @static
         * @param {Trd_PlaceOrder.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_PlaceOrder.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_PlaceOrder.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_PlaceOrder.Response
         * @static
         * @param {Trd_PlaceOrder.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_PlaceOrder.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_PlaceOrder.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_PlaceOrder.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_PlaceOrder.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_PlaceOrder.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_PlaceOrder.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_PlaceOrder.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_PlaceOrder.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_PlaceOrder.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_PlaceOrder.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_PlaceOrder.Response)
                return object;
            var message = new $root.Trd_PlaceOrder.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_PlaceOrder.Response.s2c: object expected");
                message.s2c = $root.Trd_PlaceOrder.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_PlaceOrder.Response
         * @static
         * @param {Trd_PlaceOrder.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_PlaceOrder.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_PlaceOrder.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_PlaceOrder;
})();

$root.Trd_ReconfirmOrder = (function() {

    /**
     * Namespace Trd_ReconfirmOrder.
     * @exports Trd_ReconfirmOrder
     * @namespace
     */
    var Trd_ReconfirmOrder = {};

    Trd_ReconfirmOrder.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_ReconfirmOrder
         * @interface IC2S
         * @property {Common.IPacketID} packetID C2S packetID
         * @property {Trd_Common.ITrdHeader} header C2S header
         * @property {number|Long} orderID C2S orderID
         * @property {number} reconfirmReason C2S reconfirmReason
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_ReconfirmOrder
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_ReconfirmOrder.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S packetID.
         * @member {Common.IPacketID} packetID
         * @memberof Trd_ReconfirmOrder.C2S
         * @instance
         */
        C2S.prototype.packetID = null;

        /**
         * C2S header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_ReconfirmOrder.C2S
         * @instance
         */
        C2S.prototype.header = null;

        /**
         * C2S orderID.
         * @member {number|Long} orderID
         * @memberof Trd_ReconfirmOrder.C2S
         * @instance
         */
        C2S.prototype.orderID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * C2S reconfirmReason.
         * @member {number} reconfirmReason
         * @memberof Trd_ReconfirmOrder.C2S
         * @instance
         */
        C2S.prototype.reconfirmReason = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_ReconfirmOrder.C2S
         * @static
         * @param {Trd_ReconfirmOrder.IC2S=} [properties] Properties to set
         * @returns {Trd_ReconfirmOrder.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_ReconfirmOrder.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_ReconfirmOrder.C2S
         * @static
         * @param {Trd_ReconfirmOrder.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Common.PacketID.encode(message.packetID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.orderID);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.reconfirmReason);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_ReconfirmOrder.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_ReconfirmOrder.C2S
         * @static
         * @param {Trd_ReconfirmOrder.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_ReconfirmOrder.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_ReconfirmOrder.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_ReconfirmOrder.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.packetID = $root.Common.PacketID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.orderID = reader.uint64();
                    break;
                case 4:
                    message.reconfirmReason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("packetID"))
                throw $util.ProtocolError("missing required 'packetID'", { instance: message });
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            if (!message.hasOwnProperty("orderID"))
                throw $util.ProtocolError("missing required 'orderID'", { instance: message });
            if (!message.hasOwnProperty("reconfirmReason"))
                throw $util.ProtocolError("missing required 'reconfirmReason'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_ReconfirmOrder.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_ReconfirmOrder.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_ReconfirmOrder.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Common.PacketID.verify(message.packetID);
                if (error)
                    return "packetID." + error;
            }
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (!$util.isInteger(message.orderID) && !(message.orderID && $util.isInteger(message.orderID.low) && $util.isInteger(message.orderID.high)))
                return "orderID: integer|Long expected";
            if (!$util.isInteger(message.reconfirmReason))
                return "reconfirmReason: integer expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_ReconfirmOrder.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_ReconfirmOrder.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_ReconfirmOrder.C2S)
                return object;
            var message = new $root.Trd_ReconfirmOrder.C2S();
            if (object.packetID != null) {
                if (typeof object.packetID !== "object")
                    throw TypeError(".Trd_ReconfirmOrder.C2S.packetID: object expected");
                message.packetID = $root.Common.PacketID.fromObject(object.packetID);
            }
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_ReconfirmOrder.C2S.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.orderID != null)
                if ($util.Long)
                    (message.orderID = $util.Long.fromValue(object.orderID)).unsigned = true;
                else if (typeof object.orderID === "string")
                    message.orderID = parseInt(object.orderID, 10);
                else if (typeof object.orderID === "number")
                    message.orderID = object.orderID;
                else if (typeof object.orderID === "object")
                    message.orderID = new $util.LongBits(object.orderID.low >>> 0, object.orderID.high >>> 0).toNumber(true);
            if (object.reconfirmReason != null)
                message.reconfirmReason = object.reconfirmReason | 0;
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_ReconfirmOrder.C2S
         * @static
         * @param {Trd_ReconfirmOrder.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.packetID = null;
                object.header = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.orderID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.orderID = options.longs === String ? "0" : 0;
                object.reconfirmReason = 0;
            }
            if (message.packetID != null && message.hasOwnProperty("packetID"))
                object.packetID = $root.Common.PacketID.toObject(message.packetID, options);
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (typeof message.orderID === "number")
                    object.orderID = options.longs === String ? String(message.orderID) : message.orderID;
                else
                    object.orderID = options.longs === String ? $util.Long.prototype.toString.call(message.orderID) : options.longs === Number ? new $util.LongBits(message.orderID.low >>> 0, message.orderID.high >>> 0).toNumber(true) : message.orderID;
            if (message.reconfirmReason != null && message.hasOwnProperty("reconfirmReason"))
                object.reconfirmReason = message.reconfirmReason;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_ReconfirmOrder.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_ReconfirmOrder.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_ReconfirmOrder
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {number|Long} orderID S2C orderID
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_ReconfirmOrder
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_ReconfirmOrder.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_ReconfirmOrder.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C orderID.
         * @member {number|Long} orderID
         * @memberof Trd_ReconfirmOrder.S2C
         * @instance
         */
        S2C.prototype.orderID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_ReconfirmOrder.S2C
         * @static
         * @param {Trd_ReconfirmOrder.IS2C=} [properties] Properties to set
         * @returns {Trd_ReconfirmOrder.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_ReconfirmOrder.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_ReconfirmOrder.S2C
         * @static
         * @param {Trd_ReconfirmOrder.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.orderID);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_ReconfirmOrder.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_ReconfirmOrder.S2C
         * @static
         * @param {Trd_ReconfirmOrder.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_ReconfirmOrder.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_ReconfirmOrder.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_ReconfirmOrder.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.orderID = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            if (!message.hasOwnProperty("orderID"))
                throw $util.ProtocolError("missing required 'orderID'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_ReconfirmOrder.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_ReconfirmOrder.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_ReconfirmOrder.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (!$util.isInteger(message.orderID) && !(message.orderID && $util.isInteger(message.orderID.low) && $util.isInteger(message.orderID.high)))
                return "orderID: integer|Long expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_ReconfirmOrder.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_ReconfirmOrder.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_ReconfirmOrder.S2C)
                return object;
            var message = new $root.Trd_ReconfirmOrder.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_ReconfirmOrder.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.orderID != null)
                if ($util.Long)
                    (message.orderID = $util.Long.fromValue(object.orderID)).unsigned = true;
                else if (typeof object.orderID === "string")
                    message.orderID = parseInt(object.orderID, 10);
                else if (typeof object.orderID === "number")
                    message.orderID = object.orderID;
                else if (typeof object.orderID === "object")
                    message.orderID = new $util.LongBits(object.orderID.low >>> 0, object.orderID.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_ReconfirmOrder.S2C
         * @static
         * @param {Trd_ReconfirmOrder.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.orderID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.orderID = options.longs === String ? "0" : 0;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (typeof message.orderID === "number")
                    object.orderID = options.longs === String ? String(message.orderID) : message.orderID;
                else
                    object.orderID = options.longs === String ? $util.Long.prototype.toString.call(message.orderID) : options.longs === Number ? new $util.LongBits(message.orderID.low >>> 0, message.orderID.high >>> 0).toNumber(true) : message.orderID;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_ReconfirmOrder.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_ReconfirmOrder.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_ReconfirmOrder
         * @interface IRequest
         * @property {Trd_ReconfirmOrder.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_ReconfirmOrder
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_ReconfirmOrder.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_ReconfirmOrder.IC2S} c2s
         * @memberof Trd_ReconfirmOrder.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_ReconfirmOrder.Request
         * @static
         * @param {Trd_ReconfirmOrder.IRequest=} [properties] Properties to set
         * @returns {Trd_ReconfirmOrder.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_ReconfirmOrder.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_ReconfirmOrder.Request
         * @static
         * @param {Trd_ReconfirmOrder.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_ReconfirmOrder.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_ReconfirmOrder.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_ReconfirmOrder.Request
         * @static
         * @param {Trd_ReconfirmOrder.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_ReconfirmOrder.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_ReconfirmOrder.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_ReconfirmOrder.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_ReconfirmOrder.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_ReconfirmOrder.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_ReconfirmOrder.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_ReconfirmOrder.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_ReconfirmOrder.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_ReconfirmOrder.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_ReconfirmOrder.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_ReconfirmOrder.Request)
                return object;
            var message = new $root.Trd_ReconfirmOrder.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_ReconfirmOrder.Request.c2s: object expected");
                message.c2s = $root.Trd_ReconfirmOrder.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_ReconfirmOrder.Request
         * @static
         * @param {Trd_ReconfirmOrder.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_ReconfirmOrder.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_ReconfirmOrder.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_ReconfirmOrder.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_ReconfirmOrder
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_ReconfirmOrder.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_ReconfirmOrder
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_ReconfirmOrder.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_ReconfirmOrder.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_ReconfirmOrder.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_ReconfirmOrder.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_ReconfirmOrder.IS2C|null|undefined} s2c
         * @memberof Trd_ReconfirmOrder.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_ReconfirmOrder.Response
         * @static
         * @param {Trd_ReconfirmOrder.IResponse=} [properties] Properties to set
         * @returns {Trd_ReconfirmOrder.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_ReconfirmOrder.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_ReconfirmOrder.Response
         * @static
         * @param {Trd_ReconfirmOrder.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_ReconfirmOrder.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_ReconfirmOrder.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_ReconfirmOrder.Response
         * @static
         * @param {Trd_ReconfirmOrder.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_ReconfirmOrder.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_ReconfirmOrder.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_ReconfirmOrder.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_ReconfirmOrder.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_ReconfirmOrder.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_ReconfirmOrder.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_ReconfirmOrder.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_ReconfirmOrder.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_ReconfirmOrder.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_ReconfirmOrder.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_ReconfirmOrder.Response)
                return object;
            var message = new $root.Trd_ReconfirmOrder.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_ReconfirmOrder.Response.s2c: object expected");
                message.s2c = $root.Trd_ReconfirmOrder.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_ReconfirmOrder.Response
         * @static
         * @param {Trd_ReconfirmOrder.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_ReconfirmOrder.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_ReconfirmOrder.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_ReconfirmOrder;
})();

$root.Trd_SubAccPush = (function() {

    /**
     * Namespace Trd_SubAccPush.
     * @exports Trd_SubAccPush
     * @namespace
     */
    var Trd_SubAccPush = {};

    Trd_SubAccPush.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_SubAccPush
         * @interface IC2S
         * @property {Array.<number|Long>|null} [accIDList] C2S accIDList
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_SubAccPush
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_SubAccPush.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.accIDList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S accIDList.
         * @member {Array.<number|Long>} accIDList
         * @memberof Trd_SubAccPush.C2S
         * @instance
         */
        C2S.prototype.accIDList = $util.emptyArray;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_SubAccPush.C2S
         * @static
         * @param {Trd_SubAccPush.IC2S=} [properties] Properties to set
         * @returns {Trd_SubAccPush.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_SubAccPush.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_SubAccPush.C2S
         * @static
         * @param {Trd_SubAccPush.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accIDList != null && message.accIDList.length)
                for (var i = 0; i < message.accIDList.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.accIDList[i]);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_SubAccPush.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_SubAccPush.C2S
         * @static
         * @param {Trd_SubAccPush.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_SubAccPush.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_SubAccPush.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_SubAccPush.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.accIDList && message.accIDList.length))
                        message.accIDList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.accIDList.push(reader.uint64());
                    } else
                        message.accIDList.push(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_SubAccPush.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_SubAccPush.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_SubAccPush.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accIDList != null && message.hasOwnProperty("accIDList")) {
                if (!Array.isArray(message.accIDList))
                    return "accIDList: array expected";
                for (var i = 0; i < message.accIDList.length; ++i)
                    if (!$util.isInteger(message.accIDList[i]) && !(message.accIDList[i] && $util.isInteger(message.accIDList[i].low) && $util.isInteger(message.accIDList[i].high)))
                        return "accIDList: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_SubAccPush.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_SubAccPush.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_SubAccPush.C2S)
                return object;
            var message = new $root.Trd_SubAccPush.C2S();
            if (object.accIDList) {
                if (!Array.isArray(object.accIDList))
                    throw TypeError(".Trd_SubAccPush.C2S.accIDList: array expected");
                message.accIDList = [];
                for (var i = 0; i < object.accIDList.length; ++i)
                    if ($util.Long)
                        (message.accIDList[i] = $util.Long.fromValue(object.accIDList[i])).unsigned = true;
                    else if (typeof object.accIDList[i] === "string")
                        message.accIDList[i] = parseInt(object.accIDList[i], 10);
                    else if (typeof object.accIDList[i] === "number")
                        message.accIDList[i] = object.accIDList[i];
                    else if (typeof object.accIDList[i] === "object")
                        message.accIDList[i] = new $util.LongBits(object.accIDList[i].low >>> 0, object.accIDList[i].high >>> 0).toNumber(true);
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_SubAccPush.C2S
         * @static
         * @param {Trd_SubAccPush.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.accIDList = [];
            if (message.accIDList && message.accIDList.length) {
                object.accIDList = [];
                for (var j = 0; j < message.accIDList.length; ++j)
                    if (typeof message.accIDList[j] === "number")
                        object.accIDList[j] = options.longs === String ? String(message.accIDList[j]) : message.accIDList[j];
                    else
                        object.accIDList[j] = options.longs === String ? $util.Long.prototype.toString.call(message.accIDList[j]) : options.longs === Number ? new $util.LongBits(message.accIDList[j].low >>> 0, message.accIDList[j].high >>> 0).toNumber(true) : message.accIDList[j];
            }
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_SubAccPush.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_SubAccPush.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_SubAccPush
         * @interface IS2C
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_SubAccPush
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_SubAccPush.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_SubAccPush.S2C
         * @static
         * @param {Trd_SubAccPush.IS2C=} [properties] Properties to set
         * @returns {Trd_SubAccPush.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_SubAccPush.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_SubAccPush.S2C
         * @static
         * @param {Trd_SubAccPush.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_SubAccPush.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_SubAccPush.S2C
         * @static
         * @param {Trd_SubAccPush.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_SubAccPush.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_SubAccPush.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_SubAccPush.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_SubAccPush.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_SubAccPush.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_SubAccPush.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_SubAccPush.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_SubAccPush.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_SubAccPush.S2C)
                return object;
            return new $root.Trd_SubAccPush.S2C();
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_SubAccPush.S2C
         * @static
         * @param {Trd_SubAccPush.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_SubAccPush.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_SubAccPush.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_SubAccPush
         * @interface IRequest
         * @property {Trd_SubAccPush.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_SubAccPush
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_SubAccPush.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_SubAccPush.IC2S} c2s
         * @memberof Trd_SubAccPush.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_SubAccPush.Request
         * @static
         * @param {Trd_SubAccPush.IRequest=} [properties] Properties to set
         * @returns {Trd_SubAccPush.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_SubAccPush.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_SubAccPush.Request
         * @static
         * @param {Trd_SubAccPush.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_SubAccPush.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_SubAccPush.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_SubAccPush.Request
         * @static
         * @param {Trd_SubAccPush.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_SubAccPush.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_SubAccPush.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_SubAccPush.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_SubAccPush.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_SubAccPush.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_SubAccPush.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_SubAccPush.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_SubAccPush.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_SubAccPush.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_SubAccPush.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_SubAccPush.Request)
                return object;
            var message = new $root.Trd_SubAccPush.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_SubAccPush.Request.c2s: object expected");
                message.c2s = $root.Trd_SubAccPush.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_SubAccPush.Request
         * @static
         * @param {Trd_SubAccPush.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_SubAccPush.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_SubAccPush.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_SubAccPush.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_SubAccPush
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_SubAccPush.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_SubAccPush
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_SubAccPush.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_SubAccPush.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_SubAccPush.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_SubAccPush.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_SubAccPush.IS2C|null|undefined} s2c
         * @memberof Trd_SubAccPush.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_SubAccPush.Response
         * @static
         * @param {Trd_SubAccPush.IResponse=} [properties] Properties to set
         * @returns {Trd_SubAccPush.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_SubAccPush.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_SubAccPush.Response
         * @static
         * @param {Trd_SubAccPush.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_SubAccPush.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_SubAccPush.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_SubAccPush.Response
         * @static
         * @param {Trd_SubAccPush.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_SubAccPush.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_SubAccPush.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_SubAccPush.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_SubAccPush.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_SubAccPush.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_SubAccPush.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_SubAccPush.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_SubAccPush.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_SubAccPush.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_SubAccPush.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_SubAccPush.Response)
                return object;
            var message = new $root.Trd_SubAccPush.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_SubAccPush.Response.s2c: object expected");
                message.s2c = $root.Trd_SubAccPush.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_SubAccPush.Response
         * @static
         * @param {Trd_SubAccPush.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_SubAccPush.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_SubAccPush.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_SubAccPush;
})();

$root.Trd_UnlockTrade = (function() {

    /**
     * Namespace Trd_UnlockTrade.
     * @exports Trd_UnlockTrade
     * @namespace
     */
    var Trd_UnlockTrade = {};

    Trd_UnlockTrade.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_UnlockTrade
         * @interface IC2S
         * @property {boolean} unlock C2S unlock
         * @property {string|null} [pwdMD5] C2S pwdMD5
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_UnlockTrade
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_UnlockTrade.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S unlock.
         * @member {boolean} unlock
         * @memberof Trd_UnlockTrade.C2S
         * @instance
         */
        C2S.prototype.unlock = false;

        /**
         * C2S pwdMD5.
         * @member {string} pwdMD5
         * @memberof Trd_UnlockTrade.C2S
         * @instance
         */
        C2S.prototype.pwdMD5 = "";

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_UnlockTrade.C2S
         * @static
         * @param {Trd_UnlockTrade.IC2S=} [properties] Properties to set
         * @returns {Trd_UnlockTrade.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_UnlockTrade.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_UnlockTrade.C2S
         * @static
         * @param {Trd_UnlockTrade.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.unlock);
            if (message.pwdMD5 != null && message.hasOwnProperty("pwdMD5"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pwdMD5);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_UnlockTrade.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_UnlockTrade.C2S
         * @static
         * @param {Trd_UnlockTrade.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_UnlockTrade.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_UnlockTrade.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_UnlockTrade.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.unlock = reader.bool();
                    break;
                case 2:
                    message.pwdMD5 = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("unlock"))
                throw $util.ProtocolError("missing required 'unlock'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_UnlockTrade.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_UnlockTrade.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_UnlockTrade.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.unlock !== "boolean")
                return "unlock: boolean expected";
            if (message.pwdMD5 != null && message.hasOwnProperty("pwdMD5"))
                if (!$util.isString(message.pwdMD5))
                    return "pwdMD5: string expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_UnlockTrade.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_UnlockTrade.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_UnlockTrade.C2S)
                return object;
            var message = new $root.Trd_UnlockTrade.C2S();
            if (object.unlock != null)
                message.unlock = Boolean(object.unlock);
            if (object.pwdMD5 != null)
                message.pwdMD5 = String(object.pwdMD5);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_UnlockTrade.C2S
         * @static
         * @param {Trd_UnlockTrade.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.unlock = false;
                object.pwdMD5 = "";
            }
            if (message.unlock != null && message.hasOwnProperty("unlock"))
                object.unlock = message.unlock;
            if (message.pwdMD5 != null && message.hasOwnProperty("pwdMD5"))
                object.pwdMD5 = message.pwdMD5;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_UnlockTrade.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_UnlockTrade.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_UnlockTrade
         * @interface IS2C
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_UnlockTrade
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_UnlockTrade.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_UnlockTrade.S2C
         * @static
         * @param {Trd_UnlockTrade.IS2C=} [properties] Properties to set
         * @returns {Trd_UnlockTrade.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_UnlockTrade.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_UnlockTrade.S2C
         * @static
         * @param {Trd_UnlockTrade.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_UnlockTrade.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_UnlockTrade.S2C
         * @static
         * @param {Trd_UnlockTrade.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_UnlockTrade.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_UnlockTrade.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_UnlockTrade.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_UnlockTrade.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_UnlockTrade.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_UnlockTrade.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_UnlockTrade.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_UnlockTrade.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_UnlockTrade.S2C)
                return object;
            return new $root.Trd_UnlockTrade.S2C();
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_UnlockTrade.S2C
         * @static
         * @param {Trd_UnlockTrade.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_UnlockTrade.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_UnlockTrade.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_UnlockTrade
         * @interface IRequest
         * @property {Trd_UnlockTrade.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_UnlockTrade
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_UnlockTrade.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_UnlockTrade.IC2S} c2s
         * @memberof Trd_UnlockTrade.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_UnlockTrade.Request
         * @static
         * @param {Trd_UnlockTrade.IRequest=} [properties] Properties to set
         * @returns {Trd_UnlockTrade.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_UnlockTrade.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_UnlockTrade.Request
         * @static
         * @param {Trd_UnlockTrade.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_UnlockTrade.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_UnlockTrade.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_UnlockTrade.Request
         * @static
         * @param {Trd_UnlockTrade.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_UnlockTrade.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_UnlockTrade.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_UnlockTrade.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_UnlockTrade.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_UnlockTrade.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_UnlockTrade.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_UnlockTrade.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_UnlockTrade.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_UnlockTrade.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_UnlockTrade.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_UnlockTrade.Request)
                return object;
            var message = new $root.Trd_UnlockTrade.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_UnlockTrade.Request.c2s: object expected");
                message.c2s = $root.Trd_UnlockTrade.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_UnlockTrade.Request
         * @static
         * @param {Trd_UnlockTrade.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_UnlockTrade.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_UnlockTrade.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_UnlockTrade.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_UnlockTrade
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_UnlockTrade.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_UnlockTrade
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_UnlockTrade.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_UnlockTrade.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_UnlockTrade.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_UnlockTrade.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_UnlockTrade.IS2C|null|undefined} s2c
         * @memberof Trd_UnlockTrade.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_UnlockTrade.Response
         * @static
         * @param {Trd_UnlockTrade.IResponse=} [properties] Properties to set
         * @returns {Trd_UnlockTrade.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_UnlockTrade.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_UnlockTrade.Response
         * @static
         * @param {Trd_UnlockTrade.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_UnlockTrade.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_UnlockTrade.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_UnlockTrade.Response
         * @static
         * @param {Trd_UnlockTrade.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_UnlockTrade.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_UnlockTrade.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_UnlockTrade.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_UnlockTrade.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_UnlockTrade.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_UnlockTrade.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_UnlockTrade.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_UnlockTrade.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_UnlockTrade.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_UnlockTrade.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_UnlockTrade.Response)
                return object;
            var message = new $root.Trd_UnlockTrade.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_UnlockTrade.Response.s2c: object expected");
                message.s2c = $root.Trd_UnlockTrade.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_UnlockTrade.Response
         * @static
         * @param {Trd_UnlockTrade.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_UnlockTrade.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_UnlockTrade.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_UnlockTrade;
})();

$root.Trd_UpdateOrderFill = (function() {

    /**
     * Namespace Trd_UpdateOrderFill.
     * @exports Trd_UpdateOrderFill
     * @namespace
     */
    var Trd_UpdateOrderFill = {};

    Trd_UpdateOrderFill.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_UpdateOrderFill
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {Trd_Common.IOrderFill} orderFill S2C orderFill
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_UpdateOrderFill
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_UpdateOrderFill.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_UpdateOrderFill.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C orderFill.
         * @member {Trd_Common.IOrderFill} orderFill
         * @memberof Trd_UpdateOrderFill.S2C
         * @instance
         */
        S2C.prototype.orderFill = null;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_UpdateOrderFill.S2C
         * @static
         * @param {Trd_UpdateOrderFill.IS2C=} [properties] Properties to set
         * @returns {Trd_UpdateOrderFill.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_UpdateOrderFill.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_UpdateOrderFill.S2C
         * @static
         * @param {Trd_UpdateOrderFill.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            $root.Trd_Common.OrderFill.encode(message.orderFill, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_UpdateOrderFill.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_UpdateOrderFill.S2C
         * @static
         * @param {Trd_UpdateOrderFill.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_UpdateOrderFill.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_UpdateOrderFill.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_UpdateOrderFill.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.orderFill = $root.Trd_Common.OrderFill.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            if (!message.hasOwnProperty("orderFill"))
                throw $util.ProtocolError("missing required 'orderFill'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_UpdateOrderFill.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_UpdateOrderFill.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_UpdateOrderFill.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            {
                var error = $root.Trd_Common.OrderFill.verify(message.orderFill);
                if (error)
                    return "orderFill." + error;
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_UpdateOrderFill.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_UpdateOrderFill.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_UpdateOrderFill.S2C)
                return object;
            var message = new $root.Trd_UpdateOrderFill.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_UpdateOrderFill.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.orderFill != null) {
                if (typeof object.orderFill !== "object")
                    throw TypeError(".Trd_UpdateOrderFill.S2C.orderFill: object expected");
                message.orderFill = $root.Trd_Common.OrderFill.fromObject(object.orderFill);
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_UpdateOrderFill.S2C
         * @static
         * @param {Trd_UpdateOrderFill.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                object.orderFill = null;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.orderFill != null && message.hasOwnProperty("orderFill"))
                object.orderFill = $root.Trd_Common.OrderFill.toObject(message.orderFill, options);
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_UpdateOrderFill.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_UpdateOrderFill.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_UpdateOrderFill
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_UpdateOrderFill.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_UpdateOrderFill
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_UpdateOrderFill.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_UpdateOrderFill.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_UpdateOrderFill.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_UpdateOrderFill.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_UpdateOrderFill.IS2C|null|undefined} s2c
         * @memberof Trd_UpdateOrderFill.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_UpdateOrderFill.Response
         * @static
         * @param {Trd_UpdateOrderFill.IResponse=} [properties] Properties to set
         * @returns {Trd_UpdateOrderFill.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_UpdateOrderFill.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_UpdateOrderFill.Response
         * @static
         * @param {Trd_UpdateOrderFill.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_UpdateOrderFill.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_UpdateOrderFill.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_UpdateOrderFill.Response
         * @static
         * @param {Trd_UpdateOrderFill.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_UpdateOrderFill.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_UpdateOrderFill.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_UpdateOrderFill.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_UpdateOrderFill.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_UpdateOrderFill.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_UpdateOrderFill.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_UpdateOrderFill.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_UpdateOrderFill.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_UpdateOrderFill.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_UpdateOrderFill.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_UpdateOrderFill.Response)
                return object;
            var message = new $root.Trd_UpdateOrderFill.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_UpdateOrderFill.Response.s2c: object expected");
                message.s2c = $root.Trd_UpdateOrderFill.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_UpdateOrderFill.Response
         * @static
         * @param {Trd_UpdateOrderFill.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_UpdateOrderFill.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_UpdateOrderFill.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_UpdateOrderFill;
})();

$root.Trd_UpdateOrder = (function() {

    /**
     * Namespace Trd_UpdateOrder.
     * @exports Trd_UpdateOrder
     * @namespace
     */
    var Trd_UpdateOrder = {};

    Trd_UpdateOrder.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_UpdateOrder
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {Trd_Common.IOrder} order S2C order
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_UpdateOrder
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_UpdateOrder.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_UpdateOrder.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C order.
         * @member {Trd_Common.IOrder} order
         * @memberof Trd_UpdateOrder.S2C
         * @instance
         */
        S2C.prototype.order = null;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_UpdateOrder.S2C
         * @static
         * @param {Trd_UpdateOrder.IS2C=} [properties] Properties to set
         * @returns {Trd_UpdateOrder.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_UpdateOrder.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_UpdateOrder.S2C
         * @static
         * @param {Trd_UpdateOrder.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            $root.Trd_Common.Order.encode(message.order, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_UpdateOrder.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_UpdateOrder.S2C
         * @static
         * @param {Trd_UpdateOrder.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_UpdateOrder.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_UpdateOrder.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_UpdateOrder.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.order = $root.Trd_Common.Order.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            if (!message.hasOwnProperty("order"))
                throw $util.ProtocolError("missing required 'order'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_UpdateOrder.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_UpdateOrder.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_UpdateOrder.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            {
                var error = $root.Trd_Common.Order.verify(message.order);
                if (error)
                    return "order." + error;
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_UpdateOrder.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_UpdateOrder.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_UpdateOrder.S2C)
                return object;
            var message = new $root.Trd_UpdateOrder.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_UpdateOrder.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.order != null) {
                if (typeof object.order !== "object")
                    throw TypeError(".Trd_UpdateOrder.S2C.order: object expected");
                message.order = $root.Trd_Common.Order.fromObject(object.order);
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_UpdateOrder.S2C
         * @static
         * @param {Trd_UpdateOrder.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                object.order = null;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.order != null && message.hasOwnProperty("order"))
                object.order = $root.Trd_Common.Order.toObject(message.order, options);
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_UpdateOrder.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_UpdateOrder.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_UpdateOrder
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_UpdateOrder.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_UpdateOrder
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_UpdateOrder.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_UpdateOrder.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_UpdateOrder.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_UpdateOrder.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_UpdateOrder.IS2C|null|undefined} s2c
         * @memberof Trd_UpdateOrder.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_UpdateOrder.Response
         * @static
         * @param {Trd_UpdateOrder.IResponse=} [properties] Properties to set
         * @returns {Trd_UpdateOrder.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_UpdateOrder.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_UpdateOrder.Response
         * @static
         * @param {Trd_UpdateOrder.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_UpdateOrder.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_UpdateOrder.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_UpdateOrder.Response
         * @static
         * @param {Trd_UpdateOrder.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_UpdateOrder.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_UpdateOrder.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_UpdateOrder.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_UpdateOrder.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_UpdateOrder.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_UpdateOrder.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_UpdateOrder.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_UpdateOrder.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_UpdateOrder.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_UpdateOrder.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_UpdateOrder.Response)
                return object;
            var message = new $root.Trd_UpdateOrder.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_UpdateOrder.Response.s2c: object expected");
                message.s2c = $root.Trd_UpdateOrder.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_UpdateOrder.Response
         * @static
         * @param {Trd_UpdateOrder.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_UpdateOrder.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_UpdateOrder.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_UpdateOrder;
})();

$root.Verification = (function() {

    /**
     * Namespace Verification.
     * @exports Verification
     * @namespace
     */
    var Verification = {};

    /**
     * VerificationType enum.
     * @name Verification.VerificationType
     * @enum {string}
     * @property {number} VerificationType_Unknow=0 VerificationType_Unknow value
     * @property {number} VerificationType_Picture=1 VerificationType_Picture value
     * @property {number} VerificationType_Phone=2 VerificationType_Phone value
     */
    Verification.VerificationType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "VerificationType_Unknow"] = 0;
        values[valuesById[1] = "VerificationType_Picture"] = 1;
        values[valuesById[2] = "VerificationType_Phone"] = 2;
        return values;
    })();

    /**
     * VerificationOp enum.
     * @name Verification.VerificationOp
     * @enum {string}
     * @property {number} VerificationOp_Unknow=0 VerificationOp_Unknow value
     * @property {number} VerificationOp_Request=1 VerificationOp_Request value
     * @property {number} VerificationOp_InputAndLogin=2 VerificationOp_InputAndLogin value
     */
    Verification.VerificationOp = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "VerificationOp_Unknow"] = 0;
        values[valuesById[1] = "VerificationOp_Request"] = 1;
        values[valuesById[2] = "VerificationOp_InputAndLogin"] = 2;
        return values;
    })();

    Verification.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Verification
         * @interface IC2S
         * @property {number} type C2S type
         * @property {number} op C2S op
         * @property {string|null} [code] C2S code
         */

        /**
         * Constructs a new C2S.
         * @memberof Verification
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Verification.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S type.
         * @member {number} type
         * @memberof Verification.C2S
         * @instance
         */
        C2S.prototype.type = 0;

        /**
         * C2S op.
         * @member {number} op
         * @memberof Verification.C2S
         * @instance
         */
        C2S.prototype.op = 0;

        /**
         * C2S code.
         * @member {string} code
         * @memberof Verification.C2S
         * @instance
         */
        C2S.prototype.code = "";

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Verification.C2S
         * @static
         * @param {Verification.IC2S=} [properties] Properties to set
         * @returns {Verification.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Verification.C2S.verify|verify} messages.
         * @function encode
         * @memberof Verification.C2S
         * @static
         * @param {Verification.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.op);
            if (message.code != null && message.hasOwnProperty("code"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.code);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Verification.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Verification.C2S
         * @static
         * @param {Verification.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Verification.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Verification.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Verification.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.op = reader.int32();
                    break;
                case 3:
                    message.code = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("op"))
                throw $util.ProtocolError("missing required 'op'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Verification.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Verification.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Verification.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            if (!$util.isInteger(message.op))
                return "op: integer expected";
            if (message.code != null && message.hasOwnProperty("code"))
                if (!$util.isString(message.code))
                    return "code: string expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Verification.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Verification.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Verification.C2S)
                return object;
            var message = new $root.Verification.C2S();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.op != null)
                message.op = object.op | 0;
            if (object.code != null)
                message.code = String(object.code);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Verification.C2S
         * @static
         * @param {Verification.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.op = 0;
                object.code = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.op != null && message.hasOwnProperty("op"))
                object.op = message.op;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Verification.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Verification.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Verification
         * @interface IS2C
         */

        /**
         * Constructs a new S2C.
         * @memberof Verification
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Verification.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Verification.S2C
         * @static
         * @param {Verification.IS2C=} [properties] Properties to set
         * @returns {Verification.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Verification.S2C.verify|verify} messages.
         * @function encode
         * @memberof Verification.S2C
         * @static
         * @param {Verification.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Verification.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Verification.S2C
         * @static
         * @param {Verification.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Verification.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Verification.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Verification.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Verification.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Verification.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Verification.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Verification.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Verification.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Verification.S2C)
                return object;
            return new $root.Verification.S2C();
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Verification.S2C
         * @static
         * @param {Verification.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Verification.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Verification.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Verification
         * @interface IRequest
         * @property {Verification.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Verification
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Verification.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Verification.IC2S} c2s
         * @memberof Verification.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Verification.Request
         * @static
         * @param {Verification.IRequest=} [properties] Properties to set
         * @returns {Verification.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Verification.Request.verify|verify} messages.
         * @function encode
         * @memberof Verification.Request
         * @static
         * @param {Verification.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Verification.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Verification.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Verification.Request
         * @static
         * @param {Verification.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Verification.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Verification.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Verification.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Verification.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Verification.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Verification.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Verification.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Verification.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Verification.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Verification.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Verification.Request)
                return object;
            var message = new $root.Verification.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Verification.Request.c2s: object expected");
                message.c2s = $root.Verification.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Verification.Request
         * @static
         * @param {Verification.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Verification.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Verification.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Verification.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Verification
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Verification.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Verification
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Verification.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Verification.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Verification.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Verification.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Verification.IS2C|null|undefined} s2c
         * @memberof Verification.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Verification.Response
         * @static
         * @param {Verification.IResponse=} [properties] Properties to set
         * @returns {Verification.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Verification.Response.verify|verify} messages.
         * @function encode
         * @memberof Verification.Response
         * @static
         * @param {Verification.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Verification.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Verification.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Verification.Response
         * @static
         * @param {Verification.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Verification.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Verification.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Verification.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Verification.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Verification.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Verification.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Verification.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Verification.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Verification.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Verification.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Verification.Response)
                return object;
            var message = new $root.Verification.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Verification.Response.s2c: object expected");
                message.s2c = $root.Verification.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Verification.Response
         * @static
         * @param {Verification.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Verification.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Verification.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Verification;
})();

$root.InitWebSocket = (function() {

    /**
     * Namespace InitWebSocket.
     * @exports InitWebSocket
     * @namespace
     */
    var InitWebSocket = {};

    InitWebSocket.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof InitWebSocket
         * @interface IC2S
         * @property {string|null} [IP] C2S IP
         * @property {number|null} [Port] C2S Port
         * @property {string|null} [RSAPrivateKey] C2S RSAPrivateKey
         * @property {string|null} [websocketKey] C2S websocketKey
         * @property {string|null} [clientId] C2S clientId
         */

        /**
         * Constructs a new C2S.
         * @memberof InitWebSocket
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {InitWebSocket.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S IP.
         * @member {string} IP
         * @memberof InitWebSocket.C2S
         * @instance
         */
        C2S.prototype.IP = "";

        /**
         * C2S Port.
         * @member {number} Port
         * @memberof InitWebSocket.C2S
         * @instance
         */
        C2S.prototype.Port = 0;

        /**
         * C2S RSAPrivateKey.
         * @member {string} RSAPrivateKey
         * @memberof InitWebSocket.C2S
         * @instance
         */
        C2S.prototype.RSAPrivateKey = "";

        /**
         * C2S websocketKey.
         * @member {string} websocketKey
         * @memberof InitWebSocket.C2S
         * @instance
         */
        C2S.prototype.websocketKey = "";

        /**
         * C2S clientId.
         * @member {string} clientId
         * @memberof InitWebSocket.C2S
         * @instance
         */
        C2S.prototype.clientId = "";

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof InitWebSocket.C2S
         * @static
         * @param {InitWebSocket.IC2S=} [properties] Properties to set
         * @returns {InitWebSocket.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link InitWebSocket.C2S.verify|verify} messages.
         * @function encode
         * @memberof InitWebSocket.C2S
         * @static
         * @param {InitWebSocket.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.IP != null && message.hasOwnProperty("IP"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.IP);
            if (message.Port != null && message.hasOwnProperty("Port"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Port);
            if (message.RSAPrivateKey != null && message.hasOwnProperty("RSAPrivateKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.RSAPrivateKey);
            if (message.websocketKey != null && message.hasOwnProperty("websocketKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.websocketKey);
            if (message.clientId != null && message.hasOwnProperty("clientId"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.clientId);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link InitWebSocket.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof InitWebSocket.C2S
         * @static
         * @param {InitWebSocket.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof InitWebSocket.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {InitWebSocket.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.InitWebSocket.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.IP = reader.string();
                    break;
                case 2:
                    message.Port = reader.int32();
                    break;
                case 3:
                    message.RSAPrivateKey = reader.string();
                    break;
                case 4:
                    message.websocketKey = reader.string();
                    break;
                case 5:
                    message.clientId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof InitWebSocket.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {InitWebSocket.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof InitWebSocket.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.IP != null && message.hasOwnProperty("IP"))
                if (!$util.isString(message.IP))
                    return "IP: string expected";
            if (message.Port != null && message.hasOwnProperty("Port"))
                if (!$util.isInteger(message.Port))
                    return "Port: integer expected";
            if (message.RSAPrivateKey != null && message.hasOwnProperty("RSAPrivateKey"))
                if (!$util.isString(message.RSAPrivateKey))
                    return "RSAPrivateKey: string expected";
            if (message.websocketKey != null && message.hasOwnProperty("websocketKey"))
                if (!$util.isString(message.websocketKey))
                    return "websocketKey: string expected";
            if (message.clientId != null && message.hasOwnProperty("clientId"))
                if (!$util.isString(message.clientId))
                    return "clientId: string expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof InitWebSocket.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {InitWebSocket.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.InitWebSocket.C2S)
                return object;
            var message = new $root.InitWebSocket.C2S();
            if (object.IP != null)
                message.IP = String(object.IP);
            if (object.Port != null)
                message.Port = object.Port | 0;
            if (object.RSAPrivateKey != null)
                message.RSAPrivateKey = String(object.RSAPrivateKey);
            if (object.websocketKey != null)
                message.websocketKey = String(object.websocketKey);
            if (object.clientId != null)
                message.clientId = String(object.clientId);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof InitWebSocket.C2S
         * @static
         * @param {InitWebSocket.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.IP = "";
                object.Port = 0;
                object.RSAPrivateKey = "";
                object.websocketKey = "";
                object.clientId = "";
            }
            if (message.IP != null && message.hasOwnProperty("IP"))
                object.IP = message.IP;
            if (message.Port != null && message.hasOwnProperty("Port"))
                object.Port = message.Port;
            if (message.RSAPrivateKey != null && message.hasOwnProperty("RSAPrivateKey"))
                object.RSAPrivateKey = message.RSAPrivateKey;
            if (message.websocketKey != null && message.hasOwnProperty("websocketKey"))
                object.websocketKey = message.websocketKey;
            if (message.clientId != null && message.hasOwnProperty("clientId"))
                object.clientId = message.clientId;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof InitWebSocket.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    InitWebSocket.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof InitWebSocket
         * @interface IS2C
         * @property {number|Long} serverTime S2C serverTime
         */

        /**
         * Constructs a new S2C.
         * @memberof InitWebSocket
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {InitWebSocket.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C serverTime.
         * @member {number|Long} serverTime
         * @memberof InitWebSocket.S2C
         * @instance
         */
        S2C.prototype.serverTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof InitWebSocket.S2C
         * @static
         * @param {InitWebSocket.IS2C=} [properties] Properties to set
         * @returns {InitWebSocket.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link InitWebSocket.S2C.verify|verify} messages.
         * @function encode
         * @memberof InitWebSocket.S2C
         * @static
         * @param {InitWebSocket.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.serverTime);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link InitWebSocket.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof InitWebSocket.S2C
         * @static
         * @param {InitWebSocket.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof InitWebSocket.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {InitWebSocket.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.InitWebSocket.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("serverTime"))
                throw $util.ProtocolError("missing required 'serverTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof InitWebSocket.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {InitWebSocket.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof InitWebSocket.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.serverTime) && !(message.serverTime && $util.isInteger(message.serverTime.low) && $util.isInteger(message.serverTime.high)))
                return "serverTime: integer|Long expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof InitWebSocket.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {InitWebSocket.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.InitWebSocket.S2C)
                return object;
            var message = new $root.InitWebSocket.S2C();
            if (object.serverTime != null)
                if ($util.Long)
                    (message.serverTime = $util.Long.fromValue(object.serverTime)).unsigned = false;
                else if (typeof object.serverTime === "string")
                    message.serverTime = parseInt(object.serverTime, 10);
                else if (typeof object.serverTime === "number")
                    message.serverTime = object.serverTime;
                else if (typeof object.serverTime === "object")
                    message.serverTime = new $util.LongBits(object.serverTime.low >>> 0, object.serverTime.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof InitWebSocket.S2C
         * @static
         * @param {InitWebSocket.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.serverTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.serverTime = options.longs === String ? "0" : 0;
            if (message.serverTime != null && message.hasOwnProperty("serverTime"))
                if (typeof message.serverTime === "number")
                    object.serverTime = options.longs === String ? String(message.serverTime) : message.serverTime;
                else
                    object.serverTime = options.longs === String ? $util.Long.prototype.toString.call(message.serverTime) : options.longs === Number ? new $util.LongBits(message.serverTime.low >>> 0, message.serverTime.high >>> 0).toNumber() : message.serverTime;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof InitWebSocket.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    InitWebSocket.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof InitWebSocket
         * @interface IRequest
         * @property {InitWebSocket.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof InitWebSocket
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {InitWebSocket.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {InitWebSocket.IC2S} c2s
         * @memberof InitWebSocket.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof InitWebSocket.Request
         * @static
         * @param {InitWebSocket.IRequest=} [properties] Properties to set
         * @returns {InitWebSocket.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link InitWebSocket.Request.verify|verify} messages.
         * @function encode
         * @memberof InitWebSocket.Request
         * @static
         * @param {InitWebSocket.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.InitWebSocket.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link InitWebSocket.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof InitWebSocket.Request
         * @static
         * @param {InitWebSocket.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof InitWebSocket.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {InitWebSocket.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.InitWebSocket.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.InitWebSocket.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof InitWebSocket.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {InitWebSocket.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof InitWebSocket.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.InitWebSocket.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof InitWebSocket.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {InitWebSocket.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.InitWebSocket.Request)
                return object;
            var message = new $root.InitWebSocket.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".InitWebSocket.Request.c2s: object expected");
                message.c2s = $root.InitWebSocket.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof InitWebSocket.Request
         * @static
         * @param {InitWebSocket.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.InitWebSocket.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof InitWebSocket.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    InitWebSocket.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof InitWebSocket
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {InitWebSocket.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof InitWebSocket
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {InitWebSocket.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof InitWebSocket.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof InitWebSocket.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof InitWebSocket.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {InitWebSocket.IS2C|null|undefined} s2c
         * @memberof InitWebSocket.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof InitWebSocket.Response
         * @static
         * @param {InitWebSocket.IResponse=} [properties] Properties to set
         * @returns {InitWebSocket.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link InitWebSocket.Response.verify|verify} messages.
         * @function encode
         * @memberof InitWebSocket.Response
         * @static
         * @param {InitWebSocket.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.InitWebSocket.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link InitWebSocket.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof InitWebSocket.Response
         * @static
         * @param {InitWebSocket.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof InitWebSocket.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {InitWebSocket.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.InitWebSocket.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.InitWebSocket.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof InitWebSocket.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {InitWebSocket.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof InitWebSocket.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.InitWebSocket.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof InitWebSocket.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {InitWebSocket.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.InitWebSocket.Response)
                return object;
            var message = new $root.InitWebSocket.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".InitWebSocket.Response.s2c: object expected");
                message.s2c = $root.InitWebSocket.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof InitWebSocket.Response
         * @static
         * @param {InitWebSocket.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.InitWebSocket.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof InitWebSocket.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return InitWebSocket;
})();

module.exports = $root;
